<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>xv6：文件系统 | Ember🍐</title><meta name="author" content="Ember🍐"><meta name="copyright" content="Ember🍐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MIT：xv6 chapter8"><meta property="og:type" content="article"><meta property="og:title" content="xv6：文件系统"><meta property="og:url" content="http://www.ember-l.top/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html"><meta property="og:site_name" content="Ember🍐"><meta property="og:description" content="MIT：xv6 chapter8"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png"><meta property="article:published_time" content="2023-09-24T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-25T15:24:00.037Z"><meta property="article:author" content="Ember🍐"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.ember-l.top/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"FNCTP04VYC",apiKey:"5edd8c47a13fcf53938686d6f1752dbb",indexName:"dev_blog",hits:{per_page:6},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Ember🍐",link:"链接: ",source:"来源: Ember🍐",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"xv6：文件系统",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-25 23:24:00"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/wave.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3864328_90xjkz8cfrn.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><span id="fps"></span><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/tag.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.css"><script data-pjax src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.js"></script><link rel="stylesheet" href="/css/barrage.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><script src="/js/reward.js"></script><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.6.16/dist/sweetalert2.all.min.js"></script><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="/css/precess_bar.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-SmartHome"></use></svg> <span>首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuji"></use></svg> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zongheshuju"></use></svg> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-"></use></svg> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenxiang"></use></svg> <span>随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-meishikafei"></use></svg> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg> <span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-"></use></svg> <span>照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying"></use></svg> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie"></use></svg> <span>社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg> <span>朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg> <span>友人链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg> <span>小站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao"></use></svg> <span>网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/article/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao"></use></svg> <span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshalou"></use></svg> <span>生涯</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ember🍐</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-SmartHome"></use></svg> <span>首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuji"></use></svg> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zongheshuju"></use></svg> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-"></use></svg> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenxiang"></use></svg> <span>随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-meishikafei"></use></svg> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg> <span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-"></use></svg> <span>照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying"></use></svg> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie"></use></svg> <span>社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg> <span>朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg> <span>友人链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg> <span>小站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao"></use></svg> <span>网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/article/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao"></use></svg> <span>文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshalou"></use></svg> <span>生涯</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg> <span>关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:2px;right:8px" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg> <span>搜索</span></a></div><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">xv6：文件系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-24T16:00:00.000Z" title="发表于 2023-09-25 00:00:00">2023-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-25T15:24:00.037Z" title="更新于 2023-09-25 23:24:00">2023-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">1.6w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="xv6：文件系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote><p><strong>写在前面</strong>：本文是基于xv6以及MIT6.S081课程内容所写的笔记，在阅读时配合xv6源码理解效果更佳。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​ 设计文件系统的主要目的是为了<strong>组织</strong>与<strong>存储</strong>数据。文件系统中提供了<strong>共享</strong>用户与程序的数据的方式。同时也提供了<strong>持久化</strong>(persistence)，也就是在设备丢失并重启后，数据仍然能够保存，众所周知内存(RAM)设备的数据断电后是会丢失的。</p><p>​ xv6的文件系统提供了UNIX风格的文件、目录、路径名和在磁盘存储数据(persistence)的方式。同时这样的文件系统也会给设计带来一些挑战：</p><ul><li><strong>保存在硬盘上(on-disk)的数据结构</strong>：文件系统需要表示目录和文件名称的树(tree)，记录每个文件内容块的标识，并记录磁盘中那些块是空闲的。</li><li><strong>crash恢复(crash recovery)</strong>：如果电脑crash发生，文件系统需要在重启后正常工作。问题在于在crash会中断更新的顺序，并且导致on-disk数据结构与文件数据不一致。</li><li><strong>维持不变量(maintian in variant)</strong>：不同的进程同时操作一个文件的时候，需要协调数据的更新，预防并发读写的数据竞争。</li><li><strong>内存缓存常用块(in-memory cache of popular blocks)</strong>：磁盘的访问通常会比内存访问慢几个数量级，所以文件系统需要维持<strong>常用数据块</strong>在内存中的缓存。</li></ul><p>xv6中文件系统的设计是比较简单的，但是用于学习是十分不错的。</p><h2 id="xv6文件系统"><a href="#xv6文件系统" class="headerlink" title="xv6文件系统"></a>xv6文件系统</h2><p>xv6文件系统的实现被组织为7个层，如下图所述：</p><ol><li><strong>disk layer</strong>，进程在磁盘设备上读写块(blocks);</li><li><strong>buffer cache layer</strong>，将磁盘的块缓存在<strong>内存</strong>中并同步访问，并且在只有一个内核进程才能在一个时间段内修改缓存，将该块存入对应磁盘的块中</li><li><strong>logging layer</strong>，将更高的层中对于几个或是多个的数据块的更新保存在一个<strong>事务</strong>中(transaction)，并且却表这些块能够在面临crash时能够<strong>原子的更新</strong>(要么全部更新，要么都不更新)。</li><li><strong>inode layer</strong>，提供单独的文件的信息(metadata)，每一个文件都有唯一编号(i-number)的<code>inode</code>，一个文件只有一个<code>inode</code>的，在磁盘中有固定的块会保存<code>inode</code>数据。</li><li><strong>directory layer</strong>，将目录设置为了一种特殊的<strong>inode</strong>种类，也就是说目录是文件，目录会保存目录或文件的条目的序列，每一个条目都会包含文件名与i-number。</li><li><strong>pathname layer</strong>，提供分层级的路径命名方式，如/usr/rt,/xv6/fs.c，解析路径明时使用递归的方式查询(find实验中就有所涉及)。</li><li><strong>descriptor layer</strong>，将Unix资源(pipes，devices、file…)抽象化，使用文件系统的接口，简化操作磁盘文件的方式。</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png" alt="layers"></p><p>​ 以上便是文件系统与xv6文件系统大致设计，接下来将会由底层的disk layer逐渐讲解到顶层的descriptor layer。</p><h1 id="Disk-Layer"><a href="#Disk-Layer" class="headerlink" title="Disk Layer"></a>Disk Layer</h1><h2 id="磁盘硬件交互"><a href="#磁盘硬件交互" class="headerlink" title="磁盘硬件交互"></a>磁盘硬件交互</h2><p>​ 从最低层<strong>Disk layer</strong>讲起，在实际中risc-v主板上会连接许多的存储设备，有SSD与HDD两种常用的磁盘类型，两者的区别在于性能与成本方面。</p><p>​ 这些存储设备连接到了电脑总线(bus)之上，总线也连接了<strong>CPU和内存</strong>。一个文件系统运行在CPU上，将内部的数据存储在内存，同时也会以读写block的形式存储在SSD或HDD。读写文件的接口比较简单有read/write，然后以block编号作为参数。</p><p>​ 在下图中是CSAPP中硬件的组织，通常情况CPU读取磁盘的文件或是程序，都会将其加载到内存中。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/hw_org.png" alt="hw_org"></p><blockquote><p><strong>术语</strong>：sector与block</p></blockquote><ul><li><strong>sector</strong>，通常是磁盘驱动可以读写的最小单元，它过去通常是512字节。</li><li><strong>block</strong>，通常是操作系统或者文件系统视角的数据。它由<strong>文件系统定义</strong>，在xv6中定义为1024字节。所以xv6中<code>block = 2 * sector</code>。通常来说一个block对应了一个或者多个sector。</li></ul><p>但是这两个术语没有明确的界限，所以容易导致混淆。</p><h2 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h2><p>​ 从文件系统的角度来看磁盘还是很直观的。因为对于磁盘就是读写block或者sector，我们可以将磁盘看作是一个巨大的block的数组，数组从0开始，一直增长到磁盘的最后。</p><blockquote><p>磁盘块与类型</p></blockquote><ul><li><strong>boot block</strong>，block0，被用作boot sector来启动操作系统。操作系统也是一个程序保存在数据块中，点击开机后，boot loader会将该操作系统加载内存中。xv6中没有使用boot block。</li><li><strong>super block</strong>，block1通常被称为super block，它描述了文件系统的线管信息。包含磁盘上有多少个block共同构成了文件系统这样的信息。通过block1构造出大部分的文件系统信息。</li><li><strong>log block</strong>，block2-block31。实际上log的大小可能不同，这里在super block中会定义log就是30个block。</li><li><strong>inode block</strong>，在block32到block45之间。一个inode是64字节，描述的了文件的一些相关信息。</li><li><strong>bitmap block</strong>，构建文件系统的默认方法，它只占据一个block。它记录了data block是否空闲。一个字节有8个位，那么一个字节可以表示8个数据块(通过指定位0和1表示数据块是否被使用)，例如<code>0000 0110</code>就可以表示第2和第3个数据块被使用了，一个bitmap就可以表示8*1024个数据块。</li><li><strong>data block</strong>，block46以后的块都属data block，data block存储了文件的内容和目录的内容。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>通常来说，bitmap block，inode blocks和log blocks被统称为<strong>metadata block</strong>。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据。</p><blockquote><p><strong>代码</strong>：超级块结构体</p></blockquote><p>这个结构体描述了文件系统中一些基本信息，如文件系统block、inode、log的数量等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码</strong>：超级块初始化</p></blockquote><p>​ 文件和目录内容都保存在磁盘块中，这就需要一个<strong>空闲池</strong>(free pool)用于分配空闲块。xv6块分配器(block allocator)维持了一个<strong>bitmap块</strong>，一个位(bit)代表一个块，0代表块空闲、1代表块正在使用。<code>mkfs</code>(mkfs/mkfs.c，用C语言编写的程序，本质上时制作一个镜像也就是一个文件)程序设置了这些位对应了各个块的编号，有<code>boot block</code>、<code>superblock</code>等。</p><p>​ 输入<code>make clean</code>后再输入<code>make qemu</code>，可以从<code>makefile</code>输出信息看到如下消息所示，第一条是<code>makefile</code>的编译信息，大概就是将 <code>REAMDE</code>、<code>user/_cat</code>，这些程序加载到磁盘，实际是将这些程序写入到了<code>fs.img</code>文件中，最后将这个镜像文件加载到qemu的虚拟磁盘上。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkfs/mkfs fs.img README  user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie  user/_bigfile</span><br><span class="line">----makefile</span><br><span class="line"><span class="comment">#使用gcc编译mkfs文件</span></span><br><span class="line"><span class="section">mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h</span></span><br><span class="line">	gcc <span class="variable">$(XCFLAGS)</span> -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c</span><br><span class="line"><span class="comment">#制作fs.img镜像，看/mkfs/mkfs.c代码可知这个镜像实际就是一个文件</span></span><br><span class="line"><span class="comment">#				fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);</span></span><br><span class="line"><span class="section">fs.img: mkfs/mkfs README <span class="variable">$(UEXTRA)</span> <span class="variable">$(UPROGS)</span></span></span><br><span class="line">	mkfs/mkfs fs.img README <span class="variable">$(UEXTRA)</span> <span class="variable">$(UPROGS)</span></span><br></pre></td></tr></table></figure><p>​ 接下来的<code>makefile</code>的输出信息便是mkfs文件系统的<code>printf</code>语句的输出信息，大致就是告诉你文件系统中<strong>块的布局及分配情况</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmeta 70 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000</span><br><span class="line">balloc: first 799 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br></pre></td></tr></table></figure><p>​ 在后面有一个<code>balloc</code>开头的输出语句，这实际上是块分配器的函数，接着了解一下块分配的相关操作。</p><p>在<code>mkfs/mkfs.c</code>中就就编写了超级块的初始化数据，主要是定义了文件系统的大小、磁盘块的数量、日志块的数量、日志块的开始编号、inode块的开始编号、bmap块的开始编号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat xv6_stat  <span class="comment">// avoid clash with host struct stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  sb.magic = FSMAGIC;</span><br><span class="line">  sb.size = xint(FSSIZE);</span><br><span class="line">  sb.nblocks = xint(nblocks);</span><br><span class="line">  sb.ninodes = xint(NINODES);</span><br><span class="line">  sb.nlog = xint(nlog);</span><br><span class="line">  sb.logstart = xint(<span class="number">2</span>);</span><br><span class="line">  sb.inodestart = xint(<span class="number">2</span>+nlog);</span><br><span class="line">  sb.bmapstart = xint(<span class="number">2</span>+nlog+ninodeblocks);</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Buffer-cache-layer"><a href="#Buffer-cache-layer" class="headerlink" title="Buffer cache layer"></a>Buffer cache layer</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>buffer cache层</strong>主要完成以下两个任务：</p><ol><li><strong>同步</strong>对磁盘块的访问：只有一个磁盘块的一个副本保存在内存中，并且只有一个内核线程能够在同一时间内操作这个内存副本。</li><li>缓存<strong>常用的块</strong>以提升性能：访问磁盘是特别慢的操作，缓存经常使用的块在内存中，可以加快数据访问的速度。</li></ol><p>在bio.c文件中声明了buffer cache层提供的三个接口：buffer cache层对每一个buffer包含一个<code>sleeplock</code>，保证buffer的同步性。</p><ul><li><strong>bread</strong>：获取一个buf，其中包含指定磁盘块的副本，这个副本能够在后续在磁盘中被读取与修改。返回一个已锁定的buf。</li><li><strong>bwrite</strong>：将已修改的buffer写回对应的磁盘块中。</li><li><strong>brelse</strong>：内核线程完成buffer相关修改后，调用该接口释放这个buf。释放锁定的buf。</li></ul><p>​ buffer cache是内存中保存的固定长度的<strong>双向buf(结构体)链表</strong>，那么也就是说内存中不可能缓存所有的磁盘块，那么当buffer cache满了之后，读取一个新的磁盘块，就需要回收<code>buf</code>节点。在xv6中使用了LRU(least recently used)算法，也就是将最少使用的块写回磁盘回收<code>buf</code>节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>buf结构体</p></blockquote><ul><li><strong>valid</strong>：buf中是否含有块的副本。</li><li><strong>disk</strong>：buffer块的内容是否已经写回了磁盘，这将会改变块的内容。</li><li><strong>dev</strong>：设备id。</li><li><strong>blockno</strong>：磁盘块的编号。</li><li><strong>refcnt</strong>：引用计数，持有buf节点<code>sleeplock</code>的数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><blockquote><p><strong>buffer cache初始化</strong>：</p></blockquote><p>创建双向链表bcache，bcache中有30个buf节点。如下图</p><ul><li>由<strong>右到左</strong>是使用<code>next</code>指针，这个是<strong>MRU</strong>(most recently used)链表。右边的第一个就是最常(popular)用的buffer节点，依次使用<code>next</code>指向读取下一个块，这些块的<strong>常用程度</strong>依次下降。</li><li>从<strong>左到右</strong>是使用<code>prev</code>指针，这则是<strong>LRU</strong>链表，与<strong>MRU</strong>链表刚好相反。在xv6中会将LRU链表的节点的buffer写回磁盘。</li></ul><p>下图中<code>bcache.head</code>作用是使用<code>prev</code>与<code>next</code>指针指向<strong>MRU</strong>与<strong>LRU</strong>两个方向的链表的头节点。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/linklist-5.png" alt="linklist-5"></p><p>下述代码中，将每一个buffer节点都设置了一个<code>sleeplock</code>，遍历bcache.buf的所有节点创建了双向链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bread</strong>：获得指定块的buf，返回以锁定的buf</p></blockquote><p>​ 在bread接口中会调用bget函数，返回指定磁盘块号的buf。如果该buf是新分配的节点里面没有数据，则调用<code>virtio_disk_rw</code>接口读取磁盘块的内容到buf中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bwrite</strong>：将buffer写入磁盘块</p></blockquote><p>一旦<code>bread</code>读取了磁盘并将buffer返回了调用者，调用者将独占使用这个buffer。只有在调用了<code>bwrite</code>之后将修改的数据写入磁盘才能释放buffer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bget</strong>：获取指定块的buffer</p></blockquote><p><code>bget</code>中会做两件事：</p><ol><li><strong>查找已缓存的buf</strong>：使用next指针扫描<strong>MRU</strong>链表，通过判断<code>dev</code>与<code>blockno</code>参数，如果已经缓存了这个块，获取<code>sleeplock</code>后返回已锁定的buf节点。反之说明没有缓存指定的磁盘块，则进入下一步。</li><li><strong>查找空buf</strong>：使用prev指针扫描<strong>LRU</strong>链表，查找没有使用过的buf节点(<code>b-&gt;refcnt = 0</code>)，将该buf节点的相应字段填入，获取<code>sleeplock</code>后返回已锁定的buf节点。</li></ol><p>​ 为了确保<strong>同步性</strong>，文件系统使用锁控制同步，因此每一个磁盘块只能缓存在一个buffer中，确定readers能够看见写入。<code>bget</code>函数中对链表扫描，检查buf节点是否缓存，这个过程持有<code>bcache.lock</code>直到返回，以确保不会多个buf节点缓存一个磁盘块或是一个buf节点缓存多个磁盘节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ <code>bget</code>中在<code>bcache.lock</code><strong>关键区</strong>(critical section)之外，使用<code>sleeplock</code>保护buf节点数据安全，保护对磁盘块的buf节点的读写。在关键区之内，主要是保护了<code>b-&gt;refcnt</code>变量保证buf节点不被重新用于其他磁盘节点，保护已缓存块的信息。</p><blockquote><p><strong>brelse</strong>：调用者释放buffer，减少引用计数</p></blockquote><p>​ 当调用者完成了buffer的操作，必须调用<code>brelse</code>(b-release)释放块。<code>brelse</code>释放<code>sleeplock</code>并减少引用计数。当引用计数为零(<code>b-&gt;refcnt=0</code>)的buf节点移动到链表的最右方(如下图所示)，这个buffer节点就变成了<strong>最经常使用</strong>的节点了，在<code>bget</code>中查找已缓存的节点便可以最先找到该节点。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/release_buffer.png" alt="release_buffer"></p><p>​ 移动buf节点会引起buffer cache链表以<strong>最近使用频率</strong>进行排序：(从右往左)在链表的第一个buffer是最近最多使用的，最后一个则是最近最少使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p><strong>crash safty</strong></p></blockquote><p>​ 在实际中：当使用<code>make</code>命令编译文件时候，会频繁的与文件系统交互，创建读写文件，但是在<code>make</code>命令执行的期间，你的笔记本断电了。那么到你重启笔记本后，使用<code>ls</code>命令显示文件会呈现你期望的状态。</p><p>​ <strong>crash恢复</strong>(crash recovery)是文件系统中最有趣的问题之一。这个问题主要是因为许多文件系统的操作会伴随着写磁盘操作，要写入磁盘的数据是保存在内存中的(已经在内存中修改数据)，但是当数据写入磁盘到一半或是没有将内存的数据写入完，就会出现一个问题——重启系统后导致数据不一致。</p><blockquote><p><strong>crash情景</strong></p></blockquote><p>​ 以创建和写入x文件为例，主要调用了<code>open</code>与<code>write</code>这两个系统调用。那么echo期间打印一些写入磁盘的关键操作，忽略了读取操作，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hi&quot;</span> &gt; x</span></span><br><span class="line">write:33 allocate inode for x</span><br><span class="line">write:33 init inode x </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;-crash1</span></span><br><span class="line">write:46 record x in directory&#x27;s data block</span><br><span class="line">write:32 update root inode</span><br><span class="line">write:33 update inode x</span><br></pre></td></tr></table></figure><p>​ 第一二句得知，分配inode块33，就是为x文件分配一个inode，并且初始化inode的数据，(将磁盘块读取到buffer cache，并内存中初始化后，写回磁盘)。接着是更新根目录的数据块，就是添加x文件的描述，如下图所示写到了46这个磁盘块上。最后再是更新系统<strong>根目录的inode</strong>，再是将x文件的inode写回磁盘(将buffer cache中的inode写回磁盘)。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>​ 那么此时在上图中crash1点出现系统crash，那么保存在buffer cache的内容将会被全部清空。那么系统就会丢失x文件的inode，但是这个inode已经被<strong>标记为已使用</strong>(可以查看<code>ialloc</code>的实现逻辑)。在根目录下也找不到x文件的inode，也就<strong>无法删除这个inode</strong>。这个问题也是可以恢复的，就是在重启时检查所有的inode块，如果inode没有数据块就直接删除这个inode就可以了，显然这是十分麻烦的方案。</p><p>​ 一个还有风险情景是，<strong>同一个数据块属于两个文件</strong>，例如：在文件截断(将文件大小修改为0，释放文件内容)时发生crash，由于这些写磁盘操作是序列化的，那么就会导致inode中引用了一个<strong>数据块</strong>，但是在<strong>bitmap块</strong>中却标记了这个块为空闲。</p><p>​ inode引用了空闲块会造成的问题是，在重启后，内核可能分配这个数据块给其他文件，这就会造成两个不同的文件的内容指向了同一个数据块。如果xv6支持多用户，这就会造成<strong>安全问题</strong>，因为旧文件的用户能够读写新文件用户的数据。</p><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>日志简介</strong></p></blockquote><p>​ 为了恰当的应对文件系统的crash问题，因此在xv6中提供的解决方案的方案是<strong>日志(logging)</strong>，这是来自与数据库的解决方案，提供了如下属性：</p><ul><li><strong>原子性(atomic)</strong>，确保文件系统的系统调用是原子性的。这个属性和数据库事务的原子性是完全一样的，比如你调用<code>write</code>系统调用，所有写入磁盘块的操作，要么全部成功，要么全部失败，不会出现写入部分的问题。</li><li><strong>快速恢复(Fast Recovery)</strong>，在重启之后，不需要做大量的工作来修复文件系统，只需要非常小的工作量。在另一个解决方案中，可能需要读取文件系统的所有block，并检查文件系统是否还处于正确的状态，再来修复。所以日志有<strong>快速恢复</strong>的属性。</li><li><strong>高性能(high performance)</strong>，原则上来说，它可以非常的高效，但是在xv6并不高效。</li></ul><p>​ log块保存在固定的磁盘块中，已经在superblock中标识。在superblock中记录了<strong>log块的开始索引</strong>以及<strong>log块的数量</strong>，log块总共有30块(2-31)。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>​ 通过crash safty部分得知，文件系统调用对所有磁盘块的修改是不能在写入的中途发生系统crash。因此在日志设计中，将一系列磁盘的写入操作，<strong>包装成了一个事务</strong>，将所有磁盘块的写入，转换成了对log块的写入。接着了解一下日志事务的过程。</p><blockquote><p><strong>日志事务</strong></p></blockquote><p>将写入操作的分装成事务以及将日志事务产生效果的过程如下，主要有四个步骤：</p><ol><li><strong>日志写入(log write)</strong>，将直接写入磁盘块，改为写到log块。假设我们在内存中缓存了bitmap块，也就是块45。当需要更新bitmap时，不是直接写block 45，而是将数据写入到log块中，并记录这个更新应该写入到block 45。对于所有的写 block都会有相同的操作。</li><li><strong>操作提交(commit op)</strong>，在某个时间，文件系统的<strong>写操作结束</strong>了，比如说4-5个写磁盘块操作都结束，并且都保存在log块中，我们会提交这些写操作，也就是<strong>提交事务</strong>。这意味着需要在log的某个位置记录属于同一个文件系统的操作的个数，例如5。</li><li><strong>安装日志(install log)</strong>，安装日志就是将log块区域保存的所有要修改的磁盘块，转移到对应的磁盘块，比如说log5块保存的是595块的写入数据，那么就是将log5块复制到595块，依次安装所有日志。</li><li><strong>清理日志(clean log)</strong>，完成安装日志后，就可以清除log块。清除log块实际上就是将属于同一个文件系统调用的操作的个数设置为0。</li></ol><p>以上便是日志事务的所有工作流程，接着讨论一下可能发生的crash点。</p><blockquote><p><strong>日志与crash</strong></p></blockquote><ol><li>在1和2之间发生crash，重启之后什么都不会发生，就像是在执行文件系统调用之前的状态一样。</li><li>在2和3之间发生crash，这时所有的写操作都保存在log块中，已经有<code>committed</code>的标记，重启之后就再次执行<strong>install log</strong>操作就可以了。但是在2过程中crash，就没有<code>committed</code>标记，重启之后，就像是没有写入一样。</li><li>在3执行的过程和4发生之前发生crash，下次重启的时候，我们会<strong>redo log</strong>，我们或许会再次将log块中的数据再次拷贝到文件系统。log中的数据是固定的，我们就算重复写了文件系统，每次写入的数据也是不变的。这就说明<code>install log</code>操作是幂等的(<strong>idempotence</strong>，表示执行多次和执行一次效果一样)。</li></ol><p>以上便是日志在xv6实现的方式，也是最简单的日志实现方式。</p><blockquote><p><strong>数据交互过程</strong></p></blockquote><p>如下图所示是<strong>log write</strong>与<strong>log install</strong>的过程，例如，通过write系统调用，要写入数据到文件中，主要过程如下：只以读写bitmap块为例</p><ol><li>读取块2(磁盘中日志块编号是2-32)与块45到<code>bcache</code>，分别为日志头与bitmap块。</li><li>在内存中bcache修改两个块后，触发<strong>log commit</strong>，这时就将bcache中的块45与块2写入到log块中(写入磁盘)。</li><li>之后的某个时间点触发<strong>log install</strong>，将log块中的$D_{b1}$，其中b1指的是逻辑块，就是一个文件的数据块序列号，比如文件的数据保存在块400，450，460，那么b1=400，b2 = 450，b3 = 460。那么此时b1保存的数据就是块45的数据，直接写入到磁盘块45就可以了</li></ol><p>如下图所示<strong>H</strong>代表<strong>log header</strong>，其保存block数组内容是箭头<strong>H</strong>指向的左上角的矩形框中的数据，图中的流程如上面三步骤。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/log.png" alt="log"></p><h2 id="代码：logging"><a href="#代码：logging" class="headerlink" title="代码：logging"></a>代码：logging</h2><blockquote><p><strong>日志结构</strong></p></blockquote><p>在xv6中设计的log结构：</p><ul><li><strong>logheader结构</strong>：其中n表示本次log要操作的block数量，block数组代表要写入磁盘block的编号。在<code>param.h</code>中定义了一次事务中log最大的block数量。</li><li><strong>log结构</strong>：主要定义了关于log磁盘块相关的元数据，比较特别的是xv6将日志头嵌入了log结构中，第一个log磁盘块保存的就是logheader。</li><li><strong>log对象</strong>：对于日志这个数据对象在xv6中只有一个，一次在并发的事务执行时，需要使用sleep-lock用来解决竞争。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// max # of blocks any FS op writes</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE      (MAXOPBLOCKS*3)  <span class="comment">// max data blocks in on-disk log</span></span></span><br><span class="line">----<span class="built_in">log</span>.c</span><br><span class="line"><span class="comment">//4 + 4*30 = 124字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//124 + 24 + 5 * 4 = 168字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 24字节</span></span><br><span class="line">  <span class="type">int</span> start; 		<span class="comment">//磁盘上日志块的编号，在xv6中是block2</span></span><br><span class="line">  <span class="type">int</span> size;			<span class="comment">//日志块总数量</span></span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// 统计正在执行的文件系统调用数量，例如：read、write</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// 当前事务正在提交</span></span><br><span class="line">  <span class="type">int</span> dev;        <span class="comment">//磁盘设备编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>日志封装</strong></p></blockquote><p>​ 如前面的日志介绍，xv6将对于磁盘的多次交互操作封装为<strong>日志事务</strong>，保存读写的原子性，在xv6中就使用了两个接口实现事务的封装：</p><p><strong>begin_op</strong>：在进行磁盘读写前调用，与并发操作中为保护关键区的加锁一样。调用<code>begin_op</code>会进入死循环，这时进程会处于两种状态：</p><ol><li><strong>sleep等待</strong>：(1).当另一个事务正在提交时需要将当前事务进程休眠、(2).当日志块的空间满的时候需要休眠，避免日志块的空间被覆写。只有当另一个进程调用<code>wakeup</code>执行的时候，该事务才可能会被唤醒，并往下执行操作。</li><li><strong>执行事务</strong>：增加outstanding的数量释放log锁，跳出死循环，正常执行磁盘读写操作。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;<span class="comment">//有日志事务正在提交，后来的事务等待</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">//日志块的空间已满，等待日志提交。</span></span><br><span class="line">      <span class="comment">//在这里就表示，log系统只满足两个进程同时并发</span></span><br><span class="line">      <span class="comment">//后来的第三个以及后来的执行的事务需要休眠等待</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//增加outstading</span></span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>end_op</strong>：当磁盘读写操作执行完毕后，调用end_op相当于释放锁的操作，此时将<code>outstanding-1</code>，那么就可以开始提交事务。end_op调用时同样有两种状态：</p><ol><li><p><code>outstading==0</code>：说明日志结束时，log系统当前进程在进行事务操作并结束，那么此时就可以进行<strong>事务提交</strong>操作。</p></li><li><p><code>outstading!=0</code>：说明在日志系统中，同时有两个进程在进行log事务操作，一个事务结束的时候，<code>outstading!=0</code>就说明另一个事务正在执行，那么当前事务就不能提交(主要原因是为了提高log块的利用率)。接着便唤醒(wakeup)休眠进程，因为如果还有进程在<code>begin_op</code>等待，并且<code>log.lh.n</code>的值小于10，那么在begin_op休眠的进程便会被唤醒。如果<code>log.lh.n</code>大于10，那么休眠的进程仍然会休眠，指导当前log事务提交。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//准备提交</span></span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//唤醒begin_op休眠的进程</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    commit();<span class="comment">//将内存中的内容写入到日志块</span></span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q1</strong>：为什么<code>log.lh.n&lt;10</code>的时候，在begin_op休眠的进程就会被唤醒呢？</p><p><strong>A1</strong>：在<code>begin_op</code>有这样的判断<code>log.lh.n + (log.outstanding+1) * MAXOPBLOCKS &gt; LOGSIZE</code>，可以由此计算得出，虽然是一个判断条件，却有两个束缚，只有当日志块少于10的时候，才能够支持两个进程并发执行log事务。</p><p><strong>Q2</strong>：两个log并发执行事务，难道不会耗尽log块的空间吗，例如两个进程同时修改磁盘的15以上的块？</p><p><strong>A2</strong>：在write系统调用函数(kernel/file.c:filewrite)中，一次事务修改磁盘块的大小有所限制，这样就不会导致空间被耗尽。</p><blockquote><ol><li><strong>日志写入</strong></li></ol></blockquote><p>​ 由于日志事务存在，xv6就不能够直接使用<code>bwrite</code>将<code>bcache</code>的修改数据直接写回磁盘块。取而代之的是使用<code>log_write()</code>函数：简单来说就是在log结构中记录下修改的磁盘块的编号。</p><p>​ 这样做的是方便在后续的<strong>提交操作</strong>中文件系统将bcache中已修改块先保存到磁盘log中，保证事务操作的原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is:</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">//异常检查</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line">  <span class="comment">//简单的操作操作</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);	<span class="comment">//增加buf引用</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>提交操作</strong></li></ol></blockquote><p><code>commit</code>：在end_op中，会调用commit函数进行事务提交，主要的流程如下</p><ul><li><code>write_log</code>：将bcache修改的块写入到磁盘log块上。</li><li><code>1-write_head</code>：将log数据对象写回磁盘块，是真正的<strong>日志提交点</strong>！！！</li><li><code>install_trans</code>：将磁盘log块的数据写回目标的磁盘块上。</li><li><code>2-write_head</code>：清空当前log事务</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_log</code>：这个函数并不难，理清<code>from</code>与<code>to</code>两个buf的含义。</p><ul><li><strong>from</strong>：是在bcache中保存的事务操作中，对目标磁盘块已修改的数据。</li><li><strong>to</strong>：是磁盘log块，编号是2-31。</li></ul><p>那么这里的意思也就是将内存保存的已修改的磁盘块，写到磁盘log块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line">  <span class="comment">//将bcache内存中保存的对数据修改的数据先写入磁盘log块</span></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_head</code>：这个函数有两个作用，先介绍第一个作用。</p><ol><li>作为<strong>提交点</strong>：就是将内存中log数据对象的写回磁盘块2，也就是磁盘log块的开始编号，主要是<code>logheader</code>保存的目标磁盘块的编号。在下述代码块中<strong>bwrite</strong>将log数据对象写入log块，也就代表的是日志事务的<strong>提交点</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//读取磁盘上的logheader</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="comment">//修改磁盘的logheader块保存的内容</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf); <span class="comment">// -&gt;commit point，这里才是真正的事务提交点</span></span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​ 在<code>bwrite</code>发生前出现crash，那么整个事务就视为报废，重启后也不能事务还原。在其之后发生，那么这个事务也就代表成功执行了。这里也就很好的体现了事务的<strong>原子性</strong>。</p><blockquote><ol><li><strong>安装事务</strong></li></ol></blockquote><p>​ <strong>install_trans</strong>：这个函数发生在日志提交点之后。在事务成功提交后，xv6就可以放心的将log块中保存的数据写回目标磁盘块了。下述代码也就是将磁盘log块的数据写回目标磁盘块，理解起来也十分的简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>清理日志</strong></li></ol></blockquote><p><code>write_head</code>：这里介绍其第二个作用</p><ol><li><strong>清理日志</strong>：在调用write_head前，我们首先将<code>log.lh.n</code>重置为0，那么就代表磁盘块2中保存的logheadr的n字段也被置为0，那么这里<code>write_header</code>作用就是，防止在此后发生crash后，xv6重启后又重新安装日志。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  ....</span><br><span class="line">  install_trans(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>crash恢复</strong></p></blockquote><p>​ 当xv6遭遇crash时，那么在重启xv6时就会重新读取磁盘log块，重新安装日志并将清除日志头保存的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();<span class="comment">//重新读取磁盘log块的所有数据</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">//如果在crash前已经正在提交那么就安装日志</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// 清空log块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>inode布局</strong></p></blockquote><p>inode是文件系统的<strong>术语</strong>，主要有两个相关的意思：</p><ul><li>指包含文件大小和数据块的编号，在磁盘上(on-disk)的<strong>数据结构</strong>。</li><li>指包含磁盘inode和额外的内核信息，在内存(in-memory)上的<strong>数据结构</strong>。</li></ul><p>​ 在xv6磁盘的布局图中，inode是32-45在磁盘上的14个连续的块。每个inode有固定的大小64字节，一个磁盘块有16个inode(<code>1024/64</code> )。那么给定一个inode号(i-number或inode-number)，系统就可以计算得到inode所在的磁盘块的编号。在xv6中公式为：$32+x/16$，例如，i-number=17，那么所在的block就为$32+17/16= 33$。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><blockquote><p><strong>on-disk inode</strong></p></blockquote><p>​ <strong>on-disk inode数据结构</strong>包含的内容如：文件大小、文件类型(目录、文件、特殊文件)、<strong>链接数量</strong>(指向inode的目录数量)、指向磁盘数据块的地址的指针(有直接、间接地址，实际就是磁盘块编号)等元数据。以下便是磁盘中保存的inode结构，xv6的实现省去了文件创建、修改时间等等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ xv6的inode有12个直接地址指向12个数据块，1个间接地址指向1个块(数据块)，这个数据块包含了256个块号(<code>1024/4 = 256</code>，除4是因为块号的数据类型为uint32，block number)。由此可以计算得到xv6中可以存储文件的大小最大为$(12 + 256) * 1024 = 268KB$，由此可见xv6中可以容纳的文件大小特别的小。现在inode的地址字段布局如下所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/figure8.3.png" alt="figure8.3"></p><p>​ 在fs实验中会要求能够存储大文件，超过268KB。具体的实现思路为使用<strong>两级间接指针</strong>，类似于三级页表一样，就是<strong>一级间接地址</strong>(inode保存的一个间接地址指针)指向保存的是256个<strong>二级间接地址</strong>的块，每个二级间接地址指向一个保存256个块号(uint32无符号整数指向数据块，block number)的数据块，具体的指向如下图。在该实验中就会实现前11个指针为直接地址，第12个为一级间接指针，第13个位二级间接指针，那么此时可以容纳最大的文件大小为$(11 + 256 + 256 <em>256)</em> 1024 = 64MB + 12KB $。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2level_inode.png" alt="2level_inode"></p><p>那么现代操作系统下可以保存几十个GB的文件，那么inode的地址字段又该如何设置呢？没错就要使用<strong>三级指针</strong>，这样也和三级页表更相似了。</p><blockquote><p><strong>inode锁设计</strong></p></blockquote><p>在xv6中实现了两种inode锁和两个锁风格的机制用于保护inode结构。</p><ul><li><strong>itable.lock</strong>，是自旋锁，保护inode内存表中最多出现一次inode的不变量(内存inode的<strong>ref</strong>字段，记录内存中有多少个指针指向该inode)</li><li><strong>inode.lock</strong>，是睡眠锁，每一个inode都有一个这样的锁，确保独占的访问inode的字段(如长度)和inode指向的文件或目录内容。睡眠锁可以很好了解放CPU占用问题。</li><li><strong>ref字段</strong>，记录引用该文件的进程数，如果<code>ref&gt;0</code>，<code>inode</code>会继续保存在<code>itable</code>中，并且不会将该<code>itable</code>的条目用于其他<code>inode</code>。</li><li><strong>nlink字段</strong>，用于计算目录的文件(如不同目录路径下引用的这个文件)指向该文件的<strong>条目数</strong>，同样的<code>nlink&gt;0</code>，<code>inode</code>会接续保存在<code>itable</code>中。</li></ul><p>​ 以下便是itable的结构，还是比较简单的，就是一个inode数组和自旋锁而已，由于itable保存于内存中，其保存的inode数量只有50个，是少于磁盘保存的inode数的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br></pre></td></tr></table></figure><h2 id="代码：Block-allocator"><a href="#代码：Block-allocator" class="headerlink" title="代码：Block allocator"></a>代码：Block allocator</h2><blockquote><p><strong>块分配器</strong>的相关操作：</p></blockquote><p>​ 块分配器提供了两个函数用于操作空闲池：</p><p><strong>bfree</strong>：释放磁盘块，设置bitmap，标记指定磁盘块位空闲：</p><ol><li>使用<code>bread</code>通过inode读取文件的磁盘上<strong>bitmap块</strong>，并缓存了buffer cache的节点</li><li>更改<strong>bmap块</strong>的指定文件数据块号的位的值，将指定位设置为9。例如要删除<code>block number = 60</code>的块，只需要将第一个<code>bitmap</code>块(<code>60/(1024*80) = 0</code>，使用<strong>BBLOCK</strong>计算)上，第8个字节(<code>60/8 = 7</code>，使用<strong>BPB</strong>计算，字符数组从0开始计数)，将第8个字节上的第5个位(<code>60%8 = 4</code>，同样是从0开始)，设置为0就可以了。</li><li>调用<code>log_write</code>，将该inode块的写入操作添加到log header。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 		  1024</span></span><br><span class="line"><span class="comment">//计算得出bitmap磁盘的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span></span><br><span class="line"><span class="comment">//一个字节8位，可以标识1024 * 8 个数据块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB           (BSIZE*8)</span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line">  </span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  <span class="comment">//获取数据块号的处于的位数</span></span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  <span class="comment">//标记到一个字节中</span></span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;<span class="comment">//将指定bitmap字节上的数据块位设置为0</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p><strong>balloc</strong>：分配磁盘块，设置bitmap，标记指定磁盘块已分配：</p><p>这个函数于<code>bfree</code>函数的实现思路相同，都是操作<strong>bitmap块</strong>，只不过效果是相反的，这里就不过多阐述了。</p><h2 id="代码：Inode分配"><a href="#代码：Inode分配" class="headerlink" title="代码：Inode分配"></a>代码：Inode分配</h2><blockquote><p><strong>in-memory inode</strong></p></blockquote><p>在buffer cache中保存的inode块是直接拷贝的磁盘上的inode块，但是在为了方便<strong>并发控制</strong>以及inode数据操作，xv6中设计inode层上使用的inode结构，如下所示，添加了一些字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// 磁盘设备编号</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode编号</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// 引用计数，有多少进程使用该inode</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">//包含inode的不变量</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode是否已经从磁盘上读取</span></span><br><span class="line">  <span class="comment">//以下字段是完全拷贝于磁盘inode块</span></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分配新的indoe</strong></p></blockquote><p>​ 首先xv6调用<code>ialloc</code>，这个函数与<code>balloc</code>相同：如下图所示，遍历磁盘上的所有inode节点，寻找到空闲的inode后，写入inode类型到磁盘，然后通过调用<code>iget</code>从inode表中返回一个条目。<code>ialloc</code>必须确定只有一个进程持有对<code>bp</code>的引用，并且要确定这个过程的<strong>原子性</strong>，不能同时的被其他进程看见这个inode是可获取的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="comment">// Inodes per block.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"><span class="comment">// Block containing inode i</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="comment">//buffer cache保存的inode块的结构是磁盘上的结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    <span class="comment">//bp-&gt;data字段保存的是一个inode磁盘块</span></span><br><span class="line">    <span class="comment">//加inum%IPB就能找到指定的磁盘块上的inode</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ialloc: no inodes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 接着看看如何通过<code>iget</code>将空闲的inode加入inode表(内存的保存的结构)。首先遍历整个inode表，如果这个inode以及存在(<code>ip-&gt;ref&gt;0</code>)于inode表中则添加引用计数，并将其inode返回，反之将记录一个空闲inode，退出循环后，分配inode表中这个inode槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already in the table?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;itable.inode[<span class="number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;itable.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//write info to itable&#x27;s inode entry</span></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 以上过程便是<code>ialloc</code>分配ialloc过程，，将磁盘的inode块读取到<code>buffer cache</code>中，并从<code>buffer cache</code>获取一个空闲inode，将其记录到inode表中，并返回这个inode地址。</p><p>​ 如果你看过创建文件的代码后，就可以知道在用户使用<code>open</code>系统调用时，进入内核便会调用<code>create</code>创建文件，接着会调用<code>ialloc</code>为该文件分配inode。</p><blockquote><p><strong>inode锁</strong></p></blockquote><p>在读取或写入inode的元数据或内容之前，必须使用锁来预防数据竞争。inode锁的使用方式是<code>ilock</code>与<code>unilock</code>。</p><ul><li><p><code>ilock</code>使用睡眠锁(sleep-lock)保护inode。一旦ilock独占的访问inode，如果需要就可以<strong>向磁盘读取</strong>(更多的是向buffer cache读取)inode。</p></li><li><p><code>iunlock</code>释放睡眠锁，可以让唤醒一个因等待该inode资源的进程。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">	....<span class="comment">//读取buffer cache，并更新inode表中的inode数据</span></span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码：Inode释放"><a href="#代码：Inode释放" class="headerlink" title="代码：Inode释放"></a>代码：Inode释放</h2><blockquote><p><strong>iput</strong>：释放inode</p></blockquote><ul><li><code>iput</code>：如果inode没有其他指针引用(<code>ip-&gt;ref == 1)</code>并且没有目录链接(<code>ip-&gt;nlink == 0</code>)，这个块将会被释放。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 代表没有其他进程将该inode锁定</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;itable.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>itruc</strong>：释放inode指向的文件数据</p></blockquote><p><code>itrunc</code>：在iput中会调用该函数，将文件<strong>截断</strong>为0字节，<strong>释放数据块</strong>，将inode的<code>type</code>字段设置为0(代表该inode未分配)，最后将inode写回磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line">  <span class="comment">//查找直接引用的数据块进行释放</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找间接引用的数据块进行释放</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>iput</strong>：锁与类似于锁的机制</p></blockquote><p>接着研究<code>iput</code>是如何释放inode锁定协议的，主要运用了两个锁和两个类似于锁的机制机制解决。</p><p>​ 首先第一个问题是，并发线程为了使用inode可能会在<code>ilock</code>等待，并且没有发现这个inode不会再被分配，就是没有在并发线程知道的情况下释放了inode，但是这不会发生，主要是因为如果inode没有目录链接(<code>ip-&gt;link == 0</code>)并且<code>ip-&gt;ref == 1</code>，系统调用没有方法获取内存inode的指针。而且唯一的引用还是调用<code>iput</code>的线程的引用数，所以调用iput之后检查<strong>inode的引用计数</strong>是否在<code>itable.lock</code>的关键区之外，但是此时链接数量为0，所以说明没有其他线程尝试获取这个inode。</p><p>​ 另一个点是，并发调用<code>ialloc</code>可能会选择<strong>相同</strong>的并且<strong>正在</strong>被<code>iput</code>释放的inode，这个只可能发生在<code>iupdate</code>写入inode到磁盘之后，这时inode的type字段为0。但是这个数据竞争是良性的，分配inode的线程在读取或写入inode之前，会等待以获取inode的睡眠锁，直到<code>iput</code>释放。</p><p>​ <code>iput</code>可以写入磁盘，这也就意味这任何系统调用会使用文件系统写入磁盘，因为系统调用可能是最后一个文件引用的调用。<code>read</code>系统调用以只读的方式读取文件都会在结束之前调用<code>iput</code>，这就意味则所有的文件系统调用将会封装到事务中。</p><blockquote><p><strong>挑战</strong>：crash与iput</p></blockquote><p>​ <strong>问题</strong>：crash与iput的交互是一个挑战，因为一些进程可能持有内存inode的引用，所以iput当文件的链接数为0时也不会立即的截断一个文件。但是如果<strong>crash</strong>发生在最后一个进程关闭文件文件描述符之前，然后文件才被标记，但该文件已经分配到磁盘但是没有目录条目指向这个文件，在内存inode写回磁盘时crash，就会有磁盘中有残留的文件数据。</p><p>文件系统解决上述问题，主要有两种方式：</p><ol><li>从<strong>恢复</strong>(recovery)方式上解决：在重启之后，文件系统扫描整个已经标记分配的文件，但是没有目录条目指向，此时只重新为文件添加目录条目就可以了。</li><li>从<strong>锁机制</strong>上解决：文件inode的inumber的链接计数下降到零，但是引用计数却不是零。如果当文件的引用计数到达文件系统删除文件，然后通过从列表删除inode更新磁盘列表。在恢复上，文件系统将会释放所有在list中文件。</li></ol><p>xv6没有实现上述两种方案，这也意味这上述的错误情况可能会发生在xv6中。</p><h2 id="代码：数据块分配"><a href="#代码：数据块分配" class="headerlink" title="代码：数据块分配"></a>代码：数据块分配</h2><p>​ 在为文件添加数据时，通常会创建新的数据块。查看<code>write</code>系统调用，就可以知道创建数据块是调用了<code>bmap</code>函数，在<code>bmap</code>中调用了<code>balloc</code>函数就是用于创建数据块的。</p><blockquote><p><strong>bmap</strong>：查找数据块编号</p></blockquote><p>​ <code>bmap</code>函数中会分别使用<strong>直接地址指针</strong>与<strong>间接地址指针</strong>记录数据块号，这些指针记录于inode中。在xv6的文件系统中，<code>ip.addr[0:11]</code>是直接指针地址，<code>ip.addr[12]</code>是间接地址指针地址。<code>bn</code>是用于标记现在要写入数据的块，是该文件的第几个数据块。</p><ol><li><strong>查找直接地址</strong>：如果<code>bn&lt;NDIRECT</code>，说明所写的数据偏移是小于<code>1024*12</code> (12个块)的。查找该索引的地址是否存在，不存在使用<code>balloc</code>分配数据块，并将这个数据块的编号记录到<code>addr</code>数组中，反之返回addr保存的地址值。</li><li><strong>查找间接地址</strong>：如果<code>ip.addr[12]</code>存在，那么就可以直接读取这个保存数据块地址的<strong>地址块</strong>(address block，这个块也是一个数据块)，使用<code>balloc</code>分配数据块，并将其记录到地址块的指定索引中。反之不存在就使用<code>balloc</code>分配地址块。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint)) <span class="comment">// 地址块中256个数据块地址</span></span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[bn] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;<span class="comment">//强转1024字符数组为包含256个整数的数据</span></span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>bmap</code>函数便<code>readi</code>与<code>writei</code>可以很方便的操作数据块了。</p><h1 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>​ 在linux中目录(dircetory)被设计得像<strong>文件</strong>一样，本质上就是文件加上一些文件系统能够理解的<strong>数据结构</strong>。在inode中的<code>type</code>字段为<code>T_DTR</code>则说明是一个目录，并且这个inode会保存<strong>目录条目</strong>，可以是文件或子目录，这些目录条目则保存在目录inode的<strong>地址指针指向的数据块</strong>中。</p><p>每一个目录都会包含多个目录条目，如下结构体便是目录条目(directory entry)。长度为16字节，分为如下两个字段：</p><ul><li><code>inum</code>(2B)：子目录的inode编号；</li><li><code>name</code>(14B)：文件或者子目录的名称。</li></ul><p>由此可知一个数据块能够保存<code>1024/16 = 64</code>个目录条目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来介绍以下与目录相关的代码。</p><h2 id="代码：directory-layer"><a href="#代码：directory-layer" class="headerlink" title="代码：directory layer"></a>代码：directory layer</h2><blockquote><p><strong>dirlookup</strong>：查找指定文件</p></blockquote><p>​ 通过指定的名字在<strong>目录inode</strong>中查找对应的目录条目，如果找到指定的目录条目就将返回对应的<strong>文件inode指针</strong>，将<code>*poff</code>设置为当前的目录条目偏移量，以便调用函数可以修改这个条目，最后通过<code>iget</code>返回一个未锁定的inode指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>dirlink</strong>：添加文件inode到目录inode中</p></blockquote><p>​ 在使用<code>open</code>创建文件时会使用到该函数，通过传递给定的名称和i-number作为一个<strong>目录条目</strong>到目录inode(<code>dp</code>)中。主要步骤如下：</p><ol><li><code>dirlookup</code>判断要添加的目录条目inode是否已经存在于当前目录inode中，存在的话则返回一个错误。</li><li>遍历<code>dp</code>指向的保存目录条目的数据块，寻找一个数据块中是否有空闲的目录条目节点，若找到则跳出循环。</li><li>将传递的参数写入空闲目录条目中，再将目录条目写回数据块。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h1><h2 id="代码：Path-names"><a href="#代码：Path-names" class="headerlink" title="代码：Path names"></a>代码：Path names</h2><p>​ 在操作文件的时会涉及一系列的路径名，如相对路径、绝对路径、当前路径等。只有指定了正确的路径名我们才能打开正确的文件，因此通过路径查询文件也是十分重要的功能，在xv6也提供了路径名解析的函数：</p><blockquote><p><strong>namei</strong>：解析路径名并返回指定的inode</p></blockquote><p>​ <code>namei</code>是输入一个路径名参数，以此解析路径获得文件inode。如：输入<code>/a/b/c</code>，那么获得的就是文件c的inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>nameiparent</strong>：返回文件父目录的inode</p></blockquote><p>​ <code>nameiparent</code>是<code>namei</code>函数的变种，与其不同的是需要输入两个参数，会返回<strong>父目录的inode</strong>并将路径名的最后一个元素保存到name中。例如输入<code>/a/b/c</code>，name就是c这个文件，而inode则是<code>/a/b</code>这个目录inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>namex</strong>：解析路径函数</p></blockquote><p>​ <code>namex</code>是<code>namei</code>与<code>nameiparent</code>函数的广义的函数，实际上所有的解析操作由<code>namex</code>完成。接着按照流程解释一下namex构成：</p><ol><li>判断路径名开始字符，确定路径名，如果是以<code>&#39;/&#39;</code>开始就是<strong>绝对路径</strong>，为开始读取根inode)，反之是<strong>当前路径</strong>，读取当前进程的inode。以此获得目录inode。</li><li>循环执行<code>skipelem</code>函数，解析路径名称跳过一些目录或者重复的元素(如<code>&#39;/&#39;</code>字符)。</li><li>如果<code>path=/a/b/c</code>，经过<code>skipelem</code>调用后<code>path=b/c</code>。显然path并不为0则进入循环，在循环内部首先检查ip这个inode是否为目录，如果不是则调用<code>iunlockput</code>函数释放inode。再判断调用者是否为<code>nameiparent</code>函数并且<code>path</code>是否为0，是的话则返回这个目录inode。</li><li>判断文件名(<code>name = /b/c</code>)是否在目录inode(根目录<code>/</code>)中存在，如果存在获取<code>/a/b/</code>目录的inode，并将ip设置为当前inode。</li></ol><p>以<code>/a/b/c</code>为例，那么第一次循环<code>path = b/c,name = a ip = a/</code>，第二次循环<code>path = c，name = c ip = b/</code>，第三次循环<code>path = 0,name = c</code>，退出循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line">  <span class="comment">//如///a//b/c，那么第一次调用skipelem函数 path = b/c，name= a。</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>​ Unix设计中比较意思的方面就是在Unix中的大部分资源都可以表示成为<strong>文件</strong>，包括设备(console)，管道，文件。File descriptor layer则是将所有资源统一为文件的层，体现了<strong>一致性</strong>(uniformity).</p><p>​ <strong>文件描述符</strong>从数据类型的视角来看就是一个整型<strong>int</strong>，通过文件描述符我们就可以调用<code>write</code>或<code>read</code>方法去操作文件资源。但是文件描述符的背后的数据结构并不是一个整型所能表述的，文件描述符是通过<strong>层层抽象</strong>得到一个简易的可以操作文件资源的<strong>句柄</strong>，实际原理是将文件的inode与文件描述符通过内核制作成了一个映射。</p><p>​ 那么在xv6是如何通过文件inode一步步生成文件描述符，又是如何通过文件描述符操作文件的，接着学习一下有关File descriptor layer的代码。</p><h2 id="代码：文件结构"><a href="#代码：文件结构" class="headerlink" title="代码：文件结构"></a>代码：文件结构</h2><blockquote><p>1.<strong>进程结构</strong></p></blockquote><p>进程的结构体代码，我们会发现proc结构体有两个关于文件的字段：</p><ul><li><strong>ofile</strong>：表示进程<strong>已打开</strong>的文件或文件描述符表，每一个file结构对应一个文件描述符。那么NOFILE==16，也就代表xv6中能够一个进程最多能够打开16个文件。</li><li><strong>cmd</strong>：cmd代表当前进程的<strong>文件目录</strong>的inode。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ....<span class="comment">//有关文件系统的字段</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFILE       16  <span class="comment">// open files per process</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.<strong>文件结构</strong>：保持Unix资源一致性</p></blockquote><p>​ 在xv6内核中，为了方便<strong>管理</strong>文件、设备、管道等资源、将这些资源抽象<strong>一致化为文件</strong>，设计成为了file结构体。</p><p>​ 每个打开的文件都由一个<code>struct file</code> 表示，对 <strong>inode</strong>或<strong>管道</strong>以及 I/O 偏移量等元数据的封装，不同类型的资源可以使用type字段进行标识。在用户进程每次调用open系统调用创建新文件的过程，就是创建一个新的<code>struct file</code>。file结构在多进程同样也可以很好的协调：</p><ul><li><p>如果多进程独立打开同一个文件，不同的实例的I/O偏移量也不同</p></li><li><p>另一方面，一个打开的文件可以多次出现在一个或多个进程的文件表中，如果一个进程使用 open 打开文件，然后使用 <code>dup</code> 创建别名(单进程文件表)，或使用 <code>fork</code> (多进程文件表)与子进程共享，就会出现这种情况。</p></li></ul><p>文件结构体代码，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="comment">//枚举文件类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// 记录打开文件的引用数量。</span></span><br><span class="line">  <span class="type">char</span> readable; <span class="comment">//表示文件是否可读</span></span><br><span class="line">  <span class="type">char</span> writable; <span class="comment">//表示文件是否可写</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// 记录当前文件管道</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// IO的偏移量</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>3.<strong>全局文件表</strong>：</p></blockquote><p>​ 所有以打开的文件，都会保存在系统的全局文件表中(<code>ftable</code>)，在<code>ftable</code>中提供多个函数接口给内核，用于操作全局文件表：</p><ul><li><code>filealloc</code>：分配文件。</li><li><code>filedup</code>：创建重复的文件引用，增加文件引用数。</li><li><code>fileclose</code>：释放文件引用，当引用数为0，释放文件。</li><li><code>fileread、filewrite</code>：对文件进行读写。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----file.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILE       100 </span></span><br></pre></td></tr></table></figure><p>全局文件表的主要作用：用于<strong>多进程</strong>之间文件实例的<strong>通信</strong>、内核可以更加方便的使用文件资源。</p><h2 id="代码：创建文件描述符fd"><a href="#代码：创建文件描述符fd" class="headerlink" title="代码：创建文件描述符fd"></a>代码：创建文件描述符fd</h2><blockquote><p>1.<strong>用户级</strong>文件操作示例</p></blockquote><p>​ 如下所示，在用户程序中，可以使用<code>open</code>进行创建文件，并且获取文件描述符fd。那么fd就代表这个test1文件。之后我们便可以通过这个fd访问文件，使用<code>write</code>向test1文件写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----user/test1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test1&quot;</span>,O_CREATE|O_RDWR);</span><br><span class="line">    write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着以系统调用操作的顺序进行了解。为了不混淆文件之间的概念，在此先声明下文所提每一个词汇的所指向的实体：</p><ul><li><strong>文件实例</strong>：数据类型为<code>struct file</code>，已打开的文件在全局文件表中保存，其保存的inode字段指向了文件资源。</li><li><strong>文件资源</strong>：主要用于表示磁盘块上的文件数据，内核就是通过文件实例中的inode字段，访问到文件资源的。</li><li><strong>文件描述符</strong>：用户级的文件实例，数据类型为<code>int</code>，是简化过后了文件实例，作为进程文件表的索引。</li></ul><p>以上是笔者自己的表述(不包含设备和管道的描述)，可能有所毛病，如有错请指出。</p><blockquote><p>2.<strong>open</strong>：获取文件描述符</p></blockquote><ol><li>用户通过open系统调用输入的路径(<code>./test1</code>)，在sys_open创调用create函数，创建了当前目录下的文件(<strong>test1</strong>)的inode。</li><li>调用<code>filealloc</code>分配全局文件表，分配一个文件实例。</li><li>调用<code>fdalloc</code>将上述获取的文件实例转化成为<strong>文件描述符</strong>，这可以理解建立了映射。</li><li>设置文件实例的相关字段，这里主要是将<strong>test1</strong>文件的<code>inode</code>绑定到了文件实例上。</li><li>将文件描述符返回给用户。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  argint(<span class="number">1</span>, &amp;omode);</span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  ....<span class="comment">//创建(调用create)或查找目标文件路径的inode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	....<span class="comment">//错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....<span class="comment">//修改文件结构体对应的元数据</span></span><br><span class="line">  f-&gt;ip = ip;<span class="comment">//将文件结构的inode字段设置为目标文件inode</span></span><br><span class="line">  ....<span class="comment">//修改文件结构体对应的元数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.<strong>分配文件描述符</strong>：建立文件实例映射</p></blockquote><p>​ <code>fdalloc</code>函数：观察下述代码，主要是将全局的文件实例，分配给了当前进程，fd则是代表的是进程<strong>打开文件表(open file table)的索引</strong>。那么在此之后只要是该进程的用户进程就能够通过这个文件描述符，访问到对应的文件实例。原理就是简单的hash表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----sysfile</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程粗略的可以描述为下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fd_open.png" alt="fd_open"></p><h2 id="代码：通过fd修改文件资源"><a href="#代码：通过fd修改文件资源" class="headerlink" title="代码：通过fd修改文件资源"></a>代码：通过fd修改文件资源</h2><blockquote><p>4.<strong>write</strong>：通过文件描述符操作文件</p></blockquote><p>​ 在通过<code>open</code>获得<strong>test1</strong>的文件描述符fd后，那么wrtie就可以通过fd去修改文件数据了。具体的过程就是通过<code>argfd</code>函数将fd转换为文件实例，在通过文件实例中保存的<strong>test1的inode</strong>字段，就可以对文件数据进行修改。</p><p>​ 之后在调用<code>filewrite</code>就能够将write系统调用传入的字符或字符串，写入到test1文件中了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p;</span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">  argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.<strong>获取文件实例</strong>：根据文件描述符获取对应文件实例</p></blockquote><p>​ 在前文也提到了，通过<code>argint</code>获取用户传递的fd，将fd作为当前进程结构的<code>ofile</code>字段的索引便能够得到<strong>文件实例</strong>，这样sys_write函数就能够获得<strong>文件实例</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">argfd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *pfd, <span class="keyword">struct</span> file **pf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  argint(n, &amp;fd);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  <span class="keyword">if</span>(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.<strong>修改文件资源</strong>：通过文件实例的inode字段，访问并修改文件资源。</p></blockquote><p>​ 如下述代码所示，这里我们忽略掉设备和管道等文件类型，只关注inode文件操作。在代码中，<code>filewrite</code>函数调用了<code>writei</code>函数，注意到writei中将文件实例的inode字段作为参数进行传递，也就说明<code>writei</code>函数是根据<code>inode</code>对文件资源的描述，对文件资源进行修改的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....<span class="comment">//other file type</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">        <span class="comment">// error from writei</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​ 文件系统算是操作系统中代码量比较大的一个部分，在学习上也需要配合代码来理解。由于文件系统的体量比较庞大，在学习上也比较困难。在xv6中将文件系统抽象成了7个层面，通过每一层执行不同的功能，在通过操作系统的协调，由繁至简便能够更好的去理解文件系统。</p><p>​ 在本章的学习过程中，比较难以理解的就是Buffer cache、Logging、Inode三个层面。其他的代码量也相对比较少，在此总结一下每一个层面的内容：</p><ol><li><strong>Disk layer</strong>：对磁盘数据资源按功能进行范围划分，有boot、super、log、inode、bitmap、data等类型的磁盘块，磁盘的两个扇区算作一个块。</li><li><strong>Buffer layer</strong>：将内存的一部分作为磁盘块的缓存区，加速CPU对磁盘数据的修改。在该层涉及到了双链表与LRU的操作，虽然简单，但还是比较值得学习的。</li><li><strong>Logging layer</strong>：提供数据库中的事务与日志概念，在xv6中实现log，主要是为了防止crash问题，以实现修改磁盘数据的原子性(数据库的概念)。</li><li><strong>Inode layer</strong>：Inode是描述<strong>文件</strong>的一个数据结构，通过inode可以获得文件的基本信息，在Inode层比较需要理解的就是文件指针(用于定位文件磁盘的数据块)、内存inode与磁盘inode的区别、以及内存inode的操作。</li><li><strong>Directory layer</strong>：通过目录的概念，将文件的存储设计成了分级树状的结构。</li><li><strong>Pathname layer</strong>：将一个文件路径名(如a/b/c)通过解析找到对应的文件(c)inode，对文件进行操作。</li><li><strong>File descriptor layer</strong>：将Unix大部分资源一致化，抽象化为<strong>文件</strong>形式(<code>struct file</code>)。提供给用户进程的一个文件实例，通过文件路径名并能够获得文件资源句柄，用户进程可以通过该句柄访问指定的文件进行操作。</li></ol><p>以上便是xv6文件系统的所有知识点了，建议在学习过程中配合源码进行理解。</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>xv6：文件系统</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.ember-l.top/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">http://www.ember-l.top/2023/09/25/操作系统/Chapter 8：文件系统/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Ember🍐</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-09-25</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-09-25</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂硬币</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230726141038789.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mit6.S081:lab mmap</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%202%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90/" title="xv6：操作系统组成"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img38.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">xv6：操作系统组成</div></div></a></div><div><a href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%201%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="xv6：操作系统接口"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251415483.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">xv6：操作系统接口</div></div></a></div><div><a href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%203%EF%BC%9A%E9%A1%B5%E8%A1%A8/" title="xv6：页表"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img30.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">xv6：页表</div></div></a></div><div><a href="/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%205%EF%BC%9A%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" title="xv6：中断与设备驱动"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251416606.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-14</div><div class="title">xv6：中断与设备驱动</div></div></a></div><div><a href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%204%EF%BC%9A%E9%99%B7%E9%98%B1%20trap/" title="xv6：trap机制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img41.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-14</div><div class="title">xv6：trap机制</div></div></a></div><div><a href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab1%EF%BC%9Autilities/" title="Mit6.S081:lab utilities"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">Mit6.S081:lab utilities</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">Ember🍐</div><div class="author-info__description">BugMaker 💦💦💦</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ember-l"><i></i><span>Follow me🚀</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/qq.jpg" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/assets/wx.jpg" target="_blank" title="微信"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/ember-l" target="_blank" title="github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github1"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2508856440@qq.com" target="_blank" title="邮箱"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://www.zhihu.com/people/low-45-75" target="_blank" title="知乎"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shejiaotubiao-10"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:27px;width:27px;fill:currentColor;position:relative;top:3px" aria-hidden="true"><use xlink:href="#icon-fengche"></use></svg></a><span>公告</span></div><div class="announcement_content"><center><b>--- 主域名 ---<br><a href="https://www.ember-l.top" title="此线路部署于Vercel" class="anno_content"><font color="#cc7227">ember-l.top</font></a></b></center></div><div id="welcome-info"></div></div><div class="card-widget tzy-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face"></div><div class="back face"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:27px;width:27px;fill:currentColor;position:relative;top:3px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#File-system"><span class="toc-text">File system</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xv6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">xv6文件系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Disk-Layer"><span class="toc-text">Disk Layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A1%AC%E4%BB%B6%E4%BA%A4%E4%BA%92"><span class="toc-text">磁盘硬件交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80"><span class="toc-text">磁盘布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Buffer-cache-layer"><span class="toc-text">Buffer cache layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Logging-layer"><span class="toc-text">Logging layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9Alogging"><span class="toc-text">代码：logging</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inode-layer"><span class="toc-text">Inode layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9ABlock-allocator"><span class="toc-text">代码：Block allocator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9AInode%E5%88%86%E9%85%8D"><span class="toc-text">代码：Inode分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9AInode%E9%87%8A%E6%94%BE"><span class="toc-text">代码：Inode释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%9D%97%E5%88%86%E9%85%8D"><span class="toc-text">代码：数据块分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Directory-layer"><span class="toc-text">Directory layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9Adirectory-layer"><span class="toc-text">代码：directory layer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pathname-layer"><span class="toc-text">Pathname layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9APath-names"><span class="toc-text">代码：Path names</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File-descriptor-layer"><span class="toc-text">File descriptor layer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">代码：文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd"><span class="toc-text">代码：创建文件描述符fd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A%E9%80%9A%E8%BF%87fd%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="toc-text">代码：通过fd修改文件资源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="xv6：文件系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="xv6：文件系统"></a><div class="content"><a class="title" href="/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="xv6：文件系统">xv6：文件系统</a><time datetime="2023-09-24T16:00:00.000Z" title="发表于 2023-09-25 00:00:00">2023-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/" title="Mit6.S081:lab mmap"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230726141038789.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Mit6.S081:lab mmap"></a><div class="content"><a class="title" href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/" title="Mit6.S081:lab mmap">Mit6.S081:lab mmap</a><time datetime="2023-07-25T16:00:00.000Z" title="发表于 2023-07-26 00:00:00">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/" title="Mit6.S081:lab fs"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2level_inode.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Mit6.S081:lab fs"></a><div class="content"><a class="title" href="/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/" title="Mit6.S081:lab fs">Mit6.S081:lab fs</a><time datetime="2023-07-16T16:00:00.000Z" title="发表于 2023-07-17 00:00:00">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/" title="Mit6.S081:lab locks"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img30.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Mit6.S081:lab locks"></a><div class="content"><a class="title" href="/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/" title="Mit6.S081:lab locks">Mit6.S081:lab locks</a><time datetime="2023-06-25T16:00:00.000Z" title="发表于 2023-06-26 00:00:00">2023-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/" title="Mit6.S081:lab net"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img2.4.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Mit6.S081:lab net"></a><div class="content"><a class="title" href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/" title="Mit6.S081:lab net">Mit6.S081:lab net</a><time datetime="2023-06-14T16:00:00.000Z" title="发表于 2023-06-15 00:00:00">2023-06-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Ember🍐</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20232016" target="_blank">萌ICP备20232016号</a><p>There is only one heroism in the world to see the world as it is and to love it</p><p><a target="_blank" href="https://hexo.io/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a>&nbsp;<a target="_blank" href="https://vercel.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.14.3/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{const e=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.ember-l.top/.netlify/functions/twikoo",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)")),setTimeout((function(){let e=document.querySelectorAll(".tk-comments-container .tk-comment");if(e.length>0){let n='<div class="swiper-wrapper">';for(let t=0;t<e.length;t++){let o=e[t].getAttribute("id")||"",a=e[t].querySelector(".tk-nick")?.innerText||"",i=e[t].querySelector(".tk-nick")?.href||"",r=e[t].querySelector(".tk-avatar-img")?.src||"",l=e[t].querySelector(".tk-time")?.innerText||"",c=e[t].querySelector(".tk-extras .tk-extra:first-child span:last-child")?.innerText||"",s=e[t].querySelector(".tk-content>span:last-child")?.innerHTML||"";s=s.replace(/\n/g,""),s=s.replace(/<blockquote>.*?<\/blockquote>/gi,""),s=s.replace(/<pre.*?<\/pre>/gi,"[代码]"),n+=`\n                <div class="swiper-slide">\n                  <div class="comment-barrage-item">\n                    <div class="barrage-info">\n                      <a class="barrage-title" title="跳转至评论区" href="#post-comment">热评</a>\n                      <a href="${i?i+'" target="_blank" rel="noopener noreferrer" title="访问 '+a+'"':'javascript:void(0);"'}>\n                        <img class="barrage-avatar" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="${r}">\n                      </a>\n                      <span class="barrage-nick">${a}</span>\n                      <span class="barrage-city">${c}</span>\n                      <span class="barrage-time">${l}</span>\n                      <a class="barrage-close" onclick="eurkon.switchCommentBarrage()" title="隐藏热评"><i class="fa-solid fa-xmark"></i></a>\n                    </div>\n                    <div class="barrage-content">\n                      <a title="跳转至该评论" href="#${o}">${s}</a>\n                    </div>\n                  </div>\n                </div>`}n+="</div>";let o=document.getElementById("comment-barrage")||document.createElement("div");o.id="comment-barrage",o.innerHTML=n,o.style.display="false"===window.localStorage.getItem("commentBarrageDisplay")?"none":"block",document.getElementById("post-comment").appendChild(o);var t=new Swiper("#comment-barrage",{direction:"vertical",loop:!0,mousewheel:!0,autoplay:{delay:3e3,disableOnInteraction:!0}});o.onmouseenter=function(){t.autoplay.stop()},o.onmouseleave=function(){t.autoplay.start()}}}),1e3)}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const e=document.getElementById("twikoo-count");e&&twikoo.getCommentsCount({envId:"https://twikoo.ember-l.top/.netlify/functions/twikoo",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(t){e.innerText=t[0].count})).catch((function(e){console.error(e)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(e):setTimeout(e,0)};btf.loadComment(document.getElementById("twikoo-wrap"),t)})()</script></div><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/share.js"></script><script src="/js/key.js"></script><script src="/js/barrage.js"></script><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="//at.alicdn.com/t/c/font_3864328_90xjkz8cfrn.js"></script><script async src="/js/fps.js"></script><script src="/js/nav.js" async></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script src="/js/charts.js" async></script><script defer data-pjax src="/js/beautify.js"></script><script src="/js/twikoo_beautify.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id:"Jx18u1PbLX8sXMaz",ck:"Jx18u1PbLX8sXMaz"})</script><script>(new LingQue.Monitor).init({id:"Jx18u1PbLX8sXMaz",sendSuspicious:!0})</script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/MIT6-824/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 阿梨の分布式系统学习 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 阿梨のC++学习 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 阿梨の操作系统学习 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/Tool/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 阿梨の常用工具 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.ember-l.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#fed558}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="/",qweather_key="b16a1fa0e63c46a4b8f28abfb06ae3fe",gaud_map_key="e2b04289e870b005374ee030148d64fd&s=rsv3",baidu_ak_key="undefined",flag=0,clock_rectangle="113.34532,23.15624",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img30.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt="">FaRM</a><div class="blog-slider__text">No compromises:distributed transactions with consistency, availability, and performance</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2level_inode.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt="">Mit6.S081:lab fs</a><div class="blog-slider__text">MIT6.S081：lab9</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt="">Lab4:Shards KV Service(未完善)</a><div class="blog-slider__text">MIT6.824 lab4实现# 描述</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230726141038789.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt="">Mit6.S081:lab mmap</a><div class="blog-slider__text">MIT6.S081：lab10</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt="">Lab:KVRaft</a><div class="blog-slider__text">MIT6.824 lab3实现# 描述</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/05/14/操作系统/Chapter 4：陷阱 trap/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img41.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/05/14/操作系统/Chapter 4：陷阱 trap/&quot;);" href="javascript:void(0);" alt="">xv6：trap机制</a><div class="blog-slider__text">MIT：xv6 chapter4</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/05/14/操作系统/Chapter 4：陷阱 trap/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img30.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt="">xv6：页表</a><div class="blog-slider__text">MIT：xv6 chapter3</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt="">Debugging by Pretty Printing</a><div class="blog-slider__text">Lab2：Raft美化调试工具配置方法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1s"),arr[i].setAttribute("data-wow-delay","700ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>