<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Effect C++笔记 | Ember🍐</title><meta name="author" content="Ember🍐"><meta name="copyright" content="Ember🍐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Effective C++ 的部分学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Effect C++笔记">
<meta property="og:url" content="http://www.ember-l.top/2023/01/20/C++/Effective%20C++/index.html">
<meta property="og:site_name" content="Ember🍐">
<meta property="og:description" content="Effective C++ 的部分学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg">
<meta property="article:published_time" content="2023-01-20T14:23:24.000Z">
<meta property="article:modified_time" content="2023-01-20T14:41:00.387Z">
<meta property="article:author" content="Ember🍐">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Effective C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.ember-l.top/2023/01/20/C++/Effective%20C++/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"FNCTP04VYC","apiKey":"5edd8c47a13fcf53938686d6f1752dbb","indexName":"dev_blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ember🍐","link":"链接: ","source":"来源: Ember🍐","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effect C++笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-20 22:41:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/wave.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3864328_90xjkz8cfrn.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><span id="fps"></span><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/twikoo_beautify.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/tag.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.css"><script data-pjax src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.js"></script><link rel="stylesheet" href="/css/barrage.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><script type="text/javascript" src ="/js/reward.js" ></script><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.6.16/dist/sweetalert2.all.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/precess_bar.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-SmartHome"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuji"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zongheshuju">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenxiang">                   </use></svg><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-meishikafei"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-">                   </use></svg><span> 照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan">                   </use></svg><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie">                   </use></svg><span> 友人链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg><span> 小站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao">                   </use></svg><span> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/article/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao">                   </use></svg><span> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span> 生涯</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ember🍐</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-SmartHome"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuji"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zongheshuju">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenxiang">                   </use></svg><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-meishikafei"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fabu-">                   </use></svg><span> 照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan">                   </use></svg><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie">                   </use></svg><span> 友人链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg><span> 小站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao">                   </use></svg><span> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/article/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--tongjibiao">                   </use></svg><span> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span> 生涯</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg><span> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:2px;right:8px;" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg><span> 搜索</span></a></div><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">   </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Effect C++笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-20T14:23:24.000Z" title="发表于 2023-01-20 22:23:24">2023-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-20T14:41:00.387Z" title="更新于 2023-01-20 22:41:00">2023-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.3w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>99分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effect C++笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><blockquote>
<p>Effective学习笔记</p>
</blockquote>
<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h2><p>C++高效编程时情况而变，取决于你使用C++的那一部分</p>
<hr>
<h2 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h2><p><code>Perfer consts enum and inlines to #define</code></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>✦For simple constants, prefer const objects or enums to #defines.</p>
<p>✦For function-like macros, prefer inline functions to #defines.</p>
<hr>
<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p><code>Use const whenever possible</code></p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><p>他们使class接口比较容易被理解，可以得知那个函数可以改动对象成员，那个不能</p>
</li>
<li><p>他们使用“操作const对象”成为可能。</p>
</li>
</ol>
<blockquote>
<p>constness</p>
</blockquote>
<p>当两个成员函数如果只是常量性不同，就可以用const来重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">                         <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// const objects</span></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position)  </span><br><span class="line">                        <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// non-const objects</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">//TextBlock’s operator[]s can be used like this:</span></span><br><span class="line">TextBlock <span class="built_in">tb</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];    <span class="comment">// calls non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">// calls const TextBlock::operator[]</span></span><br></pre></td></tr></table></figure>
<h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>✦Declaring something const helps compilers detect usage errors. constcan be applied to objects at any scope, to function parameters andreturn types, and to member functions as a whole.</p>
<p>✦Compilers enforce bitwise constness, but you should program usinglogical constness.</p>
<p>✦When const and non-const member functions have essentially identi-cal implementations, code duplication can be avoided by having thenon-const version call the const version.</p>
<hr>
<h2 id="条款04：确定对象被使用前已经先被初始化"><a href="#条款04：确定对象被使用前已经先被初始化" class="headerlink" title="条款04：确定对象被使用前已经先被初始化"></a>条款04：确定对象被使用前已经先被初始化</h2><p><code>Make sure that object are initialized before they&#39;re used</code></p>
<h3 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h3><blockquote>
<p>规则</p>
</blockquote>
<p>永远在使用对象之前将它初始化。对于内置内省必须要手工完成初始化</p>
<p>对于自定义类型来说，初始化职责放在构造函数上</p>
<blockquote>
<p>赋值与初始化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;<span class="comment">// ABEntry = “Address Book Entry”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">            <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;<span class="comment">// these are all assignments,</span></span><br><span class="line">    theAddress = address;<span class="comment">// not initializations</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化</p>
</blockquote>
<p>成员变量初始化动作发生在进入构造函数本体之前，相对于赋值来说发生时间更早。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones): </span><br><span class="line">        <span class="built_in">theName</span>(name),</span><br><span class="line">        <span class="built_in">theAddress</span>(address),<span class="comment">// these are now all initializations</span></span><br><span class="line">        <span class="built_in">thePhones</span>(phones),</span><br><span class="line">        <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;<span class="comment">// the ctor body is now empty</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化优点</p>
</blockquote>
<p>通常效率较高；</p>
<p><strong>赋值版本</strong>：先调用构造函数为成员变量赋予初值，然后立刻在对他们赋予新值（传入的实参）。因此会浪费一部分时间</p>
<p><strong>初始化版本</strong>：成员初始列中针对各个成员变量而设的实参，被拿去作为各成员之构造函数的实参。</p>
<blockquote>
<p>必须初始化的情况</p>
</blockquote>
<p>例如：成员变量为const或references，必须要进行成员初始列表</p>
<p><strong>综述：</strong> 一般情况总是使用成员初始列表，可以针对普遍的变量，而且比赋值更高效</p>
<h3 id="成员初始化次序"><a href="#成员初始化次序" class="headerlink" title="成员初始化次序"></a>成员初始化次序</h3><ul>
<li><p>base class -&gt; derived class </p>
</li>
<li><p><strong>成员变量以被声明的次序进行初始化</strong>因此对于示例ABEntry 中theName 最先被初始化，然后是theAddress，再是thePhone，最后是numTimesConsulted.</p>
</li>
</ul>
<h3 id="static对象"><a href="#static对象" class="headerlink" title="static对象"></a>static对象</h3><blockquote>
<p>生命周期</p>
</blockquote>
<p>从被构造出来直到程序结束，因此不是堆栈对象。</p>
<blockquote>
<p>定义</p>
</blockquote>
<p>一般这种对象被定义为global对象、定于于namspace作用域、classes、函数内、以及file作用内声明为static的对象</p>
<blockquote>
<p>local static与non-local static对象</p>
</blockquote>
<p><strong>long static对象</strong>：定义域函数内，因为它对于函数而言是local</p>
<p><strong>non-local static对象</strong>：其他剩余的static对象</p>
<h3 id="多源文件跨编译单元编译"><a href="#多源文件跨编译单元编译" class="headerlink" title="多源文件跨编译单元编译"></a>多源文件跨编译单元编译</h3><p>一般至少应该non-local static对象</p>
<blockquote>
<p>问题</p>
</blockquote>
<p>某编译单元内的某个non-local static对象初始化动作使用了另一个编译单元内的某个编译单元内的某个non-local static对象，它所用到的这个对象可能没有被初始化，因为c++对于 <strong>”定义在不同编译单元的non-local对象那个“初始化次序没有明确的规定</strong></p>
<h4 id="non-local-static-对象初始化次序问题"><a href="#non-local-static-对象初始化次序问题" class="headerlink" title="non-local static 对象初始化次序问题"></a>non-local static 对象初始化次序问题</h4><blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;<span class="comment">// from your library’s header file</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// one of many member functions</span></span><br><span class="line">...</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">// declare object for clients to use// (“tfs” = “the file system” ); definition// is in some .cpp file in your library</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;<span class="comment">// created by library client</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Directory</span>( params );...&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>( );<span class="comment">// use the tfs object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：用户决定创建应该Directory对象，用来放置临时文件</p>
<p>Directory tempDir{params}；</p>
<blockquote>
<p>初始化次序的重要性</p>
</blockquote>
<p>除非tfs在tempDir先被初始化，否则tempDir会用到尚未初始化的tfs。（但是tfs和tempDir是被不同人在不同时间创建的），他们是不同编译单元的non-local对象</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>将每个non-local对象搬到总结专属的函数内（函数也要声明为static）、</p>
<p>这些函数返回应该reference指向它所含的对象。然后用户调用这些函数</p>
<blockquote>
<p> C++保证</p>
</blockquote>
<p>函数内的local static对象会在<u>”该函数调用期间“”首次遇到该对象的定义式”</u>时被初始化。</p>
<p>因此如果用”函数调用“(返回应该reference指向local static对象)替换”直接访问non-local static对象“，就获得了保证，保证你所获得reference将指向应该历经初始化的对象。</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>从未调用non-local static对象的”仿真函数“，就绝不会引发构造和析构成本</p>
<blockquote>
<p>优化代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;; <span class="comment">// as before</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">( )</span><span class="comment">// this replaces the tfs object; it could be</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static in the FileSystem class</span></span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">// define and initialize a local static object</span></span><br><span class="line">    <span class="keyword">return</span> fs;<span class="comment">// return a reference to it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;<span class="comment">// as before</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )<span class="comment">// as before, except references to tfs are </span></span><br><span class="line">&#123;<span class="comment">// now to tfs( )</span></span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>( );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">( )</span><span class="comment">// this replaces the tempDir object; it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="comment">// could be static in the Directory class</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>;<span class="comment">// define/initialize local static object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> td;<span class="comment">// return reference to it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>✦Manually initialize objects of built-in type, because C++ only some-times initializes them itself.</p>
<p>✦In  a  constructor,  prefer  use  of  the  member  initialization  list  to  assignment  inside  the  body  of  the  constructor.  List  data  members  in the initialization list in the same order they’re declared in the class.</p>
<p>✦Avoid  initialization  order  problems  across  translation  units  by  re-placing non-local static objects with local static objects.</p>
<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="条款05：了解C-默认编写和调用了哪些函数"><a href="#条款05：了解C-默认编写和调用了哪些函数" class="headerlink" title="条款05：了解C++默认编写和调用了哪些函数"></a>条款05：了解C++默认编写和调用了哪些函数</h2><p><code>Know what functions C++silently writes and calls.</code></p>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>✦Compilers may implicitly generate a class’s default constructor, copyconstructor, copy assignment operator, and destructor</p>
<hr>
<h2 id="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"></a>条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝</h2><p><code>Explicitly disallow the use of compiler-generated functions you do not want.</code></p>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>✦To disallow functionality automatically provided by compilers, declare the corresponding member functions private and give no imple-mentations. Using a base class like private is one way to do this.</p>
<hr>
<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        D d;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//多态</span></span><br><span class="line">    &#123;</span><br><span class="line">        B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        B* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">D destrutor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">B destrutor</span><br></pre></td></tr></table></figure>
<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>✦Polymorphic base classes should declare virtual destructors. If aclass has any virtual functions, it should have a virtual destructor.</p>
<p>✦Classes not designed to be base classes or not designed to be usedpolymorphically should not declare virtual destructors.</p>
<hr>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><code>prevent exception from leaving destruction</code></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>✦Destructors should never emit exceptions. If functions called in adestructor may throw, the destructor should catch any exceptions,then swallow them or terminate the program.</p>
<p>✦If class clients need to be able to re act to exceptions thrown duringan operation, the class should provide a regular (i.e., non-destruc-tor) function that performs the operation.</p>
<hr>
<h2 id="条款11：在operator-中“自我赋值”"><a href="#条款11：在operator-中“自我赋值”" class="headerlink" title="条款11：在operator=中“自我赋值”"></a>条款11：在operator=中“自我赋值”</h2><p><code>Handle assignment to self in operator=</code></p>
<p>以widget窗口类为示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    Bit* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w = w; 自我赋值 </span><br></pre></td></tr></table></figure>
<h3 id="方法一：证同测试"><a href="#方法一：证同测试" class="headerlink" title="方法一：证同测试"></a>方法一：证同测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)                <span class="comment">//证同测试</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb；</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);    <span class="comment">//防止浅拷贝问题</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>异常问题：</p>
</blockquote>
<p>new Bitmap出现异常（分配内存错误导致错误）this-&gt;pb会指向一块被删除的内存</p>
<h3 id="方法二：异常安全性"><a href="#方法二：异常安全性" class="headerlink" title="方法二：异常安全性"></a>方法二：异常安全性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;                 <span class="comment">//创建*this一个副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);           <span class="comment">//pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig                          <span class="comment">//删除副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>证同测试效率问题</p>
</blockquote>
<p>应用证同测试会导致代码效率变低，if分支导致执行速度下降</p>
<blockquote>
<p>副本：</p>
</blockquote>
<p>不是指向一个对象只是一个<strong>值容器</strong>，如函数传参</p>
<h3 id="方法三：copy-swap（异常安全性）—-条款29"><a href="#方法三：copy-swap（异常安全性）—-条款29" class="headerlink" title="方法三：copy-swap（异常安全性）—-条款29"></a>方法三：copy-swap（异常安全性）—-条款29</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">//一个副本修改它不会修改其本身</span></span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);       <span class="comment">//rhs数据副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A variation on this theme takes advantage of the facts that</p>
<p> (1) a class’scopy assignment operator may be declared to take its argument byvalue and</p>
<p> (2) passing something by value makes a copy of it (seeItem20)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=( Widget rhs)<span class="comment">//一个副本修改它不会修改其对象本身</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);            <span class="comment">//pass by value 将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>✦Make sure operator= is well-behaved when an object is assigned to itself. Techniques include comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.</p>
<p>✦Make sure that any function operating on more than one object be-haves correctly if two or more of the objects are the same.</p>
</blockquote>
<hr>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p><code>think carefully about copying behavior in resource-managing classes</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm)</span></span><br><span class="line"><span class="function">        &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;<span class="comment">// acquire resource</span></span><br><span class="line">    ~<span class="built_in">Lock</span>( )</span><br><span class="line">        &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;<span class="comment">// release resource</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Clients use Lock in the conventional RAII fashion:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;<span class="comment">// define the mutex you need to use</span></span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// create block to define critical sectionLock </span></span><br><span class="line"><span class="built_in">ml</span>(&amp;m);    <span class="comment">// lock the mutex</span></span><br><span class="line">...    <span class="comment">// perform critical section operations</span></span><br><span class="line">&#125;    <span class="comment">// automatically unlock mutex at end</span></span><br><span class="line">    <span class="comment">// of block</span></span><br></pre></td></tr></table></figure>
<h3 id="RAII对象copied的选择"><a href="#RAII对象copied的选择" class="headerlink" title="RAII对象copied的选择"></a>RAII对象copied的选择</h3><ul>
<li><p>禁止复制（prohibit copying）</p>
</li>
<li><p>对底层资源使用“引用计数法”</p>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>✦ 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</p>
<p>✦普遍而常见的RAII classes copying 行为时：一直copying、实行引用计数法。</p>
<h2 id="条款15：在资源类中提供对原始资源的访问"><a href="#条款15：在资源类中提供对原始资源的访问" class="headerlink" title="条款15：在资源类中提供对原始资源的访问"></a>条款15：在资源类中提供对原始资源的访问</h2><p><code>provide access to raw resources in resource-managing classes</code></p>
<p><strong>原因：</strong> 编译器无法将RAII类(shared_ptr)作为指针,会将其作为一个对象，无法发生隐式转换而报错</p>
<blockquote>
<p><strong>示例</strong> ：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daysHeld</span><span class="params">(<span class="type">const</span> Investment *pi)</span></span>;<span class="comment">// return number of days</span></span><br><span class="line">                                    <span class="comment">// investment has been held</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);<span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>解决方案：</strong> </p>
</blockquote>
<p><code>convert an object of the RAII class (in this case,tr1::shared_ptr) into the raw resource</code></p>
<p>(1)<strong>explicit conversion:</strong></p>
<p>smart_ptr offer a get number function to perform explicit conversion to return a raw pointer inside this smart_ptr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>( ));<span class="comment">// fine, passes the raw pointer</span></span><br><span class="line">                                <span class="comment">// in pInv to daysHeld</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string* str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//explicit</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">test_string</span>(ptr);<span class="comment">//error can`t convert RAII to string</span></span><br><span class="line">    <span class="built_in">test_string</span>(ptr.<span class="built_in">get</span>());<span class="comment">//offer raw resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)<strong>implicit conversion:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Str</span><span class="params">(<span class="type">const</span> string&amp; str)</span>:m_str(str)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_str;&#125;<span class="comment">//implicit convertion</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_str;&#125;</span><br><span class="line">    ~<span class="built_in">Str</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_implicit_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">a</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">test_string</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>✦APIs often require access to raw resources, so each RAII classshould offer a way to get at the resource it manages.</p>
<p>✦Access may be via explicit conversion or implicit conversion. In gen-eral, explicit conversion is safer, but implicit conversion is more con-venient for clients.</p>
<hr>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款20：宁以pass-by-reference-to-const-替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; a):<span class="built_in">p_name</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;P&quot;</span>&lt;&lt;st::endl;<span class="keyword">return</span> p_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string p_name;</span><br><span class="line">    string p_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; a):<span class="built_in">s_name</span>(a)&#123;std::cout&lt;&lt;<span class="string">&quot;S construct\n&quot;</span>;&#125;</span><br><span class="line">    <span class="comment">//Student(const Student&amp; other)&#123;std::cout&lt;&lt;&quot;S copy construct\n&quot;;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;std::endl;<span class="keyword">return</span> s_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Student</span>()&#123;std::cout &lt;&lt; <span class="string">&quot;S destruct\n&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s_name;</span><br><span class="line">    string s_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;p.<span class="built_in">printN</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用pass-by-reference-to-const的好处"><a href="#用pass-by-reference-to-const的好处" class="headerlink" title="用pass-by-reference-to-const的好处"></a>用pass-by-reference-to-const的好处</h3><ol>
<li><p><strong>高效</strong>，不会创建临时对象，因此不会再次调用construt和deconstruct。</p>
</li>
<li><p><strong>准确且正确的多态</strong>，pass-by-value无法识别准确的object，如test1中，real object 都是person无法调用student的多态，pass-by-reference-to-const是可以准确调用student对象</p>
</li>
</ol>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>✦Prefer pass-by-reference-to-const over pass-by-value. It’s typicallymore efficient and it avoids the slicing problem.</p>
<p>✦The rule doesn’t apply to built-in types and STL iterator and func-tion object types. For them, pass-by-value is usually appropriat</p>
<hr>
<h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p><code>Don&#39;t try return a reference when you must return an object</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span> ()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">double</span> x, <span class="type">double</span> y):<span class="built_in">x_</span>(x),<span class="built_in">y_</span>(y)</span><br><span class="line">    &#123;cout&lt;&lt;<span class="string">&quot;construt&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该段代码描述有理数的相乘的类的设计</p>
<h3 id="当以reference作为返回值时的几大误区"><a href="#当以reference作为返回值时的几大误区" class="headerlink" title="当以reference作为返回值时的几大误区"></a>当以reference作为返回值时的几大误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">==================on the stack===================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational <span class="built_in">result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================on the heap======================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational *result =  <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line">=================<span class="type">static</span> local====================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result</span><br><span class="line">    result = <span class="built_in">Result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>on the stack</strong> :reference作为返回值时，result对象是一个stack值，当其返回时离开了作用域，result对象会被销毁，reference返回时会导致其指向了一个被销毁的值</p>
</li>
<li><p><strong>on the heap</strong> :heap分配的内存，new出来的对象，无法得知合适对该对象进行delete，因此会导致内存泄漏</p>
</li>
<li><p><strong>static local</strong> :会引起多线程问题，例如数据共享问题</p>
</li>
</ol>
<h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.x_*lhs.y_,rhs.x_*rhs.y_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：虽然会付出一点点的成本代价（construct和deconstruct），但从长远的角度和综合对比可知，此方法是最合适的做法</p>
<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>✦Never return a pointer or reference to a local stack object, a refer-ence to a heap-allocated object, or a pointer or reference to a localstatic object if there is a chance that more than one such object willbe needed. (Item4 provides an example of a design where returninga reference to a local static is reasonable, at least in single-threadedenvironments.)</p>
<hr>
<h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p><code>Declare data member private</code></p>
<h3 id="private（提供封装）和其他（提供封装）"><a href="#private（提供封装）和其他（提供封装）" class="headerlink" title="private（提供封装）和其他（提供封装）"></a>private（提供封装）和其他（提供封装）</h3><p>对于protect声明的成员变量，当其出现问题后或是被取消后，将会影响整个派生类</p>
<h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><p>✦Declare data members private. It gives clients syntactically uniformaccess to data, affords fine-grained access control, allows invariantsto be enforced, and offers class authors implementation flexibility.</p>
<p>✦protected is no more encapsulated than public（protect 与 public 差不多）</p>
<h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p><code>Perfer non-member、non-friend to member function</code> </p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>示例 :</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrower</span></span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">==================member================</span><br><span class="line"><span class="keyword">class</span> WebBrower&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">clearEverything</span>();<span class="comment">//调用clearCache、clearHistory、</span></span><br><span class="line">                           <span class="comment">//removeCookies</span></span><br><span class="line">&#125;</span><br><span class="line">=================non-member============</span><br><span class="line"><span class="type">void</span> <span class="built_in">clearBrowser</span>(WebBrowser&amp; wb)</span><br><span class="line">&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>我们更愿意使用non-member代替member函数</code></p>
<blockquote>
<p>原因</p>
</blockquote>
<p>1.non-member的封装性比member函数的更强</p>
<p>2.non-member对类的相关机能有较大的包裹弹性</p>
<blockquote>
<p><strong>封装</strong>：它使我们能够改变事物而只影响有限客户</p>
</blockquote>
<p>愈多东西被封装，愈少人能看见它，因此能够有愈大的弹性去改变它</p>
<p>愈多函数可以访问封装的函数，数据的封装性越低</p>
<p><strong>条款22</strong>：成员变量应该是private，以为如果他们不是，就有无数的函数可以去访问他们，没有封装可言</p>
<blockquote>
<p>访问限制</p>
</blockquote>
<p>能够访问private成员变量的函数只有class和member函数与friend函数可以访问</p>
<h3 id="程序设计问题"><a href="#程序设计问题" class="headerlink" title="程序设计问题"></a>程序设计问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设计特点</p>
</blockquote>
<ul>
<li><p>namespace 与classes不同，<strong>namespace可以支持跨多个源码文件</strong>而class不能</p>
</li>
<li><p>non-member、non-friend函数为用户提供较好的程序机能以及封装性</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowsers。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">//核心机能，提供所有的non-member函数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowserbookmarks。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">//声明与书签相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowsercookies</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowerStuff</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//声明与cookies相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例运用了namespace的跨越多个源码文件的特点</p>
<blockquote>
<p>标准库组织方式</p>
</blockquote>
<p>在STL头文件中std命名空间内的每一个东西，每个头文件声明std的某些机能</p>
<p>例如只想用vector，那就只用vector头文件，这允许客户支队他们所用的<strong>小部分系统形成编译依赖</strong>，但该方法不能适用于member函数，以为class必须整体定义，不可分割</p>
<p>将所有便利函数放在多个头文件内但隶属同一命名空间，意味用户可以轻松的扩展。需要只做到则是，在该命名空间<strong>添加non-member、non-friend函数</strong>。</p>
<h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<p>✦Prefer non-member non-friend functions to member functions. Do-ing so increases encapsulation, packaging flexibility, and functionalextensibility.</p>
</blockquote>
<hr>
<h2 id="条款24：-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24：-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24： 若所有参数皆需类型转换,请为此采用non-member函数"></a>条款24： 若所有参数皆需类型转换,请为此采用non-member函数</h2><p><code>Declare non-member functions when type conversions should apply to all parameters</code></p>
<blockquote>
<p>示例：Rational</p>
</blockquote>
<p>运用条款3，20，21书写正确的operator*</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">float</span> numerator = <span class="number">0</span>,<span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;<span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">    <span class="comment">// conversions</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// accessors for numerator and</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// denominator — see Item22private:</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Rational <span class="title">result</span><span class="params">((n*rhs.n),(d*rhs.d))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    <span class="type">float</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">r1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Rational r3 = r1 * r2;<span class="comment">//right</span></span><br><span class="line"></span><br><span class="line">    r3  = r1 * <span class="number">2</span>;<span class="comment">//right</span></span><br><span class="line">    r3  = <span class="number">2</span> * r1;<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;r3&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li><p>在隐式转换时，构造函数需要写出默认参数，不然不能进行隐式转换，因为Rational类构造函数有两个参数;</p>
</li>
<li><p>在构造函数加上explicit就可以防止隐式转换</p>
</li>
<li><p>2 *  r1 不能成功运行，是不是不满足交换律？</p>
</li>
</ul>
<blockquote>
<p>重写上述例子</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = r1.<span class="keyword">operator</span>*(<span class="number">2</span>);</span><br><span class="line">result = <span class="number">2.</span>opeator*(r1);<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">result = opeator*(<span class="number">2</span>,r1);</span><br></pre></td></tr></table></figure>
<p>因为r1内含一个operator<em>函数的class的对象，并且将2进行隐式转换r1.operator </em> (Rational(2))</p>
<p>对于2.operator(r1)显然时错误的,没有这个重载函数</p>
<h3 id="将operator写为non-member函数"><a href="#将operator写为non-member函数" class="headerlink" title="将operator写为non-member函数"></a>将operator写为non-member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        rhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><p>non-member函数如条款23所述封装性更强</p>
</li>
<li><p>支持所有参数的隐式类型转换</p>
</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>✦If you need type conversions on all parameters to a function (includ-ing the one that would otherwise be pointed to by the this pointer),the function must be a non-member.</p>
</blockquote>
<hr>
<h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p><code>consider support a no-throwing swap</code></p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="无法交换值、无法交换指针"><a href="#无法交换值、无法交换指针" class="headerlink" title="无法交换值、无法交换指针"></a>无法交换值、无法交换指针</h4><p>普通swap函数实现细节</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br><span class="line">========================</span><br><span class="line">地址不变，值不变</span><br></pre></td></tr></table></figure>
<blockquote>
<p>陷阱</p>
</blockquote>
<p>对于c/c++的初学者来说，犯下一个很大的陷阱，那就是我们只传过去一个地址对于者个地址值只是一个<strong>副本信息</strong>，并不是原对象，导致无法交换地址值更无法交换指针值。我们只是通过传参过来的一个 <strong>(地址)值(副本)</strong>,这是我们只是对原对象的指针副本做了交换</p>
<h4 id="无法交换地址、可以交换指针"><a href="#无法交换地址、可以交换指针" class="headerlink" title="无法交换地址、可以交换指针"></a>无法交换地址、可以交换指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析</p>
</blockquote>
<p>解引用后，此时<em>a、</em>b是a、b地址对应内存的值，也就是原对象值，改操作进行的是<strong>对(原对象)内存的进行置换</strong>，但此时并不会改变地址值，地址值仍是一个副本</p>
<h4 id="可以交换值和地址"><a href="#可以交换值和地址" class="headerlink" title="可以交换值和地址"></a>可以交换值和地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>** a,<span class="type">int</span>** b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析</p>
</blockquote>
<p>p1和p2是一个地址</p>
<p>我们用双层指针，写出一个swap的置换函数，我们传入地址进去，此时a、b的值是指向p1和p2的地址。对a、b进行解引用，则<strong>对应的<em>a 、</em>b是对应p1、p2的地址原对象</strong>。</p>
<p>进行置换则<strong>交换的是p1和p2的值</strong>，那么地址交换，相应改变的是p1和p2的对象名所对应的地址而已，而实际的内存并没有置换而已。</p>
<h4 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法既可以改值也可以改地址，因为引用的本身就是<strong>绑定一个原对象</strong>，并不是副本</p>
<h3 id="标准库swap"><a href="#标准库swap" class="headerlink" title="标准库swap"></a>标准库swap</h3><blockquote>
<p> std::swap</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// typical implementation of </span></span><br><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换</p>
<h3 id="示例：swap"><a href="#示例：swap" class="headerlink" title="示例：swap"></a>示例：swap</h3><blockquote>
<p>实践Widget类</p>
</blockquote>
<ul>
<li>用pimpl手法将Widget的数据成员封装到WidgetImpl中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;<span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// details are unimportant...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// possibly lots of data —</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;<span class="comment">// expensive to copy!...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;<span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">    &#123;        <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">        ...<span class="comment">// details on implementing</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);<span class="comment">// operator= in general,</span></span><br><span class="line">        ...<span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;<span class="comment">// ptr to object with this </span></span><br><span class="line">&#125;;<span class="comment">// Widget’s data</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>设计问题</p>
</blockquote>
<ul>
<li><p>置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl)</p>
</li>
<li><p>可以直接交换指针的地址，改变指针指向的内存</p>
</li>
</ul>
<h4 id="置换其impl指针"><a href="#置换其impl指针" class="headerlink" title="置换其impl指针"></a>置换其impl指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)<span class="comment">//std::swap的全特化版本只能对</span></span><br><span class="line">           <span class="comment">//&lt;Widget&gt;表示这一特例化版本只是针对指针交换而设计</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl,b.pImpl);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题</p>
</blockquote>
<p>pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下：</p>
<h4 id="声明public成员函数置换"><a href="#声明public成员函数置换" class="headerlink" title="声明public成员函数置换"></a>声明public成员函数置换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// addition of the swap mem func</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;<span class="comment">// the need for this declaration</span></span><br><span class="line">                    <span class="comment">// is explained later in this Item</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pImpl pointers</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// revised specialization of</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,<span class="comment">// std::swap</span></span><br><span class="line">                        Widget&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);<span class="comment">// to swap Widgets, call their</span></span><br><span class="line">&#125;<span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点</p>
</blockquote>
<p>能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>对于Widget class templates而非classes 将数据类型加以参数化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,<span class="comment">// error! illegal code!</span></span><br><span class="line">        Widget&lt;T&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">     a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误分析</p>
</blockquote>
<p>企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化，在function templates身上时不能偏特化的。因此无法编译。</p>
<h4 id="偏特化function-template"><a href="#偏特化function-template" class="headerlink" title="偏特化function template"></a>偏特化function template</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// an overloading of std::swap </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// (note the lack of “&lt;...&gt;” after</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Widget&lt;T&gt;&amp; b)</span><span class="comment">// “swap”), but see below for</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;<span class="comment">// why this isn’t valid code&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题</p>
</blockquote>
<p>重载function templates是没问题的，但std是一个特殊的命名空间：</p>
<ul>
<li><p>可以全特化std内的templates</p>
</li>
<li><p>不可以添加新的templates(class或function)到std里面</p>
</li>
</ul>
<h3 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h3><blockquote>
<p>高效正确的做法：non-member的swap、member的swap函数相结合</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...<span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// as before, including the swapclass </span></span><br><span class="line">Widget &#123; ... &#125;;<span class="comment">// member function</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// non-member swap function;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>swap实现效率不足的解决(class或template运用了pimpl手法)</p>
</blockquote>
<ol>
<li><p>提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常</p>
</li>
<li><p>在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数</p>
</li>
<li><p>如果编写一个<strong>class(而非class template)</strong>，为你的class特化一个std::swap，并令他调用你的swap的成员函数</p>
</li>
<li><p>必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符</p>
</li>
</ol>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>✦Provide a swap member function when std::swap would be inefficientfor your type. Make sure your swap doesn’t throw exceptions.</p>
<p>✦If you offer a member swap, also offer a non-member swap that callsthe member. For classes (not templates), specialize std::swap, too.</p>
<p>✦When calling swap, employ a using declaration for std::swap, then callswap without namespace qualification.</p>
<p>✦It’s fine to totally specialize std templates for user-defined types, butnever try to add something completely new to std.</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="条款26：尽量将变量的声明置后"><a href="#条款26：尽量将变量的声明置后" class="headerlink" title="条款26：尽量将变量的声明置后"></a>条款26：尽量将变量的声明置后</h2><p><code>Postpone variable definitions as long as possible</code></p>
<h3 id="变量声明前置示例"><a href="#变量声明前置示例" class="headerlink" title="变量声明前置示例"></a>变量声明前置示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...            <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                   <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题</p>
</blockquote>
<p>使用：正常执行的时候需要用到encrypted</p>
<p>未使用：当异常抛出时，encrypted对象的构造成本已经造成，而析构要离开作用域后才会启用。</p>
<h3 id="变量置后"><a href="#变量置后" class="headerlink" title="变量置后"></a>变量置后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted’s definition until it’s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...          <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环中的变量声明"><a href="#循环中的变量声明" class="headerlink" title="循环中的变量声明"></a>循环中的变量声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    w = some value dependent on i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach B: define inside loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两种方法的成本对比</p>
</blockquote>
<p>■Approach A: 1 constructor + 1 destructor + n assignments.</p>
<p>■Approach B: n constructors + n destructors.</p>
<blockquote>
<p>效率分析</p>
</blockquote>
<p>■Approach A:可见性强，当n较大时效率更好</p>
<p>■Approach B:n小时效率高</p>
<p>(1) assignment相比constructor-destruction(对)更加便宜</p>
<p>(2) 如果您正在处理代码中对性能敏感的部分，则应默认使用方法B。</p>
<h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p>✦Postpone variable definitions as long as possible. It increases pro-gram clarity and improves program efficiency.</p>
<hr>
<h2 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款27：尽量少做转型操作</h2><p><code>Minimize casting</code></p>
<h3 id="C语言转型语法"><a href="#C语言转型语法" class="headerlink" title="C语言转型语法"></a>C语言转型语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C风格的转型</span></span><br><span class="line">(T) expression<span class="comment">// cast expression to be of type T</span></span><br><span class="line"><span class="comment">//函数风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression)<span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure>
<h3 id="C-新式转型-new-style"><a href="#C-新式转型-new-style" class="headerlink" title="C++新式转型(new-style)"></a>C++新式转型(new-style)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>const_cast通常被用来将对象的常量性去除</p>
</li>
<li><p>dynamic_cast 主要用来执行“向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</p>
</li>
<li><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，不可以移植。例如将pointer to int 转型为一个int。</p>
</li>
<li><p>static_cast用来强制隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derivered。但它无法将cosnt转为non-const——这个只有const_cast才能办到。</p>
</li>
</ul>
<h3 id="新式转换的优点"><a href="#新式转换的优点" class="headerlink" title="新式转换的优点"></a>新式转换的优点</h3><ul>
<li><p>在代码中容易被识别出来(grep工具和人工识别)，找出类型系统在那个地点被破坏</p>
</li>
<li><p>各转型动作的目标越窄化，编译器越可能诊断错误地点，例如将constness去除，除非使用新式转型中的const_cast否之无法通过编译</p>
</li>
</ul>
<h3 id="旧式类型转换的使用场景："><a href="#旧式类型转换的使用场景：" class="headerlink" title="旧式类型转换的使用场景："></a>旧式类型转换的使用场景：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                        <span class="comment">// with function-style </span></span><br><span class="line"><span class="built_in">castdoSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                                        <span class="comment">// with C++-style cast</span></span><br></pre></td></tr></table></figure>
<p>在function-style看起来更像类型转换。可进行显式构造函数中类型转换。</p>
<h3 id="RTII-Run-Time-Type-Identification"><a href="#RTII-Run-Time-Type-Identification" class="headerlink" title="RTII(Run Time Type Identification)"></a>RTII(Run Time Type Identification)</h3><blockquote>
<p>含义</p>
</blockquote>
<p>令编译器编译出运行期间执行的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)/y;</span><br></pre></td></tr></table></figure>
<p>将int 转型为double会产生一些代码，因为int与double的底层描述不相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span>:<span class="keyword">public</span> Base&#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;<span class="comment">// implicitly convert Derived*⇒  Base*</span></span><br></pre></td></tr></table></figure>
<p>上述两个指针的值并不相同(&amp;d,pb)，这个时候会又一个偏移量运行期施加在Derived*指针上取得正确的指针值。</p>
<h3 id="转型容易写出似是而非的代码"><a href="#转型容易写出似是而非的代码" class="headerlink" title="转型容易写出似是而非的代码"></a>转型容易写出似是而非的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;<span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;<span class="comment">// base onResize impl</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// derived onResize impl;</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">// cast *this to Window,</span></span><br><span class="line">                                         <span class="comment">// then call its onResize;</span></span><br><span class="line">                                        <span class="comment">// this doesn’t work!</span></span><br><span class="line">    ...<span class="comment">// do SpecialWindow-</span></span><br><span class="line">    &#125;<span class="comment">// specific stuff</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题所在</p>
</blockquote>
<p>static_cast(<em>this).onResize()，调用的onResize并不是当前对象上的函数，而是稍早转型动作所建立的一个 “</em>this对象的base class成分” 的<strong>暂时副本</strong>身上的onResize。</p>
<p>(函数就是函数，它只是一个成员仅此一份，关键在于成员函数都含有个隐藏的this指针，因此会影响成员操作数据)</p>
<p><strong>换句话来说就是会丢失在当前对象base-class中对数据的操作</strong></p>
<p><code>it does not invoke that function on the current object! Instead, the cast creates a new, temporary copy of the base class part of *this, then invokes onResize on the copy!</code> </p>
<blockquote>
<p>实际示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>():<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ++size; </span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>():<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;A&gt;(*<span class="keyword">this</span>).<span class="built_in">get_size</span>();  <span class="comment">//error</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 如上述例子，我们的操作仅仅只是在*this指针强转得到一个副本上调用了函数，因此在当前对象上并没有调用base-class的成员函数，所有A::get_size中的size++不会在当前对象上作用，所以得到的结果为1.</p>
<blockquote>
<p>解决办法：去除类型转换</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>( );<span class="comment">// call Window::onResize</span></span><br><span class="line">    ...<span class="comment">// on *this</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic__cast"></a>dynamic__cast</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有指向base-class的一个pointer或reference时，想要去操作认定为derived-class对象身上执行derived-class操作函数，依靠该dynamic__cast转型方法实现</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>dynamic_cast的执行速度<strong>相当的慢</strong>，而且<strong>向下转型</strong>本就是一个<strong>不安全的行为</strong>，因此有两个办法用来取代dynamic__cast</p>
<h4 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h4><p>使用容器并在请汇总存储直接指向derived-class对象的指针(通常为只能指针)，消除了”通过base-class接口处理对象函数“的需要。</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>假设先前的window/specialwindow继承体系只有specialwindows才支持闪烁效果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span><span class="comment">// see Item13 for info</span></span><br><span class="line">std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;  </span><br><span class="line"><span class="comment">// on tr1::shared_ptr</span></span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// undesirable code:</span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// uses dynamic_cast++iter) </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;</span><br><span class="line">                                (iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// better code: uses </span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// no dynamic_cast++iter)</span></span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>
<p>缺陷在于无法在同一容器内存储指向window的任何派生类。处理多窗口需要多个容器，他们都具备类型安全性</p>
<h4 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h4><p>通过base-class接口处理所有window的所有派生类，就是在base-class内提供virtual函数做任何想多window派生类做的时</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>虽然specialwindow可以闪烁，但或许将闪烁函数声明在base-class中并提供一份空的默认函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">// default impl is no-op;</span></span><br><span class="line">    ...                    <span class="comment">// see Item34 for why</span></span><br><span class="line">&#125;;<span class="comment">// a default impl may be</span></span><br><span class="line"><span class="comment">// a bad idea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;<span class="comment">// in this class, blink</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// does something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;<span class="comment">// container holds// (ptrs to) all possible</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Window types</span></span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>( );iter != winPtrs.<span class="built_in">end</span>( );</span><br><span class="line">                ++iter)<span class="comment">// note lack of </span></span><br><span class="line">        (*iter)-&gt;<span class="built_in">blink</span>( );<span class="comment">// dynamic_cast</span></span><br></pre></td></tr></table></figure>
<p>无论是那种做法——”类安全容器“还是”virtual函数往继承体系上方移动“，都只是一个可行方案，需要靠自己判断</p>
<h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><p>✦Avoid casts whenever practical, especially dynamic_casts in perfor-mance-sensitive code. If a design requires casting, try to develop acast-free alternative. </p>
<p>✦When casting is necessary, try to hide it inside a function. Clientscan then call the function instead of putting casts in their own code.</p>
<p>✦Prefer C++-style casts to old-style casts. They are easier to see, andthey are more specific about what they do.</p>
<hr>
<h2 id="条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分"><a href="#条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分" class="headerlink" title="条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分"></a>条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分</h2><p><code>Avoid returning “handles” to object internals</code></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设您正在处理一个涉及矩形的应用程序，每个矩形可以由其左上角和右下角表示。要使矩形对象保持较小，可以决定定义其范围的点不应存储在矩形本身中，而应存储在矩形指向的辅助结构中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;<span class="comment">// Point data for a Rectangl</span></span><br><span class="line">    ePoint ulhc;<span class="comment">// ulhc = “ upper left-hand corner”</span></span><br><span class="line">    Point lrhc;<span class="comment">// lrhc = “ lower right-hand corner”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;RectData&gt; pData;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// tr1::shared_ptr</span></span><br></pre></td></tr></table></figure>
<p>对于Rectangle类我们添加两个const-reference member function，为何使用const-reference在<code>条款20</code>中有说明。但因此会导致以下问题。</p>
<h3 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;<span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                    <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">// now rec goes from</span></span><br><span class="line">                        <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure>
<p>由上述代码可以得知，我们不仅仅能对矩形的点进行读，并且能够进行修改，那么我们<strong>定义的数据成员与public就没有什么两样</strong>。(虽然我们在upperLeft()函数添加了const定义，但我们只是不能对指向Rectdata的智能指针进行修改，可以对该对象内部的值进行修改)</p>
<blockquote>
<p>修改</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过将返回值加上const我们可以让const成员限定符不在是个fake，我们只能对数据进行读写。</p>
<p>但是这种方式仍然会引起下述问题</p>
<h3 id="dangling-handles-所指对象不存在"><a href="#dangling-handles-所指对象不存在" class="headerlink" title="dangling handles 所指对象不存在"></a>dangling handles 所指对象不存在</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rectangle                <span class="comment">// returns a rectangle by</span></span><br><span class="line"><span class="built_in">boundingBox</span>(<span class="type">const</span> GUIObject&amp; obj);<span class="comment">// value; see Item3 for why</span></span><br><span class="line">                                <span class="comment">//  return type is const</span></span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//Now consider how a client might use this function:</span></span><br><span class="line">GUIObject *pgo;<span class="comment">// make pgo point to</span></span><br><span class="line">...            <span class="comment">// some GUIObject</span></span><br><span class="line"><span class="type">const</span> Point *pUpperLeft =            <span class="comment">// get a ptr to the upper </span></span><br><span class="line">    &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>( ));<span class="comment">// left point of its</span></span><br><span class="line">                                       <span class="comment">// bounding box</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题分析</p>
</blockquote>
<p>上述问题中会调用boundingBox(*pgo)函数对象，它所返回的值是一个临时的Rectangle副本(temp)，当我们用upperLeft去作用与temp身上，返回一个reference指向temp的一个内部成分</p>
<blockquote>
<p>错误</p>
</blockquote>
<p>当我们结束这段语句是会产生一个问题，就是我们的boundBox的返回值(temp)，将会被析构，也就是这个temp对象的内部成员都不复存在，那么我们的pUpperLeft就指向了一个<strong>不复存在的值</strong>。</p>
<h3 id="例外：operator"><a href="#例外：operator" class="headerlink" title="例外：operator[]"></a>例外：operator[]</h3><p>在vector和string容器中有个成员函数operator[]可以选择个别的元素，这个函数就是返回reference指向“容器内的数据”，但那些数据会随着容器的销毁而销毁。这仅仅只是有个例外。</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>✦Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helpsconst member functions act const, and minimizes the creation of dangling handles.</p>
<hr>
<h2 id="条款29：为”异常安全“而努力是值得的"><a href="#条款29：为”异常安全“而努力是值得的" class="headerlink" title="条款29：为”异常安全“而努力是值得的"></a>条款29：为”异常安全“而努力是值得的</h2><p><code>Strive for exception-safe code</code></p>
<blockquote>
<p>异常问题</p>
</blockquote>
<p>以class用来表现夹带背景图案的GUI菜单，运用于多线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;</span><br><span class="line">    ...  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image* bgImage;</span><br><span class="line">    <span class="type">int</span> imagechages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++ imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="”异常安全“的条件"><a href="#”异常安全“的条件" class="headerlink" title="”异常安全“的条件"></a>”异常安全“的条件</h3></blockquote>
<ol>
<li><p><strong>不泄漏任何资源</strong>：new Image(imgSrc)导致异常，对unlock的调用就绝不会执行。</p>
</li>
<li><p><strong>不允许数据败坏</strong>：new Iamge(imgSrc)抛出异常，bgImage就是指向一个被删除的对象，imageChanges以及被累加，而其实并没有新的图像被成功安装起来</p>
</li>
</ol>
<blockquote>
<p>RAII解决方案</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prettMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChages++;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>不在需要调用unlock</code></p>
<blockquote>
<h3 id="”异常安全函数“保证"><a href="#”异常安全函数“保证" class="headerlink" title="”异常安全函数“保证"></a>”异常安全函数“保证</h3></blockquote>
<ul>
<li><p><strong>基本承诺</strong>：异常抛出时，不会使对象或数据结构会因此而破坏，就数据保持异常抛出钱的状态</p>
</li>
<li><p><strong>强烈保证</strong>：异常抛出使，程序状态不会改变。(函数失败恢复到”调用函数之前“的状态)</p>
</li>
<li><p><strong>不抛掷保证</strong>：它们总能完成总能的原先承诺的功能</p>
</li>
</ul>
<h3 id="异常安全函数解决问题"><a href="#异常安全函数解决问题" class="headerlink" title="异常安全函数解决问题"></a>异常安全函数解决问题</h3><blockquote>
<h4 id="智能指针解决问题："><a href="#智能指针解决问题：" class="headerlink" title="智能指针解决问题："></a>智能指针解决问题：</h4></blockquote>
<p>1.引用智能指针类管理内存</p>
<p>2.将计数器的次序交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));<span class="comment">//以”new Image“;</span></span><br><span class="line">                                    <span class="comment">//设定bgImage内部指针</span></span><br><span class="line">    ++imageChagnes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：</p>
<p>不需手动delete旧图像，而且删除操作是在对象被成功创建的之后，因此new成功后才会成功调用reset函数，Image（imgSrc）的临时对象也会在reset中释放掉（delete）</p>
<p><strong>问题</strong>：</p>
<p>Image构造函数会抛出异常（输出流的读取记号已经被移走）</p>
<h3 id="Copy-and-Swap"><a href="#Copy-and-Swap" class="headerlink" title="Copy and Swap"></a>Copy and Swap</h3><blockquote>
<p><strong>原则介绍</strong>：</p>
</blockquote>
<p>为你打造修改的对象（原件）做出一个副本，然后再那副本身上做一切的修改。若修改发生错误，源对象仍能保存原始状态。修改成功，则原件和副本做置换操作。</p>
<p>修改对象数据副本，一个<strong>不会抛出异常的函数</strong>（swap）中将修改后的数据和原件置换</p>
<blockquote>
<p>”隶属对象数据“ <strong>pimpi idiom</strong></p>
</blockquote>
<p>从原对象放进一个另一个对象内，然后赋予原对象一个指针，指向那个实现对象（副本）、</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>&#123;<span class="comment">//pImpl是一个private成员具有封装性</span></span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changeBackground</span><span class="params">(std::istream pImpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">//设计copy副本（值对象），保存原始数据</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;PMImpl&gt; <span class="title">ptemp</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    <span class="comment">//修改副本</span></span><br><span class="line">    ptemp-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line"></span><br><span class="line">    ptemp-&gt;imageChanges++;</span><br><span class="line">    <span class="comment">//原始对象与副本交换</span></span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);<span class="comment">//置换数据，释放mutex·</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<p>✦Exception-safe functions leak no resources and allow no data struc-tures to become corrupted, even when exceptions are thrown. Suchfunctions offer the basic, strong, or nothrow guarantees.</p>
<p>✦The strong guarantee can often be implemented via copy-and-swap,but the strong guarantee is not practical for all functions.</p>
<p>✦A function can usually offer a guarantee no stronger than the weak-est guarantee of the functions it calls. </p>
</blockquote>
<hr>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><code>Understand the ins and outs of inlining</code></p>
<h3 id="inline的细节"><a href="#inline的细节" class="headerlink" title="inline的细节"></a>inline的细节</h3><ol>
<li>inline函数代码量不易过大会导致程序体积过大，导致代码膨胀以至于额外的换页行为</li>
<li>inline只是对编译器的申请并不是强制命令，class内的函数被隐喻的称为inline</li>
<li>inline通常被置于头文件，在编译过程中进行inlining，而为将一个“函数调用”替换为“被调用函数的本体”</li>
</ol>
<h3 id="inline的声明"><a href="#inline的声明" class="headerlink" title="inline的声明"></a>inline的声明</h3><blockquote>
<p>隐式声明为inline的函数</p>
</blockquote>
<ul>
<li>member函数</li>
<li>friend函数</li>
</ul>
<blockquote>
<p>不应被声明为inline的函数</p>
</blockquote>
<ul>
<li>构造以及析构函数</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>✦Limit most inlining to small, frequently called functions. This facili-tates debugging and binary upgradability, minimizes potential codebloat, and maximizes the chances of greater program speed.</p>
<p>✦Don’t declare function templates inline just because they appear inheader files.</p>
<hr>
<h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p><code>Minimize compilation dependdencies between files</code></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>( <span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr);</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;<span class="comment">// implementation detail</span></span><br><span class="line">Date theBirthDate;<span class="comment">// implementation detail</span></span><br><span class="line">Address theAddress;<span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要想让Person class编译需要加入以下头文件的类或函数声明式</p>
<h1 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="include &lt; string &gt;"></a>include &lt; string &gt;</h1><h1 id="include-“date-h”"><a href="#include-“date-h”" class="headerlink" title="include “date.h”"></a>include “date.h”</h1><h1 id="include-“address-h”"><a href="#include-“address-h”" class="headerlink" title="include “address.h”"></a>include “address.h”</h1><p>但这样会导致这些文件中形成一种编译的<strong>依存关系</strong>，所依赖的头文件发生改变都会让Person class的头文件进行重新文件</p>
<blockquote>
<p>将class的实现细目至于class的定义式中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">string</span>;<span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// one — see below)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题</p>
</blockquote>
<ol>
<li><p>string前置声明错误，正确的也复杂</p>
</li>
<li><p>前置声明每一个东西困难的是，编译器必须知道对象的大小</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(params)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器清楚的知道int需要多大，而Person需要询问class的定义式。</p>
<p>针对于Person类可以用以下方法：将Person分割为两个classes，一个只<strong>提供接口</strong>，一个只负责<strong>实现该接口</strong>。将负责实现的Implementation class取名为PersonImpl，Person将定义如下</p>
<h3 id="pimpl-idiom-pointer-to-implementation"><a href="#pimpl-idiom-pointer-to-implementation" class="headerlink" title="pimpl idiom(pointer to implementation)"></a>pimpl idiom(pointer to implementation)</h3><p><em>pimpl 惯例</em>是一种新式 C++ 技术，用于<strong>隐藏实现、最小化耦合和分离接口</strong>。 Pimpl 对于”指向实现的指针”是短的。你可能已熟悉概念，但通过其他名称（如 Che一 cat 或编译器防火墙惯例）了解它。</p>
<p>下面是 pimpl 惯例如何改进软件开发生命周期：</p>
<ul>
<li><p>最大程度地减少编译依赖项。</p>
</li>
<li><p>接口和实现分离。</p>
</li>
<li><p>可移植性。</p>
</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<p>有较好的封装性以及减少客户端的文件依赖性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pimpl</span></span><br><span class="line"><span class="comment">// 在头文件person.hpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Person类的实现细节放置在该前向声明的实现类中。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  <span class="comment">// 指向实现类Impl的私有指针</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源文件person.cpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;basic_info.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>::Impl &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string id;</span><br><span class="line">  BasicInfo basic_info;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>() : <span class="built_in">pimpl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>1.减少了需要包含的头文件；2.当内部实现发生变化时，客户端的代码不需要重新编译。例如：客户端在gcc编译中只需要连接上其动态连接库或者静态库文件，这时候服务端已经将所需的文件的编译完了，可以减少客户端编译的时间</p>
<p>由此修改以上Person代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="comment">// standard library components</span></span></span><br><span class="line"><span class="comment">// shouldn’t be forward-declared</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for tr1::shared_ptr; see belowclass PersonImpl;</span></span></span><br><span class="line"><span class="comment">// forward decl of Person impl. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward decls of classes used in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                    <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// ptr to implementation;</span></span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// std::tr1::shared_ptr</span></span><br></pre></td></tr></table></figure>
<p>上述代码main class中内涵一个</p>
<p>这样的设计下，Person的客户就完全与Dataes，Address以及Persons的实现的细目分离。因此哪些classes的任何实现修改都不需要Person客户断重新编译。“接口与实现分离”</p>
<blockquote>
<p>关键</p>
</blockquote>
<p>这个分离在于以“声明的依存性”替换为“定义的依存性”，编译最小化的本质：现实中让头文件尽可能的自我满足，万一做不到，则让他与其他文件内的声明式(并非定义式)相依</p>
<h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>■Avoid using objects when object references and pointers will do</p>
<p>■Depend on class declarations instead of class definitions whenever you can.</p>
<p>声明函数而它用到某个class式，你并不需要改class的定义：纵使函数以by value方式传递改类型的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// class declaration</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// fine — no definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;<span class="comment">// of Date is needed</span></span><br></pre></td></tr></table></figure>
<p>声明这两个函数的无需Date的定义式，但是当有人调用哪些函数式，调用之前需要让Date的定义式曝光</p>
<p>如果将”提供class定义式“（通过#include完成）的义务冲”<strong>函数声明所在</strong>“之头文件转移到”<strong>内涵函数调用</strong>“之客户文件，便可将”<strong>并非真正必要的类型定义</strong>“与客户端之间的<strong>编译依存</strong>去除掉</p>
<p>■Provide separate header files for declarations and definitions</p>
<p>需要两个头文件，一个用于声明式，一个用于定义式。文件必须保持一致性，如果声明式被改变，两个文件都需要改变。<strong>#include一个声明文件</strong>而非前置声明若干函数 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span><span class="comment">// header file declaring (but not</span></span></span><br><span class="line">                    <span class="comment">// defining) </span></span><br><span class="line"><span class="function"><span class="keyword">class</span> DateDate <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++中提供关键字export，允许将template声明式和template定义式分割与不同的文件内，但式这个关键字在有些编译器里不支持</p>
<h3 id="Handle-classses"><a href="#Handle-classses" class="headerlink" title="Handle classses"></a>Handle classses</h3><p>像Person这样使用pimpl idiom的classes，被称为Handle classes。</p>
<blockquote>
<p>方法一</p>
</blockquote>
<p>将他们的所有函数转交给一个相应的实验类并由后者完成实际工作。例如卖弄Person的两个成员函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span><span class="comment">// we must also #include PersonImpl’s class</span></span></span><br><span class="line"><span class="comment">// definition, otherwise we couldn’t call </span></span><br><span class="line"><span class="comment">// its member functions; note that </span></span><br><span class="line"><span class="comment">// PersonImpl has exactly the same public</span></span><br><span class="line"><span class="comment">// member functions as Person — their</span></span><br><span class="line"><span class="comment">// interfaces are identical</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">            <span class="type">const</span> Address&amp; addr): </span><br><span class="line">                        <span class="built_in">pImpl</span>(<span class="keyword">new</span> </span><br><span class="line">                            <span class="built_in">PersonImpl</span>(name, birthday, addr))&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">( )</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调PersonImpl::name，让Person百年城一个Handle class但不会改变他做的事，只会改变它做事的方法</p>
<h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>令Person称为一个特殊的抽象基类，称为interface class。这汇总class的目的事猫叔derived的接口，因此他通常不带有成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtal函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>class的用户必须以Person的pointer和reference来写应用程序，因为他不可能针对”内含pure virtual函数“的person classes具体出实体。</p>
<p>interface class的客户必须有办法为这种class创建新的对象。</p>
<p>如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt;</span><br><span class="line">                    <span class="comment">// return a tr1::shared_ptr to a new</span></span><br><span class="line">    <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,<span class="comment">// Person initialized with the</span></span><br><span class="line">            <span class="type">const</span> Date&amp; birthday,<span class="comment">// given params; see Item18 for</span></span><br><span class="line">            <span class="type">const</span> Address&amp; addr);<span class="comment">// why a tr1::shared_ptr is returned</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户将会这样使用这些接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;Address address;</span><br><span class="line">...<span class="comment">// create an object supporting the Person interface</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 address))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>( )</span><br><span class="line">                            <span class="comment">// use the object via the</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot; was born on &quot;</span></span><br><span class="line">                            <span class="comment">// Person interface</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>( )</span><br><span class="line">    &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">address</span>( );</span><br><span class="line">    ...                    <span class="comment">// the object is automatically </span></span><br><span class="line">                            <span class="comment">// deleted when pp goes out of </span></span><br><span class="line">                            <span class="comment">// scope </span></span><br></pre></td></tr></table></figure>
<p>支持interface class接口的那个concrete class 必须被定义出来，而其真正的构造函数必须被调用。一切都在virtual构造函数实现所在的文件内放生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr):   <span class="built_in">theName</span>(name), </span><br><span class="line"><span class="built_in">theBirthDate</span>(birthday), </span><br><span class="line"><span class="built_in">theAddress</span>(addr)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>( ) &#123; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// implementations of these </span></span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// functions are not shown, but </span></span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// they are easy to imagineprivate:</span></span><br><span class="line">std::string theName;Date theBirthDate;Address theAddress;&#125;;</span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">//Given RealPerson, it is truly trivial to write Person::create:</span></span><br><span class="line">std::tr1::shared_ptr&lt;Person&gt; Person::</span><br><span class="line">                        <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">                                    <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> </span><br><span class="line">                        <span class="built_in">RealPerson</span>( name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个更现实的Person::create实现代码会创建不同类型的derived class对象。取决于额外参数值、读自文件或数据库的数据、环境变量。</p>
<p>RealPerson示范实现了Interface class 的两个最常见的机制之一：从Interface class继承接口规格，然后实现出接口所覆盖的函数。第二点则是多重继承</p>
<h3 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h3><p>✦The general idea behind minimizing compilation dependencies is todepend on declarations instead of definitions. Two approachesbased on this idea are Handle classes and Interface classes.</p>
<p>✦Library header files should exist in full and declaration-only forms.This applies regardless of whether templates are involved.</p>
<hr>
<h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑造出的is-a关系"><a href="#条款32：确定你的public继承塑造出的is-a关系" class="headerlink" title="条款32：确定你的public继承塑造出的is-a关系"></a>条款32：确定你的public继承塑造出的is-a关系</h2><p><code>Make sure public inheritance models &quot;is-a&quot;</code></p>
<p>通过public继承出的关系为“is-a”关系，如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// fine, s is a Student,</span></span><br><span class="line">        <span class="comment">// and a Student is-a Person</span></span><br><span class="line"><span class="built_in">study</span>(s);<span class="comment">// fine</span></span><br><span class="line"><span class="built_in">study</span>(p);<span class="comment">// error! p isn’t a Student</span></span><br></pre></td></tr></table></figure>
<p>如上述关系可以表述出学生是人，但人这个抽象类却不一定是人</p>
<h3 id="is-a的误区"><a href="#is-a的误区" class="headerlink" title="is-a的误区"></a>is-a的误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="comment">// birds can fly</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    <span class="comment">// penguins are birds</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误</p>
</blockquote>
<p>这个继承体系中说明企鹅是鸟的派生类，那么它应该含有鸟类的所有行为，但是企鹅却不会飞，这点显得不是特别的严谨。我们应该让is-a有较佳的真实性</p>
<h3 id="方法一-双class继承体系"><a href="#方法一-双class继承体系" class="headerlink" title="方法一:双class继承体系"></a>方法一:双class继承体系</h3><blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：运行期错误"><a href="#方法二：运行期错误" class="headerlink" title="方法二：运行期错误"></a>方法二：运行期错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;<span class="comment">// defined elsewhere</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Attempt to make a penguin fly!&quot;</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处声明出企鹅是不会飞的，那么说企鹅会飞则是一种错误的认知，在运行期的时候会被检测出来</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结:"></a>总结:</h3><p>✦Public inheritance means “is-a.” Everything that applies to baseclasses must also apply to derived classes, because every derivedclass object is a base class object.</p>
<hr>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p><code>Avoid hiding inherited names</code></p>
<h3 id="命名查找规则-作用域"><a href="#命名查找规则-作用域" class="headerlink" title="命名查找规则(作用域)"></a>命名查找规则(作用域)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>&#123;<span class="built_in">mf2</span>();&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-30-29-image.png" alt=""></p>
<p>Base的作用域大于Derived的作用域，根据命名查找法，当我们在Derived类中查找mf2时，选择方向Derived-&gt;Base-&gt;global。小一级的作用域会将其覆盖。</p>
<h3 id="名称可视性-name-visibility"><a href="#名称可视性-name-visibility" class="headerlink" title="名称可视性(name visibility)"></a>名称可视性(name visibility)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-37-52-image.png" alt=""></p>
<p>Base内名为mf1和mf3的重载函数都被Derived内的mf1和mf3函数所遮掩。从名称查找观点来看Base::mf1和Base::mf3不在被Derived继承。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1d.mf1(x);</span></span><br><span class="line">        <span class="comment">// error! Derived::mf1 hides Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );<span class="comment">// fine, calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// error! Derived::mf3 hides Base::mf3</span></span><br></pre></td></tr></table></figure>
<p>更具以上代码可知，当我们在重载函数时，在子类中就只能对Derived作用域的函数名可见，但是对于重载函数是不可见的。不论是virtual还是non-virtual都是一样。</p>
<h3 id="解决继承来的名称的遮掩行为"><a href="#解决继承来的名称的遮掩行为" class="headerlink" title="解决继承来的名称的遮掩行为"></a>解决继承来的名称的遮掩行为</h3><blockquote>
<p>违反is-a关系</p>
</blockquote>
<p>当public继承而又不继承哪些重载函数就是违反base和deriver class之间的<strong>is-a关系</strong> </p>
<blockquote>
<p>using声明表达式</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1;<span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line"><span class="keyword">using</span> Base::mf3;<span class="comment">// visible (and public) in Derived’s scope</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-12-47-00-image.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// still fine, still calls Derived::mf1d.mf1(x);</span></span><br><span class="line"><span class="comment">// now okay, calls Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );</span><br><span class="line"><span class="comment">// still fine, still calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// now okay, calls Base::mf3 (The int x is </span></span><br><span class="line">        <span class="comment">// implicitly converted to a double so that</span></span><br><span class="line">        <span class="comment">// the call to Base::mf3 is valid.</span></span><br></pre></td></tr></table></figure>
<p>用using声明，derived类继承了base并加上了重载函数，此时也可以重写一部分重载函数将base的函数给覆盖。</p>
<h3 id="forward-function转交函数"><a href="#forward-function转交函数" class="headerlink" title="forward function转交函数"></a>forward function转交函数</h3><blockquote>
<p>使用场景</p>
</blockquote>
<p>不想继承base的所有函数，在“is-a”中会违背其含义</p>
<blockquote>
<p>private继承</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">...<span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span>    <span class="comment">// forwarding function; implicitly</span></span></span><br><span class="line"><span class="function"></span>&#123; Base::<span class="built_in">mf1</span>( ); &#125;    <span class="comment">// inline — see Item30. (For info...</span></span><br><span class="line">                    <span class="comment">// on calling a pure virtual</span></span><br><span class="line"><span class="comment">//-------继承private----------</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="comment">//---------------------------</span></span></span><br><span class="line"><span class="function">&#125;</span>;<span class="comment">// function, see Item34.)</span></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">// error! Base::mf1( ) is hidden</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>inline转交函数的用途</p>
</blockquote>
<p>哪些不支持using声明式，将继承而得的名称汇入derived作用域</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>✦Names in derived classes hide names in base classes. Under publicinheritance, this is never desirable. </p>
<p>✦To make hidden names visible again, employ using declarations orforwarding functions.</p>
<hr>
<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p><code>Difference between inheritance of interface and inheritance of implementation</code></p>
<blockquote>
<p>public继承概念</p>
</blockquote>
<p><strong>函数接口继承</strong>和<strong>函数实现继承</strong></p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数的接口总是会被继承"><a href="#成员函数的接口总是会被继承" class="headerlink" title="成员函数的接口总是会被继承"></a>成员函数的接口总是会被继承</h3><p>public为is-a关系继承，所有对Base class为真的事件对于Derived class也为真。</p>
<blockquote>
<p>接口与实现</p>
</blockquote>
<ul>
<li>接口：是(对外或者对继承)可视的，定义一个的对象实体可以通过(对外可视的)接口去访问该对象</li>
<li>实现：是一个实体，可以看作是接口所要做到事，对外不一定可见，对内一定可见</li>
</ul>
<blockquote>
<p>pure virtual函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pure virtual函数的特性：</p>
</blockquote>
<ul>
<li><p>必须被他们所继承的具象类所<strong>重新声明</strong></p>
</li>
<li><p>抽象类中通常没有对该函数的定义</p>
</li>
</ul>
<h3 id="pure-virtual函数-子类必须重写"><a href="#pure-virtual函数-子类必须重写" class="headerlink" title="pure virtual函数(子类必须重写)"></a>pure virtual函数(子类必须重写)</h3><blockquote>
<p><strong>让derived class只继承接口</strong></p>
</blockquote>
<p>shape class无法对shape::draw函数提供合理的默认实现，比较其模棱两可(椭圆和矩形的画法)，因此在具象derived class 中<strong>必须提供</strong>一个draw函数，并且不干涉如何实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape;<span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;<span class="comment">// fine 多态</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Rectangle::draw</span></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;<span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls base class pure virtual函数也可以有实现</span></span><br><span class="line">Shape::drawps2-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure>
<h3 id="impure-virtual函数-可选是否重写"><a href="#impure-virtual函数-可选是否重写" class="headerlink" title="impure virtual函数(可选是否重写)"></a>impure virtual函数(可选是否重写)</h3><blockquote>
<p><strong>让derived class继承函数的接口和默认实现</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Shaped::error的声明式要求derived classes必须<strong>支持一个error函数</strong>，但如果不想自己写一个，那么就可以使用<strong>Shaped class提供的默认版本</strong></p>
<h3 id="non-virtual函数-不能重写"><a href="#non-virtual函数-不能重写" class="headerlink" title="non-virtual函数(不能重写)"></a>non-virtual函数(不能重写)</h3><blockquote>
<p><strong>让derived class继承函数的接口及一份强制性实现</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>non-virtual函数：并不打算在derived classes中有不同的行为。实际上non-virtual函数表现的不变性(invariant)大于其特异性(specialization)。</p>
<p>例如：Shape::objectID是有特定计算ID的一个函数，该方法是由其定义式决定的，任何derived class都<strong>不应该修改其行为</strong>，<strong>不应该在derived class中被重新定义</strong>。(<strong>破坏多态性</strong>)</p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>✦Inheritance of interface is different from inheritance of implementa-tion.  Under  public  inheritance,  derived  classes  always  inherit  baseclass interfaces.</p>
<p>✦Pure virtual functions specify inheritance of interface only. </p>
<p>✦Simple  (impure)  virtual  functions  specify  inheritance  of  interfaceplus inheritance of a default implementation. </p>
<p>✦Non-virtual  functions  specify  inheritance  of  interface  plus  inherit-ance of a mandatory implementation.</p>
<h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><p><code>Consider alternatives to virtual function</code></p>
<p>设计一个计算人物生命值的函数healthValue()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// return character’s health rating;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// derived classes may redefine this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们一impure virtual函数去声明函数，那么当子类不提供函数重写那么人物将采用默认的声明值的计算方法</p>
<h3 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h3><p>Non-virtual interface实现方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span><span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// this — see Item36</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “before” stuff — see below</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>( );<span class="comment">// do the real work </span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “after” stuff — see below</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// default algorithm for calculating&#125;</span></span><br><span class="line">    <span class="comment">// character’s health</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基本设计</p>
</blockquote>
<p>令客户通过public non-virtual成员函数去间接的调用private virtual函数，因此称为non-virtual(NVI)手法。</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>NVI手法的优点在于“do ‘before’ stuff”和“do ‘after’ stuff”在上述的注释代码中，在Wrapper（healthValue）中设定好virtual函数的<strong>应用场景</strong></p>
<ul>
<li><p>“do ‘before’ stuff”：locking a mutex, making a log entry(日志记录项), verifying that class invariants and function preconditions aresatisfied, etc</p>
</li>
<li><p>“do ‘after’ stuff”：unlocking a mutex, veri-fying function postconditions, reverifying class invariants(再次验证class的约束条件), etc.</p>
</li>
</ul>
<blockquote>
<p>疑问</p>
</blockquote>
<p>NVI手法中涉及到derived class时base class private virtual 函数我们无法调用，但是我们需要redefining这些我们不会调用的private virtual 函数，看起来十分的矛盾。但时调用virtual函数表示它在”何时“被完成，但重定义virtual函数表示”如何“完成，这两者并不冲突。</p>
<p>NVI允许derived重新定义virtual函数，从而赋予了它如何具体实现的机能，但base class仍然保留函数合适被调用的权力</p>
<blockquote>
<p>特别的</p>
</blockquote>
<p>NVI手法中的virtual函数并不是非得是private。某些继承体要求在derived class中对应的实现必须调用器base class的对应兄弟，为了合法，那么就必须的设置为protect。</p>
<h3 id="Strategy-Pattern-via-Function-Pointers"><a href="#Strategy-Pattern-via-Function-Pointers" class="headerlink" title="Strategy Pattern via Function Pointers"></a>Strategy Pattern via Function Pointers</h3><blockquote>
<p>设计主张</p>
</blockquote>
<p>”人物的健康指数的计算与每个人物的类型无关“，这样的计算不需要人物这个成分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; </span><br><span class="line"><span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// function for the default health calculation algorithm</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                    healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点</p>
</blockquote>
<p>相比virtual函数继承，这种设计模式提供了更好的弹性</p>
<blockquote>
<p>实例</p>
</blockquote>
<ul>
<li>在<strong>同一类型的不同的实体</strong>中应用不同的计算函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                        GameCharacter(hcf )</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculationint lose</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// funcs with different</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;<span class="comment">// same-type charac-</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;<span class="comment">// ters with different// health-related</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br></pre></td></tr></table></figure>
<ul>
<li>已知人物的健康指数计算函数可在运行期变更。例如：base类可以提供一个成员函数setHealthCalculator，用来替换当前的健康计算函数</li>
</ul>
<h3 id="Strategy-Pattern-via-tr1-function"><a href="#Strategy-Pattern-via-tr1-function" class="headerlink" title="Strategy Pattern via tr1::function"></a>Strategy Pattern via tr1::function</h3><blockquote>
<p>函数指针的限制</p>
</blockquote>
<p>对template以及他们的的隐式接口的使用，基于函数的指针的做法就十分的死板。不够灵活，例如返回类型只能是int，函数对象不能是member function</p>
<blockquote>
<p>tr1::function</p>
</blockquote>
<p>改用tr1::function的对象替代函数指针，这样的对象可持有任何可调用物(callable entity 函数指针、函数对象、成员函数指针)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;<span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// HealthCalcFunc is any callable entity that can be called with</span></span><br><span class="line"><span class="comment">// anything compatible with a GameCharacter and that returns anything</span></span><br><span class="line"><span class="comment">// compatible with an int; see below for details</span></span><br><span class="line"><span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:</span></span><br><span class="line"><span class="function">                                             healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个实例中我们用tr1::function instantiation来代替目标签名式。那个签名代表的函数时”接受一个reference 指向const GamCharacter“，并返回int。这个tr1::function类型产生的对象可持有任何与此签名式兼容的可调用物。例如可调用物的<strong>参数可以被隐式的转换为const GameCharacters&amp;</strong>，其<strong>返回类型可以被隐式转换为int</strong></p>
<p>tr1::function对象相当于指向函数的泛化指针。</p>
<blockquote>
<p>更具与弹性</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculation</span></span><br><span class="line"><span class="comment">// function; note </span></span><br><span class="line"><span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class for health</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span><span class="comment">// calculation function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;<span class="comment">// objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// health calculation</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mem function; note</span></span><br><span class="line">&#125;;<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// another character</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// type; assume same</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constructor as // EvilBadGuy</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;<span class="comment">// character using a</span></span><br><span class="line">                <span class="comment">// health calculation// function</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator( ))</span></span>;<span class="comment">// character using a </span></span><br><span class="line">                <span class="comment">// health calculation// function object</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// see below for details);</span></span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析ebg2 -&gt; bind</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function"> std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br></pre></td></tr></table></figure>
<p>GameLevel::health接受两个参数，一个是隐式参数currentLevel，也就是this指向的那个、另一个是reference指向GameCharactor。</p>
<p>GameCharacters的健康计算函数值接受单一参数：GameCharacters。</p>
<p>使用GameLevel::health作为ebg2的健康计算函数，我们需要以特殊方式转换，取出GameLevel其中的健康计算函数。</p>
<p>本例中用currentLevel作为ebg2的健康函数所需的GameLevel的对象。_1意味着用currenLevel作为GamLevel的对象</p>
<h3 id="the-“Classic”-Strategy-Pattern"><a href="#the-“Classic”-Strategy-Pattern" class="headerlink" title="the “Classic” Strategy Pattern"></a>the “Classic” Strategy Pattern</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-06-21-21-05-image.png" alt=""></p>
<p>在该图中指示了GameCharacte是某个继承体系的根类，EviBadGuy与EyeCandyCharacter都是derived classes：HealthCalcFunc是另一个继承体系的根类。</p>
<blockquote>
<p>实现代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                                pHealthCalc(phcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>✦Alternatives to virtual functions include the NVI idiom and variousforms of the Strategy design pattern. The NVI idiom is itself an ex-ample of the Template Method design pattern.</p>
<p>✦A disadvantage of moving functionality from a member function to afunction outside the class is that the non-member function lacks ac-cess to the class’s non-public members.</p>
<p>✦tr1::function objects act like generalized function pointers. Such ob-jects support all callable entities compatible with a given target sig-nature.</p>
<hr>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p><code>Never redefine an inherited non-virtual function</code></p>
<blockquote>
<p>non-virtual性质</p>
</blockquote>
<p>在条款34中描述了non-virtual函数会给class建立一个<strong>不变性</strong>(invariant),凌驾其<strong>特异性</strong>(specialization)</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">                <span class="comment">//Even without knowing anything about B, D, or mf, given an object x of</span></span><br><span class="line">                <span class="comment">//type D,</span></span><br><span class="line">D x;            <span class="comment">// x is an object of type D</span></span><br><span class="line">                <span class="comment">//you would probably be quite surprised if this,</span></span><br><span class="line">B *pB = &amp;x;      <span class="comment">// get pointer to xp</span></span><br><span class="line">B-&gt;<span class="built_in">mf</span>( );        <span class="comment">// call mf through pointerbehaved differently from this:</span></span><br><span class="line">D *pD = &amp;x;     <span class="comment">// get pointer to xp</span></span><br><span class="line">D-&gt;<span class="built_in">mf</span>( );      <span class="comment">// call mf through pointer</span></span><br></pre></td></tr></table></figure>
<p>上述示例中我们都会调用<strong>B::mf()</strong> 版函数，但是如果我们在D class中重写mf()那么我们会发现以下问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;    <span class="comment">// hides B::mf; see Item33</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls D::mf should call B::mf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>non-virtual函数是一种<strong>静态绑定</strong>(statically bound)</p>
</blockquote>
<pre><code>    在子类中重写non-virutal函数，它会根据其**声明式** (也就是D* ,B*)来选取函数执行，但实际上pB与pD指向都是**同一对象**，按理来说应该调用同一对象的函数，因此重写non-virtual函数会**导致破坏多态性**。
</code></pre><blockquote>
<p>public继承关系</p>
</blockquote>
<p>public继承关系”is-a”关系，那么non-vitual函数的作用(不变性凌驾于特异性):</p>
<ol>
<li><p>适用于B对象的每一件事，也适用与D对象</p>
</li>
<li><p>B的derived classes一定会继承mf的接口与实现，因为mf是B的一个non-virutal函数</p>
</li>
</ol>
<blockquote>
<p>多态性的虚构问题</p>
</blockquote>
<p>   条款7： virtual析构函数，对于B<em> pd = new D();由于声明的是non-virtual的析构函数，那么执行的时候会根据<em>*声明式来定义</em></em> 静态绑定调用函数，因此在多态中只会使用B的析构函数，对于D的析构则不会调用，这时候有些D类的成员不能被析构，会导致内存泄漏问题</p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited non-virtual function.</p>
<hr>
<h2 id="条款37：绝不重新定义继承而来的默认参数值"><a href="#条款37：绝不重新定义继承而来的默认参数值" class="headerlink" title="条款37：绝不重新定义继承而来的默认参数值"></a>条款37：绝不重新定义继承而来的默认参数值</h2><p><code>Never redefine a function&#39;s inherited default parameter value</code></p>
<p><strong>virtual函数系动态绑定，然而默认的却是静态绑定</strong></p>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><blockquote>
<p>静态绑定义</p>
</blockquote>
<pre><code>    在程序中被**声明时**所采用的类型,静态绑定容易造成的问题如：继承类重写non-virtual函数
</code></pre><p>简单来说就是调用对象是采用声明对象的一部分行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// a class for geometric shapes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="comment">// all shapes must offer a function to draw themselves</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Shape::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// notice the different default parameter value — bad!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Rectangle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Circle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shape *ps;                    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pc = <span class="keyword">new</span> <span class="built_in">Circle</span>();    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();<span class="comment">// static type = Shape*</span></span><br><span class="line">    ps = pc;</span><br><span class="line">    ps = pr;</span><br><span class="line">   <span class="comment">// ps-&gt;draw();</span></span><br><span class="line">    pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>();<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承关系</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-07-20-28-31-image.png" alt=""></p>
<blockquote>
<p>指针(静态类型)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;    <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;<span class="comment">// static type = Shape*</span></span><br></pre></td></tr></table></figure>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><blockquote>
<p>动态绑定定义</p>
</blockquote>
<pre><code>   普遍的来说是多态性，由一个**静态类型**的对象指针(引用)指向一个子类对象，在运行其就会将行为于其指向的对象进行绑定，调用子类对象的行为。

    简单来说就是调用指向对象的行为
</code></pre><blockquote>
<p>动态类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc;<span class="comment">// ps’s dynamic type is// now Circle*</span></span><br><span class="line">ps = pr;<span class="comment">// ps’s dynamic type is// now Rectangle*</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">====================</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Circle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题分析:动态绑定与静态绑定冲突</p>
</blockquote>
<pre><code>    在pr-&gt;draw();中出现了问题，pr的动态类型为Rectangle调用为virtual函数，但Rectangle::draw默认参数为应该时GREEN，但由于pr的静态类型为Shape*，所以此一调用的默认阐述时来自于Shape class，而不是来之于Rectangle class。这个函数时两个类共同完成的
</code></pre><h3 id="NVI解决方案"><a href="#NVI解决方案" class="headerlink" title="NVI解决方案"></a>NVI解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span><span class="comment">// now non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);<span class="comment">// calls a virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">                                    <span class="comment">// the actual work is</span></span><br><span class="line">&#125;;<span class="comment">// done in this func</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;<span class="comment">// note lack of a</span></span><br><span class="line">    ...<span class="comment">// default param val.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>    non-virtual 函数一个不会被derived classes重写(条款36)，所以这个设计很清楚地使用了color的默认值为Red，相当于强制性不让动态绑定选择静态绑定的参数，NVI手法将动态绑定和静态绑定通过**private在继承中可见性**，进行了巧妙的结合
</code></pre><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited default parameter value, because defaultparameter values are statically bound, while virtual functions — theonly functions you should be redefining — are dynamically bound.</p>
<hr>
<h2 id="条款38：通过复合塑造出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑造出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑造出has-a或“根据某物实现出”"></a>条款38：通过复合塑造出has-a或“根据某物实现出”</h2><p><code>Model &quot;has-a&quot;or&quot;is-implement-in-terms-of&quot; throught composition</code></p>
<blockquote>
<p>复合类型</p>
</blockquote>
<p>在一个类中的数据成员是一个或者多个自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;<span class="comment">// where someone lives</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name;<span class="comment">// composed object</span></span><br><span class="line">Address address;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber voiceNumber;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber faxNumber;<span class="comment">// ditto</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>has-a与is-a</p>
</blockquote>
<p>在上述Person中定义了name、address、voiceNumber、faxNumber，我们都很容易说，这个人有一个名字、地址、号码，但我们不能说这个人是一个名字，另外is-a是一种继承关系</p>
<h3 id="复合类型中的has-a和“根据某物实现出”区分"><a href="#复合类型中的has-a和“根据某物实现出”区分" class="headerlink" title="复合类型中的has-a和“根据某物实现出”区分"></a>复合类型中的has-a和“根据某物实现出”区分</h3><ul>
<li><p>has-a是应用域</p>
</li>
<li><p>is-implement-in-terms-of是实现域</p>
</li>
</ul>
<p>用Set&lt; T &gt;继承list&lt; T &gt;声明如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//将list应用于Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:<span class="keyword">public</span> std::list&lt;T&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>根据上述继承关系很容易区分出错误，list可以插入相同元素，Set不能含有相同元素，因此在逻辑上，Set不适用于list的逻辑，因此也不是is-a关系，所以对于这两种关系不能用public来实现.</p>
<blockquote>
<p>正确做法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">// the right way to use list for Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;<span class="comment">// representation for Set data </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过复合类型可以很明显的看出关系，Set只是依赖list来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="type">const</span> T&amp; item) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item) != rep.<span class="built_in">end</span>( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; item)&#123; </span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::iterator it =<span class="comment">// see Item42 for info on</span></span><br><span class="line">    std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item);<span class="comment">// “typename” here</span></span><br><span class="line">                <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>( )) rep.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>✦Composition has meanings completely different from that of publicinheritance. </p>
<p>✦In the application domain, composition means has-a. In the imple-mentation domain, it means is-implemented-in-terms-of.</p>
<hr>
<h2 id="条款39：谨慎的使用“private”继承"><a href="#条款39：谨慎的使用“private”继承" class="headerlink" title="条款39：谨慎的使用“private”继承"></a>条款39：谨慎的使用“private”继承</h2><p><code>use private inheritance judiciously</code></p>
<h3 id="Private-继承"><a href="#Private-继承" class="headerlink" title="Private 继承"></a>Private 继承</h3><blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;; <span class="comment">// inheritance is now private</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// error! a Student isn’t a Person</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>private继承</p>
</blockquote>
<p>根据以上代码的展示，我们会发现private继承与public继承不是同一个含义，同样的public继承会产生一些逻辑上的错误，例如学生不是人</p>
<ul>
<li>private继承不会有隐式转换，同样<strong>不能多态</strong></li>
<li>private的语义为根据某物实现( is-implemented-in-terms-of),不会对外呈现父类的接口</li>
<li>private继承中base的成员都会变为private无论是protected还是public</li>
</ul>
<p>因此，private只在软件的实现中会有意义，在软件的设计中毫无意义</p>
<h3 id="复合与private继承的抉择"><a href="#复合与private继承的抉择" class="headerlink" title="复合与private继承的抉择"></a>复合与private继承的抉择</h3><p>private继承与复合都有根据某物实现( is-implemented-in-terms-of)的概念。</p>
<blockquote>
<p>取舍</p>
</blockquote>
<p>尽可能的选择复合，必要时才会使用private(当protected成员或virtual函数被牵扯进来)</p>
<h3 id="使用Private继承"><a href="#使用Private继承" class="headerlink" title="使用Private继承"></a>使用Private继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// automatically called for each tick</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// look at Widget usage data, etc</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于virtual函数，我们需要用private继承</p>
<p>上述代码当我们需要对一个Widget类进行计时，在运行期中周期性的检查Widget类。对于Timer这一个计时器，Widget中可以重新定义Timer内的virtual函数，但用public检查就说明Widget是一个Timer那肯定是不符合实际的。对于private继承确实是完美的选择：</p>
<ul>
<li>Widget会拥有Timer的一些实现,因此也是根据某物实现。</li>
<li>用户也不会造成接口的滥用，该此Timer实现也是对Widget对象内可见的。</li>
</ul>
<h3 id="复合实现"><a href="#复合实现" class="headerlink" title="复合实现"></a>复合实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;; </span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用复合类的方法实现private继承同样也是可以的，但是略显复杂</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-10-10-05-01-image.png" alt=""></p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>✦Private  inheritance  means  is-implemented-in-terms  of.  It’s  usually inferior  to  composition,  but  it  makes  sense  when  a  derived  classneeds access to protected base class members or needs to redefineinherited virtual functions.</p>
<p>✦Unlike composition, private inheritance can enable the empty baseoptimization. This can be important for library developers who strive to minimize object sizes</p>
<hr>
<h2 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款40：明智而谨慎地使用多重继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;<span class="comment">// something a library lets you borrow</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;<span class="comment">// check the item out from the library</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// perform self-test, return whether</span></span><br><span class="line">    ...<span class="comment">// test succeeds</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>:<span class="comment">// note MI here</span></span><br><span class="line">        <span class="keyword">public</span> BorrowableItem,<span class="comment">// (some libraries loan MP3 players)</span></span><br><span class="line">        <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123; ... &#125;;                    <span class="comment">// class definition is unimportant</span></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>();<span class="comment">// ambiguous! which checkOut?</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决方案</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure>
<p>因为在MP3player中又两个相同的接口，因此在调用是会无法识别到底调用那个，因此只能指定数据成员</p>
<p>但是会得到一个尝试调用private成员的错误</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220511205507673.png" alt="image-20220511205507673"></p>
<p>以上的继承路线有两个条那么，假设File有一个filename数据成员分别继承到InputFile和OutputFile，当IOFile进行多重继承，那么我们会得到两份filename(InputFile::filename,Output::filename)。</p>
<p>得到的IOFile中如果要操作filename这<strong>数据成员要指定来自于那个父类</strong>同上。但再逻辑上这是不符合逻辑，一个文件不可能拥有两个名字。这时候就需要<strong>虚拟继承</strong>。</p>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><blockquote>
<p>含义</p>
<p>解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员。</p>
</blockquote>
<p>防止二义性问题，共享Top-Base类数据。</p>
<blockquote>
<p>虚拟继承与普通继承的区别</p>
</blockquote>
<p><strong>时间</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。(虚拟就是运行期进行选择)</p>
<p><strong>空间</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之 多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证 这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>这样的做法就会使得再最终的outputFile中仅有一个一份filename，且不会产生二义性</p>
<h4 id="虚拟继承的成本"><a href="#虚拟继承的成本" class="headerlink" title="虚拟继承的成本"></a>虚拟继承的成本</h4><blockquote>
<p>空间</p>
</blockquote>
<p>virtual继承的class产生的non-virtual的继承体积大</p>
<blockquote>
<p>时间</p>
</blockquote>
<p>访问virtual继承的成员变量时，比访问non-virtual base classe的速度慢</p>
<h4 id="虚拟继承的初始化规则更复杂"><a href="#虚拟继承的初始化规则更复杂" class="headerlink" title="虚拟继承的初始化规则更复杂"></a>虚拟继承的初始化规则更复杂</h4><blockquote>
<p>初始化职责有继承中的最底层承担</p>
</blockquote>
<ol>
<li>classes若派生自virtual bases而需要初始化，必须要知道其virtual bases</li>
<li>当一个新的derived class加入继承体系中，它必须承当其virtual bases的初始化职责</li>
</ol>
<h4 id="虚拟继承的抉择"><a href="#虚拟继承的抉择" class="headerlink" title="虚拟继承的抉择"></a>虚拟继承的抉择</h4><ol>
<li>非必要不用虚拟继承，就用non-virtual 继承</li>
<li>必须使用virtual base classes，尽可能避免再其中放置数据</li>
</ol>
<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>✦Multiple inheritance is more complex than single inheritance. It canlead to new ambiguity issues and to the need for virtual inheritance. </p>
<p>✦Virtual  inheritance  imposes  costs  in  size,  speed,  and  complexity  ofinitialization and assignment. It’s most practical when virtual baseclasses have no data.</p>
<p>✦Multiple  inheritance  does  have  legitimate  uses.  One  scenario  in-volves  combining  public  inheritance  from  an  Interface  class  withprivate inheritance from a class that helps with implementation.CPersonIPersonPersonInfo{private}</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p><code>Understand implicit interfaces and compile-time polymorphism</code></p>
<h3 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h3><ul>
<li>提供显示接口</li>
<li>运行期多态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;<span class="comment">// see Item25</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//and this (equally meaningless) function,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">( Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析</p>
</blockquote>
<ul>
<li>显示接口：在本例中我们在<code>doProcessing</code>中调用w的接口，我们可以在源文件中找到这些接口(.h文件)，必须知道接口的实现。</li>
<li>运行期多态：在条款37中有动态类型绑定，widget中virtual函数表现出来的为运行期多态</li>
</ul>
<h3 id="Template以及泛型编程-generic-programming"><a href="#Template以及泛型编程-generic-programming" class="headerlink" title="Template以及泛型编程( generic programming )"></a>Template以及泛型编程( generic programming )</h3><blockquote>
<p>面对对象的规则依然存在但是被弱化了</p>
</blockquote>
<ul>
<li>隐式接口</li>
<li>编译期多态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>w所支持的接口，是由template中的w身上的操作来决定，w需要提供一系列的隐式接口</li>
<li>w的任何函数的调用，入operator&gt; and operator!=,有可能造成template的据具现化(instantiated),这些函数的调用都是具现化在编译期。通俗来讲就是，通过模板类型T去判断T中是否有以下行为(接口)，如果没有则会编译失败，如果存在则进行选择</li>
</ul>
<h3 id="运行期多态与编译期多态"><a href="#运行期多态与编译期多态" class="headerlink" title="运行期多态与编译期多态"></a>运行期多态与编译期多态</h3><blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>运行期多态：那个virtual函数被选择</li>
<li>编译期多态：那个重载函数被调用</li>
</ul>
<h3 id="隐式接口与显式接口"><a href="#隐式接口与显式接口" class="headerlink" title="隐式接口与显式接口"></a>隐式接口与显式接口</h3><blockquote>
<p>显式接口</p>
</blockquote>
<p>通常是由函数的签名式(函数名称、参数类型、返回类型)构成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上public接口有一个构造函数、析构函数、各个成员函数及其参数类型、返回类型、常量性构成。</p>
<blockquote>
<p>隐式接口</p>
</blockquote>
<p>它不基于函数签名式，是由有效表达式(valid expression)组成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上：</p>
<p>T的隐式接口有一系列的约束</p>
<ul>
<li>必须提供size函数</li>
<li>必须提供operator !=的类型比较函数(假设<code>someNastyWidget</code>的类型为T)</li>
</ul>
<p><strong>隐式接口同样需要支持T类型</strong></p>
<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>✦Both classes and templates support interfaces and polymorphism.</p>
<p> ✦For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions. </p>
<p>✦For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution.</p>
<hr>
<h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p><code>Understand the two meaning of typename</code></p>
<h3 id="class-and-typename-声明"><a href="#class-and-typename-声明" class="headerlink" title="class and typename 声明"></a>class and typename 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br></pre></td></tr></table></figure>
<p>class 与 typename没有任何不同。当声明template类型参数，class和typename的意义完全相同</p>
<h3 id="typename的另一重意义"><a href="#typename的另一重意义" class="headerlink" title="typename的另一重意义"></a>typename的另一重意义</h3><blockquote>
<p>声明“类型”</p>
</blockquote>
<p>当有static成员变量与T::~定义的类型命名冲突时会造成编译器的警告，因此需要typename的显式的声明这是命名为一个<strong>类型</strong>，而不是<strong>变量</strong></p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;<span class="comment">// typename allowed (as is “class”)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">const</span> C&amp; container,<span class="comment">// typename not allowed</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">typename</span> C::iterator iter)</span></span>;<span class="comment">// typename required</span></span><br></pre></td></tr></table></figure>
<p>上述的C不是嵌套从属类型名称，所以声明container时并不需要typename为签到，但C::iterator是个嵌套从属类型因此需要typename作为前置声明</p>
<blockquote>
<p>例外</p>
</blockquote>
<p>typename不能出现在base classes list内的嵌套从属类型名称之前，也不可以在member initalization list中作为base class修饰符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;<span class="comment">// base class list: typename not</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x)// base class identifier in mem.&#123;</span></span><br><span class="line">        <span class="comment">// init. list: typename not allowed</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;     <span class="comment">// use of nested dependent type</span></span><br><span class="line">        ...<span class="comment">// name not in a base class list or</span></span><br><span class="line">&#125;<span class="comment">// as a base class identifier in a </span></span><br><span class="line">...<span class="comment">// mem. init. list: typename required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>typename 与 typedef连用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>✦When declaring template parameters, class  and typename  are  inter-changeable.</p>
<p>✦Use typename  to  identify  nested  dependent  type  names,  except  inbase class lists or as a base class identifier in a member initializa-tion list</p>
<hr>
<h2 id="条款43-：学习处理模板化基类内的名称"><a href="#条款43-：学习处理模板化基类内的名称" class="headerlink" title="条款43 ：学习处理模板化基类内的名称"></a>条款43 ：学习处理模板化基类内的名称</h2><p><code>Know how to access names in templatized base classes</code></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>假设一个程序可以发送消息给不同公司，信息可以以密文或则明文的方式发送，用类模板这可以在编译期对公司进行选择</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...<span class="comment">// classes for other companies</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;<span class="comment">// class for holding information</span></span><br><span class="line"><span class="comment">// used to create a message</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        std::string msg;<span class="comment">//create msg from info;</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span><span class="comment">// similar to sendClear, except</span></span></span><br><span class="line"><span class="function">    </span>&#123; ... &#125;<span class="comment">// calls c.sendEncrypted</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MsgSender类的调用不会用任何的问题</p>
<p>添加派生类LoggingMsgSender</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//write &quot;before sending&quot; info to the log;</span></span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// call base class function;</span></span><br><span class="line">                        <span class="comment">// this code will not compile!</span></span><br><span class="line">        <span class="comment">//write &quot;after sending&quot; info to the log;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>:ice_cream: 这个派生类在新的一个non-virtual member函数中调用了父类的non-virtual member函数,这个函数解决了(条款33和条款36)non-virtual函数在派生类中出现的一系列问题，但是这个代码在不同的编译器是<strong>不能编译的</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220518220901314.png" alt="image-20220518220901314"></p>
<blockquote>
<p>问题所在</p>
</blockquote>
<p>编译器遇到LoggingMsgSender的模板定义，不知道它是继承的那个类。</p>
<p>因为Company是一个模板参数，它是不确定的一个参数，只有当LoggingMsgSender被实例化后Company才会确定，因此在MsgSender&lt; Company &gt;的派生类中会出现无法确定继承的父类的问题。</p>
<p>更加明确的说是不知道Company中是否有sendClear这个函数</p>
<blockquote>
<p>模板全特化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123;<span class="comment">// this class offers no</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// sendCleartext function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// a total specialization of </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;<span class="comment">// MsgSender; the same as the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// general template, except </span></span><br><span class="line">    ...<span class="comment">// sendClear is omitted</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通用的MsgSender模板是不适用于CompanyZ的，因为模板提供的sendClear函数是对CompanyZ没有意义的。因此在仍然会出现上述问题，在Company中找不到sendClear的声明(因为CompanyZ的特例化没有定义sendClear函数)</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><blockquote>
<p>方案一:在base class函数调用动作之前加上this-&gt;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that// sendClear will be inherited</span></span><br><span class="line">        write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方案二：使用using声明</p>
</blockquote>
<p>在条款33中找不到基类重载继承下来的隐藏的函数，是因为被派生类所隐藏</p>
<p>在本例中是编译器不搜索基类作用域</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<span class="comment">// tell compilers to assume</span></span><br><span class="line">    ...<span class="comment">// that sendClear is in the// base class</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">            ...<span class="comment">// sendClear will be inherited</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方案三：显式的指定你的函数位于base class中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">        ...<span class="comment">// sendClear will be </span></span><br><span class="line">    &#125;<span class="comment">// inherited</span></span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>这是一个不太好的方法，因为被调用的是virtual函数会导致virtual函数的绑定行为被关闭</p>
<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>✦In  derived  class  templates,  refer  to  names  in  base  class  templatesvia  a  “this-&gt;”  prefix,  via using  declarations,  or  via  an  explicit  base class qualification.</p>
<hr>
<h2 id="条款44：将于参数无关的代码抽离templates"><a href="#条款44：将于参数无关的代码抽离templates" class="headerlink" title="条款44：将于参数无关的代码抽离templates"></a>条款44：将于参数无关的代码抽离templates</h2><p>Factor parameter -independent code out of templates</p>
<blockquote>
<p>不恰当的使用template可能会导致代码膨胀(code bloat):其二进制带着重复的代码、数据</p>
</blockquote>
<p>解决方法：当两个函数实现的实质相同</p>
<p>抽离两个函数中共同的部分，将他放入第三个函数中，然后将他们调用这个新函数。class也是同样的道理，使用继承或则复合</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>用固定尺寸的方阵编写一个template。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="comment">// template for n x n matrices of</span></span><br><span class="line">            std::<span class="type">size_t</span> n&gt;<span class="comment">// objects of type T; see below for info</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;<span class="comment">// on the size_t parameter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span></span>;<span class="comment">// invert the matrix in place</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的类型为size_t的参数是一个非类型参数(non-type parameter)。</p>
<p>对上述代码进行调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析</p>
</blockquote>
<p>上述代码中，将会具现化两份invert函数，但这两份函数是完全相同，因为其中一个操作的5<em>5矩阵而另一个是10 </em>10的矩阵，除了常量5和10其他部分完全相同，这将是一个典型的代码膨胀示例</p>
<blockquote>
<p>解决方案一</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// size-independent base class for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;<span class="comment">// square matrices</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;<span class="comment">// invert matrix of the given size</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;<span class="comment">// make base class version of invert</span></span><br><span class="line">                                    <span class="comment">// visible in this class; see Items 33</span></span><br><span class="line">                                    <span class="comment">// and 43</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span> </span>&#123;<span class="built_in">invert</span>(n); &#125;<span class="comment">// make inline call to base class</span></span><br><span class="line">&#125;;<span class="comment">// version of invert</span></span><br></pre></td></tr></table></figure>
<p>上述解决方案中</p>
<p>在所有方阵实体中只会共享一个父类的invert实现，这样就有效的防止的代码膨胀</p>
<ul>
<li>避免derived class代码重复：父类使用了protect代替了public。注<code>在调用时会如果时public(实体对象仍然可以调用该接口)的话也同样会产生不同版本的代码</code></li>
<li>调用其代码的成本为0，因为derived classes的inverts调用base clas的版本是inline调用</li>
<li>this-&gt;调用表示模板化基类反之函数名称被隐盖</li>
<li>使用private的继承关系表现的是一种is-a关系</li>
</ul>
<p><strong>问题</strong>：在该方案中没有解决父类与子类之间联系的问题，因为在子类中需要带入矩阵的相关数据，因此需要加入一个指针或者引用。但是反复的传参，这样也会影响效率</p>
<blockquote>
<p>解决方案二：父类中存储一个指针，指向所在的内存</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T *pMem)<span class="comment">// store matrix size and a</span></span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123; &#125;<span class="comment">// ptr to matrix values</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">( T *ptr)</span> </span>&#123; pData = ptr; &#125;<span class="comment">// reassign pData</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;<span class="comment">// size of matrix</span></span><br><span class="line">    T *pData;<span class="comment">// pointer to matrix values</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="built_in">SquareMatrix</span>( )<span class="comment">// send matrix size and </span></span><br><span class="line">        : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123; &#125;<span class="comment">// data ptr to base class</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法在子类中调用了父类的构造函数，用来初始父类中的数据成员</p>
<p>当数据成员特别大的时候可以使用<strong>动态内存分配</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>( )<span class="comment">// set base class data ptr to null,</span></span><br><span class="line">        :   <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),<span class="comment">// allocate memory for matrixpData(new T[n*n])</span></span><br><span class="line">                                        <span class="comment">// values, save a ptr to the</span></span><br><span class="line">    &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>( )); &#125;<span class="comment">// memory, and give a copy of it</span></span><br><span class="line">    ...<span class="comment">// to the base classprivate:boost::scoped_array&lt;T&gt; pData;</span></span><br><span class="line">        <span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>✦Templates generate multiple classes and multiple functions, so anytemplate code not dependent on a template parameter causes bloat.</p>
<p>✦Bloat due to non-type template parameters can often be eliminatedby replacing template parameters with function parameters or classdata members.</p>
<p>✦Bloat due to type parameters can be reduced by sharing implemen-tations for instantiation types with identical binary representations.</p>
<hr>
<h2 id="条款45：使用成员函数template接受所有可以兼容的类型"><a href="#条款45：使用成员函数template接受所有可以兼容的类型" class="headerlink" title="条款45：使用成员函数template接受所有可以兼容的类型"></a>条款45：使用成员函数template接受所有可以兼容的类型</h2><p><code>Use member function template to accept “all compatible type”</code></p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>行为像指针的对象，并提供指针没有的技能。STL容器几乎都是用到智能指针，但是我们不会使用“++”的运算符将一个内置的指针从link list的节点移动到另一个节点，所以需要用到迭代器</p>
<h3 id="真实指针-raw-pointer"><a href="#真实指针-raw-pointer" class="headerlink" title="真实指针(raw pointer)"></a>真实指针(raw pointer)</h3><p>支持隐式转换。例如：Derived class 指针可以隐式的转换为base class指针(提供多态的选择)，“指向non-const对象”的指针可以转为”const对象”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top *pt1 = <span class="keyword">new</span> Middle;<span class="comment">// convert Middle*⇒  Top*</span></span><br><span class="line">Top *pt2 = <span class="keyword">new</span> Bottom;<span class="comment">// convert Bottom*⇒  Top*</span></span><br><span class="line"><span class="type">const</span> Top *pct2 = pt1;<span class="comment">// convert Top*⇒  const Top*</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// smart pointers are typically</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">( T *realPtr)</span></span>;<span class="comment">// initialized by built-in pointers </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =<span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =<span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;<span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></span><br><span class="line">                            <span class="comment">//SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述同一个template的不同具现体(instantiation)之间不存在继承关系，所以SmartPtr&lt; Top &gt;与SmartPtr&lt; Middle &gt;是完全不同的class</p>
<h3 id="Templates和泛型编程-Generic-Programming"><a href="#Templates和泛型编程-Generic-Programming" class="headerlink" title="Templates和泛型编程(Generic Programming)"></a>Templates和泛型编程(Generic Programming)</h3><blockquote>
<p>生产需求:自定义指针构造函数的编写</p>
</blockquote>
<p>当我们添加一个新继承关系的对象时，那没有添加转型的构造函数的情况下，就会反复的在SmartPtr中添加构造函数</p>
<p><code>class BelowBottom: public Bottom &#123; ... &#125;;</code></p>
<blockquote>
<p>member function tempaltes——泛化copy构造函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">// member template </span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);<span class="comment">// for a ”generalized</span></span><br><span class="line">    ...<span class="comment">// copy constructor”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中对于任意类型T与任意类型U，可以根据SmartPtr&lt; U &gt;生成一个SmartPtr&lt; T &gt;——因为SmartPtr&lt; T &gt;有个构造函数接受有个SmartPtr&lt; U &gt;参数。</p>
<p>泛化的copy构造函数并未被声明为explicit，因为原始指针之间(base class与derived class之间)的转换是隐式的转换，无需明白的写出转型动作(cast)</p>
<blockquote>
<p>提供原始资源的成员函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span><span class="comment">// initialize this held ptr: </span></span></span><br><span class="line"><span class="function">    <span class="title">heldPtr</span><span class="params">(other.get( ))</span> </span>&#123; ... &#125;<span class="comment">// with other’s held ptr</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// built-in pointer held</span></span><br><span class="line">    T*heldPtr;<span class="comment">// by the SmartPtr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用成员初始化列表来初始化SmartPtr&lt; T &gt;之内类型为T<em>的成员变量，并以类型为U</em>的指针作为初值。</p>
<p><code>member initialization templates</code>成员初始化列表的作用不限于构造函数，另一个作用是支持赋值操作</p>
<blockquote>
<p>摘录</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// construct from</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y * p)</span></span>;<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; <span class="comment">// built-in pointer,</span></span><br><span class="line">           <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// shared_ptr,</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// weak_ptr, or</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;<span class="comment">// auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp; r)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// assign from</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// shared_ptr or</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);<span class="comment">// auto_ptr...&#125;;</span></span><br></pre></td></tr></table></figure>
<p>上述所有构造函数都是explicit，唯有”泛化copy构造函数”除外，那么从<strong>某个shared_ptr类型隐式转为另一个shared_ptr</strong>是允许的，但是从某个内置指针或从其他智能指针进行隐式转换则是不允许的(显示的转换倒是可以)。</p>
<h3 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h3><p>✦Use member function templates to generate functions that accept allcompatible types.</p>
<p>✦If  you  declare  member  templates  for  generalized  copy  constructionor  generalized  assignment,  you’ll  still  need  to  declare  the  normalcopy constructor and copy assignment operator, too</p>
<hr>
<h2 id="条款46：需要类型转换是请为模板定义非成员函数"><a href="#条款46：需要类型转换是请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换是请为模板定义非成员函数"></a>条款46：需要类型转换是请为模板定义非成员函数</h2><p><code>Define non-member function inside templates when type conversion are desired</code></p>
<p>这个条款换个说法是：<strong>当我们需要进行模板函数参数类型需要隐式转换时，将模板函数定义为friend函数</strong></p>
<h3 id="示例：条款24的例子转为模板"><a href="#示例：条款24的例子转为模板" class="headerlink" title="示例：条款24的例子转为模板"></a>示例：条款24的例子转为模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// see Item28 for why returnconst </span></span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// values are still passed by value,</span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>进行以下混合式(mixed-mode)运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">// this example is from Item24,</span></span><br><span class="line">                            <span class="comment">// except Rational is now a template</span></span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;<span class="comment">// error! won’t compile</span></span><br></pre></td></tr></table></figure>
<p>出现以下问题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\2022-06-03-17-34-47-image.png" alt=""></p>
<blockquote>
<p>分析</p>
</blockquote>
<p>以上问题是因为没有找对应的operator * 操作符对应的函数，也就是推导失败。</p>
<p>以上代码中operator*这个non-member函数的两个参数进行隐式类型推导时出现了问题:</p>
<ul>
<li>第一个实参是onehalf，所以T一定是int，能够顺利的推导出</li>
<li>第二个实参是2，编译器无法将其推导为Rational&lt; int &gt;</li>
</ul>
<p>经过以上考虑，因该是将隐式转换类型转换函数出现调用失败的问题,无法将non-member函数指定为operator*</p>
<h3 id="friend函数声明"><a href="#friend函数声明" class="headerlink" title="friend函数声明"></a>friend函数声明</h3><p>template class中friend声明式可以指定特定的函数，Rational&lt; T &gt;可以声明operator<em>是<em>*class的一个friend函数</em></em></p>
<p>class template并不依赖template的<strong>实参推导</strong>，所以能够在class Rational&lt; T &gt;具现化时得知T,<strong>换句话说就是T的类型被确定后，就已经指定调用operator*函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">    <span class="keyword">friend</span><span class="comment">// declare operator*</span></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="comment">// function (see </span></span><br><span class="line">                             <span class="type">const</span> Rational&amp; rhs);<span class="comment">// below for details)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>此时混合式调用可以通过编译，当对象onehalf被声明为一个Rational&lt; int &gt;，class Rational&lt; int &gt;被具现化出来了。而作为过程的一部分，friend函数operator<em>(接受Rational&lt; int &gt; 参数)也就被<strong>自动声明出来</strong>。后者身为<em>*一个函而非函数模板</em></em>，因此编译器可以调用它时使用隐式转换函数。</p>
<p>上述friend函数同样可以声明为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链接错误</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\image-20220603221112025.png" alt="image-20220603221112025"></p>
<p>虽然经过修改我们能过通过编译，但是在链接时会出现上述问题了，因为friend函数只有一个声明式存在，并没有被定义，因此会导致连接器无法找到对应的实现</p>
<h3 id="函数本体与声明式结合-简单版"><a href="#函数本体与声明式结合-简单版" class="headerlink" title="函数本体与声明式结合(简单版)"></a>函数本体与声明式结合(简单版)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="friend特殊意义"><a href="#friend特殊意义" class="headerlink" title="friend特殊意义"></a>friend特殊意义</h3><p> 在本条款中虽然使用了friend却和它的<strong>传统意义</strong>不同(访问non-public成分)，但是在此的意义却是让类型转换发生于所有实参身上，我们需要一个<strong>non-member函数</strong>(条款24)；为了使这个函数<strong>自动具现化</strong>(隐式转换构造函数的指定)，我们需要将它<strong>声明在class内部</strong>；而在class内部声明non-member函数的唯一方法就是将其声明为<strong>friend函数</strong></p>
<h3 id="non-member与friend-member合作"><a href="#non-member与friend-member合作" class="headerlink" title="non-member与friend member合作"></a>non-member与friend member合作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(T numerator = <span class="number">0</span>,</span><br><span class="line">    T denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> d;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs,rhs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n;</span><br><span class="line">    T d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>✦When  writing  a  class  template  that  offers  functions  related  to  thetemplate  that  support  implicit  type  conversions  on  all  parameters,define those functions as friends inside the class template.</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Effect C++笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.ember-l.top/2023/01/20/C++/Effective%20C++/">http://www.ember-l.top/2023/01/20/C++/Effective C++/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Ember🍐</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-01-20</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-01-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Effective-C/">Effective C++</a></div><div class="post_share"><div class="social-share" data-image="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂硬币</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251417569.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">FaRM</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">可调用对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/" title="可调用对象"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-20</div><div class="title">可调用对象</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">Ember🍐</div><div class="author-info__description">BugMaker 💦💦💦</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ember-l"><i></i><span>Follow me🚀</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/qq.jpg" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/assets/wx.jpg" target="_blank" title="微信"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/ember-l" target="_blank" title="github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github1"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:2508856440@qq.com" target="_blank" title="邮箱"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://www.zhihu.com/people/low-45-75" target="_blank" title="知乎"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shejiaotubiao-10"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:27px;width:27px;fill:currentColor;position:relative;top:3px" aria-hidden="true"><use xlink:href="#icon-fengche"></use></svg></a><span>公告</span></div><div class="announcement_content"><center><b>--- 主域名 ---<br><a href="https://www.ember-l.top" title="此线路部署于Vercel" class="anno_content"><font color="#cc7227">ember-l.top</font></a></b></center></div><div id="welcome-info"></div></div><div class="card-widget tzy-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face"></div><div class="back face"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:27px;width:27px;fill:currentColor;position:relative;top:3px" aria-hidden="true"><use xlink:href="#icon-mulu"></use></svg></a><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-C"><span class="toc-text">Effective C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-text">让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE01"><span class="toc-text">条款01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2-define"><span class="toc-text">条款02：尽量以const，enum，inline替换#define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-text">条款03：尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8const%E5%92%8Cnon-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D"><span class="toc-text">在const和non-const成员函数中避免重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E7%BB%8F%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">条款04：确定对象被使用前已经先被初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-text">初始化与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F"><span class="toc-text">成员初始化次序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%AF%B9%E8%B1%A1"><span class="toc-text">static对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%BC%96%E8%AF%91"><span class="toc-text">多源文件跨编译单元编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#non-local-static-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">non-local static 对象初始化次序问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E8%AE%A4%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">条款05：了解C++默认编写和调用了哪些函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%9B%A0%E8%AF%A5%E6%98%8E%E7%A1%AE%E7%9A%84%E6%8B%92%E7%BB%9D"><span class="toc-text">条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-4"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款08：别让异常逃离析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator-%E4%B8%AD%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-text">条款11：在operator&#x3D;中“自我赋值”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%AF%81%E5%90%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">方法一：证同测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">方法二：异常安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9Acopy-swap%EF%BC%88%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89%E2%80%94-%E6%9D%A1%E6%AC%BE29"><span class="toc-text">方法三：copy-swap（异常安全性）—-条款29</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款14：在资源管理类中小心copying行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E5%AF%B9%E8%B1%A1copied%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">RAII对象copied的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">条款15：在资源类中提供对原始资源的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-text">设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5pass-by-reference-to-const-%E6%9B%BF%E6%8D%A2pass-by-value"><span class="toc-text">条款20：宁以pass-by-reference-to-const 替换pass-by-value</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8pass-by-reference-to-const%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">用pass-by-reference-to-const的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-text">条款21：必须返回对象时，别妄想返回其reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%BB%A5reference%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E7%9A%84%E5%87%A0%E5%A4%A7%E8%AF%AF%E5%8C%BA"><span class="toc-text">当以reference作为返回值时的几大误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-text">正确做法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-5"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-text">条款22：将成员变量声明为private</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#private%EF%BC%88%E6%8F%90%E4%BE%9B%E5%B0%81%E8%A3%85%EF%BC%89%E5%92%8C%E5%85%B6%E4%BB%96%EF%BC%88%E6%8F%90%E4%BE%9B%E5%B0%81%E8%A3%85%EF%BC%89"><span class="toc-text">private（提供封装）和其他（提供封装）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-6"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-text">条款23：宁以non-member、non-friend替换member函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-text">程序设计问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-7"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-text">条款24： 若所有参数皆需类型转换,请为此采用non-member函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86operator%E5%86%99%E4%B8%BAnon-member%E5%87%BD%E6%95%B0"><span class="toc-text">将operator写为non-member函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-text">条款25：考虑写出一个不抛出异常的swap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BA%A4%E6%8D%A2%E5%80%BC%E3%80%81%E6%97%A0%E6%B3%95%E4%BA%A4%E6%8D%A2%E6%8C%87%E9%92%88"><span class="toc-text">无法交换值、无法交换指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E4%BA%A4%E6%8D%A2%E5%9C%B0%E5%9D%80%E3%80%81%E5%8F%AF%E4%BB%A5%E4%BA%A4%E6%8D%A2%E6%8C%87%E9%92%88"><span class="toc-text">无法交换地址、可以交换指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%BA%A4%E6%8D%A2%E5%80%BC%E5%92%8C%E5%9C%B0%E5%9D%80"><span class="toc-text">可以交换值和地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">引用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93swap"><span class="toc-text">标准库swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9Aswap"><span class="toc-text">示例：swap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E5%85%B6impl%E6%8C%87%E9%92%88"><span class="toc-text">置换其impl指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8Epublic%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%BD%AE%E6%8D%A2"><span class="toc-text">声明public成员函数置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96function-template"><span class="toc-text">偏特化function template</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%81%9A%E6%B3%95"><span class="toc-text">标准做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%86%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E7%BD%AE%E5%90%8E"><span class="toc-text">条款26：尽量将变量的声明置后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%89%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-text">变量声明前置示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BD%AE%E5%90%8E"><span class="toc-text">变量置后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">循环中的变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-8"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">条款27：尽量少做转型操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%BD%AC%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-text">C语言转型语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%96%B0%E5%BC%8F%E8%BD%AC%E5%9E%8B-new-style"><span class="toc-text">C++新式转型(new-style)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">新式转换的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">旧式类型转换的使用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTII-Run-Time-Type-Identification"><span class="toc-text">RTII(Run Time Type Identification)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%9E%8B%E5%AE%B9%E6%98%93%E5%86%99%E5%87%BA%E4%BC%BC%E6%98%AF%E8%80%8C%E9%9D%9E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">转型容易写出似是而非的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic__cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E6%B3%95%E4%B8%80"><span class="toc-text">做法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E6%B3%95%E4%BA%8C"><span class="toc-text">做法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-9"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles-reference-pointer-iterators-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-text">条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">破坏封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dangling-handles-%E6%89%80%E6%8C%87%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="toc-text">dangling handles 所指对象不存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%A4%96%EF%BC%9Aoperator"><span class="toc-text">例外：operator[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9C%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-text">条款29：为”异常安全“而努力是值得的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9C%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">”异常安全“的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E2%80%9C%E4%BF%9D%E8%AF%81"><span class="toc-text">”异常安全函数“保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-text">异常安全函数解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">智能指针解决问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-and-Swap"><span class="toc-text">Copy and Swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-10"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-text">条款30：透彻了解inlining的里里外外</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inline%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">inline的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">inline的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-text">条款31：将文件间的编译依存关系降至最低</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-lt-string-gt"><span class="toc-text">include &lt; string &gt;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Cdate-h%E2%80%9D"><span class="toc-text">include “date.h”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Caddress-h%E2%80%9D"><span class="toc-text">include “address.h”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pimpl-idiom-pointer-to-implementation"><span class="toc-text">pimpl idiom(pointer to implementation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5"><span class="toc-text">设计策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-classses"><span class="toc-text">Handle classses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-classes"><span class="toc-text">Interface classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-11"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E9%80%A0%E5%87%BA%E7%9A%84is-a%E5%85%B3%E7%B3%BB"><span class="toc-text">条款32：确定你的public继承塑造出的is-a关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#is-a%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-text">is-a的误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E5%8F%8Cclass%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-text">方法一:双class继承体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%94%99%E8%AF%AF"><span class="toc-text">方法二：运行期错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-text">总结:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">命名查找规则(作用域)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E5%8F%AF%E8%A7%86%E6%80%A7-name-visibility"><span class="toc-text">名称可视性(name visibility)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0%E7%9A%84%E9%81%AE%E6%8E%A9%E8%A1%8C%E4%B8%BA"><span class="toc-text">解决继承来的名称的遮掩行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-function%E8%BD%AC%E4%BA%A4%E5%87%BD%E6%95%B0"><span class="toc-text">forward function转交函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">条款34：区分接口继承和实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%80%BB%E6%98%AF%E4%BC%9A%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-text">成员函数的接口总是会被继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pure-virtual%E5%87%BD%E6%95%B0-%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99"><span class="toc-text">pure virtual函数(子类必须重写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#impure-virtual%E5%87%BD%E6%95%B0-%E5%8F%AF%E9%80%89%E6%98%AF%E5%90%A6%E9%87%8D%E5%86%99"><span class="toc-text">impure virtual函数(可选是否重写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-virtual%E5%87%BD%E6%95%B0-%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99"><span class="toc-text">non-virtual函数(不能重写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-text">条款35：考虑virtual函数以外的其他选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Method%E6%A8%A1%E5%BC%8F"><span class="toc-text">Template Method模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strategy-Pattern-via-Function-Pointers"><span class="toc-text">Strategy Pattern via Function Pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strategy-Pattern-via-tr1-function"><span class="toc-text">Strategy Pattern via tr1::function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-%E2%80%9CClassic%E2%80%9D-Strategy-Pattern"><span class="toc-text">the “Classic” Strategy Pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-text">条款36：绝不重新定义继承而来的non-virtual函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">条款37：绝不重新定义继承而来的默认参数值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">静态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NVI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">NVI解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E9%80%A0%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-text">条款38：通过复合塑造出has-a或“根据某物实现出”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84has-a%E5%92%8C%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D%E5%8C%BA%E5%88%86"><span class="toc-text">复合类型中的has-a和“根据某物实现出”区分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39%EF%BC%9A%E8%B0%A8%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%9Cprivate%E2%80%9D%E7%BB%A7%E6%89%BF"><span class="toc-text">条款39：谨慎的使用“private”继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Private-%E7%BB%A7%E6%89%BF"><span class="toc-text">Private 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E4%B8%8Eprivate%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="toc-text">复合与private继承的抉择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Private%E7%BB%A7%E6%89%BF"><span class="toc-text">使用Private继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">复合实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E8%B0%A8%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">条款40：明智而谨慎地使用多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-text">菱形继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-text">虚拟继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">虚拟继承的成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E6%9B%B4%E5%A4%8D%E6%9D%82"><span class="toc-text">虚拟继承的初始化规则更复杂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="toc-text">虚拟继承的抉择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-text">条款41：了解隐式接口和编译期多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-text">面对对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-generic-programming"><span class="toc-text">Template以及泛型编程( generic programming )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-text">运行期多态与编译期多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">隐式接口与显式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-19"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">条款42：了解typename的双重意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class-and-typename-%E5%A3%B0%E6%98%8E"><span class="toc-text">class and typename 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typename%E7%9A%84%E5%8F%A6%E4%B8%80%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">typename的另一重意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-20"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43-%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款43 ：学习处理模板化基类内的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-21"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE44%EF%BC%9A%E5%B0%86%E4%BA%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates"><span class="toc-text">条款44：将于参数无关的代码抽离templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-22"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0template%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%AE%B9%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">条款45：使用成员函数template接受所有可以兼容的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%8C%87%E9%92%88-raw-pointer"><span class="toc-text">真实指针(raw pointer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">自定义智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Templates%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-Generic-Programming"><span class="toc-text">Templates和泛型编程(Generic Programming)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-12"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%98%AF%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款46：需要类型转换是请为模板定义非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9D%A1%E6%AC%BE24%E7%9A%84%E4%BE%8B%E5%AD%90%E8%BD%AC%E4%B8%BA%E6%A8%A1%E6%9D%BF"><span class="toc-text">示例：条款24的例子转为模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#friend%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">friend函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9C%AC%E4%BD%93%E4%B8%8E%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%93%E5%90%88-%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-text">函数本体与声明式结合(简单版)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#friend%E7%89%B9%E6%AE%8A%E6%84%8F%E4%B9%89"><span class="toc-text">friend特殊意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-member%E4%B8%8Efriend-member%E5%90%88%E4%BD%9C"><span class="toc-text">non-member与friend member合作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-23"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/" title="Mit6.S081:lab mmap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251415687.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mit6.S081:lab mmap"/></a><div class="content"><a class="title" href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/" title="Mit6.S081:lab mmap">Mit6.S081:lab mmap</a><time datetime="2023-07-25T16:00:00.000Z" title="发表于 2023-07-26 00:00:00">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/" title="Mit6.S081:lab fs"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img40.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mit6.S081:lab fs"/></a><div class="content"><a class="title" href="/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/" title="Mit6.S081:lab fs">Mit6.S081:lab fs</a><time datetime="2023-07-16T16:00:00.000Z" title="发表于 2023-07-17 00:00:00">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/" title="Mit6.S081:lab locks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mit6.S081:lab locks"/></a><div class="content"><a class="title" href="/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/" title="Mit6.S081:lab locks">Mit6.S081:lab locks</a><time datetime="2023-06-25T16:00:00.000Z" title="发表于 2023-06-26 00:00:00">2023-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/" title="Mit6.S081:lab net"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mit6.S081:lab net"/></a><div class="content"><a class="title" href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/" title="Mit6.S081:lab net">Mit6.S081:lab net</a><time datetime="2023-06-14T16:00:00.000Z" title="发表于 2023-06-15 00:00:00">2023-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%205%EF%BC%9A%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" title="xv6：中断与设备驱动"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251417569.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xv6：中断与设备驱动"/></a><div class="content"><a class="title" href="/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%205%EF%BC%9A%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" title="xv6：中断与设备驱动">xv6：中断与设备驱动</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Ember🍐</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20232016" target="_blank">萌ICP备20232016号</a> <p>There is only one heroism in the world to see the world as it is and to love it<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.14.3/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.49.0/instantsearch.production.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Lea321/cdn/js/algolia.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.ember-l.top',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
        setTimeout(function(){
          let tk_comment = document.querySelectorAll('.tk-comments-container .tk-comment')
          if (tk_comment.length > 0) {
            let html = `<div class="swiper-wrapper">`
            for (let i = 0; i < tk_comment.length; i++) {
              let tk_id = tk_comment[i].getAttribute('id') || ''
              let tk_nick = tk_comment[i].querySelector('.tk-nick')?.innerText || ''
              let tk_href = tk_comment[i].querySelector('.tk-nick')?.href || ''
              let tk_avatar = tk_comment[i].querySelector('.tk-avatar-img')?.src || ''
              let tk_time = tk_comment[i].querySelector('.tk-time')?.innerText || ''
              let tk_city = tk_comment[i].querySelector('.tk-extras .tk-extra:first-child span:last-child')?.innerText || ''
              let tk_content = tk_comment[i].querySelector('.tk-content>span:last-child')?.innerHTML || ''
              tk_content = tk_content.replace(/\n/g, '') // replace \n
              tk_content = tk_content.replace(/<blockquote>.*?<\/blockquote>/gi, '') // replace blockquote
              tk_content = tk_content.replace(/<pre.*?<\/pre>/gi, '[代码]') // replace code
              html += `
                <div class="swiper-slide">
                  <div class="comment-barrage-item">
                    <div class="barrage-info">
                      <a class="barrage-title" title="跳转至评论区" href="#post-comment">热评</a>
                      <a href="${tk_href ? tk_href + '" target="_blank" rel="noopener noreferrer" title="访问 '+ tk_nick +'"' : 'javascript:void(0);"'}>
                        <img class="barrage-avatar" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="${tk_avatar}">
                      </a>
                      <span class="barrage-nick">${tk_nick}</span>
                      <span class="barrage-city">${tk_city}</span>
                      <span class="barrage-time">${tk_time}</span>
                      <a class="barrage-close" onclick="eurkon.switchCommentBarrage()" title="隐藏热评"><i class="fa-solid fa-xmark"></i></a>
                    </div>
                    <div class="barrage-content">
                      <a title="跳转至该评论" href="#${tk_id}">${tk_content}</a>
                    </div>
                  </div>
                </div>`
            }
            html += '</div>'
            let barrageContainer = document.getElementById('comment-barrage') || document.createElement('div')
            barrageContainer.id = 'comment-barrage'
            barrageContainer.innerHTML = html
            barrageContainer.style.display = window.localStorage.getItem('commentBarrageDisplay') === 'false' ? 'none' : 'block'
            document.getElementById('post-comment').appendChild(barrageContainer)
            var barrageSwiper = new Swiper('#comment-barrage', {
              direction: 'vertical',
              loop: true,
              mousewheel: true,
              autoplay: {
                delay: 3000,
                disableOnInteraction: true,
              }
            })
            barrageContainer.onmouseenter = function () {
              barrageSwiper.autoplay.stop()
            };
            barrageContainer.onmouseleave = function () {
              barrageSwiper.autoplay.start()
            };
          }
        }, 1000)
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.ember-l.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/share.js"></script><script src="/js/key.js"></script><script src="/js/barrage.js"></script><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="//at.alicdn.com/t/c/font_3864328_90xjkz8cfrn.js"></script><script async src="/js/fps.js"></script><script src="/js/nav.js" async></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script src="/js/charts.js" async></script><script defer data-pjax src="/js/beautify.js"></script><script src="/js/twikoo_beautify.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script> LA.init({id:"Jx18u1PbLX8sXMaz",ck:"Jx18u1PbLX8sXMaz"})</script><script>new LingQue.Monitor().init({id:"Jx18u1PbLX8sXMaz",sendSuspicious:true});</script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/MIT6-824/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 阿梨の分布式系统学习 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 阿梨のC++学习 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 阿梨の操作系统学习 (15)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ember-l.top/categories/Tool/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 阿梨の常用工具 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.ember-l.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #fed558}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img40.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt="">Mit6.S081:lab fs</a><div class="blog-slider__text">MIT：lab9</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/07/17/操作系统/lab/Lab9：fs/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251415687.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt="">Mit6.S081:lab mmap</a><div class="blog-slider__text">MIT：lab4</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/07/26/操作系统/lab/Lab10：mmap/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 1：操作系统接口/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251415687.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 1：操作系统接口/&quot;);" href="javascript:void(0);" alt="">xv6：操作系统接口</a><div class="blog-slider__text">MIT：xv6 chapter1</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 1：操作系统接口/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/202301251417569.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt="">FaRM</a><div class="blog-slider__text">No compromises:distributed transactions with consistency, availability, and performance</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/FaRM论文笔记/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 2：操作系统组成/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 2：操作系统组成/&quot;);" href="javascript:void(0);" alt="">xv6：操作系统组成</a><div class="blog-slider__text">MIT：xv6 chapter2</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 2：操作系统组成/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img31.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt="">Lab4:Shards KV Service(未完善)</a><div class="blog-slider__text">MIT6.824 lab4实现# 描述</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Sharded KV Service/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/C++/Effective C++/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img32.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/C++/Effective C++/&quot;);" href="javascript:void(0);" alt="">Effect C++笔记</a><div class="blog-slider__text">Effective C++ 的部分学习笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/C++/Effective C++/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/Spanner论文笔记/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img30.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/Spanner论文笔记/&quot;);" href="javascript:void(0);" alt="">Spanner</a><div class="blog-slider__text">No compromises:distributed transactions with consistency, availability, and performance</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/20/分布式系统/Spanner论文笔记/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt="">Lab:KVRaft</a><div class="blog-slider__text">MIT6.824 lab3实现# 描述</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/13/分布式系统/实验/KVRaft/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt="">xv6：页表</a><div class="blog-slider__text">MIT：xv6 chapter3</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/操作系统/Chapter 3：页表/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img25.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt="">Debugging by Pretty Printing</a><div class="blog-slider__text">Lab2：Raft美化调试工具配置方法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/03/14/分布式系统/实验/Debug/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '700ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>