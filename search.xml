<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NVim配置</title>
      <link href="/2023/03/14/Nvim/"/>
      <url>/2023/03/14/Nvim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>实验环境：</strong> VMware+Ubuntu20.4，配置参考</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu下安装neovim</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install neovim</span><br></pre></td></tr></table></figure><p>Python依赖安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-neovim</span><br></pre></td></tr></table></figure><h1 id="安装终端字体"><a href="#安装终端字体" class="headerlink" title="安装终端字体"></a>安装终端字体</h1><ol><li><p>进入<a href="www.nerdfonts.com">nerdfonts</a>,选择自己想要的字体，我选择的字体是Hack Nerd Font</p></li><li><p>解压字体，到用户字体文件夹中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip Hack -d /usr/share/fonts/Hack</span><br></pre></td></tr></table></figure></li><li><p>使用命令安装字体</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/fonts/Hack</span><br><span class="line">sudo mkfontscale <span class="comment"># 生成核心字体信息</span></span><br><span class="line">sudo mkfontdir <span class="comment"># 生成字体文件夹</span></span><br><span class="line">sudo fc-cache -fv <span class="comment"># 刷新系统字体缓存</span></span><br></pre></td></tr></table></figure></li><li><p>在terminal中修改字体<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/p2.png" alt=""></p></li></ol><h1 id="配置nvim"><a href="#配置nvim" class="headerlink" title="配置nvim"></a>配置nvim</h1><blockquote><p><strong>文件目录树</strong></p></blockquote><ul><li>core目录：放置一些常用键的映射(options.lua)文件，nvim一些选项的修改(缩进长度等)</li><li>plugins目录：一些插件的lua文件配置</li><li>plugin目录：插件包</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/p1.png" alt=""></p><h2 id="初始化nvim文件"><a href="#初始化nvim文件" class="headerlink" title="初始化nvim文件"></a>初始化nvim文件</h2><p>在<code>~/.config/nvim</code>文件目录下新建一个文件<code>init.lua</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> init.lua</span><br><span class="line">nvim init.lua</span><br></pre></td></tr></table></figure><p>文件的内容如下：core.options指向的是./lua/core/options.lua文件内容</p><blockquote><p>lua语法还是相对vim配置语法是比较简单的，<code>--</code>表示注释</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--核心配置</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core.options&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core.keymaps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.plugins-setup&quot;</span>)<span class="comment">--插件安装管理插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.nvim-tree&quot;</span>)<span class="comment">--目录树插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.lualine&quot;</span>)<span class="comment">--状态栏</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.treesitter&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.lsp&quot;</span>)<span class="comment">--代码</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.cmp&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.autopairs&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.Comment&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.gitsigns&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.bufferline&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.telescope&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="核心文件"><a href="#核心文件" class="headerlink" title="核心文件"></a>核心文件</h2><h3 id="option-lua"><a href="#option-lua" class="headerlink" title="option.lua"></a>option.lua</h3><p>新建文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lua</span><br><span class="line"><span class="built_in">mkdir</span> lua/core</span><br><span class="line"><span class="built_in">touch</span> lua/core/options.lua</span><br></pre></td></tr></table></figure><ul><li>local opt声明局部变量</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行号</span></span><br><span class="line">opt.relativenumber = <span class="literal">true</span></span><br><span class="line">opt.number = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 缩进</span></span><br><span class="line">opt.tabstop = <span class="number">2</span></span><br><span class="line">opt.shiftwidth = <span class="number">2</span></span><br><span class="line">opt.expandtab = <span class="literal">true</span></span><br><span class="line">opt.autoindent = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 防止包裹</span></span><br><span class="line">opt.<span class="built_in">wrap</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 光标行</span></span><br><span class="line">opt.cursorline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用鼠标</span></span><br><span class="line">opt.mouse:append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统剪贴板</span></span><br><span class="line"><span class="comment">--opt.clipboard:append(&quot;unnamedplus&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 默认新窗口右和下</span></span><br><span class="line">opt.splitright = <span class="literal">true</span></span><br><span class="line">opt.splitbelow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索</span></span><br><span class="line">opt.ignorecase = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外观</span></span><br><span class="line">opt.termguicolors = <span class="literal">true</span></span><br><span class="line">opt.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line">vim.cmd<span class="string">[[colorscheme tokyonight]]</span><span class="comment">--选择对应的主题</span></span><br></pre></td></tr></table></figure><h3 id="keymaps-lua"><a href="#keymaps-lua" class="headerlink" title="keymaps.lua~~~~"></a>keymaps.lua~~~~</h3><p>新建文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> lua/core/keymap.lua</span><br></pre></td></tr></table></figure><p>文件内容：</p><p>像配置vim的按键配置一样，我们先要设置一个主键，将主键设置为空格。</p><p>键映射的设置：keymap.set(“模式”,”修改后的键”,”修改前的键”)</p><blockquote><p>建议是不要设置太多的键，否则会导致键位冲突以及难以记住，</p></blockquote><p>键位介绍</p><ul><li><p><code>&lt;CR&gt;</code>表示换行</p></li><li><p><code>&lt;leader&gt;</code>表示主键</p></li><li><p><code>&lt;C+w&gt;</code>表示ctrl+一个w键，若w是大写，则是ctrl+shift+w</p></li><li><p>插入模式退出：ESE-&gt;jk(连续点击)</p></li><li><p>可视模式多行移动：选中多行shift+j向上移动，shift+k向下移动</p></li></ul><p>正常模式：</p><ul><li><p>添加窗口：空格(主键)+sv分割右半区窗口，空格+sh分割下半区窗口</p></li><li><p>取消搜索高亮：空格+nh</p></li><li><p>切换标签栏(buffer)：空格+l向左切换，空格+l向右切换</p></li><li><p>打开目录树：空格+e，打开文件目录</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim.g.mapleader = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">local</span> keymap = vim.keymap</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 插入模式 ---------- ---</span></span><br><span class="line">keymap.set(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;jk&quot;</span>, <span class="string">&quot;&lt;ESC&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 视觉模式 ---------- ---</span></span><br><span class="line"><span class="comment">-- 单行或多行移动</span></span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;:m &#x27;&gt;+1&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;:m &#x27;&lt;-2&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 正常模式 ---------- ---</span></span><br><span class="line"><span class="comment">-- 窗口</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sv&quot;</span>, <span class="string">&quot;&lt;C-w&gt;v&quot;</span>) <span class="comment">-- 水平新增窗口 </span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sh&quot;</span>, <span class="string">&quot;&lt;C-w&gt;s&quot;</span>) <span class="comment">-- 垂直新增窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消高亮</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;nh&quot;</span>, <span class="string">&quot;:nohl&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换buffer</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;l&quot;</span>, <span class="string">&quot;:bnext&lt;CR&gt;&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;r&quot;</span>, <span class="string">&quot;:bprevious&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 插件 ---------- ---</span></span><br><span class="line"><span class="comment">-- nvim-tree</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;:NvimTreeToggle&lt;CR&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="plugins-setup-lua：自动安装插件管理文件"><a href="#plugins-setup-lua：自动安装插件管理文件" class="headerlink" title="plugins-setup.lua：自动安装插件管理文件"></a>plugins-setup.lua：自动安装插件管理文件</h3><p>新建文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lua/plugins</span><br><span class="line"><span class="built_in">touch</span> lua/plugins/plugin-set.lua</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自动安装packer</span></span><br><span class="line"><span class="keyword">local</span> ensure_packer = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> fn = vim.fn</span><br><span class="line">  <span class="keyword">local</span> install_path = fn.stdpath(<span class="string">&#x27;data&#x27;</span>)..<span class="string">&#x27;/site/pack/packer/start/packer.nvim&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> fn.empty(fn.glob(install_path)) &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    fn.system(&#123;<span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--depth&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;https://github.com/wbthomason/packer.nvim&#x27;</span>, install_path&#125;)</span><br><span class="line">    vim.cmd <span class="string">[[packadd packer.nvim]]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> packer_bootstrap = ensure_packer()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存此文件自动更新安装软件</span></span><br><span class="line"><span class="comment">-- 注意PackerCompile改成了PackerSync</span></span><br><span class="line"><span class="comment">-- plugins.lua改成了plugins-setup.lua，适应本地文件名字</span></span><br><span class="line">vim.cmd(<span class="string">[[</span></span><br><span class="line"><span class="string">  augroup packer_user_config</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd BufWritePost plugins-setup.lua source &lt;afile&gt; | PackerSync</span></span><br><span class="line"><span class="string">  augroup end</span></span><br><span class="line"><span class="string">]]</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;packer&#x27;</span>).startup(<span class="function"><span class="keyword">function</span><span class="params">(use)</span></span></span><br><span class="line">  use <span class="string">&#x27;wbthomason/packer.nvim&#x27;</span></span><br><span class="line">  use <span class="string">&#x27;folke/tokyonight.nvim&#x27;</span> <span class="comment">-- 主题</span></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-lualine/lualine.nvim&#x27;</span>,  <span class="comment">-- 状态栏</span></span><br><span class="line">    requires = &#123; <span class="string">&#x27;kyazdani42/nvim-web-devicons&#x27;</span>, opt = <span class="literal">true</span> &#125;  <span class="comment">-- 状态栏图标</span></span><br><span class="line">  &#125;</span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-tree/nvim-tree.lua&#x27;</span>,  <span class="comment">-- 文档树</span></span><br><span class="line">    requires = &#123;</span><br><span class="line">      <span class="string">&#x27;nvim-tree/nvim-web-devicons&#x27;</span>, <span class="comment">-- 文档树图标</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  use <span class="string">&quot;christoomey/vim-tmux-navigator&quot;</span> <span class="comment">-- 用ctl-hjkl来定位窗口</span></span><br><span class="line">  use <span class="string">&quot;nvim-treesitter/nvim-treesitter&quot;</span> <span class="comment">-- 语法高亮</span></span><br><span class="line">  use <span class="string">&quot;p00f/nvim-ts-rainbow&quot;</span> <span class="comment">-- 配合treesitter，不同括号颜色区分</span></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&quot;williamboman/mason.nvim&quot;</span>,</span><br><span class="line">    <span class="string">&quot;williamboman/mason-lspconfig.nvim&quot;</span>,  <span class="comment">-- 这个相当于mason.nvim和lspconfig的桥梁</span></span><br><span class="line">    <span class="string">&quot;neovim/nvim-lspconfig&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">-- 自动补全</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/nvim-cmp&quot;</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/cmp-nvim-lsp&quot;</span></span><br><span class="line">  use <span class="string">&quot;L3MON4D3/LuaSnip&quot;</span> <span class="comment">-- snippets引擎，不装这个自动补全会出问题</span></span><br><span class="line">  use <span class="string">&quot;saadparwaiz1/cmp_luasnip&quot;</span></span><br><span class="line">  use <span class="string">&quot;rafamadriz/friendly-snippets&quot;</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/cmp-path&quot;</span> <span class="comment">-- 文件路径</span></span><br><span class="line"></span><br><span class="line">  use <span class="string">&quot;numToStr/Comment.nvim&quot;</span> <span class="comment">-- gcc和gc注释</span></span><br><span class="line">  use <span class="string">&quot;windwp/nvim-autopairs&quot;</span> <span class="comment">-- 自动补全括号</span></span><br><span class="line"></span><br><span class="line">  use <span class="string">&quot;akinsho/bufferline.nvim&quot;</span> <span class="comment">-- buffer分割线</span></span><br><span class="line">  use <span class="string">&quot;lewis6991/gitsigns.nvim&quot;</span> <span class="comment">-- 左则git提示</span></span><br><span class="line"></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-telescope/telescope.nvim&#x27;</span>, tag = <span class="string">&#x27;0.1.1&#x27;</span>,  <span class="comment">-- 文件检索</span></span><br><span class="line">    requires = &#123; &#123;<span class="string">&#x27;nvim-lua/plenary.nvim&#x27;</span>&#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> packer_bootstrap <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;packer&#x27;</span>).sync()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1Td4y1578E/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c265abadb6d61a5e86273ce8c3af5dc6">【全程讲解】Neovim从零配置成属于你的个人编辑器_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> NVim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab4:Shards KV Service</title>
      <link href="/2023/03/14/Sharded%20KV%20Service/"/>
      <url>/2023/03/14/Sharded%20KV%20Service/</url>
      
        <content type="html"><![CDATA[<div class="tip warning faa-parent animated-hover"><p><p class="faa-horizontal">这个实验由于时间关系PartB部分只完成了一点，但是我后续还是会更新的，读者可以不介意的话可以观看</p></div>  <div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div> <h1 id="Shards实验简述"><a href="#Shards实验简述" class="headerlink" title="Shards实验简述"></a>Shards实验简述</h1><h2 id="为何需要Shards？"><a href="#为何需要Shards？" class="headerlink" title="为何需要Shards？"></a>为何需要Shards？</h2><blockquote><p>Shard设计的目的简单来说就是为了并行性(parallel)、多个区域能够有Shards的副本能够加快访问就是是locally</p></blockquote><p>在分布式的事务处理中数据通常情况不会放置到一个副本中，一个事务中通常情况下会包含许多的key分布在不同的副本中，为了保证分区的容错性副本也被设计为一个raft组，这样每个副本中的数据(数据库)就是一个Shard，如何操作这样一个事务具体实现也是和[[Spanner 论文笔记]]中的描述相同。</p><h2 id="Sharded-KV-Service的组成"><a href="#Sharded-KV-Service的组成" class="headerlink" title="Sharded KV Service的组成"></a>Sharded KV Service的组成</h2><ul><li><strong>a set of replica groups：</strong> 每一个replica Group作为一个副本是Shards的子集，一个副本由一些服务器组成，这些服务器使用Raft来复制组间的Shards。</li><li><strong>shard controller：</strong> shard controller是知道那个Raft Group含有客户请求的键，这些信息叫做Cofiguration，Cofiguration会随着时间进行改变。Client会向Shard controller询问那个replica Group有这个特定的键,replica Group为了查明那个Shards应该用于服务也会询问Shard Controller。为了实现容错shard Controller任然是一个Raft Group。</li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><blockquote><p>本次实验主要挑战是处理Reconfiguration的问题——组间分片分配的改变</p></blockquote><p>在单一给应该replica Group中，所有的Group members必须同意当一个reconfiguration发生在与Client有关的Put/Append/Get操作。Put可能与reconfigurantion同时到达，reconfigurantion会导致复制组停止对持有Put的key的Shard负责。组中的所有副本必须在Put发生在reconfigurantion之前还是之后达成一致。</p><p>reconfigurantion还需要副本组之间的交互。例如，在configuration10中，组G1可能负责分片S1。在configuration11中，组G2可能负责分片S1。在10到11的reconfigurantion过程中，G1和G2必须使用RPC将分片S1的内容(键/值对)从G1移动到G2。</p><p>本次实验的通用架构(一个配置服务和一组副本组)遵循与Flat Datacenter Storage、BigTable、Spanner、FAWN、Apache HBase、Rosebud、Spinnaker和许多其他相同的通用模式。然而，这些系统在许多细节上与这个lab不同，而且通常也更复杂和更有能力。</p><h1 id="Part-A-The-Shard-controller"><a href="#Part-A-The-Shard-controller" class="headerlink" title="Part A: The Shard controller"></a>Part A: The Shard controller</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>Shardctrler管理着一个序列的cofiguration，每个configuration描述着一个组的replica Group和分配给replica的分片。每当这个分配需要改变时，Shardctrler就会用新的recofiguration一个新的configuration。K/V客户端和服务器在想要知道当前(或过去)配置时联系shardctrler。</p><p>该实验也是一个像[[KVRaft]]一样的设计，需要检测冗余的设置</p><blockquote><p>HINTS: Go maps are references. If you assign one variable of type map to another, both variables refer to the same map. Thus if you want to create a new Config based on a previous one, you need to create a new map object (with make()) and copy the keys and values individually.</p></blockquote><p>本次Part A最重要的是<strong>实现分片的移动</strong>的问题(建议是自己独立实现)，对于新添加group与删除group都应该做出对应的处理，其余的设计与lab3的设计相似，需要在applier中进行判断操作的类型并做出相应的处理。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>Configuration的参数是每个config的id、Shards一个整数数组存放GID、一个map Group ID对应的servers名称列表。我们将会根据Shards中的GID来分配，意思也是这个Shard最多由10replica Group来分配。例如有3个Group为1,2,3我们就需要将10个shards均匀的分配给这三个group可以是 {1,1,1,2,2,2,3,3,3,3}、 {1,1,1,2,2,2,2,3,3,3}、{1,1,1,1,2,2,2,3,3,3}这三种情况来是Shards的服务达到负载均衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NShards = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">    Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">    Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RPC完善"><a href="#RPC完善" class="headerlink" title="RPC完善"></a>RPC完善</h2><p>Part A我们需要去完成Join、Leave、Move和Query等RPC，这些RPC都是用于允许管理员(Client)去控制Shard controller：添加replica Group、删除replica Group、在replica Group间移动shards(RPC的参数也是在comm.go中进行添加)</p><h3 id="Join-RPC"><a href="#Join-RPC" class="headerlink" title="Join RPC"></a>Join RPC</h3><p>管理者使用这个RPC去添加新的replica group，实参是mappings从唯一的，非零的replica group的标识符(GID)到服务器的名称列表的集合。当包含了新的replica group的时候shardctrler应该<strong>更新</strong>configuration，新的configuration应该在完整的组集中尽可能均匀地分配碎片，并且应该尽<strong>可能少地move shards</strong>以实现该目标。shardctrler应该允许重用GID，只要GID不是当前configuration的一部分.</p><h4 id="Join分片策略"><a href="#Join分片策略" class="headerlink" title="Join分片策略"></a>Join分片策略</h4><p>在设计上我们需要尽<strong>可能少的去移动</strong>分片以达到分片的服务的负载平衡，如我们在{1,1,1,1,1,2,2,2,2,2} ，G1与G2各有五个分片，此时我们添加有个G3，则我们需要重新分配一下每个组的分片，最大组与最小组的分片个数差不应该大于1，分配应该时G1:4，G2:3，G3:3 这样此时我们需要从G1中分配一个分片给G3，G2中分配两分片给G3，这样便可以到达负载均衡，结果为{1,1,1,1,3,2,2,2,3,3}</p><blockquote><p><strong>NOTE</strong>:在go语言中map的遍历是无序的，因此为了保持整个leader与follower的shards的分配是一致，需要将每个从map遍历中获取的gids进行一次排序</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> MoveShards_Join(new_gids []<span class="type">int</span>, add_gids []<span class="type">int</span>, Shards [NShards]<span class="type">int</span>) [NShards]<span class="type">int</span> &#123;</span><br><span class="line">    Assign_shards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>) <span class="comment">//gid-&gt;  the num of assigning shards</span></span><br><span class="line">    Gshards := <span class="built_in">len</span>(Shards) / <span class="built_in">len</span>(new_gids)</span><br><span class="line">    Remain_shards := <span class="built_in">len</span>(Shards) % <span class="built_in">len</span>(new_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign shards to group</span></span><br><span class="line">    <span class="comment">//均匀分配给现存的groups</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> new_gids &#123;</span><br><span class="line">        <span class="keyword">if</span> Remain_shards != <span class="number">0</span> &#123;</span><br><span class="line">            Remain_shards--</span><br><span class="line">            Assign_shards[g] = Gshards + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Assign_shards[g] = Gshards</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move_gid_i := <span class="number">0</span>                  <span class="comment">//the index of add_gids</span></span><br><span class="line">    move_gid := add_gids[move_gid_i] <span class="comment">//assign the shard to add_id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, gid := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">if</span> Assign_shards[gid] != <span class="number">0</span> &#123;</span><br><span class="line">            Assign_shards[gid]--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当执行多个move操作后导致shard的负载不均衡</span></span><br><span class="line">            <span class="comment">//因此需要使用改方法来调节</span></span><br><span class="line">            <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(add_gids) &lt;= move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> id, shards := <span class="keyword">range</span> Assign_shards &#123;</span><br><span class="line">                    <span class="keyword">if</span> shards &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> is_exist <span class="type">bool</span></span><br><span class="line">                        <span class="keyword">for</span> m_i := i; m_i &lt; <span class="built_in">len</span>(Shards); m_i++ &#123;</span><br><span class="line">                            <span class="keyword">if</span> Shards[m_i] == id &#123;</span><br><span class="line">                                is_exist = <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> !is_exist &#123;</span><br><span class="line">                            move_gid = id</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move shards</span></span><br><span class="line">            Shards[i] = move_gid</span><br><span class="line">            Assign_shards[move_gid]--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更换需要添加分片的组</span></span><br><span class="line">        <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(add_gids) &gt; move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">            move_gid_i++</span><br><span class="line">            move_gid = add_gids[move_gid_i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Shards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个参数的意思</p><ol><li><p><strong>new_gid：</strong> join后的分组，组号数组</p></li><li><p><strong>add_gid：</strong> join加入的分组，可能是多个组，后续用于修改shards对应索引的gid</p></li><li><p><strong>Assign_shards：</strong> 一个map用于组号与分片数量的映射，<code>[Gid]shards</code></p></li><li><p><strong>Gshards：</strong> 每个组应该获得的“商”分片，也就是<code>总分片/组数</code></p></li><li><p><strong>Remain_shards：</strong>  <code>总分片%组数</code> 获得的余数，用于均匀的分配分片</p></li></ol><h3 id="Leave-RPC"><a href="#Leave-RPC" class="headerlink" title="Leave RPC"></a>Leave RPC</h3><p>参数是先前加入组的gid列表。shardctrler创建一个不包括这些组的新configuration，并将这些组的碎片分配给其余组。新的配置应该在组中尽可能均匀地分配碎片，并且应该尽可能少地移动碎片以实现该目标。</p><h4 id="Leave分片策略"><a href="#Leave分片策略" class="headerlink" title="Leave分片策略"></a>Leave分片策略</h4><p>其原理与Join的相关参数相同，都是要尽可能通过少的去移动分片到达平衡。例如{1,1,1,4,2,2,2,3,3,4}分片的策略，此时我们需要移除G1这个组，则我们应该将G1的分片分配给G2,G3,G4。结果为{2,3,4,4,2,2,2,3,3,4}.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> MoveShards_Leave(new_gids []<span class="type">int</span>, leave_gids []<span class="type">int</span>, Shards [NShards]<span class="type">int</span>) [NShards]<span class="type">int</span> &#123;</span><br><span class="line">    Assign_shards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>) <span class="comment">//gid-&gt;  the num of assigning shards</span></span><br><span class="line">    Gshards := <span class="built_in">len</span>(Shards) / <span class="built_in">len</span>(new_gids)</span><br><span class="line">    Remain_shards := <span class="built_in">len</span>(Shards) % <span class="built_in">len</span>(new_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign shards to group</span></span><br><span class="line">    <span class="comment">//均匀分配分片给现存的group</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> new_gids &#123;</span><br><span class="line">        <span class="keyword">if</span> Remain_shards != <span class="number">0</span> &#123;</span><br><span class="line">            Remain_shards--</span><br><span class="line">            Assign_shards[g] = Gshards + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Assign_shards[g] = Gshards</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提取出需要添加分片的Gid</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">if</span> Assign_shards[g] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            Assign_shards[g]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得需要移动分片的gid的数组</span></span><br><span class="line">    <span class="keyword">var</span> move_gids []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> Assign_shards &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            move_gids = <span class="built_in">append</span>(move_gids, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要移动分片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(move_gids) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Shards</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map是无序遍历，对move_gids重新排序</span></span><br><span class="line">    sort.Ints(move_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//load re-balance</span></span><br><span class="line">    move_gid_i := <span class="number">0</span>                   <span class="comment">//the index of add_gids</span></span><br><span class="line">    move_gid := move_gids[move_gid_i] <span class="comment">//assign the shard to newGroups(gid)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将leave_group的分片给剩余的groups</span></span><br><span class="line">    <span class="keyword">for</span> i, g := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">for</span> _, lg := <span class="keyword">range</span> leave_gids &#123;</span><br><span class="line">            <span class="keyword">if</span> g == lg &#123;<span class="comment">//shards索引对应的id是需要移除的组号</span></span><br><span class="line">                <span class="keyword">if</span> Assign_shards[move_gid] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    Shards[i] = move_gid</span><br><span class="line">                    Assign_shards[move_gid]--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟换需要添加分片的组号</span></span><br><span class="line">        <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(move_gids) &gt; move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">            move_gid_i++</span><br><span class="line">            move_gid = move_gids[move_gid_i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Shards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Move-RPC"><a href="#Move-RPC" class="headerlink" title="Move RPC"></a>Move RPC</h4><p>参数是一个shard号和一个GID。shardctrler应该创建一个新的配置，其中将分片分配给组。Move的目的是让我们能够测试我们的软件。Move后的join或leave可能会取消Move，因为join和leave重新平衡。(也就是将相应的Shard位置的Server改为Move的参数)(逻辑十分简单，可以自行完成)</p><h4 id="Query-RPC"><a href="#Query-RPC" class="headerlink" title="Query RPC"></a>Query RPC</h4><p>RPC的参数是一个configuration号。shardctrler回复具有该编号的configuration。如果该编号为-1或大于已知的最大配置编号，则shardctrler应返回最新配置。Query(-1)的结果应该反映shardctrler在接收到Query(-1) RPC之前完成处理的每个Join、Leave或Move RPC。(逻辑十分简单，可以自行完成)</p><h1 id="Part-B：Sharded-Key-Value-Server"><a href="#Part-B：Sharded-Key-Value-Server" class="headerlink" title="Part B：Sharded Key/Value Server"></a>Part B：Sharded Key/Value Server</h1><h2 id="实验概述-1"><a href="#实验概述-1" class="headerlink" title="实验概述"></a>实验概述</h2><p>PartB的实验简单来说就是Shards + KVServer，也就是我们有多台KVServer作为数据库的分片存储，因此我们可以将lab3中的代码迁移到lab4中,值得注意的是shardctrler(PartA)与本环节的搭配。</p><blockquote><p>组成成分：</p></blockquote><ul><li><p><strong>Client：</strong> 提供接口向ctrler与raft group进行通讯，如一个应用一样</p></li><li><p><strong>shardctrler：</strong> 一个Raft Group，拥有指定Shard的对应Replica Group的信息</p></li><li><p><strong>Replica Group：</strong> 一个Raft Group，存储了一个KV数据库表示着一个shard </p></li></ul><p>在Client.go中有个接口叫做Key2shard()，通过该函数判断那个分片有我们请求的数据，实现原理简单来说就是根据输入的key进行hash(%10)，得到的余数(也就是Shards中索引)作为返回值。<code>在PartA中我们也知道一个索引在shards数组中对应的是一个Gid</code>。</p><h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><ul><li><p>通过第一个测试点没有配置改变的情形是静态的分片，将KVServer的基础上+shardctrler边可以通过该测试点</p></li><li><p>处理动态配置的情形，同一个Replica Group中的所有server的需要对数据进行迁移，如join操作后，原来只有一个分组G1的Configuration<code>[1,1,1,1,1,1,1,1,1,1]</code>，加入分组G2变为<code>[1,1,1,1,1,2,2,2,2,2]</code> ，因此G1需要检查配置变化并将shard5-shard9的数据迁移到G2。</p></li></ul><p><strong>实验过程交互图：</strong> 以3个Replica Group为例。开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230126210055.png" alt="interact of ShardKV.png"></p><h2 id="实现-概述"><a href="#实现-概述" class="headerlink" title="实现-概述"></a>实现-概述</h2><blockquote><p>Relica Group应该<strong>周期性</strong>(&lt;=100ms)的去轮询shardctrler配置是否发生改变，如果发生改变需要立即去处理迁移问题</p><p>Replica Group之间应该提供RPC，以便能够在发现配置改变后去转移分片(也就是传送KV表)，shardctrler的Config结构体包含服务器名称，需要一个labrpc.ClientEnd去发送RPC。使用传递给StartServer()的make_end()函数将服务器名转换为客户端。</p></blockquote><h3 id="修改Lab3的内存模型"><a href="#修改Lab3的内存模型" class="headerlink" title="修改Lab3的内存模型"></a>修改Lab3的内存模型</h3><ul><li>将KV表转换为多个(NShards=10)Shard便于移动或删除</li><li>添加深拷贝接口，<code>map是一个引用</code></li><li>在申请内存时需要先建立NShards个Shard分片，之后给每个分片申请内存</li><li>添加Migration的Shard处理接口<ul><li><strong>服务端：</strong> Shard_Migration()对请求的分片进行复制</li><li><strong>客户端：</strong> Shard_Get()将服务端请求回来的数据进行同步复制(WAL)到follower并应用</li></ul></li><li>添加分片状态：<ol><li>Pulling:该分片正处理拉取阶段，需要等待拉取成功，Get与PutAppend都需要等待Pulling状态改变</li><li>Empty:该分片为空，GET进行读取时也需要等待，PutAppend操作进行写入时可以不用等待</li><li>Used:分片已被使用，说明该分片是有数据的，可以进行直接进行读写，不需要任何等待</li></ol></li></ul><blockquote><p><strong>注意：</strong> 在lab3的kvserver中我们的snapshot的设计的快照存储需要进行对应的调整</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Pulling = <span class="number">1</span></span><br><span class="line">    Empty   = <span class="number">2</span></span><br><span class="line">    Used    = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShardStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mShards <span class="keyword">map</span>[<span class="type">int</span>]*Shard<span class="comment">//也可以使用数组替代map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shard <span class="keyword">struct</span> &#123;</span><br><span class="line">    KV    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    State ShardState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewShard</span><span class="params">()</span></span> *Shard &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Shard&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>), Empty&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mShard.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mShard.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mShard.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mShard.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mShard.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> Shard_Migrate() (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, Err) &#123;</span><br><span class="line">    KV := mShard.DeepCopy().KV</span><br><span class="line">    mShard.KV = <span class="literal">nil</span></span><br><span class="line">    mShard.KV = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">return</span> KV, OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> Shard_Get(newKV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> newKV &#123;</span><br><span class="line">        mShard.KV[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> DeepCopy() *Shard &#123;</span><br><span class="line">    newShard := NewShard()</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mShard.KV &#123;</span><br><span class="line">        newShard.KV[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newShard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(StateMachine *ShardStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    shard := key2shard(op.Key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = StateMachine.mShards[shard].KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[shard].KV_Append(op.Key, op.Value)</span><br><span class="line">        StateMachine.mShards[shard].State = Used</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[shard].KV_Put(op.Key, op.Value)</span><br><span class="line">        StateMachine.mShards[shard].State = Used</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Migrate&quot;</span>:</span><br><span class="line">        cr.KV, cr.Err = StateMachine.mShards[op.Shard].Shard_Migrate()</span><br><span class="line">        StateMachine.mShards[op.Shard].State = Empty</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SetShard&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[op.Shard].Shard_Get(op.KV)</span><br><span class="line">        StateMachine.mShards[op.Shard].State = Used</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拉取最新的Configuration"><a href="#拉取最新的Configuration" class="headerlink" title="拉取最新的Configuration"></a>拉取最新的Configuration</h3><p>获取配置(poll)像applier的异步设计一样，我们开启一个协程进行周期性(不大于100ms)的获取最新配置，而且在获得到新配置后，通过判断其分片状态与组号进行修改分片的状态</p><blockquote><p><strong>Pulling State：</strong> 在migration中进行拉取对应的shard的操作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> poll() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> iShard := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">            <span class="comment">//cancel old cfg of the Pulling state</span></span><br><span class="line">            <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) == <span class="number">0</span> &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Empty</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Used</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newCfg := kv.mck.Query(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">//check change cfg</span></span><br><span class="line">        <span class="keyword">if</span> kv.Is_CfgChanged(newCfg.Num) &#123;</span><br><span class="line">            <span class="comment">//kv.LastCfg = kv.CurrentCfg</span></span><br><span class="line">            <span class="keyword">if</span> _, isleader := kv.rf.GetState(); isleader &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;G%v&#123;S%v&#125; poll Config change Cfg.Shards:%v CfgNum %d&quot;</span>,</span><br><span class="line">                    kv.gid, kv.me, newCfg.Shards, newCfg.Num)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.CurrentCfg = newCfg</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//convert shard state to pull</span></span><br><span class="line">        <span class="keyword">for</span> iShard, gid := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Empty &amp;&amp; gid == kv.gid &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Pulling</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        time.Sleep(<span class="number">75</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE：</strong> 需要增加WrongGroup的检测</p></blockquote><h3 id="分片迁移"><a href="#分片迁移" class="headerlink" title="分片迁移"></a>分片迁移</h3><blockquote><p>思考：</p><ol><li>配置改变后，以何种方式进行迁移分片(push or pull)？</li><li>在何种情况判断需要进行转移分片</li><li>如何设计RPC？</li><li>如何处理RPC?</li><li>如何处理RPC的回复(WAL)？</li></ol></blockquote><ol><li><p><strong>迁移分片的方式：</strong> 迁移分片有两种策略Pull与Push，两种方案没有具体的难度区别，我的设计采用的是Pull：</p><ul><li><p><strong>Push：</strong> 当G1的Leader发现配置变化(添加G2)，那么G1的Leader向G2的服务器发送RPC(含有Shard的数据),等待RPC的回复。</p><ul><li><strong>Pull：</strong> 当G2的Leader发现配置变化(添加G2)，那么G2的Leader的Leader向G1发送RPC，获得Shard的数据。</li></ul></li></ul></li><li><p><strong>迁移分片(Pull)条件：</strong> 我们开启一个协程叫做<strong>migration</strong>，通过周期性的观察观察新旧配置和判断shard的状态来判断是否需要进行pull。</p></li></ol><p>如<code>lastCfg=[1,1,1,1,1,1,1,1,1,1](Cfg.Num=1)</code>,<code>currentCfg=[1,1,1,1,1,2,2,2,2,2](Cfg.Num=2)</code>,每个Replica Group的migration的协程中进行处理。那么我们新加入的G2需要shard5-shard9这五个分片的数据，那Leader需要<strong>遍历Cfg.Shards中的gid</strong>，若gid = kv.gid并且判断该分片的状态，为Empty说明需要向target group进行pull分片。</p><blockquote><p>发送MigrationRPC：为了提高效率，采用了goroutine与waitgroup的方式进行并发发送RPC。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> migration() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        <span class="keyword">if</span> _, is_leader := kv.rf.GetState(); is_leader &#123;</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">for</span> iShard := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">                <span class="comment">//current sending pull request</span></span><br><span class="line">                <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                    <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) == <span class="number">0</span> &#123;</span><br><span class="line">                    wg.Add(<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(iShard <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        kv.mu.Lock()</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        kv.CommandId++</span><br><span class="line">                        KV := kv.StartPull(iShard)</span><br><span class="line">                        <span class="comment">//handle the err KV</span></span><br><span class="line">                        kv.ReplicateShard(KV, iShard)</span><br><span class="line">                        kv.mu.Unlock()</span><br><span class="line">                    &#125;(iShard)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>RPC设计：</strong> 我们采用pull的方式，当主机发现了配置改变后，向拥有分片的分组发送请求迁移分片，此时我们的发送RPC的Replica Group是作为<strong>客户端</strong>进行发送请求(意味着需要像lab3的实验中client一样设计ClientId与CommandId)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MigrateArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"> ClientId  <span class="type">int64</span></span><br><span class="line"> CommandId <span class="type">int64</span></span><br><span class="line"> Shard     <span class="type">int</span></span><br><span class="line"> CfgNum    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>type MigrateReply struct {<br>    KV  map[string]string<br>    Err Err<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">4. **处理RPC：**  接收方作为**服务端**接收RPC并发送了Raft层进行同步(**Migration操作不是幂等操作**)引用，因此这个操作的处理需要进行**冗余判断**。</span><br><span class="line">```go</span><br><span class="line">func (kv *ShardKV) Migrate(args *MigrateArgs, reply *MigrateReply) &#123;</span><br><span class="line">    ...//一些错误判断</span><br><span class="line"></span><br><span class="line">    if kv.CurrentCfg.Num &lt; args.CfgNum &#123;</span><br><span class="line">        DPrintf(&quot;G%d&#123;S%d&#125; outdate Cfg %d Args.Cfg %d&quot;, kv.gid, kv.me, kv.CurrentCfg.Num, args.CfgNum)</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if kv.StateMachine.mShards[args.Shard].State == Empty &#123;</span><br><span class="line">        reply.Err = ErrEmpty</span><br><span class="line">        reply.KV = nil</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(&quot;G%v&#123;S%v&#125; receive Migrate(pull) message&quot;, kv.gid, kv.me)</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        ClientId:    args.ClientId,</span><br><span class="line">        CommandId:   args.CommandId,</span><br><span class="line">        Opt:         &quot;Migrate&quot;,</span><br><span class="line">        CfgNum:      args.CfgNum,</span><br><span class="line">        Shard:       args.Shard,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    if !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //handle the channle reply</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>处理RPC回复(Replicat Shard)：</strong> </li></ol><p>我们为什么需要通过调用Raft接口(Start)预写日志(WAL)来实现同步呢？</p><p>在Lab2、3中我们都深刻的体会到了Raft所提供的容错的作用，主要是在Leader服务器崩溃后实现数据的容错(follower的Shard的数据与leader相同)，也能满足<strong>线性一致性</strong>。</p><blockquote><p><strong>NOTE：</strong> 我们在migration()中是开启了锁，在处理RPC的回复(也就是复制Shard)是我们是调用了Start接口，因此我们在Raft层与Server层都有锁，造成死锁问题，需要在调用Start时解锁，并在收到applych的消息后进行加锁</p></blockquote><p>分片迁移交互过程图如下：<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230127004744.png" alt="image.png"></p><ol><li>新加入的组，根据配置向有指定分片的组发送Migration RPC</li><li>服务分片的组，处理MigrationRPC将指定的分片的数据进行深拷贝并删除的日志同步到follower并应用。</li><li>服务分片的组，返回MigrationRPC作为回复</li><li>新加入分组根据RPC的信息，写入日志同步到follower并应用<br>Lab4B实验添加的流程大致就是如前两幅图所示的情形。接着我们还要继续讨论一些细节，例如并发请求的处理、配置丢失等问题。</li></ol><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><h3 id="1-no-op空日志添加"><a href="#1-no-op空日志添加" class="headerlink" title="1.no-op空日志添加"></a>1.no-op空日志添加</h3><blockquote><p>在lab3中，实现了对于Read only query，在其中就使用了no-op的空日志使状态机重演(replay)以提交日志，使状态机的日志达到最新。</p></blockquote><p>在本次实验中我们仍然需要使用no-op去使状态机达到最新，因为对于shard实验，我们需要考虑到shard的状态以及配置号是否匹配的问题，我们需要使状态机的shard恢复到以前的状态，这样才能使Get操作能够正常运行。</p><h3 id="2-target-gid的寻找："><a href="#2-target-gid的寻找：" class="headerlink" title="2.target_gid的寻找："></a>2.target_gid的寻找：</h3><p>我们每次都需要通过查找旧配置与新配置比较，获知哪个组存储了指定分片，获得到一个target_gid后，但是发送MigrationRPC，回复的分片的数据并没有数据。</p><blockquote><p><strong>原因：</strong></p></blockquote><p>实验中PutAppend的操作<strong>间隔短</strong>，poll、migration<strong>周期尚未到达</strong>，导致我们在获取最新配置后跳过了很多的配置，因此我们需要进行一次重新获取target_gid</p><blockquote><p><strong>优化：</strong> </p></blockquote><p>我们同时可以进行优化，RPC发送到Server回复的时间过长，我们需要记录下已经发送的target_gid避免无效的浪费。</p><h3 id="3-MigrationRPC错误回复的处理"><a href="#3-MigrationRPC错误回复的处理" class="headerlink" title="3.MigrationRPC错误回复的处理"></a>3.MigrationRPC错误回复的处理</h3><p>通过target_gid进行pull分片，如果跳过了许多配置导致target_gid，只能返回一个ErrEmpty，此时就需要寻找新的target_gid，进行重新pull</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send Migration RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> SendMigrationRPC(iShard <span class="type">int</span>, Group []<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, si := <span class="keyword">range</span> Group &#123; <span class="comment">//find the leader of target group</span></span><br><span class="line">            <span class="keyword">var</span> reply MigrateReply</span><br><span class="line">            srv := kv.make_end(si)</span><br><span class="line">            ok := srv.Call(<span class="string">&quot;ShardKV.Migrate&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">            <span class="keyword">if</span> !ok || (ok &amp;&amp; (reply.Err == ErrWrongLeader ||</span><br><span class="line">                reply.Err == ErrTimeout)) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> reply.Err == ErrWrongGroup || reply.Err == ErrOutdate ||</span><br><span class="line">                reply.Err == ErrEmpty &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, reply.Err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reply.KV, OK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find targetid to send RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> StartPull(iShard <span class="type">int</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> target_gid <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> Err Err</span><br><span class="line">    CfgNum := kv.CurrentCfg.Num</span><br><span class="line">    term, _ := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="comment">// find target gid to pull shard</span></span><br><span class="line">        target_gid, CfgNum, Groups = kv.GetTargetId(iShard, kv.gid, CfgNum)</span><br><span class="line">        <span class="keyword">if</span> target_gid != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//crecete gid chage shard state</span></span><br><span class="line">            Group := Groups[target_gid]</span><br><span class="line"></span><br><span class="line">            KV, Err = kv.SendMigrationRPC(iShard, Group)</span><br><span class="line">            <span class="comment">//err targetid</span></span><br><span class="line">            <span class="keyword">if</span> Err == ErrEmpty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> Err == ErrOutdate || Err == ErrWrongGroup &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> KV</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-服务端数据不匹配客户端的请求："><a href="#4-服务端数据不匹配客户端的请求：" class="headerlink" title="4.服务端数据不匹配客户端的请求："></a>4.服务端数据不匹配客户端的请求：</h3><p>配置增长过大时有可能会导致客户端向请求服务端的数据回复了一个空数据(违背了线性一致)，主要原因也是客户端请求的组还未Pull到正确的target_gid。</p><blockquote><p>解决方案</p></blockquote><ol><li>当我们发现Shard状态为Pulling时，不能只<strong>回复一个ErrNoKey</strong>。</li></ol><p>当服务端处理<strong>Get</strong>请求发现Shard状态不为Used时</p><ul><li>我们可以让客户端进行重发Get请求</li><li>或者等待一段时间让Shard的数据得到更新(Get是幂等操作是否Apply并不是很重要)</li></ul><p>我的设计是将主处理线程暂停100毫秒，让poll与migrate线程去处理分片。如果还是错误则返回客户端，更新完配置后，重新发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------server.go-------------------*/</span></span><br><span class="line"><span class="keyword">if</span> ishard := key2shard(args.Key); kv.StateMachine.mShards[ishard].State != Used &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> kv.StateMachine.mShards[ishard].State != Used &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">5</span> &#123;</span><br><span class="line">            reply.Err = ErrOutdate</span><br><span class="line">            DPrintf(<span class="string">&quot;G%d Shard[%d] return ErrOutdate To Client&quot;</span>, kv.gid, ishard)</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">        time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------client.go-------------------*/</span></span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrWrongGroup || reply.Err == ErrOutdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> reply.Err == ErrOutdate &#123;</span><br><span class="line">        ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">        args.CfgNum = ck.config.Num</span><br><span class="line">        DPrintf(<span class="string">&quot;resend&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务端处理<strong>PutAppend</strong>请求发现Shard状态为Pulling时</p><ul><li>在请求Start前进行判断Shard是否为Pulling，来决定是否停止下来等待pull和replicate shard操作完成 </li></ul><ol><li>首先在处理Get与PutAppend时，要判断客户端与服务端的<strong>配置是否相同</strong> :如果客户端是过期或是比服务器高的配置请求都会导致读写操作出现问题。写操作会导致分片与组号不匹配，读操作会导致一直读一个错误的分片导致死锁。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> kv.CurrentCfg.Num != args.CfgNum &#123;</span><br><span class="line">    reply.Err = ErrOutdate</span><br><span class="line">    DPrintf(<span class="string">&quot;G%d Cfg is Outdate&quot;</span>, kv.gid)</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> Shards </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debugging by Pretty Printing</title>
      <link href="/2023/03/14/Debug/"/>
      <url>/2023/03/14/Debug/</url>
      
        <content type="html"><![CDATA[<h1 id="Debugging-In-Detributed-System"><a href="#Debugging-In-Detributed-System" class="headerlink" title="Debugging In Detributed System"></a>Debugging In Detributed System</h1><p>Debug官方博客<a href="[Debugging by Pretty Printing (josejg.com">Debugging by Pretty Printing </a>](<a href="https://blog.josejg.com/debugging-pretty/">https://blog.josejg.com/debugging-pretty/</a>))</p><h2 id="Go-Side"><a href="#Go-Side" class="headerlink" title="Go Side"></a>Go Side</h2><p>在文件util.go中进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> raft</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve the verbosity level from an environment variable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getVerbosity</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    v := os.Getenv(<span class="string">&quot;VERBOSE&quot;</span>)</span><br><span class="line">    level := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> v != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        level, err = strconv.Atoi(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;Invalid verbosity %v&quot;</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> logTopic <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dClient  logTopic = <span class="string">&quot;CLNT&quot;</span></span><br><span class="line">    dCommit  logTopic = <span class="string">&quot;CMIT&quot;</span></span><br><span class="line">    dDrop    logTopic = <span class="string">&quot;DROP&quot;</span></span><br><span class="line">    dError   logTopic = <span class="string">&quot;ERRO&quot;</span></span><br><span class="line">    dInfo    logTopic = <span class="string">&quot;INFO&quot;</span></span><br><span class="line">    dLeader  logTopic = <span class="string">&quot;LEAD&quot;</span></span><br><span class="line">    dLog     logTopic = <span class="string">&quot;LOG1&quot;</span></span><br><span class="line">    dLog2    logTopic = <span class="string">&quot;LOG2&quot;</span></span><br><span class="line">    dPersist logTopic = <span class="string">&quot;PERS&quot;</span></span><br><span class="line">    dSnap    logTopic = <span class="string">&quot;SNAP&quot;</span></span><br><span class="line">    dTerm    logTopic = <span class="string">&quot;TERM&quot;</span></span><br><span class="line">    dTest    logTopic = <span class="string">&quot;TEST&quot;</span></span><br><span class="line">    dTimer   logTopic = <span class="string">&quot;TIMR&quot;</span></span><br><span class="line">    dTrace   logTopic = <span class="string">&quot;TRCE&quot;</span></span><br><span class="line">    dVote    logTopic = <span class="string">&quot;VOTE&quot;</span></span><br><span class="line">    dWarn    logTopic = <span class="string">&quot;WARN&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debugStart time.Time</span><br><span class="line"><span class="keyword">var</span> debugVerbosity <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    debugVerbosity = getVerbosity()</span><br><span class="line">    debugStart = time.Now()</span><br><span class="line"></span><br><span class="line">    log.SetFlags(log.Flags() &amp;^ (log.Ldate | log.Ltime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Debug</span><span class="params">(topic logTopic, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> debugVerbosity &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        time := time.Since(debugStart).Microseconds()</span><br><span class="line">        time /= <span class="number">100</span></span><br><span class="line">        prefix := fmt.Sprintf(<span class="string">&quot;%06d %v &quot;</span>, time, <span class="type">string</span>(topic))</span><br><span class="line">        format = prefix + format</span><br><span class="line">        log.Printf(format, a...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Debug方式</p></blockquote><p>在原有的log.Printf处修改为Debug()；注S%d打印当前server号是有必要的，可以在后续dslog的脚本中进行分栏打印</p><p>示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug(dLog, <span class="string">&quot;S%d T:%d -&gt; S%d Sending PLI: %d PLT: %d LC: %d &quot;</span>,</span><br><span class="line">                        rf.me, rf.currentTerm, server, Args.PrevlogIndex, Args.PrevlogTerm,</span><br><span class="line">                        Args.LeaderCommit)</span><br></pre></td></tr></table></figure><blockquote><p>运行方式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERBOSE=1 go <span class="built_in">test</span> -run 2B</span><br></pre></td></tr></table></figure><h2 id="Python-Script"><a href="#Python-Script" class="headerlink" title="Python Script"></a>Python Script</h2><h3 id="将python脚本转为终端命令"><a href="#将python脚本转为终端命令" class="headerlink" title="将python脚本转为终端命令"></a>将python脚本转为终端命令</h3><blockquote><p>本需要加上python3 <em>.py( </em> 可以不用后缀)，将其转为如ls那样的内部终端命令</p></blockquote><p>1.需要的环境,python3解释器</p><p>2.打开终端,输入which python3 复制解释器地址</p><p>3.在你需要执行的python文件最上方加上 #! python解释器地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin python3</span></span><br></pre></td></tr></table></figure><p>4.修改当前需要执行的文件的权限 chmod +x python文件名</p><p>5.复制当前文件到python解释器的bin/文件目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp dtest ~/bin</span><br></pre></td></tr></table></figure><p>6.终端直接输入你的python文件名就可以看到运行结果了</p><blockquote><p>效果如下</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/python%20command.png" alt="command"></p><h3 id="dslog：Prettifying-the-Logs"><a href="#dslog：Prettifying-the-Logs" class="headerlink" title="dslog：Prettifying the Logs"></a>dslog：Prettifying the Logs</h3><p>经过Go side处理后我们的Log仍旧比较杂乱颜色单一，因此使用python脚本进行优化，首先要去在系统环境中装载python <a href="https://github.com/Textualize/rich">rich</a>的美化包</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERBOSE=1 go <span class="built_in">test</span> -run 2B &gt; output.log</span><br></pre></td></tr></table></figure><p>然后打印处output.log</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">008258 LOG2 S2 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008256 VOTE S3 Granting Vote to S1 at T1</span><br><span class="line">008258 VOTE S1 &lt;- S0 Got vote</span><br><span class="line">008258 VOTE S4 Granting Vote to S1 at T1</span><br><span class="line">008259 PERS S4 Saved State T:1 VF:1</span><br><span class="line">008258 PERS S3 Saved State T:1 VF:1</span><br><span class="line">008259 LOG2 S3 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008259 VOTE S1 &lt;- S2 Got vote</span><br><span class="line">008260 LEAD S1 Achieved Majority for T1 (3), converting to Leader</span><br><span class="line">008260 TIMR S1 Broadcast, reseting HBT</span><br><span class="line">008260 LOG1 S1 -&gt; S0 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008260 LOG1 S1 -&gt; S2 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008259 LOG2 S4 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008261 LOG1 S1 -&gt; S3 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008262 LOG1 S1 -&gt; S4 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008262 TIMR S1 Leader, checking heartbeats</span><br><span class="line">008263 TIMR S0 Resetting ELT, received AppEnt T1</span><br><span class="line">008263 TIMR S3 Resetting ELT, received AppEnt T1</span><br><span class="line">008264 TIMR S2 Resetting ELT, received AppEnt T1</span><br><span class="line">008264 LOG2 S2 LOG: (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后将脚本代码写入dslog</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"><span class="keyword">from</span> rich <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">from</span> rich.columns <span class="keyword">import</span> Columns</span><br><span class="line"><span class="keyword">from</span> rich.console <span class="keyword">import</span> Console</span><br><span class="line"><span class="keyword">from</span> rich.traceback <span class="keyword">import</span> install</span><br><span class="line"></span><br><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line"><span class="comment"># Mapping from topics to colors</span></span><br><span class="line">TOPICS = &#123;</span><br><span class="line">    <span class="string">&quot;TIMR&quot;</span>: <span class="string">&quot;#9a9a99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;VOTE&quot;</span>: <span class="string">&quot;#67a0b2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LEAD&quot;</span>: <span class="string">&quot;#d0b343&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TERM&quot;</span>: <span class="string">&quot;#70c43f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LOG1&quot;</span>: <span class="string">&quot;#4878bc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LOG2&quot;</span>: <span class="string">&quot;#398280&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CMIT&quot;</span>: <span class="string">&quot;#98719f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PERS&quot;</span>: <span class="string">&quot;#d08341&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SNAP&quot;</span>: <span class="string">&quot;#FD971F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DROP&quot;</span>: <span class="string">&quot;#ff615c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CLNT&quot;</span>: <span class="string">&quot;#00813c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TEST&quot;</span>: <span class="string">&quot;#fe2c79&quot;</span>,</span><br><span class="line">    <span class="string">&quot;INFO&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WARN&quot;</span>: <span class="string">&quot;#d08341&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ERRO&quot;</span>: <span class="string">&quot;#fe2626&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TRCE&quot;</span>: <span class="string">&quot;#fe2626&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># fmt: on</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_topics</span>(<span class="params">value: <span class="type">Optional</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    topics = value.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topic <span class="keyword">in</span> topics:</span><br><span class="line">        <span class="keyword">if</span> topic <span class="keyword">not</span> <span class="keyword">in</span> TOPICS:</span><br><span class="line">            <span class="keyword">raise</span> typer.BadParameter(<span class="string">f&quot;topic <span class="subst">&#123;topic&#125;</span> not recognized&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> topics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"></span></span><br><span class="line"><span class="params">    file: typer.FileText = typer.Argument(<span class="params"><span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;File to read, stdin otherwise&quot;</span></span>),</span></span><br><span class="line"><span class="params">    colorize: <span class="built_in">bool</span> = typer.Option(<span class="params"><span class="literal">True</span>, <span class="string">&quot;--no-color&quot;</span></span>),</span></span><br><span class="line"><span class="params">    n_columns: <span class="type">Optional</span>[<span class="built_in">int</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--columns&quot;</span>, <span class="string">&quot;-c&quot;</span></span>),</span></span><br><span class="line"><span class="params">    ignore: <span class="type">Optional</span>[<span class="built_in">str</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--ignore&quot;</span>, <span class="string">&quot;-i&quot;</span>, callback=list_topics</span>),</span></span><br><span class="line"><span class="params">    just: <span class="type">Optional</span>[<span class="built_in">str</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--just&quot;</span>, <span class="string">&quot;-j&quot;</span>, callback=list_topics</span>),</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    topics = <span class="built_in">list</span>(TOPICS)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We can take input from a stdin (pipes) or from a file</span></span><br><span class="line">    input_ = file <span class="keyword">if</span> file <span class="keyword">else</span> sys.stdin</span><br><span class="line">    <span class="comment"># Print just some topics or exclude some topics (good for avoiding verbose ones)</span></span><br><span class="line">    <span class="keyword">if</span> just:</span><br><span class="line">        topics = just</span><br><span class="line">    <span class="keyword">if</span> ignore:</span><br><span class="line">        topics = [lvl <span class="keyword">for</span> lvl <span class="keyword">in</span> topics <span class="keyword">if</span> lvl <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">set</span>(ignore)]</span><br><span class="line"></span><br><span class="line">    topics = <span class="built_in">set</span>(topics)</span><br><span class="line">    console = Console()</span><br><span class="line">    width = console.size.width</span><br><span class="line"></span><br><span class="line">    panic = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> input_:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time, topic, *msg = line.strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="comment"># To ignore some topics</span></span><br><span class="line">            <span class="keyword">if</span> topic <span class="keyword">not</span> <span class="keyword">in</span> topics:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            msg = <span class="string">&quot; &quot;</span>.join(msg)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Debug calls from the test suite aren&#x27;t associated with</span></span><br><span class="line">            <span class="comment"># any particular peer. Otherwise we can treat second column</span></span><br><span class="line">            <span class="comment"># as peer id</span></span><br><span class="line">            <span class="keyword">if</span> topic != <span class="string">&quot;TEST&quot;</span>:</span><br><span class="line">                i = <span class="built_in">int</span>(msg[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Colorize output by using rich syntax when needed</span></span><br><span class="line">            <span class="keyword">if</span> colorize <span class="keyword">and</span> topic <span class="keyword">in</span> TOPICS:</span><br><span class="line">                color = TOPICS[topic]</span><br><span class="line">                msg = <span class="string">f&quot;[<span class="subst">&#123;color&#125;</span>]<span class="subst">&#123;msg&#125;</span>[/<span class="subst">&#123;color&#125;</span>]&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Single column printing. Always the case for debug stmts in tests</span></span><br><span class="line">            <span class="keyword">if</span> n_columns <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> topic == <span class="string">&quot;TEST&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(time, msg)</span><br><span class="line">            <span class="comment"># Multi column printing, timing is dropped to maximize horizontal</span></span><br><span class="line">            <span class="comment"># space. Heavylifting is done through rich.column.Columns object</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cols = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_columns)]</span><br><span class="line">                msg = <span class="string">&quot;&quot;</span> + msg</span><br><span class="line">                cols[i] = msg</span><br><span class="line">                col_width = <span class="built_in">int</span>(width / n_columns)</span><br><span class="line">                cols = Columns(cols, width=col_width - <span class="number">1</span>, equal=<span class="literal">True</span>, expand=<span class="literal">True</span>)</span><br><span class="line">                <span class="built_in">print</span>(cols)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># Code from tests or panics does not follow format</span></span><br><span class="line">            <span class="comment"># so we print it as is</span></span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;panic&quot;</span>):</span><br><span class="line">                panic = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># Output from tests is usually important so add a</span></span><br><span class="line">            <span class="comment"># horizontal line with hashes to make it more obvious</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> panic:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * console.width)</span><br><span class="line">            <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    typer.run(main)</span><br></pre></td></tr></table></figure><p>当我们将脚本安装好后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dslog --<span class="built_in">help</span> <span class="comment">#查看脚本使用参数</span></span><br><span class="line"></span><br><span class="line">dslog -n 3 -i TIMR output.log </span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://blog.josejg.com/assets/images/debugging-raft/colored.png" alt=""></p><h3 id="dtest：Capturing-Rare-Failures"><a href="#dtest：Capturing-Rare-Failures" class="headerlink" title="dtest：Capturing Rare Failures"></a>dtest：Capturing Rare Failures</h3><p>dtest脚本的作用是多次运行测试，方便检查出稀有的错误</p><p>如dslog将dtest安装完毕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Dict</span>, DefaultDict, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"><span class="keyword">import</span> rich</span><br><span class="line"><span class="keyword">from</span> rich <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">from</span> rich.table <span class="keyword">import</span> Table</span><br><span class="line"><span class="keyword">from</span> rich.progress <span class="keyword">import</span> (</span><br><span class="line">    Progress,</span><br><span class="line">    TimeElapsedColumn,</span><br><span class="line">    TimeRemainingColumn,</span><br><span class="line">    TextColumn,</span><br><span class="line">    BarColumn,</span><br><span class="line">    SpinnerColumn,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> rich.live <span class="keyword">import</span> Live</span><br><span class="line"><span class="keyword">from</span> rich.panel <span class="keyword">import</span> Panel</span><br><span class="line"><span class="keyword">from</span> rich.traceback <span class="keyword">import</span> install</span><br><span class="line"></span><br><span class="line">install(show_locals=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatsMeter</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Auxiliary classs to keep track of online stats including: count, mean, variance</span></span><br><span class="line"><span class="string">    Uses Welford&#x27;s algorithm to compute sample mean and sample variance incrementally.</span></span><br><span class="line"><span class="string">    https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#On-line_algorithm</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    n: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">    mean: <span class="built_in">float</span> = <span class="number">0.0</span></span><br><span class="line">    S: <span class="built_in">float</span> = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, datum</span>):</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line">        delta = datum - self.mean</span><br><span class="line">        <span class="comment"># Mk = Mk-1+ (xk – Mk-1)/k</span></span><br><span class="line">        self.mean += delta / self.n</span><br><span class="line">        <span class="comment"># Sk = Sk-1 + (xk – Mk-1)*(xk – Mk).</span></span><br><span class="line">        self.S += delta * (datum - self.mean)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">variance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.S / self.n</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">std</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(self.variance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_results</span>(<span class="params">results: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Dict</span>[<span class="built_in">str</span>, StatsMeter]], timing=<span class="literal">False</span></span>):</span><br><span class="line">    table = Table(show_header=<span class="literal">True</span>, header_style=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Failed&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Total&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> timing:</span><br><span class="line">        table.add_column(<span class="string">&quot;Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.add_column(<span class="string">&quot;Real Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;User Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;System Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> test, stats <span class="keyword">in</span> results.items():</span><br><span class="line">        <span class="keyword">if</span> stats[<span class="string">&quot;completed&quot;</span>].n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        color = <span class="string">&quot;green&quot;</span> <span class="keyword">if</span> stats[<span class="string">&quot;failed&quot;</span>].n == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;red&quot;</span></span><br><span class="line">        row = [</span><br><span class="line">            <span class="string">f&quot;[<span class="subst">&#123;color&#125;</span>]<span class="subst">&#123;test&#125;</span>[/<span class="subst">&#123;color&#125;</span>]&quot;</span>,</span><br><span class="line">            <span class="built_in">str</span>(stats[<span class="string">&quot;failed&quot;</span>].n),</span><br><span class="line">            <span class="built_in">str</span>(stats[<span class="string">&quot;completed&quot;</span>].n),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> timing:</span><br><span class="line">            row.append(<span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row.extend(</span><br><span class="line">                [</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;real_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;real_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;user_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;user_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;system_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;system_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        table.add_row(*row)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_test</span>(<span class="params">test: <span class="built_in">str</span>, race: <span class="built_in">bool</span>, timing: <span class="built_in">bool</span></span>):</span><br><span class="line">    test_cmd = [<span class="string">&quot;go&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">f&quot;-run=<span class="subst">&#123;test&#125;</span>&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> race:</span><br><span class="line">        test_cmd.append(<span class="string">&quot;-race&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> timing:</span><br><span class="line">        test_cmd = [<span class="string">&quot;time&quot;</span>] + cmd</span><br><span class="line">    f, path = tempfile.mkstemp()</span><br><span class="line">    start = time.time()</span><br><span class="line">    proc = subprocess.run(test_cmd, stdout=f, stderr=f)</span><br><span class="line">    runtime = time.time() - start</span><br><span class="line">    os.close(f)</span><br><span class="line">    <span class="keyword">return</span> test, path, proc.returncode, runtime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">last_line</span>(<span class="params">file: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(-<span class="number">2</span>, os.SEEK_END)</span><br><span class="line">        <span class="keyword">while</span> f.read(<span class="number">1</span>) != <span class="string">b&quot;\n&quot;</span>:</span><br><span class="line">            f.seek(-<span class="number">2</span>, os.SEEK_CUR)</span><br><span class="line">        line = f.readline().decode()</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_tests</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tests: <span class="type">List</span>[<span class="built_in">str</span>],</span></span><br><span class="line"><span class="params">    sequential: <span class="built_in">bool</span>       = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--sequential&#x27;</span>,      <span class="string">&#x27;-s&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Run all test of each group in order&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    workers: <span class="built_in">int</span>           = typer.Option(<span class="params"><span class="number">1</span>,      <span class="string">&#x27;--workers&#x27;</span>,         <span class="string">&#x27;-p&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Number of parallel tasks&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    iterations: <span class="built_in">int</span>        = typer.Option(<span class="params"><span class="number">10</span>,     <span class="string">&#x27;--iter&#x27;</span>,            <span class="string">&#x27;-n&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Number of iterations to run&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    output: <span class="type">Optional</span>[Path] = typer.Option(<span class="params"><span class="literal">None</span>,   <span class="string">&#x27;--output&#x27;</span>,          <span class="string">&#x27;-o&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Output path to use&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    verbose: <span class="built_in">int</span>           = typer.Option(<span class="params"><span class="number">0</span>,      <span class="string">&#x27;--verbose&#x27;</span>,         <span class="string">&#x27;-v&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Verbosity level&#x27;</span>, count=<span class="literal">True</span></span>),</span></span><br><span class="line"><span class="params">    archive: <span class="built_in">bool</span>          = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--archive&#x27;</span>,         <span class="string">&#x27;-a&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Save all logs intead of only failed ones&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    race: <span class="built_in">bool</span>             = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--race/--no-race&#x27;</span>,  <span class="string">&#x27;-r/-R&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Run with race checker&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    loop: <span class="built_in">bool</span>             = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--loop&#x27;</span>,            <span class="string">&#x27;-l&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Run continuously&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    growth: <span class="built_in">int</span>            = typer.Option(<span class="params"><span class="number">10</span>,     <span class="string">&#x27;--growth&#x27;</span>,          <span class="string">&#x27;-g&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Growth ratio of iterations when using --loop&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    timing: <span class="built_in">bool</span>           = typer.Option(<span class="params"><span class="literal">False</span>,   <span class="string">&#x27;--timing&#x27;</span>,          <span class="string">&#x27;-t&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Report timing, only works on macOS&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    <span class="comment"># fmt: on</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        timestamp = datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d_%H%M%S&quot;</span>)</span><br><span class="line">        output = Path(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> race:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[yellow]Running with the race detector\n[/yellow]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[yellow] Verbosity level set to <span class="subst">&#123;verbose&#125;</span>[/yellow]&quot;</span>)</span><br><span class="line">        os.environ[<span class="string">&#x27;VERBOSE&#x27;</span>] = <span class="built_in">str</span>(verbose)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        total = iterations * <span class="built_in">len</span>(tests)</span><br><span class="line">        completed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        results = &#123;test: defaultdict(StatsMeter) <span class="keyword">for</span> test <span class="keyword">in</span> tests&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sequential:</span><br><span class="line">            test_instances = itertools.chain.from_iterable(itertools.repeat(test, iterations) <span class="keyword">for</span> test <span class="keyword">in</span> tests)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            test_instances = itertools.chain.from_iterable(itertools.repeat(tests, iterations))</span><br><span class="line">        test_instances = <span class="built_in">iter</span>(test_instances)</span><br><span class="line"></span><br><span class="line">        total_progress = Progress(</span><br><span class="line">            <span class="string">&quot;[progress.description]&#123;task.description&#125;&quot;</span>,</span><br><span class="line">            BarColumn(),</span><br><span class="line">            TimeRemainingColumn(),</span><br><span class="line">            <span class="string">&quot;[progress.percentage]&#123;task.percentage:&gt;3.0f&#125;%&quot;</span>,</span><br><span class="line">            TimeElapsedColumn(),</span><br><span class="line">        )</span><br><span class="line">        total_task = total_progress.add_task(<span class="string">&quot;[yellow]Tests[/yellow]&quot;</span>, total=total)</span><br><span class="line"></span><br><span class="line">        task_progress = Progress(</span><br><span class="line">            <span class="string">&quot;[progress.description]&#123;task.description&#125;&quot;</span>,</span><br><span class="line">            SpinnerColumn(),</span><br><span class="line">            BarColumn(),</span><br><span class="line">            <span class="string">&quot;&#123;task.completed&#125;/&#123;task.total&#125;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        tasks = &#123;test: task_progress.add_task(test, total=iterations) <span class="keyword">for</span> test <span class="keyword">in</span> tests&#125;</span><br><span class="line"></span><br><span class="line">        progress_table = Table.grid()</span><br><span class="line">        progress_table.add_row(total_progress)</span><br><span class="line">        progress_table.add_row(Panel.fit(task_progress))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> Live(progress_table, transient=<span class="literal">True</span>) <span class="keyword">as</span> live:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">_, frame</span>):</span><br><span class="line">                live.stop()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                print_results(results)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            signal.signal(signal.SIGINT, handler)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> ThreadPoolExecutor(max_workers=workers) <span class="keyword">as</span> executor:</span><br><span class="line"></span><br><span class="line">                futures = []</span><br><span class="line">                <span class="keyword">while</span> completed &lt; total:</span><br><span class="line">                    n = <span class="built_in">len</span>(futures)</span><br><span class="line">                    <span class="keyword">if</span> n &lt; workers:</span><br><span class="line">                        <span class="keyword">for</span> test <span class="keyword">in</span> itertools.islice(test_instances, workers-n):</span><br><span class="line">                            futures.append(executor.submit(run_test, test, race, timing))</span><br><span class="line"></span><br><span class="line">                    done, not_done = wait(futures, return_when=FIRST_COMPLETED)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> future <span class="keyword">in</span> done:</span><br><span class="line">                        test, path, rc, runtime = future.result()</span><br><span class="line"></span><br><span class="line">                        results[test][<span class="string">&#x27;completed&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line">                        results[test][<span class="string">&#x27;time&#x27;</span>].add(runtime)</span><br><span class="line">                        task_progress.update(tasks[test], advance=<span class="number">1</span>)</span><br><span class="line">                        dest = (output / <span class="string">f&quot;<span class="subst">&#123;test&#125;</span>_<span class="subst">&#123;completed&#125;</span>.log&quot;</span>).as_posix()</span><br><span class="line">                        <span class="keyword">if</span> rc != <span class="number">0</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;Failed test <span class="subst">&#123;test&#125;</span> - <span class="subst">&#123;dest&#125;</span>&quot;</span>)</span><br><span class="line">                            task_progress.update(tasks[test], description=<span class="string">f&quot;[red]<span class="subst">&#123;test&#125;</span>[/red]&quot;</span>)</span><br><span class="line">                            results[test][<span class="string">&#x27;failed&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> results[test][<span class="string">&#x27;completed&#x27;</span>].n == iterations <span class="keyword">and</span> results[test][<span class="string">&#x27;failed&#x27;</span>].n == <span class="number">0</span>:</span><br><span class="line">                                task_progress.update(tasks[test], description=<span class="string">f&quot;[green]<span class="subst">&#123;test&#125;</span>[/green]&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> rc != <span class="number">0</span> <span class="keyword">or</span> archive:</span><br><span class="line">                            output.mkdir(exist_ok=<span class="literal">True</span>, parents=<span class="literal">True</span>)</span><br><span class="line">                            shutil.copy(path, dest)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> timing:</span><br><span class="line">                            line = last_line(path)</span><br><span class="line">                            real, _, user, _, system, _ = line.replace(<span class="string">&#x27; &#x27;</span>*<span class="number">8</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                            results[test][<span class="string">&#x27;real_time&#x27;</span>].add(<span class="built_in">float</span>(real))</span><br><span class="line">                            results[test][<span class="string">&#x27;user_time&#x27;</span>].add(<span class="built_in">float</span>(user))</span><br><span class="line">                            results[test][<span class="string">&#x27;system_time&#x27;</span>].add(<span class="built_in">float</span>(system))</span><br><span class="line"></span><br><span class="line">                        os.remove(path)</span><br><span class="line"></span><br><span class="line">                        completed += <span class="number">1</span></span><br><span class="line">                        total_progress.update(total_task, advance=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                        futures = <span class="built_in">list</span>(not_done)</span><br><span class="line"></span><br><span class="line">        print_results(results, timing)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> loop:</span><br><span class="line">            iterations *= growth</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[yellow]Increasing iterations to <span class="subst">&#123;iterations&#125;</span>[/yellow]&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    typer.run(run_tests)</span><br></pre></td></tr></table></figure><blockquote><p>运行示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dtest --<span class="built_in">help</span> <span class="comment">#查看运行参数</span></span><br><span class="line"></span><br><span class="line">dtest -n 100(运行一百遍) -p 5(五个并发的运行测试加快运行速率) -s(顺序执行) </span><br><span class="line">-v(将Debug打印到<span class="built_in">log</span>) 2B(测试点名称)</span><br></pre></td></tr></table></figure><p><img src="https://blog.josejg.com/assets/images/debugging-raft/progress.png" alt=""></p><p><img src="https://blog.josejg.com/assets/images/debugging-raft/table.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> Debug </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统接口</title>
      <link href="/2023/03/14/Chapter%201%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/03/14/Chapter%201%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在操作系统的简介中，说到为了方便程序使用硬件资源操作系统会提供一些应用接口。</p><p>如Figure1.1所示，在xv6中采取一个<strong>内核(kernel)空间</strong>的设计：一个特殊的程序提供服务给运行的程序。每个运行的程序我们称作为进程(Process)拥有指令、数据、栈。<strong>用户空间(user space)：</strong> 抽象出的一个空间，用于用户运行应用程序，如shell(本质上是一个应用程序，功能就是读取命令并执行)、cat</p><ul><li>指令(instruction)：实现程序的计算</li><li>数据(data)：一些计算的变量</li><li>栈(stack)：组织的程序(C语言中的函数)的调用</li></ul><p>当进程调用内核服务时我们就需要进行(invoke)<strong>系统调用</strong>，系统调用会进入内核，然后内核执行服务并返回，于是这样的一个进程会选择在用户空间与内核空间执行。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230128013838.png" alt="image.png"></p><h1 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h1><h2 id="进程-Process-："><a href="#进程-Process-：" class="headerlink" title="进程(Process)："></a>进程(Process)：</h2><blockquote><p>进程的概念：进程简单来说就是正在运行的程序，例如我们以及启动的word办公软件、游戏应用等应用程序。</p></blockquote><p>我们为了实现一个系统能够同时运行多个程序，系统需要提供一种拥有多个CPU的假象，称作为<strong>虚拟化CPU</strong></p><p>那为了实现这种技术我们采用了一种叫做<strong>时分(time sharing)</strong> 的CPU技术：一个进程只会运行一个时间片，之后便切换到其他进程，从而提供多个CPU的假象。</p><p>进程之间的切换称作为上下文切换(context switch).</p><h2 id="进程系统调用：xv6"><a href="#进程系统调用：xv6" class="headerlink" title="进程系统调用：xv6"></a>进程系统调用：xv6</h2><p>进程API设计所需要包含的内容</p><ul><li>创建（create）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 </li><li>销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。</li><li>等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。 </li><li>其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。</li><li>状态（status）：通常也有一些接口可以获得有关进程的状态信息。</li></ul><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>exit(int status)</code></td><td>中止当前进程，将状态报告给wait(),没有返回</td></tr><tr><td>int <code>getpid()</code></td><td>返回当前进程的PID</td></tr><tr><td>int <code>fork()</code></td><td>创建进程，返回子进程的PID</td></tr><tr><td>int <code>wait(int *status)</code></td><td>父进程等待子进程退出(exit);退出状态是<code>*Status</code>，返回值为子进程的PID</td></tr><tr><td>int <code>sleep(int n)</code></td><td>暂停进程n个时钟ticks的时间</td></tr><tr><td>int exec<code>(char *file, char *argv[])</code></td><td>加载文件<code>(*file)</code>执行，以其参数<code>(*argv)</code>执行程序，错误后返回-1</td></tr><tr><td>int <code>kill(int pid)</code></td><td>中止进程号为PID的进程，成功返回0，错误返回-1</td></tr><tr><td>char <code>*sbrk(int n)</code></td><td>增加当前进程的内存空间，并返回新内存的开始位置</td></tr></tbody></table></div><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ol><li><p>创建<br>使用<code>fork()</code>系统调用，可以创建进程，新创建的进程(child)会复制当前进程(parent)的内存(数据与指令)。<code>fork()</code>创建进程成功后(不同的进程的PID不会相同)，子进程的返回值为0，父进程的返回值为子进程的PID</p></li><li><p>退出—-其他控制<br>使用<code>exit()</code>系统调用，会导致调用它的进程停止运行，并且释放诸如内存和打开文件在内的资源。</p></li><li><p>等待<br>使用<code>wait()</code>系统调用，会返回一个当前进程已退出的子进程，如果没有子进程退出，wait 会等候直到有一个子进程退出。如果调用该接口的进程没有子进程，会返回-1，当我们不在意子进程的状态时，我们可以传入0去等待。</p></li></ol><p>观看下述代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中的运行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent: child=32381</span><br><span class="line">child: exiting</span><br><span class="line">//这条语句是等待子进程退出后才会执行</span><br><span class="line">child 32381 is done</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> 虽然我们父子进程在初始化时会有相同的内存，但是在之后，他们会有单独的寄存器与内存，两个进程的变量彼此互不干扰。例如，对于变量PID，父进程中PID = 32381，而子进程的PID = 0</p></blockquote><ol><li>执行文件<br>使用exec系统调用 ，将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。</li></ol><p>示例：这段代码将调用程序替换为 /bin/echo 这个程序，这个程序的参数列表为echo hello。大部分的程序都忽略第一个参数，这个参数惯例上是程序的名字（此例是 echo）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>xv6：</strong> user/sh.c中我们会开启一个死循环进行读取用户的输入，我们会创建一个进程，将解析完成的参数，传递给runcmd()函数去调用exce执行程序(echo程序)，wait是主程序需要等待f子进程的退出。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">    <span class="comment">//+3(&quot;cd &quot;) meanning skip to the string for dir</span></span><br><span class="line">    <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(parsecmd(buf));</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xv6 通常隐式地分配用户的内存空间。fork 在子进程需要装入父进程的内存拷贝时分配空间，exec 在需要装入可执行文件时分配空间。一个进程在需要额外内存时可以通过调用 sbrk(n) 来增加 n 字节的数据内存。 sbrk 返回新的内存的地址。</p><h2 id="进程创建-细节"><a href="#进程创建-细节" class="headerlink" title="进程创建(细节)"></a>进程创建(细节)</h2><ol><li>将代码和静态数据(初始化变量)加载到内存，再加载到进程的地址空间。(操作系统读取硬盘程序字节，并将其读入到内存中)</li><li>为程序运行期栈(run-time stack)分配内存，在C语言中我们使用栈来存放局部变量、函数参数和返回地址。操作系统可以使用参数来初始化栈，例如在linux中我们将argc、argv参数填入main中</li><li>为程序的堆(heap)分配内存，如C语言中使用malloc与free，申请与释放的内存为堆内存。注：堆内存远大于栈内存，因此一些大型数据结构需要使用堆来申请内存。</li><li>执行一些初始化任务，如一些IO操作。在unix中，每个进程默认情况都会打开3个文件描述符(file descriptor，一个整数句柄)，用于标准输入输出和错误。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230129133311.png" alt="OSTEP4.1"></p><h2 id="进程的数据结构-xv6"><a href="#进程的数据结构-xv6" class="headerlink" title="进程的数据结构(xv6)"></a>进程的数据结构(xv6)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="I-O-与-文件描述符"><a href="#I-O-与-文件描述符" class="headerlink" title="I/O 与 文件描述符"></a>I/O 与 文件描述符</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul><li><strong>I/O：</strong> 输入(input)与输出(output),C语言的头文件<code>&lt;stdio.h&gt;</code>,代表的就是标准输入与输出</li><li><strong>文件描述符：</strong> file descriptor，用一个整数来表示内核管理的对象，进程可以通过该描述符进行读或写，文件描述符接口将这些文件、管道、设备抽象为字节流</li></ul><blockquote><p><strong>获得文件描述符(fd)</strong>,可以通过打开文件、目录、或设备、创建一个管道(Pipe)、通过复制(duplicate)已经存在的文件描述符</p></blockquote><ul><li><strong>进程表：</strong> 在xv6中每个进程都会有一个进程表，而文件描述符就是作为其中的一个索引。因此每个进程的私有空间内的文件描述符都是以0开始。</li></ul><p>在xv6中，通常情况下，进程会默认定义了3个文件描述符。</p><ul><li>标准输入：0，将fd=0文件的内容进行读取，也就是读取命令行的内容，等同于C语言中的stdin</li><li>标准输出：1，将内容输出写入到fd=1的文件中，也就是输出内容到命令行，等同于stdout</li><li>错误信息：2，将错误信息输出到fd=2的文件中，等同于stderr</li></ul><blockquote><p>fd = 0,1,2，这三个描述符引用的都是同一个文件<strong>console</strong>，相当于复制(duplicate)的操作，将三个描述符用于不同的路径。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;<span class="comment">//我们会陆续获得到0，1，2三个描述，为3时破除循环</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O系统调用：xv6"><a href="#I-O系统调用：xv6" class="headerlink" title="I/O系统调用：xv6"></a>I/O系统调用：xv6</h2><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>open(char *file, int flags)</code></td><td>打开一个文件，指定读写的标识(flag),返回文件描述符</td></tr><tr><td>int <code>write(int fd, char *buf, int n)</code></td><td>将buf的内容写入fd引用的文件，返回值为n</td></tr><tr><td>int <code>read(int fd, char *buf, int n)</code></td><td>将fd的文件内容读取到buf中，返回读取的数量，如果为0这代表EOF</td></tr><tr><td>int <code>close(int fd)</code></td><td>释放打开的文件描述符，包括open、pipe、dup所产生的fd，释放后可以复用该fd</td></tr><tr><td>int <code>dup(int fd)</code></td><td>返回一个新的描述符并引用与fd相同的文件</td></tr><tr><td>int <code>pipe(int p[])</code></td><td>创建管道，将标准输入输出描述符放入<code>p[0]</code>、<code>p[1]</code>中</td></tr></tbody></table></div><blockquote><p>open()接口的第二个参数为标识符(打开文件的方式)：</p></blockquote><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_CREATE：指定的文件不存在，新建文件</li><li>O_TRUNC：截断，将文件内容清除</li></ul><h2 id="应用示例-1"><a href="#应用示例-1" class="headerlink" title="应用示例"></a>应用示例</h2><ul><li><p>cat应用：文件位置user/cat.c，我们将open、read、write三个系统接口接口聚合形成了cat这个打印文件内容的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *agrv[])</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(argv[i], <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cat: cannot open %s\n&quot;</span>, argv[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cat(fd);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><p>void cat(int fd){<br>  …<br>  while((n = read(fd, buf, sizeof(buf))) &gt; 0) {<br>    if (write(1, buf, n) != n) {<br>      fprintf(2, “cat: write error\n”);<br>      exit(1);<br>    }<br>  }<br>  …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如我们使用cat打印hello.txt，文件内容为hello world!</span><br><span class="line">```shell</span><br><span class="line">cat hello.txt</span><br></pre></td></tr></table></figure><ol><li>首先在main中使用open打开hello.txt，第二个参数0代表只读(kernel / fctrl.c)中定义了O_RDONLY为0x000</li><li>然后将文件描述符传递给cat函数，根据指定的文件描述符使用read接口读取hello.txt的内容</li><li>最后再通过write将缓冲区的内容，写入到标准输出中</li></ol><h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><blockquote><p><strong>I/O重定向：</strong> 通常情况我们都是将内容输出到屏幕也就是命令行，通过I/O重定向便可以将内容输出到指定文件内。<strong>I/O的重定向</strong> = 将标准输入、输出、错误信息打印，三个文件描述符替换，作为指定文件的描述符</p></blockquote><p>linux下的重定向符号使用</p><ul><li><code>命令 &gt; 文件</code>：将内容输出到指定文件</li><li><code>命令 2&gt; 文件</code>,可以将错误信息输出到指定文件</li><li><code>命令 &gt;&gt; 文件</code>：以追加的形式输出到指定文件</li><li><p><code>命令 &gt; 文件 2&gt;&amp;1</code>：将标准输出于错误消息输出到指定文件，在后续将会使用到该符号，等同于<code>命令 &amp;&gt; 文件</code>。个人理解:&amp;作为引用相当于duplicate，fd=2作为一个fd=1的副本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> a b &gt; tmp1 2&gt;&amp;1 <span class="comment">#b目录不存在,将2(标准错误打印)重定向1(标准输出)</span></span></span><br></pre></td></tr></table></figure></li><li><code>命令 &lt; 文件</code>：将文件内容输入到指定位置，将文件内容作为命令的标准输入</li><li><code>命令 &lt; 文件1 &gt; 文件2</code>：将文件1作为命令的标准输入，并将标准输出到文件2</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">----打印到屏幕上----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world!</span></span><br><span class="line">----写入hello.txt文件中----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world! &gt; hello.txt</span></span><br><span class="line">----使用重定向清空文件内容,原理是将空内容输出到指定文件内----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">: &gt; hello.txt <span class="comment"># or true &gt; hello.txt</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/null &gt; hello.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> &gt; hello.txt</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>实现：</strong> <code>fork()</code> + 文件描述符</p></blockquote><p>在进程讲解中我们知道了，fork生成的子进程会拷贝父进程的内存，那么父进程的描述符同样会拷贝到子进程。<code>exec()</code>系统调用将会替代调用进程的内存(后续不再执行该进程)，但是会保留文件表。</p><blockquote><p><strong>扩展：</strong> 在命令行键入<code>cat</code>，不加上文件名。cat会采用标准输入(fd=0)作为输入流运行程序。键入<code>cat</code>后，cat程序会一直占用标准输入，我们输入一行命令，就会输出一行命令。</p></blockquote><p>由于所有进程默认打开了三个文件描述符0，1，2。因此使用open打开文件的返回值是3。要想单个cat命令能够获取文件内容，我们就需要使用IO重定向。那么我们通过使用fork+exec两个接口来实现重定向，以<code>cat &lt; input.txt</code>为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;fd = %d\n&quot;</span>,fd);</span><br><span class="line">        execvp( <span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前的标准输入(fd = 0)替换为需要读入的文件描述符，也就是关闭完标准输入(fd = 0)后，此时调用open，我们会发现这个文件的描述符为0。这时我们再使用单个<code>cat</code>命令，只会读取我们打开的文件的内容。</p><blockquote><p>为什么我们需要将exec与fork两个接口分开</p></blockquote><p>子进程进行IO重定向，不会影响到主进程的IO设置。根据cat重定向，根据上述程序，若我们只使用一个forkexec，没有更换标准文件描述符的机会，就不可能实现IO重定向的功能。</p><blockquote><p>硬件接口占用问题</p></blockquote><p>虽然父子进程拥有隔离的文件描述符表，但是父子进程共用相同的文件偏移量。也就是当父子进程都使用同一个文件描述符时，我们无法控制其运行的顺序。例如：父子进程同时使用了标准输出的描述符，若没有wait，会出现<code>world\n hello</code>的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中我们使用了wait(0)，让父进程去等待子进程退出，从而控制了执行顺序。</p><blockquote><p>dup接口使用</p></blockquote><p>上述程序使用了dup接口进行改写，复制的fd引用了标准输出(fd=1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><blockquote><p>xv6中的IO重定向(user/sh.c)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);<span class="comment">//使用exce</span></span><br></pre></td></tr></table></figure><h1 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h1><h2 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h2><p><strong>管道：</strong> 是一个小的内核缓冲区提供给进程，作为一对文件描述符。一个用于写，一个用于读。给两个程序中创建一个通讯的管道，能够进行数据交换。</p><p><strong>作用：</strong> 用于不同进程之间的通讯，省去了临时文件的创建于删除。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>该程序wc(wordcount),我们将标准输入连接到了管道的读取端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);<span class="comment">// 复制一个 p[0](管道读端)，此时文件描述符 0（标准输入）也</span></span><br><span class="line">            <span class="comment">//引用管道读端，故改变了标准输入。</span></span><br><span class="line">    close(p[<span class="number">0</span>]);<span class="comment">//关闭了标准输入，同时p[0]管道端也失效</span></span><br><span class="line">    close(p[<span class="number">1</span>]);<span class="comment">//防止子进程自己阻塞自己</span></span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);<span class="comment">// wc 从标准输入读取数据(同cat)，并写入到</span></span><br><span class="line">                        <span class="comment">// 参数中的每一个文件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该程序中我们调用了pipe()系统调用，我们创建了新的管道，在p中记录下了文件的读写描述符。父子进程都标准IO引用同一管道</p><ul><li>子进程中我们close了标准输入(fd=0)的描述符，使用dup复制了管道输入描述符，从而引用了管道的读取(输入)端。简单来说就是<strong>将标准输入替换成了管道输入</strong>也就是重定向。</li><li>父进程中我们关闭了标准读取(输入)管道，将文件内容写入标准写入(输出)管道，从而将内容写入pipe缓冲区</li></ul><p>管道数据流向图</p><p><img src="../img/pipe.png" alt="pipe"></p><blockquote><p>父进程比子进程慢一点执行的话，缓冲区没有数据，会不会导致子进程读取失败？</p></blockquote><p>缓冲区没有数据，会有以下三种情况：</p><ul><li><p>等待写入(输出)端写入数据，输入端再进行读取(<strong>阻塞</strong>)</p></li><li><p>等待引用写入(输出)端的管道描述符被关闭</p></li></ul><p>在执行exec程序前，执行<code>close(p[1])</code>，若注释该语句，我们将不会有输出。<br>wc 的一个fd仍然引用了管道的写端，那么 wc 将永远看不到文件的关闭（被自己阻塞）。</p><ul><li>读取为0，就像读取到EOF一样</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在xv6中shell实现了管道，如<code>grep fork sh.c | wc -l</code>。创建两个子进程分别执行，将左端grep输出的内容，发送给了右端wc作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">   pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">     panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">1</span>);</span><br><span class="line">     dup(p[<span class="number">1</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">0</span>);</span><br><span class="line">     dup(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230201232207.png" alt="xv6-pipe"></p><p>如图：</p><ol><li>创建两个子进程(c1、c2)，创建管道连接左端(写入端)和右端(读取端)</li><li><strong>左端写入端：</strong> 子进程1中，运行runcmd，命令如grep fork sh.c，将内容写入buffer</li><li><strong>读取端：</strong> 子进程2中，运行runcmd，如wc -l，读取buffer的数据</li><li>互相等待其完成，简单来说一写一读</li></ol><p>右端可以包含一个或多个命令，如<code>a|b|c</code>，其中a为写入端，b、c都是读取端，b、c都是两个子进程</p><blockquote><p>Pipe的实际作用</p></blockquote><p>下述示例中管道除了没有临时文件产生没有什么用途了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pipe</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world | <span class="built_in">wc</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">common:without pipe</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; <span class="built_in">wc</span> &lt;/tmp/xyz</span></span><br></pre></td></tr></table></figure><p>但是管道与临时文件相比也有以下<strong>优势</strong></p><ol><li>管道会自动清理自己；如果是文件重定向，shell 在完成后必须小心翼翼地删除/tmp/xyz。</li><li>第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。</li><li>管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。</li><li>如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</li></ol><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><blockquote><p><strong>文件系统</strong> </p></blockquote><p>操作系统中用于管理磁盘的软件，可以高效的将用户创建的文件通过I/O设备存储到系统的磁盘中，从而实现持久化地存储数据。</p><blockquote><p><strong>文件类型</strong></p></blockquote><ul><li>目录：保存了数据文件与其他目录的名称引用，目录本质上也是文件</li><li>数据文件：连续的字节数组</li><li>设备文件：所有硬件都有对应的文件，文件系统通过文件去访问特定的设备。<a href="https://www.zhihu.com/question/61665350/answer/1700474752">什么是设备文件？ - 知乎</a></li></ul><blockquote><p><strong>文件存储路径</strong></p></blockquote><p>目录和文件将会形成一个树状结构(tree)。</p><p><code>/</code> 称为根(root)目录是所有文件的开始目录，以<code>/</code> 开始表示的路径称为<strong>绝对路径</strong> ，如/a/b/c，代表访问到了c这个文件或者是目录。反之不是以<code>/</code>开始的路径称为的<strong>相对路径</strong>。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230203190038.png" alt="file_tree"></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和<strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><blockquote><p><strong>索引节点(inode)</strong></p></blockquote><p>文件系统会给硬盘内的每个文件分配一个底层数据结构inode，每一个inode的编号对应一个文件，用于保存文件<strong>元信息</strong>。在linux下我们可以使用stat命令查看inode消息，inode数据结构存在于磁盘中。</p><p>inode中的<strong>元信息(metadata)</strong> 如</p><ul><li>索引节点ID：对应文件本身</li><li>文件的字节数</li><li>文件类型:数据文件、目录、设备文件</li><li>链接数，即有多少文件名指向这个inode</li></ul><ul><li>文件内容在磁盘的位置</li></ul><blockquote><p><strong>目录项(directory entry)</strong> = dentry</p></blockquote><p>用来记录文件的<strong>名字</strong>、inode指针以及与其他dentry的层级关联关系。多个dentry关联起来，就会形成目录结构，但它与inode不同的是，目录项是由<strong>内核维护</strong>的一个数据结构，<strong>不存放于磁盘</strong>，而是缓存在内存。</p><p>由于inode唯一标识一个文件，而dentry记录着文件的名称，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个名称。</p><blockquote><p>硬盘存储数据</p></blockquote><p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p><p>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p><p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230203180037.png" alt="inode and entry"></p><blockquote><p>inode是存储在硬盘上的数据，那么为了加速文件的访问，通常会把inode加载到内存中</p></blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/183238194">小林coding</a></p><h2 id="文件系统调用：xv6"><a href="#文件系统调用：xv6" class="headerlink" title="文件系统调用：xv6"></a>文件系统调用：xv6</h2><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>chdir(char *dir)</code></td><td>Change the current directory.</td></tr><tr><td>int <code>mkdir(char *dir)</code></td><td>Create a new directory.</td></tr><tr><td>int <code>mknod(char *file, int, int)</code></td><td>Create a device file.</td></tr><tr><td>int <code>fstat(int fd, struct stat *st)</code></td><td>Place info about an open file into <code>*st</code>.</td></tr><tr><td>int <code>stat(char *file, struct stat *st)</code></td><td>Place info about a named file into <code>*st.</code></td></tr><tr><td>int <code>link(char *file1, char *file2)</code></td><td>Create another name (file2) for the file file1.</td></tr><tr><td>int <code>unlink(char *file)</code></td><td>Remove a file.</td></tr></tbody></table></div><ul><li><p>cddir: 切换当前文件目录，同cd命令</p></li><li><p>mkdir: 创建目录，同linux下的mkdir命令</p></li><li><p>mknod: 创建一个特殊的文件，对设备文件进行引用，与设备文件相关的是主要和次要设备编号（mknod的两个参数），它们唯一地标识内核设备。</p></li><li><p>link:创建一个文件名，对相同的inode进行引用作为一个存在的文件</p><h2 id="应用示例-2"><a href="#应用示例-2" class="headerlink" title="应用示例"></a>应用示例</h2></li><li><p>chdir与open</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---使用chdir改变当前目录，以相对路径创建文件---*/</span></span><br><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="comment">/*---以绝对路径创建文件---*/</span></span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure></li><li><p>mkdir与mknod</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在根目录下创建dir文件夹，并以只写的方式创建file文件*/</span></span><br><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="comment">/*创建console设备文件*/</span></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>创建设备文件后，内核回将读写的系统调用转移到内核设备，而不是传递给文件系统</p></blockquote></li><li><p>link与unlink</p><blockquote><p><strong>链接(link)：</strong> 每个链接由目录中的条目也就是(dentry)组成，dentry内容包含文件名与引用的inode</p></blockquote></li></ul><p>如下，创建b的文件进行读写和对a进行读写的效果相同，对a、b文件使用stat命令进行观察，可以观测到a、b有相同的inode号与一样的链接数(nlink) =2。当使用unlink后，我们再观测b文件会返现nlink=0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个文件a，创建b文件对a进行链接*/</span></span><br><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">/*取消a文件的链接*/</span></span><br><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="数据结构-xv6"><a href="#数据结构-xv6" class="headerlink" title="数据结构(xv6)"></a>数据结构(xv6)</h2><ul><li><p>fstat系统调用检索inode的文件描述符信息，并将其填入stat结构体中如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br></pre></td></tr></table></figure></li></ul><p>struct stat {<br>  int dev;     // File system’s disk device<br>  uint ino;    // Inode number<br>  short type;  // Type of file<br>  short nlink; // Number of links to file<br>  uint64 size; // Size of file in bytes<br>};</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- cd命令改变shell当前的工作目录，如果cd作为普通命令执行，那么我们将会fork一个子进程，而子进程只会改变当前目录，不会该改变父进程目录。以此不需要fork一个进程去修改目录。</span><br><span class="line">```c</span><br><span class="line">  // Read and run input commands.</span><br><span class="line">  while(getcmd(buf, sizeof(buf)) &gt;= 0)&#123;</span><br><span class="line">    if(buf[0] == &#x27;c&#x27; &amp;&amp; buf[1] == &#x27;d&#x27; &amp;&amp; buf[2] == &#x27; &#x27;)&#123;</span><br><span class="line">      // Chdir must be called by the parent, not the child.</span><br><span class="line">      buf[strlen(buf)-1] = 0;  // chop \n</span><br><span class="line">      //buf+3(&quot;cd &quot;) &#x27;+3&#x27;meanning skip to the string for dir</span><br><span class="line">      if(chdir(buf+3) &lt; 0)</span><br><span class="line">        fprintf(2, &quot;cannot cd %s\n&quot;, buf+3);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(fork1() == 0)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章主要是讲解了系统调用的一些接口，并且简单的介绍了一些linux的常识。本节课也有对应的实验，可以让你去实现一些常用linux的工具<a href="https://pdos.csail.mit.edu/6.828/2022/labs/util.html">lab1</a>(其中十分有趣的实验用pipe去实现流水线)。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统组成</title>
      <link href="/2023/03/14/Chapter2%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90/"/>
      <url>/2023/03/14/Chapter2%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>O/S提供CPU等硬件资源分配以及安全的功能</p></blockquote><ul><li>时分(time-share)的机制：让CPU资源能够被合理的调度。<a href="">进程调度</a></li><li>隔离性(isolation)：进程的资源(如内存)与故障都不会相互干扰</li><li>复用(multiplexing)：c语言的库文件</li><li>交互(interaction)：进程之间的通讯，如管道pipe</li></ul><blockquote><p>xv6运行在多核RISC-V微处理器上，RISC-V是一个64位CPU.</p></blockquote><p>xv6是一个用”LP64“C编写的内核(L-long，P-pointer)，在c语言中long类型与pointer类型都是64位，int类型位32位。</p><p>qemu是一个c语言编写的模拟硬件的程序，但是我们在编写xv6时，应该qemu看作一块RISC-V主板，内含CPU、ROM、RAM、磁盘等等硬件，xv6就是运行在该主板上的操作系统。</p><h1 id="抽象物理资源"><a href="#抽象物理资源" class="headerlink" title="抽象物理资源"></a>抽象物理资源</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><blockquote><p>为什么要使用操作系统？</p></blockquote><p>应用通过图1.2的系统调用接口(库)可以直接与<strong>硬件资源交互</strong>，方便程序设计者去编写程序</p><blockquote><p>库方法的缺陷</p></blockquote><p>有多个应用同时运行，应用必须保持良好的特性(不能有bug)。例如应用需要周期性的放弃CPU，让其他应用使用。这便是时分的调度资源的方法。</p><p><strong>协助时分方案</strong>(cooperative time share scheme)：提供了共享CPU的方法，但是如果有bug的软件运行，那么会导致整个系统奔溃。因此我们需要系统提供隔离性。</p><blockquote><p>将物理资源抽象为 <strong>服务(文件服务)或是系统调用</strong> 提供那些便利？</p></blockquote><ol><li><strong>强隔离性</strong>：禁止应用直接访问硬件资源，而是提供便捷的方式去访问物理资源。</li></ol><ul><li><p>提供文件服务(文件名)方便对硬盘资源进行交互操作，使用read、write、open接口使用硬盘资源</p></li><li><p>通过进程访问cpu的资源，同时应用也不需要考虑时间共享问题，系统中有调度程序去控制进程的切换。</p></li></ul><ol><li><strong>编程便捷性</strong>：对于程序员来说，我们不需要记住这些硬件的(二进制)指令来进行编程，而是通过简单易懂的接口直接使用物理资源进行程序编写。</li></ol><h1 id="模式与系统调用"><a href="#模式与系统调用" class="headerlink" title="模式与系统调用"></a>模式与系统调用</h1><h2 id="强隔离性："><a href="#强隔离性：" class="headerlink" title="强隔离性："></a>强隔离性：</h2><ul><li><strong>应用与硬件隔离</strong>：禁止应用直接<strong>访问</strong>敏感的<strong>硬件资源</strong>，将资源抽象为服务。例如使用文件系统调用接口去访问磁盘。</li><li><strong>进程隔离</strong>：一个进程不能够访问(操作)另一个进程的资源，例如：不能篡改另一个进程的内存资源</li><li><strong>硬边界(安全性)</strong>：用户空间与内核空间的实现。当应用出错时，O/S进程不会被这一个应用影响，相反O/S会将这个错误应用清除并运行另一个应用</li></ul><blockquote><p>O/S实现强隔离性</p></blockquote><ol><li>应用禁止修改O/S的数据结构和指令</li><li>应用不能访问其他进程资源</li></ol><blockquote><p>CPU提供隔离性</p></blockquote><p>在RISC-V这样中三种特权模式：</p><ol><li>机器模式(machine mode)：CPU初始时以该模式启动，并且指令最高特权级运行，该模式主要用于配置计算机。</li><li>管理者模式(supervisor mode)：允许CPU执行特权指令，如禁用中断，读写页表地址寄存器等。用户执行这些指令会导致程序终止。运行在内核空间的<strong>软件</strong>称为内核，其可以执行特权指令</li><li>用户模式(user mode)：应用只能执行用户指令，运行在用户空间。</li></ol><h2 id="特权模式转换"><a href="#特权模式转换" class="headerlink" title="特权模式转换"></a>特权模式转换</h2><p>应用想要调用内核函数(系统调用)必须要转到内核，但是应用不能直接调用内核函数，</p><p>CPU提供了特别指令：从用户模式到管理者模式然后进入内核指定的入口点(entry point)。在RISC-V中使用ecall可以达到目的</p><p>当CPU转换到管理者模式，内核将验证系统调用的参数，决定是否要执行请求操作。</p><blockquote><p>特权级修改指令</p></blockquote><ul><li><strong>ecall</strong>：当进程使用系统调用将会执行ecall指令(RISC-V)，该指令将会<strong>提升硬件的特权级</strong>，改变程序计数器到内核定义的入口点(entry point)。这样就可以转到内核栈并执行内核指令。</li><li><strong>sret</strong>：当内核执行完系统调用返回用户空间时，使用sret指令将会降低硬件的特权级，并重新执行用户指令</li></ul><h1 id="内核组织"><a href="#内核组织" class="headerlink" title="内核组织"></a>内核组织</h1><blockquote><p>关键：O/S运行在管理者模式</p></blockquote><h2 id="单内核-monolithic-kernel"><a href="#单内核-monolithic-kernel" class="headerlink" title="单内核(monolithic kernel)"></a>单内核(monolithic kernel)</h2><blockquote><p>定义：整个操作系统都在内核空间中，所有系统调用都运行在管理者模式</p></blockquote><p>这种内核组织中整个O/S以完全的(full)硬件特权级运行，这样的方便之处在于</p><ul><li>OS的设计者不需要决定O/S的那一个部分需要完全硬件特权级</li><li>使O/S不同部分之间的协作更加简单，如文件系统与虚拟内存系统可以共享缓冲区缓存</li></ul><blockquote><p>缺点</p></blockquote><ul><li>O/S的不同部分的接口会更加复杂，容易让系统开发者犯错。同时在单内核中犯错是致命的</li><li>内核故障会导致整个计算机停止工作，同时应用也会故障，计算机必须重启才行。</li></ul><h2 id="微内核-microkernel"><a href="#微内核-microkernel" class="headerlink" title="微内核(microkernel)"></a>微内核(microkernel)</h2><blockquote><p>定义：减少大量运行在管理者模式的OS代码，并将大部分的OS在用户模式运行</p></blockquote><p>图2.1</p><p>图中阐明了，文件系统像一个用户程序一样运行，作为进程运行的OS服务称为<strong>服务器</strong>，为了允许应用与文件服务器交互，内核提供了了进程间的交流机制从一个用户进程发送消息(message)到另一个进程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，单内核与微内核都非常普遍。许多Unix的内核实现如单内核，而向Minix、L4、QNX这样的OS就是微内核，并且微内核经常适用于嵌入式设置开发。</p><p>xv6是一个单内核实现的(类unix系统)，因此xv6内核接口相对于OS接口，内核实现完全像是一个OS。</p><h2 id="代码：xv6组织"><a href="#代码：xv6组织" class="headerlink" title="代码：xv6组织"></a>代码：xv6组织</h2><p>xv6的内核资源圈在kernel/的子文件中，资源也是被分为文件，像是一个个模块一样。图2.2也列出了这些文件，模块间的接口定义在(kernel/defs.h)中。</p><h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><p>xv6中的<strong>隔离单元</strong>(unit of isolation)就是一个进程，进程抽象是为了预防进程破坏或是监听另一进程的资源(CPU、内存、文件描述符等)，同时也保证了进程不会破坏内核程序，更不可能破坏内核的隔离机制。</p><blockquote><p>进程抽象对隔离性的实施提供了帮助</p></blockquote><ul><li>程序像是运行在一个私有的机器上。这机器中有私有的内存系统和地址空间，其他进程禁止读写。同时进程运行在这个机器的CPU上，执行程序指令。</li></ul><p>但实际上这个机器上可以运行许多个程序，而进程都会共享机器的CPU、内存(虚拟内存)等资源。进程的抽象给进程造成了一种假象，那就是这个机器只有我这一个程序在运行。</p><blockquote><p>页表提供了内存的隔离性</p></blockquote><p>xv6中我们使用了页表(用硬件实现的)给每个进程一个私有空间，将内存的物理空间(物理地址，physical address，PA)划分一个<strong>固定大小的地址空间</strong>(图2.3)给进程作为私有的虚拟空间(虚拟地址，virtual address，VA)。</p><p>那么通过这样就可以实现内存上的隔离，简单来说就是将一块大蛋糕(物理内存)划分给每一个进程，给它们一种自己得到所有蛋糕的错觉，那么它们就不会打扰其他进程的运行了</p><p>RISC-V页表的作用，主要是将虚拟地址通过映射转换为一个物理地址，也就是<strong>map</strong>(VA-&gt;PA)</p><p>xv6中维持了给每一个页表维持了一个独立的页表，定义了进程的地址空间。进程的虚拟地址空间是从0开始的，如图2.3中的布局</p><ol><li>user text and data：保存了指令与全局变量</li><li>user stack：用户栈，保存了局部变量与函数调用地址</li><li>heap：堆，用户可以根据需求进行扩展(malloc)</li><li>trapframe：一个页(page)，映射保存/恢复用户进程的状态</li><li>trampoline：一个页(page)，包含进出内核的代码</li></ol><blockquote><p>进程地址空间有所限制，RISC-V是一个64位宽的指针，在页表硬件只用低39位查找虚拟地址空间，xv6只使用39位中的38位。最大的地址空间为$MAXVA=2^{38}-1$ = 0x3fffffffff。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Figure2.3.png" alt="Figure2.3.png"></p><h3 id="进程的虚拟内存分配-扩展"><a href="#进程的虚拟内存分配-扩展" class="headerlink" title="进程的虚拟内存分配(扩展)"></a>进程的虚拟内存分配(扩展)</h3><blockquote><p>《CSAPP》<strong>进程地址空间</strong>分配:：进程创建时会分配这些固定的内存，从上到下依次为</p></blockquote><ol><li>用户<strong>栈(Stack)</strong>(运行期创建)：函数调用与局部数据变量</li><li>内存<strong>映射</strong>区域：链接共享库</li><li>运行期<strong>堆(heap)</strong>：C语言以malloc分配，C++以new分配</li><li><strong>读写段</strong>(R/W Segment)：<ul><li>.data:已经初始的全局变量和静态变量(C语言的Static变量)。</li><li>.bss:未初始化(或是初始化为0)的全局变量和静态变量。<br>说明全局变量和静态变量(全局静态变量也是一样)的生命周期是编译期到程序结束，注意局部的变量是保存在用户栈中。</li></ul></li><li><strong>只读段</strong>(R/O Segment)：<ul><li>.init:定义了一个小函数，叫做_init，被程序初始化代码调用</li><li>.text:编译期生成的机器码</li><li>.rodata:只读数据，如printf语句中的格式化字符串，或是const声明的变量</li></ul></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230128020458.png" alt="Process space"></p><blockquote><p><strong>程序计数器:</strong> program counter 简称为PC</p></blockquote><p>PC是CPU中的<strong>寄存器</strong>，保存了当前正在执行的指令的地址（位置）。当每个指令被获取，PC的<strong>存储地址加一</strong>。在每个指令被获取之后，程序计数器指向顺序中的下一个指令。当计算机重启或复位时，程序计数器通常恢复到零。</p><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul><li>线程(thread)：进程最开始只有一个线程，运行进程的指令</li><li>内核栈：p-&gt;kstack，内核栈是一个独立存在，因此，进程的用户栈出现问题时，内核也可以运行。</li><li>用户栈：储存局部变量等数据</li><li>进程状态：p-&gt;state，xv6中进程状态：分配(allocated)、就绪(ready)、运行(running)、阻塞(blocked)</li><li>页表：p-&gt;pagetable，页表作为物理地址的记录分配后存储在内存中，在用户空间执行进程时，xv6使分页硬件使用p-&gt;pagetable。</li></ul><blockquote><p>栈的切换</p></blockquote><ol><li>进程运行用户指令只使用用户栈，而用户栈为空</li><li>进程进入内核，用户栈会保存数据，但不会使用这个栈</li><li>进程的线程将会选择用户栈与内核栈</li></ol><h3 id="进程状态-扩展-：OSTEP"><a href="#进程状态-扩展-：OSTEP" class="headerlink" title="进程状态(扩展)：OSTEP"></a>进程状态(扩展)：OSTEP</h3><ul><li>运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。</li><li>就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。</li><li>阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器。</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230130003713.png" alt="Process: State Transitions"></p><blockquote><p>进程：两个主要设计思想</p></blockquote><ol><li>地址空间(<strong>内存虚拟化</strong>)：给进程以为自己拥有整个内存的错觉</li><li>线程(<strong>CPU虚拟化</strong>)：给进程以为自己独占CPU的错觉</li></ol><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在xv6的内核维持了进程的许多状态，全都汇集到了struct proc数据结构中。我们通常使用p-&gt;xxx指向一个proc结构体中的元素。</p><blockquote><p>进程重要的状态</p></blockquote><ul><li>页表</li><li>内核栈(p-&gt;kstack)</li><li>运行状态(proc.h中procstate枚举类型)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br></pre></td></tr></table></figure><h3 id="CPU状态"><a href="#CPU状态" class="headerlink" title="CPU状态"></a>CPU状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="XV6启动"><a href="#XV6启动" class="headerlink" title="XV6启动"></a>XV6启动</h1><h2 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h2><blockquote><p>加载内核</p></blockquote><p>RISC-V主板电源启动-&gt;ROM中的主引导程序(Boot loader)将内核程序载入内存-&gt;进入机器模式</p><blockquote><p>加载机器模式(machine mode)</p></blockquote><p>CPU执行<code>_entry</code>程序，将分页(paging)硬件禁用(start.c:34)：虚拟内存直接映射到物理内存</p><blockquote><p>为什么XV6内核在内存中的初始化物理地址为0x80000000？</p></blockquote><p>0x00000000:0x80000000这一段地址保存的是I/O的设备</p><blockquote><p>生成内核栈</p></blockquote><p><code>_entry</code>中加载了栈指针寄存器<code>sp</code>其地址为stack0+4096,处于栈顶(栈在RISC-V中是向下增长的),生成内核栈。</p><blockquote><p>设置寄存器</p></blockquote><p>entry.S在之后调用了start.c文件，开始配置特权模式</p><p><code>mret</code>这个指令，可以让CPU进入管理者(surpervisor)模式，主要是用于让上一个调用中返回，从管理者模式返回到机器模式。</p><ol><li>mstatus：保存了上一个特权模式，调用mret指令就进入该特权模式</li><li><strong>mepc</strong>：设置mret的返回地址</li><li><strong>satp</strong>：页表寄存器，写入0就禁用了页表硬件</li></ol><blockquote><p>初始化时钟，设置时间片</p></blockquote><p>start函数最后调用mret指令，将程序计数器转到main，进入管理者模式转到main.c程序中</p><p>内核模式如何配置查看后续的代码分析中的main函数</p><h2 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="1-entry-S：生成内核栈"><a href="#1-entry-S：生成内核栈" class="headerlink" title="1.entry.S：生成内核栈"></a>1.entry.S：生成内核栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # 设置C语言的栈</span><br><span class="line">        # stack0在start.c中被声明</span><br><span class="line">        # with a 4096-byte stack per CPU. 每个CPU的栈只有4096字节</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure><h3 id="2-start-c"><a href="#2-start-c" class="headerlink" title="2.start.c"></a>2.start.c</h3><ul><li>在11行处声明了，stack0</li><li>在21行处<code>_entry</code>被调用入了C代码</li></ul><blockquote><p>start不会像一个调用一样返回(returning)，而是将这些事情设置的像有过调用一样，并且在机器模式下执行</p></blockquote><ol><li>通过在寄存器<code>mstatus</code>中，设置之前的特权模式为管理者模式(24-27行)</li><li>通过写入main地址到寄存器<code>mepc</code>，设置返回地址为main的地址(31行)</li><li>通过写入0到页表寄存器<code>satp</code>，在管理者模式中将<strong>虚拟地址禁用</strong>(34行)</li><li>将所有的异常与中断托付给<strong>管理者模式</strong>(37-39行)</li><li>管理者模式能够接触到所有物理内存(43-44行)</li></ol><p>简单来说通过设置mstatus的模式为管理者模式，通过调用mret就能进入管理者模式了。而我们将mret的返回地址设置为main，这样xv6就在管理者模式中进入内核程序的主函数中了</p><blockquote><p>时钟生成</p></blockquote><p>在进入管理者模式之前，<code>start</code>还要执行一个任务(47行)：对时间切片进行编程初始化<strong>时钟中断</strong>。</p><blockquote><p>进入管理者模式,转到内核主函数</p></blockquote><p>在54行处通过mret汇编代码转换为管理者模式(内核模式)，进入main函数,mret指令最多被用来从先前的管理者模式转到机器模式。之后程序的计数器转到main函数(main.c:11)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timerinit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S needs one stack per CPU.内核栈</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a scratch area per CPU for machine-mode timer interrupts.</span></span><br><span class="line">uint64 timer_scratch[NCPU][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">timervec</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="user-main-c"><a href="#user-main-c" class="headerlink" title="user/main.c"></a>user/main.c</h3><p>main程序初始化设备与子系统(文件系统)，它通过userinit(proc.c:233行)去创建第一个进程。第一个进程将会执行汇编写的程序user/initcode.S，进行第一个系统调用。</p><p>在initcode.S(3行)载入了exec系统调用的编号，SYS_EXEC(syscall.h:8行)到寄存器a7然后调用ecall返回到内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>内核在syscall(132行)中使用寄存器a7的编号，去调用想要的系统调用。系统调用表(syscall.c)持有SYS_EXEC到sys_exec的映射</p><p>当内核完成exec，将会/init进程<strong>返回到用户空间</strong>。init(user/init.c:15行)创建一个控制台的设备文件，然后在控制台中启动console，xv6启动了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p><a href="https://blog.csdn.net/u011675745/article/details/122656997#:~:text=Undefined%20item%3A%20%22riscv%3Arv64%22%20%E4%BD%BF%E7%94%A8%20gdb-multiarch%20%E6%97%B6%E4%BC%9A%E5%9C%A8%E5%BC%80%E5%A4%B4%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%20set%20architecture,riscv64%20%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%8C%E6%80%AA%E4%B8%8D%E5%BE%97%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E3%80%82%20%E5%9C%A8%20Stack%20Overflow%20%E4%B8%8A%E6%89%BE%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E8%AF%B4%E9%9C%80%E8%A6%81%E5%B0%86%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%88%B0%208.3%20%E4%BB%A5%E4%B8%8A%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82">参考链接</a></p><blockquote><p>我的实验环境为<strong>ubuntu20.04</strong>，只有gdb-multiarch这个gdb调试工具</p></blockquote><h2 id="连接GDB-Server"><a href="#连接GDB-Server" class="headerlink" title="连接GDB Server"></a>连接GDB Server</h2><ol><li><p>打开一个terminal，在xv6的文件夹中键入make qemu-gdb打开gdbserver。在课程演示中我们使用了CPUs=1这个选项以一个cpu运行xv6<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091040.png" alt="image.png"></p></li><li><p>再打开一terminal，同样在xv6文件夹中，键入gdb-multiarch这个命令就可以链接到gdb-server了，链接成功后如图所示<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091420.png" alt="image.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugin Plus</title>
      <link href="/2023/01/27/Tag%20Plugins%20Plus/"/>
      <url>/2023/01/27/Tag%20Plugins%20Plus/</url>
      
        <content type="html"><![CDATA[<h1 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h1><ol><li>安装插件,在博客根目录[Blogroot]下打开终端，运行以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure><p>考虑到hexo自带的markdown渲染插件hexo-renderer-marked与外挂标签语法的兼容性较差，建议您将其替换成hexo-renderer-kramed</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol><li>添加配置信息，以下为写法示例</li></ol><p>在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag-plugins-plus</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/615e2dec/</span></span><br><span class="line"><span class="attr">tag_plugins:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="literal">false</span> <span class="comment">#issues标签依赖注入开关</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">/img/link.png</span> <span class="comment">#link_card标签默认的图标图片</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line">    <span class="attr">anima:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css</span> <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">    <span class="attr">jquery:</span> <span class="string">https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">issues:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">iconfont:</span> <span class="string">//at.alicdn.com/t/font_2032782_8d5kxvn09md.js</span> <span class="comment">#参看https://akilar.top/posts/d2ebecef/</span></span><br><span class="line">    <span class="attr">carousel:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js</span></span><br><span class="line">    <span class="attr">tag_plugins_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css</span></span><br></pre></td></tr></table></figure><ol><li>参数释义</li></ol><div class="table-container"><table><thead><tr><th>参数</th><th>备选值/类型</th><th>释义</th></tr></thead><tbody><tr><td>enable</td><td>true/false</td><td>【必选】控制开关</td></tr><tr><td>priority</td><td>number</td><td>【可选】过滤器优先级，数值越小，执行越早，默认为10，选填</td></tr><tr><td>issues</td><td>true/false</td><td>【可选】issues标签控制开关，默认为false</td></tr><tr><td>link.placeholder</td><td>【必选】link卡片外挂标签的默认图标</td><td></td></tr><tr><td>CDN.anima    URL</td><td>URL</td><td>【可选】issues标签依赖</td></tr><tr><td>CDN.iconfont    URL</td><td>URL</td><td>【可选】iconfont标签symbol样式引入，如果不想引入，则设为false</td></tr><tr><td>CDN.carousel</td><td>URL</td><td>【可选】carousel旋转相册标签鼠标拖动依赖，如果不想引入则设为false</td></tr><tr><td>CDN.tag_plugins_css</td><td>URL</td><td>【可选】外挂标签样式的CSS依赖，为避免CDN缓存延迟，建议将@latest改为具体版本号</td></tr></tbody></table></div><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="分栏tab"><a href="#分栏tab" class="headerlink" title="分栏tab"></a>分栏tab</h2><div class="tabs" id="分栏tab"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#分栏tab-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏tab-2">配置参数</button></li><li class="tab active"><button type="button" data-href="#分栏tab-3">样例展示</button></li><li class="tab"><button type="button" data-href="#分栏tab-4">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="分栏tab-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏tab-2"><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子/页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="分栏tab-3"><blockquote><p>Demo 1 - 预设选择第一个【默认】</p></blockquote><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 2 - 预设选择tabs</p></blockquote><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 3 - 没有预设值</p></blockquote><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p></blockquote><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏tab-4"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="链接卡片link"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#链接卡片link-1">标签语法</button></li><li class="tab active"><button type="button" data-href="#链接卡片link-2">样式预览</button></li><li class="tab"><button type="button" data-href="#链接卡片link-3">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="链接卡片link-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="链接卡片link-2"><div class="tag link"><a class="link-card" title="TagPlugin教程" href="链接"><div class="left"><img src="/img/favicon.ico"/></div><div class="right"><p class="text">TagPlugin教程</p><p class="url">链接</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="链接卡片link-3"><div class="tag link"><a class="link-card" title="TagPlugin教程" href="链接"><div class="left"><img src="/img/favicon.ico"/></div><div class="right"><p class="text">TagPlugin教程</p><p class="url">链接</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="引用文献"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#引用文献-1">标签语法</button></li><li class="tab"><button type="button" data-href="#引用文献-2">参数配置</button></li><li class="tab active"><button type="button" data-href="#引用文献-3">样式预览</button></li><li class="tab"><button type="button" data-href="#引用文献-4">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="引用文献-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="引用文献-2"><p>referto 引用上标<br>id: 上标序号内容，需与referfrom标签的id对应才能实现跳转<br>literature: 引用的参考文献名称</p><p>referfrom 引用出处<br>id: 序号内容，需与referto标签的id对应才能实现跳转<br>literature: 引用的参考文献名称<br>url: 引用的参考文献链接，可省略</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="引用文献-3"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，Butterfly主题<span class="hidden-anchor" id="referto_[3]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[7]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[8]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[9]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="引用文献-4"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 魔改日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> 魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可调用对象</title>
      <link href="/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="std-function-and-bind"><a href="#std-function-and-bind" class="headerlink" title="std::function and bind"></a>std::function and bind</h1><h2 id="可调用对象-Callable-Object"><a href="#可调用对象-Callable-Object" class="headerlink" title="可调用对象(Callable Object)"></a>可调用对象(Callable Object)</h2><ol><li><p>函数指针</p></li><li><p>具有operator()成员函数的类对象(仿函数)</p></li><li><p>可被转换为函数指针的类对象</p></li><li><p>类成员函数指针</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;函数指针&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;仿函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">fr_t</span> = <span class="built_in">void</span>(*)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;指向函数的类对象&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">fr_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;成员函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">void</span>) = func;</span><br><span class="line">    <span class="built_in">func_ptr</span>();</span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (A::*mem_func_ptr)(<span class="type">void</span>) = A::mem_func;</span><br><span class="line">    <span class="type">int</span> A::*mem_obj_ptr = &amp;A::a;</span><br><span class="line"></span><br><span class="line">    A aa;</span><br><span class="line"></span><br><span class="line">    (aa.*mem_func_ptr)();</span><br><span class="line"></span><br><span class="line">    aa.*mem_obj_ptr = <span class="number">123</span>;</span><br><span class="line">    std::cout&lt;&lt;aa.a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可调用对象的包装器-std-function"><a href="#可调用对象的包装器-std-function" class="headerlink" title="可调用对象的包装器-std::function"></a>可调用对象的包装器<code>-std::function</code></h2><blockquote><p>简介</p></blockquote><p>它是一个类模板，可以容纳类成员(函数)指针(<strong>需要用bind该函数将实际对象绑定</strong>)之外的所有可调用对象。通过指定他的模板参数，它可以统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</p><blockquote><p>弹性更强</p></blockquote><ul><li>对于函数对象的返回值可以进行适当隐式转换(short and float -&gt; int)(兼容性)</li><li>对于函数对象的参数可以被隐式转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> f_int = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">foo_func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;    </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">f_int</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo_func;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f</span><span class="params">()</span></span>&#123;</span><br><span class="line">       std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr1 = func;</span><br><span class="line">    <span class="built_in">fr1</span>();</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr2 = Foo::foo_func;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr2</span>(<span class="number">2</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//隐式转换类型</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr3 = <span class="built_in">Foo</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr3</span>(<span class="number">3</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr4 = <span class="built_in">Bar</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr4</span>(<span class="number">4</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind和function联合</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----bind and function---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> bf1 = std::<span class="built_in">bind</span>(&amp;A::mem_func,&amp;a);<span class="comment">//第二个引用可有可无</span></span><br><span class="line">    <span class="keyword">auto</span> bp1 = std::<span class="built_in">bind</span>(&amp;A::a,a);<span class="comment">//第二个取引用只是指向该类的对象</span></span><br><span class="line">    <span class="built_in">bp1</span>() = <span class="number">123</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">bp1</span>()&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;a.a&lt;&lt;std::endl;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr5 = bf1;</span><br><span class="line">    <span class="built_in">fr5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test_f</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">call_when_even</span>(i,output);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind用来将可调用对象与其参数一起进行绑定，绑定后的结构可以使用std::function进行保存，并延迟调用到任何我们需要的时候</p><blockquote><p>作用</p></blockquote><ol><li><p>将可调用对象与其参数一起帮定成一个仿函数</p></li><li><p>将多元参数可调用对象转成一元或者(n-1)元金额调用对象，及只绑定部分参数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FuncEntity</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">eFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FuncEntity e;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">bind</span>(&amp;FuncEntity::eFunc,e,std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">a</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add_2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x+<span class="number">2</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output_add_2,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>        <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::bind</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();                           <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);      <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);      <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="comment">// error: 调用时没有第二个参数</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>);</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 输出: 2 2</span></span><br><span class="line">   <span class="comment">// 调用时的第一个参数被吞掉了</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1,std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_2,std::placeholders::_1)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind简化和增强bind1st和bind2nd"><a href="#bind简化和增强bind1st和bind2nd" class="headerlink" title="bind简化和增强bind1st和bind2nd"></a>bind简化和增强bind1st和bind2nd</h3><p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道，bind1st和bind2nd的作用是将一个二元算子转换成一个一元算子，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><hr><p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，并且还要想想到底是用bind1st还是bind2nd，用起来十分不便。</p><p>现在我们有了bind，就可以以统一的方式去实现了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>这样就不用关心到底是用bind1st还是bind2nd，只需要使用bind即可。</p><p>2.使用组合bind函数</p><p>bind还有一个强大之处就是可以组合多个函数。假设要找出集合中大于5小于10的元素个数应该怎么做呢？</p><p>首先，需要一个用来判断是否大于5的功能闭包，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这里std：：bind返回的仿函数只有一个int参数。当输入了这个int参数后，输入的int值将直接和5进行大小比较，并在大于5时返回true。</p><p>然后，我们需要一个判断是否小于10的功能闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>有了这两个闭包之后，只需要用逻辑与把它们连起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>然后就可以复合多个函数（或者说闭包）的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// 查找集合中大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>小于</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素个数</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), f);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FaRM</title>
      <link href="/2023/01/20/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/20/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="FaRM高性能分布式事务"><a href="#FaRM高性能分布式事务" class="headerlink" title="FaRM高性能分布式事务"></a>FaRM高性能分布式事务</h1><blockquote><p><strong>Title:</strong> No compromises: distributed transactions with consistency, availability, and performance</p></blockquote><h2 id="FaRM-Overview"><a href="#FaRM-Overview" class="headerlink" title="FaRM Overview"></a>FaRM Overview</h2><blockquote><p><strong>FaRM</strong> = Fast + Remote + Memory</p></blockquote><h3 id="为何要学习FaRM"><a href="#为何要学习FaRM" class="headerlink" title="为何要学习FaRM"></a>为何要学习FaRM</h3><ul><li><p>另一种对transactions+replication+sharding的实现：这仍然在研究领域，没有投入实际生产。</p></li><li><p>乐观并发控制OOC(stric serializability)</p></li><li><p>利用了了RDAM NICs的巨大性能潜力。</p></li></ul><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><ul><li><p>FaRM全部通讯都在一个数据中心</p><ul><li>与Spanner不同的是，Spanner全球性的广域的设计</li></ul></li><li><p>configuration manager：使用ZooKeeper, 选择主从复制 primaries/backups</p></li><li><p>Shards采用主从复制(只有在恢复的时候会进行通信)<br>  P1 B1<br>  P2 B2<br>  …</p><ul><li>只要至少有一个shard的副本就能恢复</li><li>f+1的副本就容忍f次的故障</li></ul></li><li><p>事务代码充当两阶段提交的事务协调器(TC)</p></li></ul><h3 id="FaRM目标"><a href="#FaRM目标" class="headerlink" title="FaRM目标"></a>FaRM目标</h3><ul><li>每秒完成百万数量级的事务<ul><li>时间的预算是几十微妙</li></ul></li></ul><h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><h3 id="如何高性能"><a href="#如何高性能" class="headerlink" title="如何高性能"></a>如何高性能</h3><ul><li><p>在多个服务器上进行分片(在评估中是90个)</p></li><li><p>数据必须符合总RAM(因此没有磁盘读取)</p></li><li><p>降低CPU的利用率 </p><ul><li>非易失性RAM(因此没有磁盘写入)</li><li>one-sided RDMA(快速跨网络访问内存)</li></ul></li><li><p>快速用户级访问网卡</p></li><li><p>事务+复制协议，利用单边RDMA</p></li></ul><h3 id="NVRAM-non-volatile-RAM"><a href="#NVRAM-non-volatile-RAM" class="headerlink" title="NVRAM (non-volatile RAM)"></a>NVRAM (non-volatile RAM)</h3><p>FaRM 直接写入RAM不需要写入磁盘 — eliminates a huge bottleneck</p><ul><li>RAM write takes 200 ns, hard drive write takes 10 ms, SSD write 100 us<ul><li>ns = nanosecond, ms = millisecond, us = microsecond<br>但是当我们在电源故障后将会使RAM的内容丢失，RAM不能持久化。因此我们使用了UPS。</li></ul></li></ul><h4 id="UPS-distributed-uninterruptible-power-supply"><a href="#UPS-distributed-uninterruptible-power-supply" class="headerlink" title="UPS(distributed uninterruptible power supply)"></a>UPS(distributed uninterruptible power supply)</h4><p>装备电池在每个机架上，当服务器发生断电时，可以再让运行机器几分钟。具体执行过程如下</p><ul><li><p>电源硬件通知软件当主电源断电，软件停止所有事务，软件将FaRM的RAM的数据写入到SSD，可能几分钟后机器就会关机。</p></li><li><p>在重新启动时，FaRM从SSD读取保存的内存映像“非易失性RAM”</p></li></ul><h4 id="如果奔溃阻止了软件写入SSD"><a href="#如果奔溃阻止了软件写入SSD" class="headerlink" title="如果奔溃阻止了软件写入SSD?"></a>如果奔溃阻止了软件写入SSD?</h4><p>例如FaRM或内核中的bug或者cpu/内存/硬件错误，FaRM处理单机崩溃和复制崩溃(除了电源故障)必须是独立的!因此崩溃不会阻止FaRm写入将RAM的数据写入SSD</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>NVRAM消除了持久写入瓶颈，剩下的瓶颈是网络和CPU</p><h3 id="降低CPU使用率-Reduce-CPU-Utilization"><a href="#降低CPU使用率-Reduce-CPU-Utilization" class="headerlink" title="降低CPU使用率(Reduce CPU Utilization)"></a>降低CPU使用率(Reduce CPU Utilization)</h3><h4 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h4><p>为什么网络在通常情况下会是性能瓶颈？</p><ul><li>FaRM假设只有一个数据中心，因此具有较低的光速延迟</li><li>但网络数据处理的CPU成本往往很大</li></ul><p>网络交互：<br>从应用中将数据写入socket的缓存中通过TCP封装，传递给网卡的硬件驱动，通过网卡进行发送。如下述例子所述<br>    app                               app</p><pre><code>---                                 ---socket buffers               buffersTCP                               TCPNIC driver                     driverNIC  -------------------- NIC</code></pre><p>大量昂贵的CPU操作如系统调用、复制信息、中断、上下文转换。这些都会成为FaRM的性能瓶颈</p><h4 id="Kernel-bypass"><a href="#Kernel-bypass" class="headerlink" title="Kernel bypass"></a>Kernel bypass</h4><blockquote><p>NIC直接访问内存</p></blockquote><p>FaRM应用直接与网卡交互，<strong>没有系统调用与内核参与</strong> </p><ul><li><p>网卡使用DMA访问用户的RAM</p></li><li><p>FaRM轮询DMA(内存)区域检查收入的消息</p><ul><li>NIC会维持一个接收消息的队列 </li></ul></li><li><p>网卡轮询DMA(内存)区域检查发送的消息</p><ul><li>NIC会维持一个发送消息的队列</li></ul></li><li><p>轮询是一个线程，用于代替系统中断，直接访问消息队列</p></li></ul><h4 id="one-sided-RDMA"><a href="#one-sided-RDMA" class="headerlink" title="one-sided RDMA"></a>one-sided RDMA</h4><blockquote><p>remote NIC directly reads/writes memory：宏观来讲就是直接访问另一台机器的内存且接收方CPU不参与操作</p></blockquote><p><strong>RDMA</strong>：是一些现代网卡实现的特殊功能。网卡寻找通过网络到达的特殊命令包，并自行执行命令(<strong>而不将包交给CPU</strong>)。这些命令指定内存操作，例如将值写入地址或从地址读取并通过网络将值发回。</p><p>此外，RDMA网卡允许应用程序代码直接与NIC通信以发送特殊的RDMA命令包，并在“<strong>硬件ACK</strong>”包到达时收到通知，表明接收网卡已经执行了命令。</p><ul><li><p>“One-sided” “指的是一台计算机中的应用程序代码使用这些RDMA网卡直接读取或写入另一台计算机中的内存，而<strong>不涉及另一台计算机的CPU</strong>。</p></li><li><p>FaRM有时使用RDMA作为一种快速方法来实现类似rpc的方案，以便与接收计算机上运行的软件进行通信。</p></li><li><p>RDMA的好处是速度快。单向RDMA读写只需1/18微秒，而传统RPC可能需要10微秒。即使FaRM使用RDMA进行消息传递也比传统RPC快得多:接收器中的用户空间代码经常<strong>轮询传入的NIC队列</strong>，以便快速查看新消息，而不是涉及中断和用户/内核转换。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM4.PNG" alt=""><br>该图表示了FaRM应用通过Kernel bypass + RDMA降低了CPU的利用率。NIC是一个特殊的网卡同时支持kernel bypass与RDMA。</p><ul><li><p>通过Kernel bypass发送消息将直接发送包到NIC不需要CPU参与</p></li><li><p>通过one-sided RDMA，接收方的接收处理包也不需要CPU的参与</p></li><li><p><strong>RDMA Read：</strong> “Validate”阶段仅使用one-sided读取。</p><ul><li>将请求对象的包(头部设置为RDMA包)，加入NIC的发送队列，传送到目的主机的接收队列，进行定时轮询内存区域，FaRM应用将对象的数据再通过NIC回复给请求主机</li></ul></li><li><p><strong>RDMA Write：</strong> “Lock”阶段以这种方式使用RDMA。(不需要加入NIC队列)</p><ul><li>发送方使用RDMA将请求消息写入接收方FaRM软件轮询(定期检查)的内存区域，将请求消息放入消息队列进行处理、Record写入Log，接收方以同样的方式发送应答。 </li></ul></li></ul><h2 id="编程模型与架构"><a href="#编程模型与架构" class="headerlink" title="编程模型与架构"></a>编程模型与架构</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM5.PNG" alt=""></p><h4 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h4><ul><li><p><strong>Region：</strong> 可以看作一个2GB的字节数组，其中包含了多个Object。同时Region也对应着(Pi,Bi)的映射</p></li><li><p><strong>Object：</strong> 一个数据结构，用于存储数据。object有唯一的一个标识符为oid，oid对应了Region号与地址，并且object的头部包含了一个64为的整数，高1位表示的是否Lock，低63位标识版本号</p></li><li><p><strong>Zookeeper：</strong> 作为FaRM的服务协调，提供一个Coordinator Management</p></li><li><p><strong>SSD：</strong> 断电时存储RAM内的数据</p></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Txn BEGIN</span><br><span class="line"></span><br><span class="line">O &lt;------ Read(oid)</span><br><span class="line"></span><br><span class="line">O.f + 1 = 1</span><br><span class="line"></span><br><span class="line">write(oid,O)</span><br><span class="line"></span><br><span class="line">Txn COMMIT</span><br></pre></td></tr></table></figure><p>该例子中我们使用了两个API为read与write。我们通过调用read方法填入oid(object id)从而实现了获得数据对象O，在O的字段上+1并缓存到本地，之后再调用write方法将对象写入。(一个事务可能跨多个Region)</p><h2 id="分布式事务与复制"><a href="#分布式事务与复制" class="headerlink" title="分布式事务与复制"></a>分布式事务与复制</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM1.png" alt=""></p><p>图中虚线为处理读取，实线是写入，点线是硬件回复。其中P1、P2是处理读写事务，P3是只读事务。C为Zookeeper中的Coordinator[[ZooKeeper 论文笔记]]、P为Primary、B为Backup。黑色的方块为对象(副本中只有一个Backup，因此该副本只有一个容错)</p><ul><li><p>Coordiantor获取LOCK消息最后一条Ack消息的点为序列化点</p></li><li><p>Coordiantor获取VALIDATE消息的最后一条ACK消息的点为Decision点，<strong>事务开始提交</strong></p></li><li><p>Coordiantor获取COMMIT-PRIMARY的第一条ACK消息为开始提交的报告给应用，<strong>事务提交结束</strong></p></li></ul><h3 id="执行阶段-Execute-phase"><a href="#执行阶段-Execute-phase" class="headerlink" title="执行阶段(Execute phase)"></a>执行阶段(Execute phase)</h3><p>Coordinator进行操作</p><ul><li><p>one-sided RDMA对Primary进行读取(OCC)</p></li><li><p>将修改对象的内容缓存到本地</p></li><li><p>记录这些primary的<strong>地址</strong>以及读取并记录到的数据的<strong>版本号</strong>。</p><ul><li>如果Primary与backup与coordinator位于同一台机器上就不会使用RDMA进行读，而是使用本地内存进行访问(读取操作)</li></ul></li></ul><p>在Figure4中该阶段读取了三个分片，为S1，S2，S3</p><h3 id="提交阶段-Commit-phase"><a href="#提交阶段-Commit-phase" class="headerlink" title="提交阶段(Commit phase)"></a>提交阶段(Commit phase)</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li><p>原子性的分布式提交：全部写入或都没写入</p></li><li><p>序列化：每个事务都有先后顺序</p></li></ul><h4 id="五个步骤"><a href="#五个步骤" class="headerlink" title="五个步骤"></a>五个步骤</h4><ol><li><strong>Lock(写入日志).</strong> Coordinator通过<strong>RDMA Write</strong>发送一条Lock消息给每台读取对象的primary的日志中</li></ol><ul><li><p>Lock记录包含了这包含了oid、版本号和写对象的新值</p></li><li><p>Lock消息既是预读日志条目(Read-ahead log)，也是对主服务器的RPC请求。</p></li><li><p>日志将被加入到NVRAM中防止断电或者电源故障</p></li></ul><p><strong>收到LOCK后primary会做什么</strong>?</p><ul><li><p>FaRM软件轮询内存中的日志, 发现写入的日志</p><ul><li>检查日志，如果对象已经加锁了或者写入的对象的版本号与读取的不相同<ul><li>发送一个no的回复给coordinator</li></ul></li></ul></li><li><p>反之，将对象的Lock flag设置为1，回复一个yes给coordinator</p><ul><li><strong>并不会修改对象</strong>，也不会修改对象的版本号</li></ul></li><li><p>lock检查-&gt;版本号检查-&gt;lock的设置是原子性</p><ol><li>使用原子性的compare-and-swap指令将对象锁定在指定版本</li><li>防止其他CPU也在处理LOCK，或者客户端正在用RDMA读取</li></ol></li></ul><ol><li><strong>Validate(检查读取对象).</strong> Coordinator使用one-sided RDMA发送Validate消息给读取对象的primary，该消息只包含了oid以及版本号，执行读取验证(read Validate)。</li></ol><p><strong>Priamry处理</strong></p><p>检查Validate的版本号与primary内存中的版本号以及对象是否上锁</p><ul><li><p>如果冲突，则验证失败，发送no给coordinator，事务将会终止。</p></li><li><p>如果相同，则验证相同，发送yes给coordinator。</p></li><li><p>Validate默认使用的是one-side RDMA。</p></li></ul><ol><li><p><strong>Commit backups.(副本写入日志)</strong> Coordiantor写入一个COMMIT-BACKUP的记录(与Lock内容相同)到Backups的不易失的日志中，并等待不会让CPU中断的NIC硬件返送ACK消息。</p></li><li><p><strong>Commit primaries(处理日志).</strong> coordinator在接受到所有COMMIT-BACKUP的ACK消息后，Coordinator发送COMMIT-PRIMARY消息给每一台Primary中。</p></li></ol><ul><li>coordinator会等待硬件的ACK应答<ul><li>不会等待Primary处理日志</li><li>硬件应答意味着Primary的NVRAM很安全</li></ul></li></ul><p><strong>Primary处理日志</strong></p><ul><li><p>将新值拷贝到对象的内存中</p></li><li><p><strong>增加对象的版本号</strong></p></li><li><p>清除对象的lock flag，设置为0</p></li></ul><hr><ol><li><strong>Truncate.</strong> Primary与Backup中的日志会一直保存直到被截断。Coordinator接收到所有Primary的ACK后，将会阶段Primay与Backup的日志</li></ol><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><p>Q：为什么发现锁已经被其他锁占用后是中止而不是等待解除阻塞</p><p>A：Figure4中是读写事务，发现锁被其他事务占用说明我们读操作读取的数据的就已经被修改了，因此会破坏Strict Serializability，产生错误。</p><p>Q：Primary与Backup是主从复制，那为什么他们不直接通讯？</p><p>A：应用的设计是这样的，他们的一致性是由CM来保证(Lock与commit Backup消息内容相同)。只有在崩溃恢复时Primary与Backup会进行沟通。</p><p>Q：下述案例中，T2在T1完成Lock与Validate后，在T1提交前提交，这样会有什么样的错误(T1的validate阶段读取了T2修改的版本号)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1: Wx0 Wy0 Rz0 .....   L V .... C</span><br><span class="line"></span><br><span class="line">T2:             Rz0 Wz1 ... C</span><br></pre></td></tr></table></figure><p>A：T1 &lt; T2 ，T2在T1之后开始，因此根据严格序列化规则：T2必须看见T1的写入，因此根据该规则，T2的读也需要在T1提交之后才能执行。意思也就是T2比T1提前提交这种情况也是不会出现的。</p><h4 id="Log-Record-type"><a href="#Log-Record-type" class="headerlink" title="Log Record type"></a>Log Record type</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Log record type</th><th style="text-align:center">Content</th></tr></thead><tbody><tr><td style="text-align:center">LOCK</td><td style="text-align:center">transaction ID, IDs of all regions with objects written by the transaction, and addresses, versions, and values of all objects written by the transaction that the destination is primary for</td></tr><tr><td style="text-align:center">COMMIT-BACKUP</td><td style="text-align:center">contents are the same as lock record</td></tr><tr><td style="text-align:center">COMMIT-PRIMARY</td><td style="text-align:center">transaction ID to commit</td></tr><tr><td style="text-align:center">ABORT</td><td style="text-align:center">transaction ID to abort</td></tr><tr><td style="text-align:center">TRUNCATE</td><td style="text-align:center">low bound transaction ID for non-truncated transactions and transaction IDs to truncate</td></tr><tr><td style="text-align:center">表中展示了每条日志信息的类型以及对应的内容</td></tr></tbody></table></div><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><h4 id="乐观并发控制-OCC"><a href="#乐观并发控制-OCC" class="headerlink" title="乐观并发控制(OCC)"></a>乐观并发控制(OCC)</h4><blockquote><p><strong>OCC</strong>  = Serializability  + Snapshot isolation(MVCC)</p></blockquote><p> 对于读写事务中对于<strong>读操作是不需要加锁的</strong>，而写操作仍是需要加锁。读操作是通过Strict Serializaiblility来实现一致性。</p><p><strong>严格的序列化：</strong> 序列化点总是在开始执行和向应用程序报告完成之间(Figure4)</p><p>对于读操作我们在提交阶段加上了冲突检测版本号</p><ul><li>版本号冲突(写对象有锁或是版本号改变)的话事务中止(abort)</li><li>版本号相同则进行提交(commit)</li></ul><p>FaRM使用OCC的原因：</p><ul><li>使用了one-sided RDMA读取</li><li>服务器(CPU)不需要主动参与读取</li></ul><h4 id="Validate的作用"><a href="#Validate的作用" class="headerlink" title="Validate的作用"></a>Validate的作用</h4><p>当我们处理两事务：假设开始时X=0，y=0</p><ul><li>T1：if x == 0 ，set y = 1</li><li>T2：if y == 0 ，set x = 1</li></ul><p>我们假设可能产生的结果:绝不可能并发执行时产生x=1，y=1</p><ul><li>T1产生：x = 0 ，y = 1</li><li>T2产生：x = 1 ，y = 0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   excution   commit</span><br><span class="line">T1 Rx0 Ry0  | Ly Vx            Cy</span><br><span class="line"></span><br><span class="line">T2 Rx0 Ry0  |       Lx Vy(fail)   Cx</span><br></pre></td></tr></table></figure><p>当我们并发执行T1与T2：T1的x与T2的y都可以上锁</p><ol><li>首先T1先开始提交，将y上锁(不会增加对象版本号)，验证x；</li><li>然后T2开始提交，将x上锁，验证y，但是由于y已经上锁(说明y可能已经别其他对象修改)，因此需要中止T2事务</li></ol><h4 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h4><p>一个纯只读的FaRM事务只使用使用one-sided RDMA read：不需要写入、不需要日志、不需要锁。速率十分的快。(个人觉得不需要validate阶段像spanner的只读事务一样)</p><h4 id="提交时机"><a href="#提交时机" class="headerlink" title="提交时机"></a>提交时机</h4><ul><li>在<strong>最后一次读取</strong>后提交只读事务</li></ul><ul><li><p>在获取写锁时提交读写事务是<strong>可序列化的</strong></p><ul><li>在可序列化的点上的对象的版本号与执行阶段的相同</li></ul></li><li><p>Locking确定对象被写入，Validate确定对象为只读</p><ul><li>如果没有失败，这就相当于在<strong>序列化点原子地</strong>执行和提交整个事务。 </li></ul></li></ul><h4 id="提交协议"><a href="#提交协议" class="headerlink" title="提交协议"></a>提交协议</h4><ul><li><p><strong>传统两段提交协议：</strong> Participant可以在处理prepare消息时预留资源以提交事务，或者在没有足够的资源时拒绝准备事务。</p></li><li><p><strong>FaRM的提交协议：</strong></p><ul><li>在提交过程中避免Backup的CPU参加，Coordinator必须为所有参与者保留日志空间，以保证进度。</li><li>Coordinator为所有提交协议记录预留空间，包括在开始提交协议之前截断主日志和备份日志中的记录。<ul><li>如果截断被附加在另一条消息上，截断记录保留也会被释放 </li></ul></li></ul></li></ul><h2 id="Spanner-与-FaRM"><a href="#Spanner-与-FaRM" class="headerlink" title="Spanner 与 FaRM"></a>Spanner 与 FaRM</h2><h3 id="共同之处"><a href="#共同之处" class="headerlink" title="共同之处"></a>共同之处</h3><p>都是关于分片、复制和使用了事务的二段提交(2PC)</p><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><h4 id="Spanner"><a href="#Spanner" class="headerlink" title="Spanner:"></a>Spanner:</h4><ul><li><p>重点讨论由于地理复制而引起的网络延迟</p></li><li><p>Paxos提供容错延迟</p></li><li><p>TrueTime 让客户端读取当地的副本</p></li><li><p>性能方面: 读写事务处理花费10到100 ms (Tables 3 and 6)</p></li></ul><h4 id="FaRM"><a href="#FaRM" class="headerlink" title="FaRM"></a>FaRM</h4><ul><li><p>重点讨论减少CPU的利用率</p></li><li><p>RDMA、直接NIC获取、NVRAM去避免磁盘写入</p></li><li><p>RDMA让FaRM可以使用OCC</p></li><li><p>性能方面: 58微秒的时间处理简单的事务 (6.3, Figure 7)</p><ul><li>i.e. 比Spanner快100倍</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>超快速度的分布式事务</p></li><li><p>硬件是还处于研究阶段(NVRAM和RDMA)，但可能很快就会普及</p></li><li><p>使用OCC提高速度并允许快速One-sided RDMA读取</p></li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><h4 id="Q-目前使用FaRM的系统有哪些"><a href="#Q-目前使用FaRM的系统有哪些" class="headerlink" title="Q: 目前使用FaRM的系统有哪些?"></a>Q: 目前使用FaRM的系统有哪些?</h4><p>A: FaRM似乎是一个研究系统，而不是用于生产。我怀疑它会影响未来的设计，也许它本身会发展成一个生产系统。</p><h4 id="Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密"><a href="#Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密" class="headerlink" title="Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?"></a>Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?</h4><p>A: 这些公司发表的论文只涉及他们所编写软件的一小部分。他们发表文章的原因之一是，这些系统部分是由具有学术背景的人(即拥有博士学位的人)开发的，这些人认为他们人生的一部分使命是帮助世界理解他们发明的新思想。他们为自己的工作感到自豪，希望人们能欣赏他们的工作。另一个原因是，这些论文可能有助于公司吸引顶尖人才，因为这些论文是如何在那里进行智力上有趣的工作的。</p><h4 id="Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗"><a href="#Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗" class="headerlink" title="Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?"></a>Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?</h4><p>A: 论文的这一部分看起来更像是广告而不是科学。历史表明，没有哪个绩效水平高到没有人会想要更高的，而那些人很可能愿意在其他方面做出妥协，以获得他们所需的绩效。</p><h4 id="Q-FaRM的局限性是什么"><a href="#Q-FaRM的局限性是什么" class="headerlink" title="Q: FaRM的局限性是什么?"></a>Q: FaRM的局限性是什么?</h4><p>A: 数据必须符合RAM。如果事务冲突很多，OCC将产生大量中止。事务API(在他们的NSDI 2014论文中描述)看起来使用起来很尴尬，因为回复在回调中返回。应用程序代码必须紧密交织执行应用程序事务和轮询RDMA NIC队列和日志来自其他计算机的消息。应用程序代码在执行最终会中止的事务时可以看到不一致。应用程序可能不能为自己的目的免费使用线程，因为FaRM将线程固定到核心，并使用所有核心。FaRM需要特殊的网络硬件，但尚未广泛部署。只有当所有的计算机彼此靠近时，这种设计才有意义;它不是地理分布的秘方(因此容错能力有限)。当然，FaRM是一个旨在探索新想法的研究原型。它不是一般用途的成品。如果人们继续从事这项工作，我们最终可能会看到FaRM的后代没有那么多粗糙的地方。</p><h4 id="Q-为什么FaRM基于RDMA的RPC比传统RPC更快"><a href="#Q-为什么FaRM基于RDMA的RPC比传统RPC更快" class="headerlink" title="Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?"></a>Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?</h4><p>A: 传统RPC要求应用程序对本地内核进行系统调用，内核要求本地NIC发送一个数据包。在接收计算机上，NIC将数据包写入内存中的队列，并中断接收计算机的内核。内核将数据包复制到用户空间，然后上下文切换到接收应用程序。接收应用程序反向发送应答(系统调用内核，内核与NIC通话，另一端的NIC中断内核，等等)。这一点是为每个RPC执行大量的代码，而且速度不是很快。</p><p>相反，FaRM安排应用程序代码可以直接读写内存以与NIC通信，并将CPU内核(本文称之为硬件线程)专门用于轮询传入消息。这消除了中断、系统调用、在用户和内核之间复制数据以及上下文切换的成本。</p><h4 id="Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献"><a href="#Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献" class="headerlink" title="Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?"></a>Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?</h4><p>A: FaRM速度快的一个原因是硬件速度快。但是硬件已经存在了很多年了，但是还没有人知道如何将所有的部件组合在一起，从而真正发挥硬件的潜力。FaRM做得这么好的一个原因是他们同时投入了大量的精力来优化网络、持久存储和CPU的使用;许多以前的系统只优化了一个，而不是全部。一个特定的设计点是FaRM对许多交互使用快速单边RDMA(而不是较慢的完整RPC)的方式。</p><h4 id="Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储"><a href="#Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储" class="headerlink" title="Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?"></a>Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?</h4><p>A: 这种想法是古老的;例如，Harp复制文件服务在20世纪90年代早期就使用了它。许多存储系统以相关的方式使用电池(例如在RAID控制器中)来持续写入而不等待磁盘。然而，FaRM使用的这种电池设置并不是特别常见，所以必须通用的软件不能依赖它。如果您将自己的硬件配置为有电池，那么修改Raft(或k/v服务器)以利用电池是有意义的。</p><h4 id="Q-如果没有电池支持的RAM-FaRM的设计还有意义吗"><a href="#Q-如果没有电池支持的RAM-FaRM的设计还有意义吗" class="headerlink" title="Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?"></a>Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?</h4><p>A: 我不确定FaRM在没有非易失性RAM的情况下是否有意义，因为这样单方面的日志写入(例如图4中的COMMIT-BACKUP)就不会在电源故障时持续存在。您可以修改FaRM，以便在返回之前将所有日志更新写入SSD，但这样会大大降低性能。SSD写入大约需要100微秒，而FaRM的单边RDMA写入非易失性RAM只需要几微秒。</p><h4 id="Q-DRAM本身不是不稳定的吗"><a href="#Q-DRAM本身不是不稳定的吗" class="headerlink" title="Q: DRAM本身不是不稳定的吗?"></a>Q: DRAM本身不是不稳定的吗?</h4><p>A: 作者通过使用UPS使RAM“非易失性”，允许FaRM在电源故障时将RAM的内容写入SSD。但是，这确实不是完全非易失性的，因为如果计算机由于任何其他原因而崩溃，而不是电源故障，那么故障机器的内存内容就会丢失。这就是为什么他们在多台机器上复制每个区域，并具有快速恢复协议的原因。</p><h4 id="Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗"><a href="#Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗" class="headerlink" title="Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?"></a>Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?</h4><p>A: 他们使用ssd是因为它们速度快。他们本可以在不改变设计的情况下使用硬盘驱动器。然而，在断电期间将数据写入磁盘将花费大约10倍的时间，在恢复供电后将数据读入磁盘将花费大约10倍的时间。这需要更大的电池和更大的耐心。</p><h4 id="Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色"><a href="#Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色" class="headerlink" title="Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?"></a>Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?</h4><p>A: 数据在许多主/备份集之间进行分片。备份的目的是存储碎片数据和日志的副本，以防主服务器出现故障。主数据中心<strong>执行对分片中数据的所有读写操作</strong>，而备份数据中心<strong>只执行写操作</strong>(以保持它们的数据副本与主数据中心的副本相同)。只有一个配置管理器。它跟踪哪些主备份处于活动状态，并跟踪数据如何在它们之间进行分片。在较高的级别上，这种安排类似于GFS，后者也在许多主/备份集之间对数据进行分片，并且也有一个主系统来跟踪数据的存储位置。</p><h4 id="Q-FaRM在小范围内可行吗"><a href="#Q-FaRM在小范围内可行吗" class="headerlink" title="Q: FaRM在小范围内可行吗?"></a>Q: FaRM在小范围内可行吗?</h4><p>A: 我认为FaRM只有在需要每秒支持大量事务时才有意义。如果您只需要每秒处理几千个事务，您可以使用现成的成熟技术，如MySQL。您可以设置一个比作者的90台机器系统小得多的FaRM系统。但是FaRM没有意义，除非你是在分片和复制数据，这意味着你至少需要四个数据服务器(两个分片，每个分片两个服务器)和一些用于ZooKeeper的机器(尽管你可能可以在这四台机器上运行ZooKeeper)。然后，也许你有一个成本约为10,000美元的系统，每秒可以执行数百万个简单交易，这是非常好的。</p><h4 id="Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的"><a href="#Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的" class="headerlink" title="Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!"></a>Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!</h4><p>A:Farm仅保证提交的事务的可序列化性。如果事务看到了第3节所讨论的那种不一致，FaRM将中止事务。应用程序必须处理不一致，因为它们不应该崩溃，这样它们就可以请求提交，这样FaRM就可以中止它们。</p><h4 id="Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么"><a href="#Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么" class="headerlink" title="Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?"></a>Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?</h4><p>A: 这里有两个危险。首先，对于一个大对象，读取器可能会在并发事务写入它之前读取对象的前半部分，而在并发事务写入它之后读取后半部分，这可能会导致读取程序崩溃。其次，如果读事务不能与并发写事务串行化，则不允许提交它。</p><p>根据我对作者之前的NSDI 2014论文的阅读，第一个问题的解决方案是每个对象的每个缓存行都有一个版本号，单缓存行RDMA读写是原子的。读取事务的FaRM库获取对象的所有缓存行，然后检查它们是否都具有相同的版本号。如果是，标准库将对象的副本提供给应用程序;如果没有，库将通过RDMA再次读取它。第二个问题是由FaRM在第4节中描述的验证方案解决的。在VALIDATE步骤中，如果自我们的事务启动以来，另一个事务写入了由我们的事务读取的对象，那么我们的事务将被中止。</p><h4 id="Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗"><a href="#Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗" class="headerlink" title="Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?"></a>Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?</h4><p>A: 在TC看到主服务器和备份服务器的日志中都有一个COMMIT-PRIMARY或COMMIT-BACKUP后，TC告诉主服务器和备份服务器删除事务的日志条目。为了使恢复知道尽管截断了事务，但事务还是完成了，第62页提到，即使在截断之后，primary也会记住已完成的事务id。截断意味着删除截断点之前的所有日志条目;这是因为每个主/备份在每个TC上都有一个单独的日志。</p><h4 id="Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障"><a href="#Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障" class="headerlink" title="Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?"></a>Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?</h4><p>A: 我想是的。如果其中一个备份没有响应，并且TC崩溃，那么事务可能会在恢复期间中止。</p><h4 id="Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗"><a href="#Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗" class="headerlink" title="Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?"></a>Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?</h4><p>A:当多个事务同时修改同一个对象时，其中一些事务将在图4的LOCK阶段看到锁已经被持有。在VALIDATE阶段，读者可能会看到更改的版本或锁定标志。每个这样的事务都将中止并从头开始重新启动。如果这种情况经常发生，业绩确实会受到影响。“乐观并发控制”中的“乐观”指的是希望这样的冲突将很少发生，并且执行无锁读取的能力将产生高性能。事实上，对于作者测量的应用程序，FaRM获得了出色的性能。一个很可能的原因是，它们的应用程序具有相对较少的冲突事务，因此没有太多中止。</p><h4 id="Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢"><a href="#Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢" class="headerlink" title="Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?"></a>Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?</h4><p>A: 我怀疑服务器的极限是总共每秒只能处理大约1.4亿次操作。如果客户端发送操作的速度比这快，其中一些将不得不等待;这种等待会增加延迟。</p><h4 id="Q-什么是vertical-Paxos"><a href="#Q-什么是vertical-Paxos" class="headerlink" title="Q:什么是vertical Paxos?"></a>Q:什么是vertical Paxos?</h4><p>A: 它是Paxos协议的一种风格，其中外部主服务器执行重新配置，而Paxos组在进行重新配置时可以继续执行操作 (see <a href="https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf">https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf</a> for the details). 在FaRM论文中，作者使用术语“垂直Paxos”来松散地表示配置管理是由外部服务(Zookeeper和CM)完成的，事务的处理写是通过标准的主/备份协议完成的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-2015.pdf">FaRM论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-faq.txt">FaRM FQA</a></li><li><a href="https://pdos.csail.mit.edu/6.824/notes/l-farm.txt">FaRM Lecture</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> FaRM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effect C++笔记</title>
      <link href="/2023/01/20/Effective%20C++/"/>
      <url>/2023/01/20/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><blockquote><p>Effective学习笔记</p></blockquote><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h2><p>C++高效编程时情况而变，取决于你使用C++的那一部分</p><hr><h2 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h2><p><code>Perfer consts enum and inlines to #define</code></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>✦For simple constants, prefer const objects or enums to #defines.</p><p>✦For function-like macros, prefer inline functions to #defines.</p><hr><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p><code>Use const whenever possible</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><blockquote><p>优点</p></blockquote><ol><li><p>他们使class接口比较容易被理解，可以得知那个函数可以改动对象成员，那个不能</p></li><li><p>他们使用“操作const对象”成为可能。</p></li></ol><blockquote><p>constness</p></blockquote><p>当两个成员函数如果只是常量性不同，就可以用const来重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">                         <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// const objects</span></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position)  </span><br><span class="line">                        <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// non-const objects</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">//TextBlock’s operator[]s can be used like this:</span></span><br><span class="line">TextBlock <span class="built_in">tb</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];    <span class="comment">// calls non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">// calls const TextBlock::operator[]</span></span><br></pre></td></tr></table></figure><h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>✦Declaring something const helps compilers detect usage errors. constcan be applied to objects at any scope, to function parameters andreturn types, and to member functions as a whole.</p><p>✦Compilers enforce bitwise constness, but you should program usinglogical constness.</p><p>✦When const and non-const member functions have essentially identi-cal implementations, code duplication can be avoided by having thenon-const version call the const version.</p><hr><h2 id="条款04：确定对象被使用前已经先被初始化"><a href="#条款04：确定对象被使用前已经先被初始化" class="headerlink" title="条款04：确定对象被使用前已经先被初始化"></a>条款04：确定对象被使用前已经先被初始化</h2><p><code>Make sure that object are initialized before they&#39;re used</code></p><h3 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h3><blockquote><p>规则</p></blockquote><p>永远在使用对象之前将它初始化。对于内置内省必须要手工完成初始化</p><p>对于自定义类型来说，初始化职责放在构造函数上</p><blockquote><p>赋值与初始化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;<span class="comment">// ABEntry = “Address Book Entry”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">            <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;<span class="comment">// these are all assignments,</span></span><br><span class="line">    theAddress = address;<span class="comment">// not initializations</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化</p></blockquote><p>成员变量初始化动作发生在进入构造函数本体之前，相对于赋值来说发生时间更早。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones): </span><br><span class="line">        <span class="built_in">theName</span>(name),</span><br><span class="line">        <span class="built_in">theAddress</span>(address),<span class="comment">// these are now all initializations</span></span><br><span class="line">        <span class="built_in">thePhones</span>(phones),</span><br><span class="line">        <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;<span class="comment">// the ctor body is now empty</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化优点</p></blockquote><p>通常效率较高；</p><p><strong>赋值版本</strong>：先调用构造函数为成员变量赋予初值，然后立刻在对他们赋予新值（传入的实参）。因此会浪费一部分时间</p><p><strong>初始化版本</strong>：成员初始列中针对各个成员变量而设的实参，被拿去作为各成员之构造函数的实参。</p><blockquote><p>必须初始化的情况</p></blockquote><p>例如：成员变量为const或references，必须要进行成员初始列表</p><p><strong>综述：</strong> 一般情况总是使用成员初始列表，可以针对普遍的变量，而且比赋值更高效</p><h3 id="成员初始化次序"><a href="#成员初始化次序" class="headerlink" title="成员初始化次序"></a>成员初始化次序</h3><ul><li><p>base class -&gt; derived class </p></li><li><p><strong>成员变量以被声明的次序进行初始化</strong>因此对于示例ABEntry 中theName 最先被初始化，然后是theAddress，再是thePhone，最后是numTimesConsulted.</p></li></ul><h3 id="static对象"><a href="#static对象" class="headerlink" title="static对象"></a>static对象</h3><blockquote><p>生命周期</p></blockquote><p>从被构造出来直到程序结束，因此不是堆栈对象。</p><blockquote><p>定义</p></blockquote><p>一般这种对象被定义为global对象、定于于namspace作用域、classes、函数内、以及file作用内声明为static的对象</p><blockquote><p>local static与non-local static对象</p></blockquote><p><strong>long static对象</strong>：定义域函数内，因为它对于函数而言是local</p><p><strong>non-local static对象</strong>：其他剩余的static对象</p><h3 id="多源文件跨编译单元编译"><a href="#多源文件跨编译单元编译" class="headerlink" title="多源文件跨编译单元编译"></a>多源文件跨编译单元编译</h3><p>一般至少应该non-local static对象</p><blockquote><p>问题</p></blockquote><p>某编译单元内的某个non-local static对象初始化动作使用了另一个编译单元内的某个编译单元内的某个non-local static对象，它所用到的这个对象可能没有被初始化，因为c++对于 <strong>”定义在不同编译单元的non-local对象那个“初始化次序没有明确的规定</strong></p><h4 id="non-local-static-对象初始化次序问题"><a href="#non-local-static-对象初始化次序问题" class="headerlink" title="non-local static 对象初始化次序问题"></a>non-local static 对象初始化次序问题</h4><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;<span class="comment">// from your library’s header file</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// one of many member functions</span></span><br><span class="line">...</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">// declare object for clients to use// (“tfs” = “the file system” ); definition// is in some .cpp file in your library</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;<span class="comment">// created by library client</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Directory</span>( params );...&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>( );<span class="comment">// use the tfs object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：用户决定创建应该Directory对象，用来放置临时文件</p><p>Directory tempDir{params}；</p><blockquote><p>初始化次序的重要性</p></blockquote><p>除非tfs在tempDir先被初始化，否则tempDir会用到尚未初始化的tfs。（但是tfs和tempDir是被不同人在不同时间创建的），他们是不同编译单元的non-local对象</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>将每个non-local对象搬到总结专属的函数内（函数也要声明为static）、</p><p>这些函数返回应该reference指向它所含的对象。然后用户调用这些函数</p><blockquote><p> C++保证</p></blockquote><p>函数内的local static对象会在<u>”该函数调用期间“”首次遇到该对象的定义式”</u>时被初始化。</p><p>因此如果用”函数调用“(返回应该reference指向local static对象)替换”直接访问non-local static对象“，就获得了保证，保证你所获得reference将指向应该历经初始化的对象。</p><blockquote><p>优点</p></blockquote><p>从未调用non-local static对象的”仿真函数“，就绝不会引发构造和析构成本</p><blockquote><p>优化代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;; <span class="comment">// as before</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">( )</span><span class="comment">// this replaces the tfs object; it could be</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static in the FileSystem class</span></span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">// define and initialize a local static object</span></span><br><span class="line">    <span class="keyword">return</span> fs;<span class="comment">// return a reference to it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;<span class="comment">// as before</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )<span class="comment">// as before, except references to tfs are </span></span><br><span class="line">&#123;<span class="comment">// now to tfs( )</span></span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>( );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">( )</span><span class="comment">// this replaces the tempDir object; it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="comment">// could be static in the Directory class</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>;<span class="comment">// define/initialize local static object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> td;<span class="comment">// return reference to it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>✦Manually initialize objects of built-in type, because C++ only some-times initializes them itself.</p><p>✦In  a  constructor,  prefer  use  of  the  member  initialization  list  to  assignment  inside  the  body  of  the  constructor.  List  data  members  in the initialization list in the same order they’re declared in the class.</p><p>✦Avoid  initialization  order  problems  across  translation  units  by  re-placing non-local static objects with local static objects.</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="条款05：了解C-默认编写和调用了哪些函数"><a href="#条款05：了解C-默认编写和调用了哪些函数" class="headerlink" title="条款05：了解C++默认编写和调用了哪些函数"></a>条款05：了解C++默认编写和调用了哪些函数</h2><p><code>Know what functions C++silently writes and calls.</code></p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>✦Compilers may implicitly generate a class’s default constructor, copyconstructor, copy assignment operator, and destructor</p><hr><h2 id="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"></a>条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝</h2><p><code>Explicitly disallow the use of compiler-generated functions you do not want.</code></p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>✦To disallow functionality automatically provided by compilers, declare the corresponding member functions private and give no imple-mentations. Using a base class like private is one way to do this.</p><hr><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        D d;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//多态</span></span><br><span class="line">    &#123;</span><br><span class="line">        B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        B* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">D destrutor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">B destrutor</span><br></pre></td></tr></table></figure><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>✦Polymorphic base classes should declare virtual destructors. If aclass has any virtual functions, it should have a virtual destructor.</p><p>✦Classes not designed to be base classes or not designed to be usedpolymorphically should not declare virtual destructors.</p><hr><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><code>prevent exception from leaving destruction</code></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>✦Destructors should never emit exceptions. If functions called in adestructor may throw, the destructor should catch any exceptions,then swallow them or terminate the program.</p><p>✦If class clients need to be able to re act to exceptions thrown duringan operation, the class should provide a regular (i.e., non-destruc-tor) function that performs the operation.</p><hr><h2 id="条款11：在operator-中“自我赋值”"><a href="#条款11：在operator-中“自我赋值”" class="headerlink" title="条款11：在operator=中“自我赋值”"></a>条款11：在operator=中“自我赋值”</h2><p><code>Handle assignment to self in operator=</code></p><p>以widget窗口类为示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    Bit* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w = w; 自我赋值 </span><br></pre></td></tr></table></figure><h3 id="方法一：证同测试"><a href="#方法一：证同测试" class="headerlink" title="方法一：证同测试"></a>方法一：证同测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)                <span class="comment">//证同测试</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb；</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);    <span class="comment">//防止浅拷贝问题</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>异常问题：</p></blockquote><p>new Bitmap出现异常（分配内存错误导致错误）this-&gt;pb会指向一块被删除的内存</p><h3 id="方法二：异常安全性"><a href="#方法二：异常安全性" class="headerlink" title="方法二：异常安全性"></a>方法二：异常安全性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;                 <span class="comment">//创建*this一个副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);           <span class="comment">//pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig                          <span class="comment">//删除副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>证同测试效率问题</p></blockquote><p>应用证同测试会导致代码效率变低，if分支导致执行速度下降</p><blockquote><p>副本：</p></blockquote><p>不是指向一个对象只是一个<strong>值容器</strong>，如函数传参</p><h3 id="方法三：copy-swap（异常安全性）—-条款29"><a href="#方法三：copy-swap（异常安全性）—-条款29" class="headerlink" title="方法三：copy-swap（异常安全性）—-条款29"></a>方法三：copy-swap（异常安全性）—-条款29</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">//一个副本修改它不会修改其本身</span></span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);       <span class="comment">//rhs数据副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A variation on this theme takes advantage of the facts that</p><p> (1) a class’scopy assignment operator may be declared to take its argument byvalue and</p><p> (2) passing something by value makes a copy of it (seeItem20)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=( Widget rhs)<span class="comment">//一个副本修改它不会修改其对象本身</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);            <span class="comment">//pass by value 将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦Make sure operator= is well-behaved when an object is assigned to itself. Techniques include comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.</p><p>✦Make sure that any function operating on more than one object be-haves correctly if two or more of the objects are the same.</p></blockquote><hr><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p><code>think carefully about copying behavior in resource-managing classes</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm)</span></span><br><span class="line"><span class="function">        &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;<span class="comment">// acquire resource</span></span><br><span class="line">    ~<span class="built_in">Lock</span>( )</span><br><span class="line">        &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;<span class="comment">// release resource</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Clients use Lock in the conventional RAII fashion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;<span class="comment">// define the mutex you need to use</span></span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// create block to define critical sectionLock </span></span><br><span class="line"><span class="built_in">ml</span>(&amp;m);    <span class="comment">// lock the mutex</span></span><br><span class="line">...    <span class="comment">// perform critical section operations</span></span><br><span class="line">&#125;    <span class="comment">// automatically unlock mutex at end</span></span><br><span class="line">    <span class="comment">// of block</span></span><br></pre></td></tr></table></figure><h3 id="RAII对象copied的选择"><a href="#RAII对象copied的选择" class="headerlink" title="RAII对象copied的选择"></a>RAII对象copied的选择</h3><ul><li><p>禁止复制（prohibit copying）</p></li><li><p>对底层资源使用“引用计数法”</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>✦ 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</p><p>✦普遍而常见的RAII classes copying 行为时：一直copying、实行引用计数法。</p><h2 id="条款15：在资源类中提供对原始资源的访问"><a href="#条款15：在资源类中提供对原始资源的访问" class="headerlink" title="条款15：在资源类中提供对原始资源的访问"></a>条款15：在资源类中提供对原始资源的访问</h2><p><code>provide access to raw resources in resource-managing classes</code></p><p><strong>原因：</strong> 编译器无法将RAII类(shared_ptr)作为指针,会将其作为一个对象，无法发生隐式转换而报错</p><blockquote><p><strong>示例</strong> ：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daysHeld</span><span class="params">(<span class="type">const</span> Investment *pi)</span></span>;<span class="comment">// return number of days</span></span><br><span class="line">                                    <span class="comment">// investment has been held</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);<span class="comment">// error!</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>解决方案：</strong> </p></blockquote><p><code>convert an object of the RAII class (in this case,tr1::shared_ptr) into the raw resource</code></p><p>(1)<strong>explicit conversion:</strong></p><p>smart_ptr offer a get number function to perform explicit conversion to return a raw pointer inside this smart_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>( ));<span class="comment">// fine, passes the raw pointer</span></span><br><span class="line">                                <span class="comment">// in pInv to daysHeld</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string* str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//explicit</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">test_string</span>(ptr);<span class="comment">//error can`t convert RAII to string</span></span><br><span class="line">    <span class="built_in">test_string</span>(ptr.<span class="built_in">get</span>());<span class="comment">//offer raw resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)<strong>implicit conversion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Str</span><span class="params">(<span class="type">const</span> string&amp; str)</span>:m_str(str)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_str;&#125;<span class="comment">//implicit convertion</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_str;&#125;</span><br><span class="line">    ~<span class="built_in">Str</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_implicit_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">a</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">test_string</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>✦APIs often require access to raw resources, so each RAII classshould offer a way to get at the resource it manages.</p><p>✦Access may be via explicit conversion or implicit conversion. In gen-eral, explicit conversion is safer, but implicit conversion is more con-venient for clients.</p><hr><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款20：宁以pass-by-reference-to-const-替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; a):<span class="built_in">p_name</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;P&quot;</span>&lt;&lt;st::endl;<span class="keyword">return</span> p_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string p_name;</span><br><span class="line">    string p_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; a):<span class="built_in">s_name</span>(a)&#123;std::cout&lt;&lt;<span class="string">&quot;S construct\n&quot;</span>;&#125;</span><br><span class="line">    <span class="comment">//Student(const Student&amp; other)&#123;std::cout&lt;&lt;&quot;S copy construct\n&quot;;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;std::endl;<span class="keyword">return</span> s_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Student</span>()&#123;std::cout &lt;&lt; <span class="string">&quot;S destruct\n&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s_name;</span><br><span class="line">    string s_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;p.<span class="built_in">printN</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用pass-by-reference-to-const的好处"><a href="#用pass-by-reference-to-const的好处" class="headerlink" title="用pass-by-reference-to-const的好处"></a>用pass-by-reference-to-const的好处</h3><ol><li><p><strong>高效</strong>，不会创建临时对象，因此不会再次调用construt和deconstruct。</p></li><li><p><strong>准确且正确的多态</strong>，pass-by-value无法识别准确的object，如test1中，real object 都是person无法调用student的多态，pass-by-reference-to-const是可以准确调用student对象</p></li></ol><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>✦Prefer pass-by-reference-to-const over pass-by-value. It’s typicallymore efficient and it avoids the slicing problem.</p><p>✦The rule doesn’t apply to built-in types and STL iterator and func-tion object types. For them, pass-by-value is usually appropriat</p><hr><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p><code>Don&#39;t try return a reference when you must return an object</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span> ()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">double</span> x, <span class="type">double</span> y):<span class="built_in">x_</span>(x),<span class="built_in">y_</span>(y)</span><br><span class="line">    &#123;cout&lt;&lt;<span class="string">&quot;construt&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该段代码描述有理数的相乘的类的设计</p><h3 id="当以reference作为返回值时的几大误区"><a href="#当以reference作为返回值时的几大误区" class="headerlink" title="当以reference作为返回值时的几大误区"></a>当以reference作为返回值时的几大误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">==================on the stack===================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational <span class="built_in">result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================on the heap======================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational *result =  <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line">=================<span class="type">static</span> local====================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result</span><br><span class="line">    result = <span class="built_in">Result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>on the stack</strong> :reference作为返回值时，result对象是一个stack值，当其返回时离开了作用域，result对象会被销毁，reference返回时会导致其指向了一个被销毁的值</p></li><li><p><strong>on the heap</strong> :heap分配的内存，new出来的对象，无法得知合适对该对象进行delete，因此会导致内存泄漏</p></li><li><p><strong>static local</strong> :会引起多线程问题，例如数据共享问题</p></li></ol><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.x_*lhs.y_,rhs.x_*rhs.y_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：虽然会付出一点点的成本代价（construct和deconstruct），但从长远的角度和综合对比可知，此方法是最合适的做法</p><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>✦Never return a pointer or reference to a local stack object, a refer-ence to a heap-allocated object, or a pointer or reference to a localstatic object if there is a chance that more than one such object willbe needed. (Item4 provides an example of a design where returninga reference to a local static is reasonable, at least in single-threadedenvironments.)</p><hr><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p><code>Declare data member private</code></p><h3 id="private（提供封装）和其他（提供封装）"><a href="#private（提供封装）和其他（提供封装）" class="headerlink" title="private（提供封装）和其他（提供封装）"></a>private（提供封装）和其他（提供封装）</h3><p>对于protect声明的成员变量，当其出现问题后或是被取消后，将会影响整个派生类</p><h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><p>✦Declare data members private. It gives clients syntactically uniformaccess to data, affords fine-grained access control, allows invariantsto be enforced, and offers class authors implementation flexibility.</p><p>✦protected is no more encapsulated than public（protect 与 public 差不多）</p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p><code>Perfer non-member、non-friend to member function</code> </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>示例 :</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrower</span></span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">==================member================</span><br><span class="line"><span class="keyword">class</span> WebBrower&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">clearEverything</span>();<span class="comment">//调用clearCache、clearHistory、</span></span><br><span class="line">                           <span class="comment">//removeCookies</span></span><br><span class="line">&#125;</span><br><span class="line">=================non-member============</span><br><span class="line"><span class="type">void</span> <span class="built_in">clearBrowser</span>(WebBrowser&amp; wb)</span><br><span class="line">&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>我们更愿意使用non-member代替member函数</code></p><blockquote><p>原因</p></blockquote><p>1.non-member的封装性比member函数的更强</p><p>2.non-member对类的相关机能有较大的包裹弹性</p><blockquote><p><strong>封装</strong>：它使我们能够改变事物而只影响有限客户</p></blockquote><p>愈多东西被封装，愈少人能看见它，因此能够有愈大的弹性去改变它</p><p>愈多函数可以访问封装的函数，数据的封装性越低</p><p><strong>条款22</strong>：成员变量应该是private，以为如果他们不是，就有无数的函数可以去访问他们，没有封装可言</p><blockquote><p>访问限制</p></blockquote><p>能够访问private成员变量的函数只有class和member函数与friend函数可以访问</p><h3 id="程序设计问题"><a href="#程序设计问题" class="headerlink" title="程序设计问题"></a>程序设计问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设计特点</p></blockquote><ul><li><p>namespace 与classes不同，<strong>namespace可以支持跨多个源码文件</strong>而class不能</p></li><li><p>non-member、non-friend函数为用户提供较好的程序机能以及封装性</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowsers。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">//核心机能，提供所有的non-member函数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowserbookmarks。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">//声明与书签相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowsercookies</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowerStuff</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//声明与cookies相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例运用了namespace的跨越多个源码文件的特点</p><blockquote><p>标准库组织方式</p></blockquote><p>在STL头文件中std命名空间内的每一个东西，每个头文件声明std的某些机能</p><p>例如只想用vector，那就只用vector头文件，这允许客户支队他们所用的<strong>小部分系统形成编译依赖</strong>，但该方法不能适用于member函数，以为class必须整体定义，不可分割</p><p>将所有便利函数放在多个头文件内但隶属同一命名空间，意味用户可以轻松的扩展。需要只做到则是，在该命名空间<strong>添加non-member、non-friend函数</strong>。</p><h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Prefer non-member non-friend functions to member functions. Do-ing so increases encapsulation, packaging flexibility, and functionalextensibility.</p></blockquote><hr><h2 id="条款24：-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24：-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24： 若所有参数皆需类型转换,请为此采用non-member函数"></a>条款24： 若所有参数皆需类型转换,请为此采用non-member函数</h2><p><code>Declare non-member functions when type conversions should apply to all parameters</code></p><blockquote><p>示例：Rational</p></blockquote><p>运用条款3，20，21书写正确的operator*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">float</span> numerator = <span class="number">0</span>,<span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;<span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">    <span class="comment">// conversions</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// accessors for numerator and</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// denominator — see Item22private:</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Rational <span class="title">result</span><span class="params">((n*rhs.n),(d*rhs.d))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    <span class="type">float</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">r1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Rational r3 = r1 * r2;<span class="comment">//right</span></span><br><span class="line"></span><br><span class="line">    r3  = r1 * <span class="number">2</span>;<span class="comment">//right</span></span><br><span class="line">    r3  = <span class="number">2</span> * r1;<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;r3&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li><p>在隐式转换时，构造函数需要写出默认参数，不然不能进行隐式转换，因为Rational类构造函数有两个参数;</p></li><li><p>在构造函数加上explicit就可以防止隐式转换</p></li><li><p>2 *  r1 不能成功运行，是不是不满足交换律？</p></li></ul><blockquote><p>重写上述例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = r1.<span class="keyword">operator</span>*(<span class="number">2</span>);</span><br><span class="line">result = <span class="number">2.</span>opeator*(r1);<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">result = opeator*(<span class="number">2</span>,r1);</span><br></pre></td></tr></table></figure><p>因为r1内含一个operator<em>函数的class的对象，并且将2进行隐式转换r1.operator </em> (Rational(2))</p><p>对于2.operator(r1)显然时错误的,没有这个重载函数</p><h3 id="将operator写为non-member函数"><a href="#将operator写为non-member函数" class="headerlink" title="将operator写为non-member函数"></a>将operator写为non-member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        rhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><ul><li><p>non-member函数如条款23所述封装性更强</p></li><li><p>支持所有参数的隐式类型转换</p></li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦If you need type conversions on all parameters to a function (includ-ing the one that would otherwise be pointed to by the this pointer),the function must be a non-member.</p></blockquote><hr><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p><code>consider support a no-throwing swap</code></p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="无法交换值、无法交换指针"><a href="#无法交换值、无法交换指针" class="headerlink" title="无法交换值、无法交换指针"></a>无法交换值、无法交换指针</h4><p>普通swap函数实现细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br><span class="line">========================</span><br><span class="line">地址不变，值不变</span><br></pre></td></tr></table></figure><blockquote><p>陷阱</p></blockquote><p>对于c/c++的初学者来说，犯下一个很大的陷阱，那就是我们只传过去一个地址对于者个地址值只是一个<strong>副本信息</strong>，并不是原对象，导致无法交换地址值更无法交换指针值。我们只是通过传参过来的一个 <strong>(地址)值(副本)</strong>,这是我们只是对原对象的指针副本做了交换</p><h4 id="无法交换地址、可以交换指针"><a href="#无法交换地址、可以交换指针" class="headerlink" title="无法交换地址、可以交换指针"></a>无法交换地址、可以交换指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>解引用后，此时<em>a、</em>b是a、b地址对应内存的值，也就是原对象值，改操作进行的是<strong>对(原对象)内存的进行置换</strong>，但此时并不会改变地址值，地址值仍是一个副本</p><h4 id="可以交换值和地址"><a href="#可以交换值和地址" class="headerlink" title="可以交换值和地址"></a>可以交换值和地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>** a,<span class="type">int</span>** b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>p1和p2是一个地址</p><p>我们用双层指针，写出一个swap的置换函数，我们传入地址进去，此时a、b的值是指向p1和p2的地址。对a、b进行解引用，则<strong>对应的<em>a 、</em>b是对应p1、p2的地址原对象</strong>。</p><p>进行置换则<strong>交换的是p1和p2的值</strong>，那么地址交换，相应改变的是p1和p2的对象名所对应的地址而已，而实际的内存并没有置换而已。</p><h4 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法既可以改值也可以改地址，因为引用的本身就是<strong>绑定一个原对象</strong>，并不是副本</p><h3 id="标准库swap"><a href="#标准库swap" class="headerlink" title="标准库swap"></a>标准库swap</h3><blockquote><p> std::swap</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// typical implementation of </span></span><br><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换</p><h3 id="示例：swap"><a href="#示例：swap" class="headerlink" title="示例：swap"></a>示例：swap</h3><blockquote><p>实践Widget类</p></blockquote><ul><li>用pimpl手法将Widget的数据成员封装到WidgetImpl中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;<span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// details are unimportant...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// possibly lots of data —</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;<span class="comment">// expensive to copy!...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;<span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">    &#123;        <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">        ...<span class="comment">// details on implementing</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);<span class="comment">// operator= in general,</span></span><br><span class="line">        ...<span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;<span class="comment">// ptr to object with this </span></span><br><span class="line">&#125;;<span class="comment">// Widget’s data</span></span><br></pre></td></tr></table></figure><blockquote><p>设计问题</p></blockquote><ul><li><p>置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl)</p></li><li><p>可以直接交换指针的地址，改变指针指向的内存</p></li></ul><h4 id="置换其impl指针"><a href="#置换其impl指针" class="headerlink" title="置换其impl指针"></a>置换其impl指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)<span class="comment">//std::swap的全特化版本只能对</span></span><br><span class="line">           <span class="comment">//&lt;Widget&gt;表示这一特例化版本只是针对指针交换而设计</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl,b.pImpl);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下：</p><h4 id="声明public成员函数置换"><a href="#声明public成员函数置换" class="headerlink" title="声明public成员函数置换"></a>声明public成员函数置换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// addition of the swap mem func</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;<span class="comment">// the need for this declaration</span></span><br><span class="line">                    <span class="comment">// is explained later in this Item</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pImpl pointers</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// revised specialization of</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,<span class="comment">// std::swap</span></span><br><span class="line">                        Widget&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);<span class="comment">// to swap Widgets, call their</span></span><br><span class="line">&#125;<span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本</p><blockquote><p>缺点</p></blockquote><p>对于Widget class templates而非classes 将数据类型加以参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,<span class="comment">// error! illegal code!</span></span><br><span class="line">        Widget&lt;T&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">     a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>错误分析</p></blockquote><p>企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化，在function templates身上时不能偏特化的。因此无法编译。</p><h4 id="偏特化function-template"><a href="#偏特化function-template" class="headerlink" title="偏特化function template"></a>偏特化function template</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// an overloading of std::swap </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// (note the lack of “&lt;...&gt;” after</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Widget&lt;T&gt;&amp; b)</span><span class="comment">// “swap”), but see below for</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;<span class="comment">// why this isn’t valid code&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>重载function templates是没问题的，但std是一个特殊的命名空间：</p><ul><li><p>可以全特化std内的templates</p></li><li><p>不可以添加新的templates(class或function)到std里面</p></li></ul><h3 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h3><blockquote><p>高效正确的做法：non-member的swap、member的swap函数相结合</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...<span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// as before, including the swapclass </span></span><br><span class="line">Widget &#123; ... &#125;;<span class="comment">// member function</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// non-member swap function;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>swap实现效率不足的解决(class或template运用了pimpl手法)</p></blockquote><ol><li><p>提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常</p></li><li><p>在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数</p></li><li><p>如果编写一个<strong>class(而非class template)</strong>，为你的class特化一个std::swap，并令他调用你的swap的成员函数</p></li><li><p>必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符</p></li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>✦Provide a swap member function when std::swap would be inefficientfor your type. Make sure your swap doesn’t throw exceptions.</p><p>✦If you offer a member swap, also offer a non-member swap that callsthe member. For classes (not templates), specialize std::swap, too.</p><p>✦When calling swap, employ a using declaration for std::swap, then callswap without namespace qualification.</p><p>✦It’s fine to totally specialize std templates for user-defined types, butnever try to add something completely new to std.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="条款26：尽量将变量的声明置后"><a href="#条款26：尽量将变量的声明置后" class="headerlink" title="条款26：尽量将变量的声明置后"></a>条款26：尽量将变量的声明置后</h2><p><code>Postpone variable definitions as long as possible</code></p><h3 id="变量声明前置示例"><a href="#变量声明前置示例" class="headerlink" title="变量声明前置示例"></a>变量声明前置示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...            <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                   <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>使用：正常执行的时候需要用到encrypted</p><p>未使用：当异常抛出时，encrypted对象的构造成本已经造成，而析构要离开作用域后才会启用。</p><h3 id="变量置后"><a href="#变量置后" class="headerlink" title="变量置后"></a>变量置后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted’s definition until it’s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...          <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环中的变量声明"><a href="#循环中的变量声明" class="headerlink" title="循环中的变量声明"></a>循环中的变量声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    w = some value dependent on i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach B: define inside loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方法的成本对比</p></blockquote><p>■Approach A: 1 constructor + 1 destructor + n assignments.</p><p>■Approach B: n constructors + n destructors.</p><blockquote><p>效率分析</p></blockquote><p>■Approach A:可见性强，当n较大时效率更好</p><p>■Approach B:n小时效率高</p><p>(1) assignment相比constructor-destruction(对)更加便宜</p><p>(2) 如果您正在处理代码中对性能敏感的部分，则应默认使用方法B。</p><h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p>✦Postpone variable definitions as long as possible. It increases pro-gram clarity and improves program efficiency.</p><hr><h2 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款27：尽量少做转型操作</h2><p><code>Minimize casting</code></p><h3 id="C语言转型语法"><a href="#C语言转型语法" class="headerlink" title="C语言转型语法"></a>C语言转型语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C风格的转型</span></span><br><span class="line">(T) expression<span class="comment">// cast expression to be of type T</span></span><br><span class="line"><span class="comment">//函数风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression)<span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure><h3 id="C-新式转型-new-style"><a href="#C-新式转型-new-style" class="headerlink" title="C++新式转型(new-style)"></a>C++新式转型(new-style)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><p>const_cast通常被用来将对象的常量性去除</p></li><li><p>dynamic_cast 主要用来执行“向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，不可以移植。例如将pointer to int 转型为一个int。</p></li><li><p>static_cast用来强制隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derivered。但它无法将cosnt转为non-const——这个只有const_cast才能办到。</p></li></ul><h3 id="新式转换的优点"><a href="#新式转换的优点" class="headerlink" title="新式转换的优点"></a>新式转换的优点</h3><ul><li><p>在代码中容易被识别出来(grep工具和人工识别)，找出类型系统在那个地点被破坏</p></li><li><p>各转型动作的目标越窄化，编译器越可能诊断错误地点，例如将constness去除，除非使用新式转型中的const_cast否之无法通过编译</p></li></ul><h3 id="旧式类型转换的使用场景："><a href="#旧式类型转换的使用场景：" class="headerlink" title="旧式类型转换的使用场景："></a>旧式类型转换的使用场景：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                        <span class="comment">// with function-style </span></span><br><span class="line"><span class="built_in">castdoSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                                        <span class="comment">// with C++-style cast</span></span><br></pre></td></tr></table></figure><p>在function-style看起来更像类型转换。可进行显式构造函数中类型转换。</p><h3 id="RTII-Run-Time-Type-Identification"><a href="#RTII-Run-Time-Type-Identification" class="headerlink" title="RTII(Run Time Type Identification)"></a>RTII(Run Time Type Identification)</h3><blockquote><p>含义</p></blockquote><p>令编译器编译出运行期间执行的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)/y;</span><br></pre></td></tr></table></figure><p>将int 转型为double会产生一些代码，因为int与double的底层描述不相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span>:<span class="keyword">public</span> Base&#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;<span class="comment">// implicitly convert Derived*⇒  Base*</span></span><br></pre></td></tr></table></figure><p>上述两个指针的值并不相同(&amp;d,pb)，这个时候会又一个偏移量运行期施加在Derived*指针上取得正确的指针值。</p><h3 id="转型容易写出似是而非的代码"><a href="#转型容易写出似是而非的代码" class="headerlink" title="转型容易写出似是而非的代码"></a>转型容易写出似是而非的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;<span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;<span class="comment">// base onResize impl</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// derived onResize impl;</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">// cast *this to Window,</span></span><br><span class="line">                                         <span class="comment">// then call its onResize;</span></span><br><span class="line">                                        <span class="comment">// this doesn’t work!</span></span><br><span class="line">    ...<span class="comment">// do SpecialWindow-</span></span><br><span class="line">    &#125;<span class="comment">// specific stuff</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题所在</p></blockquote><p>static_cast(<em>this).onResize()，调用的onResize并不是当前对象上的函数，而是稍早转型动作所建立的一个 “</em>this对象的base class成分” 的<strong>暂时副本</strong>身上的onResize。</p><p>(函数就是函数，它只是一个成员仅此一份，关键在于成员函数都含有个隐藏的this指针，因此会影响成员操作数据)</p><p><strong>换句话来说就是会丢失在当前对象base-class中对数据的操作</strong></p><p><code>it does not invoke that function on the current object! Instead, the cast creates a new, temporary copy of the base class part of *this, then invokes onResize on the copy!</code> </p><blockquote><p>实际示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>():<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ++size; </span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>():<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;A&gt;(*<span class="keyword">this</span>).<span class="built_in">get_size</span>();  <span class="comment">//error</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如上述例子，我们的操作仅仅只是在*this指针强转得到一个副本上调用了函数，因此在当前对象上并没有调用base-class的成员函数，所有A::get_size中的size++不会在当前对象上作用，所以得到的结果为1.</p><blockquote><p>解决办法：去除类型转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>( );<span class="comment">// call Window::onResize</span></span><br><span class="line">    ...<span class="comment">// on *this</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic__cast"></a>dynamic__cast</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有指向base-class的一个pointer或reference时，想要去操作认定为derived-class对象身上执行derived-class操作函数，依靠该dynamic__cast转型方法实现</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>dynamic_cast的执行速度<strong>相当的慢</strong>，而且<strong>向下转型</strong>本就是一个<strong>不安全的行为</strong>，因此有两个办法用来取代dynamic__cast</p><h4 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h4><p>使用容器并在请汇总存储直接指向derived-class对象的指针(通常为只能指针)，消除了”通过base-class接口处理对象函数“的需要。</p><blockquote><p>示例</p></blockquote><p>假设先前的window/specialwindow继承体系只有specialwindows才支持闪烁效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span><span class="comment">// see Item13 for info</span></span><br><span class="line">std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;  </span><br><span class="line"><span class="comment">// on tr1::shared_ptr</span></span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// undesirable code:</span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// uses dynamic_cast++iter) </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;</span><br><span class="line">                                (iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// better code: uses </span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// no dynamic_cast++iter)</span></span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure><p>缺陷在于无法在同一容器内存储指向window的任何派生类。处理多窗口需要多个容器，他们都具备类型安全性</p><h4 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h4><p>通过base-class接口处理所有window的所有派生类，就是在base-class内提供virtual函数做任何想多window派生类做的时</p><blockquote><p>示例</p></blockquote><p>虽然specialwindow可以闪烁，但或许将闪烁函数声明在base-class中并提供一份空的默认函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">// default impl is no-op;</span></span><br><span class="line">    ...                    <span class="comment">// see Item34 for why</span></span><br><span class="line">&#125;;<span class="comment">// a default impl may be</span></span><br><span class="line"><span class="comment">// a bad idea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;<span class="comment">// in this class, blink</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// does something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;<span class="comment">// container holds// (ptrs to) all possible</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Window types</span></span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>( );iter != winPtrs.<span class="built_in">end</span>( );</span><br><span class="line">                ++iter)<span class="comment">// note lack of </span></span><br><span class="line">        (*iter)-&gt;<span class="built_in">blink</span>( );<span class="comment">// dynamic_cast</span></span><br></pre></td></tr></table></figure><p>无论是那种做法——”类安全容器“还是”virtual函数往继承体系上方移动“，都只是一个可行方案，需要靠自己判断</p><h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><p>✦Avoid casts whenever practical, especially dynamic_casts in perfor-mance-sensitive code. If a design requires casting, try to develop acast-free alternative. </p><p>✦When casting is necessary, try to hide it inside a function. Clientscan then call the function instead of putting casts in their own code.</p><p>✦Prefer C++-style casts to old-style casts. They are easier to see, andthey are more specific about what they do.</p><hr><h2 id="条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分"><a href="#条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分" class="headerlink" title="条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分"></a>条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分</h2><p><code>Avoid returning “handles” to object internals</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设您正在处理一个涉及矩形的应用程序，每个矩形可以由其左上角和右下角表示。要使矩形对象保持较小，可以决定定义其范围的点不应存储在矩形本身中，而应存储在矩形指向的辅助结构中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;<span class="comment">// Point data for a Rectangl</span></span><br><span class="line">    ePoint ulhc;<span class="comment">// ulhc = “ upper left-hand corner”</span></span><br><span class="line">    Point lrhc;<span class="comment">// lrhc = “ lower right-hand corner”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;RectData&gt; pData;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>对于Rectangle类我们添加两个const-reference member function，为何使用const-reference在<code>条款20</code>中有说明。但因此会导致以下问题。</p><h3 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;<span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                    <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">// now rec goes from</span></span><br><span class="line">                        <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure><p>由上述代码可以得知，我们不仅仅能对矩形的点进行读，并且能够进行修改，那么我们<strong>定义的数据成员与public就没有什么两样</strong>。(虽然我们在upperLeft()函数添加了const定义，但我们只是不能对指向Rectdata的智能指针进行修改，可以对该对象内部的值进行修改)</p><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过将返回值加上const我们可以让const成员限定符不在是个fake，我们只能对数据进行读写。</p><p>但是这种方式仍然会引起下述问题</p><h3 id="dangling-handles-所指对象不存在"><a href="#dangling-handles-所指对象不存在" class="headerlink" title="dangling handles 所指对象不存在"></a>dangling handles 所指对象不存在</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rectangle                <span class="comment">// returns a rectangle by</span></span><br><span class="line"><span class="built_in">boundingBox</span>(<span class="type">const</span> GUIObject&amp; obj);<span class="comment">// value; see Item3 for why</span></span><br><span class="line">                                <span class="comment">//  return type is const</span></span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//Now consider how a client might use this function:</span></span><br><span class="line">GUIObject *pgo;<span class="comment">// make pgo point to</span></span><br><span class="line">...            <span class="comment">// some GUIObject</span></span><br><span class="line"><span class="type">const</span> Point *pUpperLeft =            <span class="comment">// get a ptr to the upper </span></span><br><span class="line">    &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>( ));<span class="comment">// left point of its</span></span><br><span class="line">                                       <span class="comment">// bounding box</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析</p></blockquote><p>上述问题中会调用boundingBox(*pgo)函数对象，它所返回的值是一个临时的Rectangle副本(temp)，当我们用upperLeft去作用与temp身上，返回一个reference指向temp的一个内部成分</p><blockquote><p>错误</p></blockquote><p>当我们结束这段语句是会产生一个问题，就是我们的boundBox的返回值(temp)，将会被析构，也就是这个temp对象的内部成员都不复存在，那么我们的pUpperLeft就指向了一个<strong>不复存在的值</strong>。</p><h3 id="例外：operator"><a href="#例外：operator" class="headerlink" title="例外：operator[]"></a>例外：operator[]</h3><p>在vector和string容器中有个成员函数operator[]可以选择个别的元素，这个函数就是返回reference指向“容器内的数据”，但那些数据会随着容器的销毁而销毁。这仅仅只是有个例外。</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>✦Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helpsconst member functions act const, and minimizes the creation of dangling handles.</p><hr><h2 id="条款29：为”异常安全“而努力是值得的"><a href="#条款29：为”异常安全“而努力是值得的" class="headerlink" title="条款29：为”异常安全“而努力是值得的"></a>条款29：为”异常安全“而努力是值得的</h2><p><code>Strive for exception-safe code</code></p><blockquote><p>异常问题</p></blockquote><p>以class用来表现夹带背景图案的GUI菜单，运用于多线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;</span><br><span class="line">    ...  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image* bgImage;</span><br><span class="line">    <span class="type">int</span> imagechages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++ imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="”异常安全“的条件"><a href="#”异常安全“的条件" class="headerlink" title="”异常安全“的条件"></a>”异常安全“的条件</h3></blockquote><ol><li><p><strong>不泄漏任何资源</strong>：new Image(imgSrc)导致异常，对unlock的调用就绝不会执行。</p></li><li><p><strong>不允许数据败坏</strong>：new Iamge(imgSrc)抛出异常，bgImage就是指向一个被删除的对象，imageChanges以及被累加，而其实并没有新的图像被成功安装起来</p></li></ol><blockquote><p>RAII解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prettMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChages++;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>不在需要调用unlock</code></p><blockquote><h3 id="”异常安全函数“保证"><a href="#”异常安全函数“保证" class="headerlink" title="”异常安全函数“保证"></a>”异常安全函数“保证</h3></blockquote><ul><li><p><strong>基本承诺</strong>：异常抛出时，不会使对象或数据结构会因此而破坏，就数据保持异常抛出钱的状态</p></li><li><p><strong>强烈保证</strong>：异常抛出使，程序状态不会改变。(函数失败恢复到”调用函数之前“的状态)</p></li><li><p><strong>不抛掷保证</strong>：它们总能完成总能的原先承诺的功能</p></li></ul><h3 id="异常安全函数解决问题"><a href="#异常安全函数解决问题" class="headerlink" title="异常安全函数解决问题"></a>异常安全函数解决问题</h3><blockquote><h4 id="智能指针解决问题："><a href="#智能指针解决问题：" class="headerlink" title="智能指针解决问题："></a>智能指针解决问题：</h4></blockquote><p>1.引用智能指针类管理内存</p><p>2.将计数器的次序交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));<span class="comment">//以”new Image“;</span></span><br><span class="line">                                    <span class="comment">//设定bgImage内部指针</span></span><br><span class="line">    ++imageChagnes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><p>不需手动delete旧图像，而且删除操作是在对象被成功创建的之后，因此new成功后才会成功调用reset函数，Image（imgSrc）的临时对象也会在reset中释放掉（delete）</p><p><strong>问题</strong>：</p><p>Image构造函数会抛出异常（输出流的读取记号已经被移走）</p><h3 id="Copy-and-Swap"><a href="#Copy-and-Swap" class="headerlink" title="Copy and Swap"></a>Copy and Swap</h3><blockquote><p><strong>原则介绍</strong>：</p></blockquote><p>为你打造修改的对象（原件）做出一个副本，然后再那副本身上做一切的修改。若修改发生错误，源对象仍能保存原始状态。修改成功，则原件和副本做置换操作。</p><p>修改对象数据副本，一个<strong>不会抛出异常的函数</strong>（swap）中将修改后的数据和原件置换</p><blockquote><p>”隶属对象数据“ <strong>pimpi idiom</strong></p></blockquote><p>从原对象放进一个另一个对象内，然后赋予原对象一个指针，指向那个实现对象（副本）、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>&#123;<span class="comment">//pImpl是一个private成员具有封装性</span></span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changeBackground</span><span class="params">(std::istream pImpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">//设计copy副本（值对象），保存原始数据</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;PMImpl&gt; <span class="title">ptemp</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    <span class="comment">//修改副本</span></span><br><span class="line">    ptemp-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line"></span><br><span class="line">    ptemp-&gt;imageChanges++;</span><br><span class="line">    <span class="comment">//原始对象与副本交换</span></span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);<span class="comment">//置换数据，释放mutex·</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Exception-safe functions leak no resources and allow no data struc-tures to become corrupted, even when exceptions are thrown. Suchfunctions offer the basic, strong, or nothrow guarantees.</p><p>✦The strong guarantee can often be implemented via copy-and-swap,but the strong guarantee is not practical for all functions.</p><p>✦A function can usually offer a guarantee no stronger than the weak-est guarantee of the functions it calls. </p></blockquote><hr><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><code>Understand the ins and outs of inlining</code></p><h3 id="inline的细节"><a href="#inline的细节" class="headerlink" title="inline的细节"></a>inline的细节</h3><ol><li>inline函数代码量不易过大会导致程序体积过大，导致代码膨胀以至于额外的换页行为</li><li>inline只是对编译器的申请并不是强制命令，class内的函数被隐喻的称为inline</li><li>inline通常被置于头文件，在编译过程中进行inlining，而为将一个“函数调用”替换为“被调用函数的本体”</li></ol><h3 id="inline的声明"><a href="#inline的声明" class="headerlink" title="inline的声明"></a>inline的声明</h3><blockquote><p>隐式声明为inline的函数</p></blockquote><ul><li>member函数</li><li>friend函数</li></ul><blockquote><p>不应被声明为inline的函数</p></blockquote><ul><li>构造以及析构函数</li></ul><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>✦Limit most inlining to small, frequently called functions. This facili-tates debugging and binary upgradability, minimizes potential codebloat, and maximizes the chances of greater program speed.</p><p>✦Don’t declare function templates inline just because they appear inheader files.</p><hr><h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p><code>Minimize compilation dependdencies between files</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>( <span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr);</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;<span class="comment">// implementation detail</span></span><br><span class="line">Date theBirthDate;<span class="comment">// implementation detail</span></span><br><span class="line">Address theAddress;<span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要想让Person class编译需要加入以下头文件的类或函数声明式</p><h1 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="include &lt; string &gt;"></a>include &lt; string &gt;</h1><h1 id="include-“date-h”"><a href="#include-“date-h”" class="headerlink" title="include “date.h”"></a>include “date.h”</h1><h1 id="include-“address-h”"><a href="#include-“address-h”" class="headerlink" title="include “address.h”"></a>include “address.h”</h1><p>但这样会导致这些文件中形成一种编译的<strong>依存关系</strong>，所依赖的头文件发生改变都会让Person class的头文件进行重新文件</p><blockquote><p>将class的实现细目至于class的定义式中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">string</span>;<span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// one — see below)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><ol><li><p>string前置声明错误，正确的也复杂</p></li><li><p>前置声明每一个东西困难的是，编译器必须知道对象的大小</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(params)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器清楚的知道int需要多大，而Person需要询问class的定义式。</p><p>针对于Person类可以用以下方法：将Person分割为两个classes，一个只<strong>提供接口</strong>，一个只负责<strong>实现该接口</strong>。将负责实现的Implementation class取名为PersonImpl，Person将定义如下</p><h3 id="pimpl-idiom-pointer-to-implementation"><a href="#pimpl-idiom-pointer-to-implementation" class="headerlink" title="pimpl idiom(pointer to implementation)"></a>pimpl idiom(pointer to implementation)</h3><p><em>pimpl 惯例</em>是一种新式 C++ 技术，用于<strong>隐藏实现、最小化耦合和分离接口</strong>。 Pimpl 对于”指向实现的指针”是短的。你可能已熟悉概念，但通过其他名称（如 Che一 cat 或编译器防火墙惯例）了解它。</p><p>下面是 pimpl 惯例如何改进软件开发生命周期：</p><ul><li><p>最大程度地减少编译依赖项。</p></li><li><p>接口和实现分离。</p></li><li><p>可移植性。</p></li></ul><blockquote><p>优点</p></blockquote><p>有较好的封装性以及减少客户端的文件依赖性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pimpl</span></span><br><span class="line"><span class="comment">// 在头文件person.hpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Person类的实现细节放置在该前向声明的实现类中。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  <span class="comment">// 指向实现类Impl的私有指针</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源文件person.cpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;basic_info.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>::Impl &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string id;</span><br><span class="line">  BasicInfo basic_info;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>() : <span class="built_in">pimpl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>1.减少了需要包含的头文件；2.当内部实现发生变化时，客户端的代码不需要重新编译。例如：客户端在gcc编译中只需要连接上其动态连接库或者静态库文件，这时候服务端已经将所需的文件的编译完了，可以减少客户端编译的时间</p><p>由此修改以上Person代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="comment">// standard library components</span></span></span><br><span class="line"><span class="comment">// shouldn’t be forward-declared</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for tr1::shared_ptr; see belowclass PersonImpl;</span></span></span><br><span class="line"><span class="comment">// forward decl of Person impl. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward decls of classes used in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                    <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// ptr to implementation;</span></span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// std::tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>上述代码main class中内涵一个</p><p>这样的设计下，Person的客户就完全与Dataes，Address以及Persons的实现的细目分离。因此哪些classes的任何实现修改都不需要Person客户断重新编译。“接口与实现分离”</p><blockquote><p>关键</p></blockquote><p>这个分离在于以“声明的依存性”替换为“定义的依存性”，编译最小化的本质：现实中让头文件尽可能的自我满足，万一做不到，则让他与其他文件内的声明式(并非定义式)相依</p><h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>■Avoid using objects when object references and pointers will do</p><p>■Depend on class declarations instead of class definitions whenever you can.</p><p>声明函数而它用到某个class式，你并不需要改class的定义：纵使函数以by value方式传递改类型的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// class declaration</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// fine — no definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;<span class="comment">// of Date is needed</span></span><br></pre></td></tr></table></figure><p>声明这两个函数的无需Date的定义式，但是当有人调用哪些函数式，调用之前需要让Date的定义式曝光</p><p>如果将”提供class定义式“（通过#include完成）的义务冲”<strong>函数声明所在</strong>“之头文件转移到”<strong>内涵函数调用</strong>“之客户文件，便可将”<strong>并非真正必要的类型定义</strong>“与客户端之间的<strong>编译依存</strong>去除掉</p><p>■Provide separate header files for declarations and definitions</p><p>需要两个头文件，一个用于声明式，一个用于定义式。文件必须保持一致性，如果声明式被改变，两个文件都需要改变。<strong>#include一个声明文件</strong>而非前置声明若干函数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span><span class="comment">// header file declaring (but not</span></span></span><br><span class="line">                    <span class="comment">// defining) </span></span><br><span class="line"><span class="function"><span class="keyword">class</span> DateDate <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>C++中提供关键字export，允许将template声明式和template定义式分割与不同的文件内，但式这个关键字在有些编译器里不支持</p><h3 id="Handle-classses"><a href="#Handle-classses" class="headerlink" title="Handle classses"></a>Handle classses</h3><p>像Person这样使用pimpl idiom的classes，被称为Handle classes。</p><blockquote><p>方法一</p></blockquote><p>将他们的所有函数转交给一个相应的实验类并由后者完成实际工作。例如卖弄Person的两个成员函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span><span class="comment">// we must also #include PersonImpl’s class</span></span></span><br><span class="line"><span class="comment">// definition, otherwise we couldn’t call </span></span><br><span class="line"><span class="comment">// its member functions; note that </span></span><br><span class="line"><span class="comment">// PersonImpl has exactly the same public</span></span><br><span class="line"><span class="comment">// member functions as Person — their</span></span><br><span class="line"><span class="comment">// interfaces are identical</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">            <span class="type">const</span> Address&amp; addr): </span><br><span class="line">                        <span class="built_in">pImpl</span>(<span class="keyword">new</span> </span><br><span class="line">                            <span class="built_in">PersonImpl</span>(name, birthday, addr))&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">( )</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调PersonImpl::name，让Person百年城一个Handle class但不会改变他做的事，只会改变它做事的方法</p><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>令Person称为一个特殊的抽象基类，称为interface class。这汇总class的目的事猫叔derived的接口，因此他通常不带有成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtal函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>class的用户必须以Person的pointer和reference来写应用程序，因为他不可能针对”内含pure virtual函数“的person classes具体出实体。</p><p>interface class的客户必须有办法为这种class创建新的对象。</p><p>如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt;</span><br><span class="line">                    <span class="comment">// return a tr1::shared_ptr to a new</span></span><br><span class="line">    <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,<span class="comment">// Person initialized with the</span></span><br><span class="line">            <span class="type">const</span> Date&amp; birthday,<span class="comment">// given params; see Item18 for</span></span><br><span class="line">            <span class="type">const</span> Address&amp; addr);<span class="comment">// why a tr1::shared_ptr is returned</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户将会这样使用这些接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;Address address;</span><br><span class="line">...<span class="comment">// create an object supporting the Person interface</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 address))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>( )</span><br><span class="line">                            <span class="comment">// use the object via the</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot; was born on &quot;</span></span><br><span class="line">                            <span class="comment">// Person interface</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>( )</span><br><span class="line">    &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">address</span>( );</span><br><span class="line">    ...                    <span class="comment">// the object is automatically </span></span><br><span class="line">                            <span class="comment">// deleted when pp goes out of </span></span><br><span class="line">                            <span class="comment">// scope </span></span><br></pre></td></tr></table></figure><p>支持interface class接口的那个concrete class 必须被定义出来，而其真正的构造函数必须被调用。一切都在virtual构造函数实现所在的文件内放生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr):   <span class="built_in">theName</span>(name), </span><br><span class="line"><span class="built_in">theBirthDate</span>(birthday), </span><br><span class="line"><span class="built_in">theAddress</span>(addr)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>( ) &#123; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// implementations of these </span></span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// functions are not shown, but </span></span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// they are easy to imagineprivate:</span></span><br><span class="line">std::string theName;Date theBirthDate;Address theAddress;&#125;;</span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">//Given RealPerson, it is truly trivial to write Person::create:</span></span><br><span class="line">std::tr1::shared_ptr&lt;Person&gt; Person::</span><br><span class="line">                        <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">                                    <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> </span><br><span class="line">                        <span class="built_in">RealPerson</span>( name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更现实的Person::create实现代码会创建不同类型的derived class对象。取决于额外参数值、读自文件或数据库的数据、环境变量。</p><p>RealPerson示范实现了Interface class 的两个最常见的机制之一：从Interface class继承接口规格，然后实现出接口所覆盖的函数。第二点则是多重继承</p><h3 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h3><p>✦The general idea behind minimizing compilation dependencies is todepend on declarations instead of definitions. Two approachesbased on this idea are Handle classes and Interface classes.</p><p>✦Library header files should exist in full and declaration-only forms.This applies regardless of whether templates are involved.</p><hr><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑造出的is-a关系"><a href="#条款32：确定你的public继承塑造出的is-a关系" class="headerlink" title="条款32：确定你的public继承塑造出的is-a关系"></a>条款32：确定你的public继承塑造出的is-a关系</h2><p><code>Make sure public inheritance models &quot;is-a&quot;</code></p><p>通过public继承出的关系为“is-a”关系，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// fine, s is a Student,</span></span><br><span class="line">        <span class="comment">// and a Student is-a Person</span></span><br><span class="line"><span class="built_in">study</span>(s);<span class="comment">// fine</span></span><br><span class="line"><span class="built_in">study</span>(p);<span class="comment">// error! p isn’t a Student</span></span><br></pre></td></tr></table></figure><p>如上述关系可以表述出学生是人，但人这个抽象类却不一定是人</p><h3 id="is-a的误区"><a href="#is-a的误区" class="headerlink" title="is-a的误区"></a>is-a的误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="comment">// birds can fly</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    <span class="comment">// penguins are birds</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>错误</p></blockquote><p>这个继承体系中说明企鹅是鸟的派生类，那么它应该含有鸟类的所有行为，但是企鹅却不会飞，这点显得不是特别的严谨。我们应该让is-a有较佳的真实性</p><h3 id="方法一-双class继承体系"><a href="#方法一-双class继承体系" class="headerlink" title="方法一:双class继承体系"></a>方法一:双class继承体系</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二：运行期错误"><a href="#方法二：运行期错误" class="headerlink" title="方法二：运行期错误"></a>方法二：运行期错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;<span class="comment">// defined elsewhere</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Attempt to make a penguin fly!&quot;</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处声明出企鹅是不会飞的，那么说企鹅会飞则是一种错误的认知，在运行期的时候会被检测出来</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结:"></a>总结:</h3><p>✦Public inheritance means “is-a.” Everything that applies to baseclasses must also apply to derived classes, because every derivedclass object is a base class object.</p><hr><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p><code>Avoid hiding inherited names</code></p><h3 id="命名查找规则-作用域"><a href="#命名查找规则-作用域" class="headerlink" title="命名查找规则(作用域)"></a>命名查找规则(作用域)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>&#123;<span class="built_in">mf2</span>();&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-30-29-image.png" alt=""></p><p>Base的作用域大于Derived的作用域，根据命名查找法，当我们在Derived类中查找mf2时，选择方向Derived-&gt;Base-&gt;global。小一级的作用域会将其覆盖。</p><h3 id="名称可视性-name-visibility"><a href="#名称可视性-name-visibility" class="headerlink" title="名称可视性(name visibility)"></a>名称可视性(name visibility)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-37-52-image.png" alt=""></p><p>Base内名为mf1和mf3的重载函数都被Derived内的mf1和mf3函数所遮掩。从名称查找观点来看Base::mf1和Base::mf3不在被Derived继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1d.mf1(x);</span></span><br><span class="line">        <span class="comment">// error! Derived::mf1 hides Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );<span class="comment">// fine, calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// error! Derived::mf3 hides Base::mf3</span></span><br></pre></td></tr></table></figure><p>更具以上代码可知，当我们在重载函数时，在子类中就只能对Derived作用域的函数名可见，但是对于重载函数是不可见的。不论是virtual还是non-virtual都是一样。</p><h3 id="解决继承来的名称的遮掩行为"><a href="#解决继承来的名称的遮掩行为" class="headerlink" title="解决继承来的名称的遮掩行为"></a>解决继承来的名称的遮掩行为</h3><blockquote><p>违反is-a关系</p></blockquote><p>当public继承而又不继承哪些重载函数就是违反base和deriver class之间的<strong>is-a关系</strong> </p><blockquote><p>using声明表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1;<span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line"><span class="keyword">using</span> Base::mf3;<span class="comment">// visible (and public) in Derived’s scope</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-12-47-00-image.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// still fine, still calls Derived::mf1d.mf1(x);</span></span><br><span class="line"><span class="comment">// now okay, calls Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );</span><br><span class="line"><span class="comment">// still fine, still calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// now okay, calls Base::mf3 (The int x is </span></span><br><span class="line">        <span class="comment">// implicitly converted to a double so that</span></span><br><span class="line">        <span class="comment">// the call to Base::mf3 is valid.</span></span><br></pre></td></tr></table></figure><p>用using声明，derived类继承了base并加上了重载函数，此时也可以重写一部分重载函数将base的函数给覆盖。</p><h3 id="forward-function转交函数"><a href="#forward-function转交函数" class="headerlink" title="forward function转交函数"></a>forward function转交函数</h3><blockquote><p>使用场景</p></blockquote><p>不想继承base的所有函数，在“is-a”中会违背其含义</p><blockquote><p>private继承</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">...<span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span>    <span class="comment">// forwarding function; implicitly</span></span></span><br><span class="line"><span class="function"></span>&#123; Base::<span class="built_in">mf1</span>( ); &#125;    <span class="comment">// inline — see Item30. (For info...</span></span><br><span class="line">                    <span class="comment">// on calling a pure virtual</span></span><br><span class="line"><span class="comment">//-------继承private----------</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="comment">//---------------------------</span></span></span><br><span class="line"><span class="function">&#125;</span>;<span class="comment">// function, see Item34.)</span></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">// error! Base::mf1( ) is hidden</span></span><br></pre></td></tr></table></figure><blockquote><p>inline转交函数的用途</p></blockquote><p>哪些不支持using声明式，将继承而得的名称汇入derived作用域</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>✦Names in derived classes hide names in base classes. Under publicinheritance, this is never desirable. </p><p>✦To make hidden names visible again, employ using declarations orforwarding functions.</p><hr><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p><code>Difference between inheritance of interface and inheritance of implementation</code></p><blockquote><p>public继承概念</p></blockquote><p><strong>函数接口继承</strong>和<strong>函数实现继承</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数的接口总是会被继承"><a href="#成员函数的接口总是会被继承" class="headerlink" title="成员函数的接口总是会被继承"></a>成员函数的接口总是会被继承</h3><p>public为is-a关系继承，所有对Base class为真的事件对于Derived class也为真。</p><blockquote><p>接口与实现</p></blockquote><ul><li>接口：是(对外或者对继承)可视的，定义一个的对象实体可以通过(对外可视的)接口去访问该对象</li><li>实现：是一个实体，可以看作是接口所要做到事，对外不一定可见，对内一定可见</li></ul><blockquote><p>pure virtual函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>pure virtual函数的特性：</p></blockquote><ul><li><p>必须被他们所继承的具象类所<strong>重新声明</strong></p></li><li><p>抽象类中通常没有对该函数的定义</p></li></ul><h3 id="pure-virtual函数-子类必须重写"><a href="#pure-virtual函数-子类必须重写" class="headerlink" title="pure virtual函数(子类必须重写)"></a>pure virtual函数(子类必须重写)</h3><blockquote><p><strong>让derived class只继承接口</strong></p></blockquote><p>shape class无法对shape::draw函数提供合理的默认实现，比较其模棱两可(椭圆和矩形的画法)，因此在具象derived class 中<strong>必须提供</strong>一个draw函数，并且不干涉如何实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape;<span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;<span class="comment">// fine 多态</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Rectangle::draw</span></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;<span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls base class pure virtual函数也可以有实现</span></span><br><span class="line">Shape::drawps2-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure><h3 id="impure-virtual函数-可选是否重写"><a href="#impure-virtual函数-可选是否重写" class="headerlink" title="impure virtual函数(可选是否重写)"></a>impure virtual函数(可选是否重写)</h3><blockquote><p><strong>让derived class继承函数的接口和默认实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Shaped::error的声明式要求derived classes必须<strong>支持一个error函数</strong>，但如果不想自己写一个，那么就可以使用<strong>Shaped class提供的默认版本</strong></p><h3 id="non-virtual函数-不能重写"><a href="#non-virtual函数-不能重写" class="headerlink" title="non-virtual函数(不能重写)"></a>non-virtual函数(不能重写)</h3><blockquote><p><strong>让derived class继承函数的接口及一份强制性实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>non-virtual函数：并不打算在derived classes中有不同的行为。实际上non-virtual函数表现的不变性(invariant)大于其特异性(specialization)。</p><p>例如：Shape::objectID是有特定计算ID的一个函数，该方法是由其定义式决定的，任何derived class都<strong>不应该修改其行为</strong>，<strong>不应该在derived class中被重新定义</strong>。(<strong>破坏多态性</strong>)</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>✦Inheritance of interface is different from inheritance of implementa-tion.  Under  public  inheritance,  derived  classes  always  inherit  baseclass interfaces.</p><p>✦Pure virtual functions specify inheritance of interface only. </p><p>✦Simple  (impure)  virtual  functions  specify  inheritance  of  interfaceplus inheritance of a default implementation. </p><p>✦Non-virtual  functions  specify  inheritance  of  interface  plus  inherit-ance of a mandatory implementation.</p><h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><p><code>Consider alternatives to virtual function</code></p><p>设计一个计算人物生命值的函数healthValue()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// return character’s health rating;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// derived classes may redefine this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们一impure virtual函数去声明函数，那么当子类不提供函数重写那么人物将采用默认的声明值的计算方法</p><h3 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h3><p>Non-virtual interface实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span><span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// this — see Item36</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “before” stuff — see below</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>( );<span class="comment">// do the real work </span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “after” stuff — see below</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// default algorithm for calculating&#125;</span></span><br><span class="line">    <span class="comment">// character’s health</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本设计</p></blockquote><p>令客户通过public non-virtual成员函数去间接的调用private virtual函数，因此称为non-virtual(NVI)手法。</p><blockquote><p>优点</p></blockquote><p>NVI手法的优点在于“do ‘before’ stuff”和“do ‘after’ stuff”在上述的注释代码中，在Wrapper（healthValue）中设定好virtual函数的<strong>应用场景</strong></p><ul><li><p>“do ‘before’ stuff”：locking a mutex, making a log entry(日志记录项), verifying that class invariants and function preconditions aresatisfied, etc</p></li><li><p>“do ‘after’ stuff”：unlocking a mutex, veri-fying function postconditions, reverifying class invariants(再次验证class的约束条件), etc.</p></li></ul><blockquote><p>疑问</p></blockquote><p>NVI手法中涉及到derived class时base class private virtual 函数我们无法调用，但是我们需要redefining这些我们不会调用的private virtual 函数，看起来十分的矛盾。但时调用virtual函数表示它在”何时“被完成，但重定义virtual函数表示”如何“完成，这两者并不冲突。</p><p>NVI允许derived重新定义virtual函数，从而赋予了它如何具体实现的机能，但base class仍然保留函数合适被调用的权力</p><blockquote><p>特别的</p></blockquote><p>NVI手法中的virtual函数并不是非得是private。某些继承体要求在derived class中对应的实现必须调用器base class的对应兄弟，为了合法，那么就必须的设置为protect。</p><h3 id="Strategy-Pattern-via-Function-Pointers"><a href="#Strategy-Pattern-via-Function-Pointers" class="headerlink" title="Strategy Pattern via Function Pointers"></a>Strategy Pattern via Function Pointers</h3><blockquote><p>设计主张</p></blockquote><p>”人物的健康指数的计算与每个人物的类型无关“，这样的计算不需要人物这个成分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; </span><br><span class="line"><span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// function for the default health calculation algorithm</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                    healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>相比virtual函数继承，这种设计模式提供了更好的弹性</p><blockquote><p>实例</p></blockquote><ul><li>在<strong>同一类型的不同的实体</strong>中应用不同的计算函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                        GameCharacter(hcf )</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculationint lose</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// funcs with different</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;<span class="comment">// same-type charac-</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;<span class="comment">// ters with different// health-related</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br></pre></td></tr></table></figure><ul><li>已知人物的健康指数计算函数可在运行期变更。例如：base类可以提供一个成员函数setHealthCalculator，用来替换当前的健康计算函数</li></ul><h3 id="Strategy-Pattern-via-tr1-function"><a href="#Strategy-Pattern-via-tr1-function" class="headerlink" title="Strategy Pattern via tr1::function"></a>Strategy Pattern via tr1::function</h3><blockquote><p>函数指针的限制</p></blockquote><p>对template以及他们的的隐式接口的使用，基于函数的指针的做法就十分的死板。不够灵活，例如返回类型只能是int，函数对象不能是member function</p><blockquote><p>tr1::function</p></blockquote><p>改用tr1::function的对象替代函数指针，这样的对象可持有任何可调用物(callable entity 函数指针、函数对象、成员函数指针)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;<span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// HealthCalcFunc is any callable entity that can be called with</span></span><br><span class="line"><span class="comment">// anything compatible with a GameCharacter and that returns anything</span></span><br><span class="line"><span class="comment">// compatible with an int; see below for details</span></span><br><span class="line"><span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:</span></span><br><span class="line"><span class="function">                                             healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个实例中我们用tr1::function instantiation来代替目标签名式。那个签名代表的函数时”接受一个reference 指向const GamCharacter“，并返回int。这个tr1::function类型产生的对象可持有任何与此签名式兼容的可调用物。例如可调用物的<strong>参数可以被隐式的转换为const GameCharacters&amp;</strong>，其<strong>返回类型可以被隐式转换为int</strong></p><p>tr1::function对象相当于指向函数的泛化指针。</p><blockquote><p>更具与弹性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculation</span></span><br><span class="line"><span class="comment">// function; note </span></span><br><span class="line"><span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class for health</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span><span class="comment">// calculation function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;<span class="comment">// objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// health calculation</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mem function; note</span></span><br><span class="line">&#125;;<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// another character</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// type; assume same</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constructor as // EvilBadGuy</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;<span class="comment">// character using a</span></span><br><span class="line">                <span class="comment">// health calculation// function</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator( ))</span></span>;<span class="comment">// character using a </span></span><br><span class="line">                <span class="comment">// health calculation// function object</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// see below for details);</span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>解析ebg2 -&gt; bind</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function"> std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br></pre></td></tr></table></figure><p>GameLevel::health接受两个参数，一个是隐式参数currentLevel，也就是this指向的那个、另一个是reference指向GameCharactor。</p><p>GameCharacters的健康计算函数值接受单一参数：GameCharacters。</p><p>使用GameLevel::health作为ebg2的健康计算函数，我们需要以特殊方式转换，取出GameLevel其中的健康计算函数。</p><p>本例中用currentLevel作为ebg2的健康函数所需的GameLevel的对象。_1意味着用currenLevel作为GamLevel的对象</p><h3 id="the-“Classic”-Strategy-Pattern"><a href="#the-“Classic”-Strategy-Pattern" class="headerlink" title="the “Classic” Strategy Pattern"></a>the “Classic” Strategy Pattern</h3><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-06-21-21-05-image.png" alt=""></p><p>在该图中指示了GameCharacte是某个继承体系的根类，EviBadGuy与EyeCandyCharacter都是derived classes：HealthCalcFunc是另一个继承体系的根类。</p><blockquote><p>实现代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                                pHealthCalc(phcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>✦Alternatives to virtual functions include the NVI idiom and variousforms of the Strategy design pattern. The NVI idiom is itself an ex-ample of the Template Method design pattern.</p><p>✦A disadvantage of moving functionality from a member function to afunction outside the class is that the non-member function lacks ac-cess to the class’s non-public members.</p><p>✦tr1::function objects act like generalized function pointers. Such ob-jects support all callable entities compatible with a given target sig-nature.</p><hr><h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p><code>Never redefine an inherited non-virtual function</code></p><blockquote><p>non-virtual性质</p></blockquote><p>在条款34中描述了non-virtual函数会给class建立一个<strong>不变性</strong>(invariant),凌驾其<strong>特异性</strong>(specialization)</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">                <span class="comment">//Even without knowing anything about B, D, or mf, given an object x of</span></span><br><span class="line">                <span class="comment">//type D,</span></span><br><span class="line">D x;            <span class="comment">// x is an object of type D</span></span><br><span class="line">                <span class="comment">//you would probably be quite surprised if this,</span></span><br><span class="line">B *pB = &amp;x;      <span class="comment">// get pointer to xp</span></span><br><span class="line">B-&gt;<span class="built_in">mf</span>( );        <span class="comment">// call mf through pointerbehaved differently from this:</span></span><br><span class="line">D *pD = &amp;x;     <span class="comment">// get pointer to xp</span></span><br><span class="line">D-&gt;<span class="built_in">mf</span>( );      <span class="comment">// call mf through pointer</span></span><br></pre></td></tr></table></figure><p>上述示例中我们都会调用<strong>B::mf()</strong> 版函数，但是如果我们在D class中重写mf()那么我们会发现以下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;    <span class="comment">// hides B::mf; see Item33</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls D::mf should call B::mf</span></span><br></pre></td></tr></table></figure><blockquote><p>non-virtual函数是一种<strong>静态绑定</strong>(statically bound)</p></blockquote><pre><code>    在子类中重写non-virutal函数，它会根据其**声明式** (也就是D* ,B*)来选取函数执行，但实际上pB与pD指向都是**同一对象**，按理来说应该调用同一对象的函数，因此重写non-virtual函数会**导致破坏多态性**。</code></pre><blockquote><p>public继承关系</p></blockquote><p>public继承关系”is-a”关系，那么non-vitual函数的作用(不变性凌驾于特异性):</p><ol><li><p>适用于B对象的每一件事，也适用与D对象</p></li><li><p>B的derived classes一定会继承mf的接口与实现，因为mf是B的一个non-virutal函数</p></li></ol><blockquote><p>多态性的虚构问题</p></blockquote><p>   条款7： virtual析构函数，对于B<em> pd = new D();由于声明的是non-virtual的析构函数，那么执行的时候会根据<em>*声明式来定义</em></em> 静态绑定调用函数，因此在多态中只会使用B的析构函数，对于D的析构则不会调用，这时候有些D类的成员不能被析构，会导致内存泄漏问题</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited non-virtual function.</p><hr><h2 id="条款37：绝不重新定义继承而来的默认参数值"><a href="#条款37：绝不重新定义继承而来的默认参数值" class="headerlink" title="条款37：绝不重新定义继承而来的默认参数值"></a>条款37：绝不重新定义继承而来的默认参数值</h2><p><code>Never redefine a function&#39;s inherited default parameter value</code></p><p><strong>virtual函数系动态绑定，然而默认的却是静态绑定</strong></p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><blockquote><p>静态绑定义</p></blockquote><pre><code>    在程序中被**声明时**所采用的类型,静态绑定容易造成的问题如：继承类重写non-virtual函数</code></pre><p>简单来说就是调用对象是采用声明对象的一部分行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// a class for geometric shapes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="comment">// all shapes must offer a function to draw themselves</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Shape::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// notice the different default parameter value — bad!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Rectangle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Circle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shape *ps;                    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pc = <span class="keyword">new</span> <span class="built_in">Circle</span>();    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();<span class="comment">// static type = Shape*</span></span><br><span class="line">    ps = pc;</span><br><span class="line">    ps = pr;</span><br><span class="line">   <span class="comment">// ps-&gt;draw();</span></span><br><span class="line">    pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>();<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承关系</p></blockquote><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-07-20-28-31-image.png" alt=""></p><blockquote><p>指针(静态类型)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;    <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;<span class="comment">// static type = Shape*</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><blockquote><p>动态绑定定义</p></blockquote><pre><code>   普遍的来说是多态性，由一个**静态类型**的对象指针(引用)指向一个子类对象，在运行其就会将行为于其指向的对象进行绑定，调用子类对象的行为。    简单来说就是调用指向对象的行为</code></pre><blockquote><p>动态类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc;<span class="comment">// ps’s dynamic type is// now Circle*</span></span><br><span class="line">ps = pr;<span class="comment">// ps’s dynamic type is// now Rectangle*</span></span><br></pre></td></tr></table></figure><blockquote><p>调用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">====================</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Circle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析:动态绑定与静态绑定冲突</p></blockquote><pre><code>    在pr-&gt;draw();中出现了问题，pr的动态类型为Rectangle调用为virtual函数，但Rectangle::draw默认参数为应该时GREEN，但由于pr的静态类型为Shape*，所以此一调用的默认阐述时来自于Shape class，而不是来之于Rectangle class。这个函数时两个类共同完成的</code></pre><h3 id="NVI解决方案"><a href="#NVI解决方案" class="headerlink" title="NVI解决方案"></a>NVI解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span><span class="comment">// now non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);<span class="comment">// calls a virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">                                    <span class="comment">// the actual work is</span></span><br><span class="line">&#125;;<span class="comment">// done in this func</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;<span class="comment">// note lack of a</span></span><br><span class="line">    ...<span class="comment">// default param val.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>    non-virtual 函数一个不会被derived classes重写(条款36)，所以这个设计很清楚地使用了color的默认值为Red，相当于强制性不让动态绑定选择静态绑定的参数，NVI手法将动态绑定和静态绑定通过**private在继承中可见性**，进行了巧妙的结合</code></pre><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited default parameter value, because defaultparameter values are statically bound, while virtual functions — theonly functions you should be redefining — are dynamically bound.</p><hr><h2 id="条款38：通过复合塑造出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑造出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑造出has-a或“根据某物实现出”"></a>条款38：通过复合塑造出has-a或“根据某物实现出”</h2><p><code>Model &quot;has-a&quot;or&quot;is-implement-in-terms-of&quot; throught composition</code></p><blockquote><p>复合类型</p></blockquote><p>在一个类中的数据成员是一个或者多个自定义数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;<span class="comment">// where someone lives</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name;<span class="comment">// composed object</span></span><br><span class="line">Address address;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber voiceNumber;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber faxNumber;<span class="comment">// ditto</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>has-a与is-a</p></blockquote><p>在上述Person中定义了name、address、voiceNumber、faxNumber，我们都很容易说，这个人有一个名字、地址、号码，但我们不能说这个人是一个名字，另外is-a是一种继承关系</p><h3 id="复合类型中的has-a和“根据某物实现出”区分"><a href="#复合类型中的has-a和“根据某物实现出”区分" class="headerlink" title="复合类型中的has-a和“根据某物实现出”区分"></a>复合类型中的has-a和“根据某物实现出”区分</h3><ul><li><p>has-a是应用域</p></li><li><p>is-implement-in-terms-of是实现域</p></li></ul><p>用Set&lt; T &gt;继承list&lt; T &gt;声明如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//将list应用于Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:<span class="keyword">public</span> std::list&lt;T&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>根据上述继承关系很容易区分出错误，list可以插入相同元素，Set不能含有相同元素，因此在逻辑上，Set不适用于list的逻辑，因此也不是is-a关系，所以对于这两种关系不能用public来实现.</p><blockquote><p>正确做法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">// the right way to use list for Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;<span class="comment">// representation for Set data </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过复合类型可以很明显的看出关系，Set只是依赖list来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="type">const</span> T&amp; item) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item) != rep.<span class="built_in">end</span>( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; item)&#123; </span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::iterator it =<span class="comment">// see Item42 for info on</span></span><br><span class="line">    std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item);<span class="comment">// “typename” here</span></span><br><span class="line">                <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>( )) rep.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>✦Composition has meanings completely different from that of publicinheritance. </p><p>✦In the application domain, composition means has-a. In the imple-mentation domain, it means is-implemented-in-terms-of.</p><hr><h2 id="条款39：谨慎的使用“private”继承"><a href="#条款39：谨慎的使用“private”继承" class="headerlink" title="条款39：谨慎的使用“private”继承"></a>条款39：谨慎的使用“private”继承</h2><p><code>use private inheritance judiciously</code></p><h3 id="Private-继承"><a href="#Private-继承" class="headerlink" title="Private 继承"></a>Private 继承</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;; <span class="comment">// inheritance is now private</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// error! a Student isn’t a Person</span></span><br></pre></td></tr></table></figure><blockquote><p>private继承</p></blockquote><p>根据以上代码的展示，我们会发现private继承与public继承不是同一个含义，同样的public继承会产生一些逻辑上的错误，例如学生不是人</p><ul><li>private继承不会有隐式转换，同样<strong>不能多态</strong></li><li>private的语义为根据某物实现( is-implemented-in-terms-of),不会对外呈现父类的接口</li><li>private继承中base的成员都会变为private无论是protected还是public</li></ul><p>因此，private只在软件的实现中会有意义，在软件的设计中毫无意义</p><h3 id="复合与private继承的抉择"><a href="#复合与private继承的抉择" class="headerlink" title="复合与private继承的抉择"></a>复合与private继承的抉择</h3><p>private继承与复合都有根据某物实现( is-implemented-in-terms-of)的概念。</p><blockquote><p>取舍</p></blockquote><p>尽可能的选择复合，必要时才会使用private(当protected成员或virtual函数被牵扯进来)</p><h3 id="使用Private继承"><a href="#使用Private继承" class="headerlink" title="使用Private继承"></a>使用Private继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// automatically called for each tick</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// look at Widget usage data, etc</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于virtual函数，我们需要用private继承</p><p>上述代码当我们需要对一个Widget类进行计时，在运行期中周期性的检查Widget类。对于Timer这一个计时器，Widget中可以重新定义Timer内的virtual函数，但用public检查就说明Widget是一个Timer那肯定是不符合实际的。对于private继承确实是完美的选择：</p><ul><li>Widget会拥有Timer的一些实现,因此也是根据某物实现。</li><li>用户也不会造成接口的滥用，该此Timer实现也是对Widget对象内可见的。</li></ul><h3 id="复合实现"><a href="#复合实现" class="headerlink" title="复合实现"></a>复合实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;; </span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用复合类的方法实现private继承同样也是可以的，但是略显复杂</p><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-10-10-05-01-image.png" alt=""></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>✦Private  inheritance  means  is-implemented-in-terms  of.  It’s  usually inferior  to  composition,  but  it  makes  sense  when  a  derived  classneeds access to protected base class members or needs to redefineinherited virtual functions.</p><p>✦Unlike composition, private inheritance can enable the empty baseoptimization. This can be important for library developers who strive to minimize object sizes</p><hr><h2 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款40：明智而谨慎地使用多重继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;<span class="comment">// something a library lets you borrow</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;<span class="comment">// check the item out from the library</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// perform self-test, return whether</span></span><br><span class="line">    ...<span class="comment">// test succeeds</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>:<span class="comment">// note MI here</span></span><br><span class="line">        <span class="keyword">public</span> BorrowableItem,<span class="comment">// (some libraries loan MP3 players)</span></span><br><span class="line">        <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123; ... &#125;;                    <span class="comment">// class definition is unimportant</span></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>();<span class="comment">// ambiguous! which checkOut?</span></span><br></pre></td></tr></table></figure><blockquote><p>解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure><p>因为在MP3player中又两个相同的接口，因此在调用是会无法识别到底调用那个，因此只能指定数据成员</p><p>但是会得到一个尝试调用private成员的错误</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220511205507673.png" alt="image-20220511205507673"></p><p>以上的继承路线有两个条那么，假设File有一个filename数据成员分别继承到InputFile和OutputFile，当IOFile进行多重继承，那么我们会得到两份filename(InputFile::filename,Output::filename)。</p><p>得到的IOFile中如果要操作filename这<strong>数据成员要指定来自于那个父类</strong>同上。但再逻辑上这是不符合逻辑，一个文件不可能拥有两个名字。这时候就需要<strong>虚拟继承</strong>。</p><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><blockquote><p>含义</p><p>解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员。</p></blockquote><p>防止二义性问题，共享Top-Base类数据。</p><blockquote><p>虚拟继承与普通继承的区别</p></blockquote><p><strong>时间</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。(虚拟就是运行期进行选择)</p><p><strong>空间</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之 多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证 这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这样的做法就会使得再最终的outputFile中仅有一个一份filename，且不会产生二义性</p><h4 id="虚拟继承的成本"><a href="#虚拟继承的成本" class="headerlink" title="虚拟继承的成本"></a>虚拟继承的成本</h4><blockquote><p>空间</p></blockquote><p>virtual继承的class产生的non-virtual的继承体积大</p><blockquote><p>时间</p></blockquote><p>访问virtual继承的成员变量时，比访问non-virtual base classe的速度慢</p><h4 id="虚拟继承的初始化规则更复杂"><a href="#虚拟继承的初始化规则更复杂" class="headerlink" title="虚拟继承的初始化规则更复杂"></a>虚拟继承的初始化规则更复杂</h4><blockquote><p>初始化职责有继承中的最底层承担</p></blockquote><ol><li>classes若派生自virtual bases而需要初始化，必须要知道其virtual bases</li><li>当一个新的derived class加入继承体系中，它必须承当其virtual bases的初始化职责</li></ol><h4 id="虚拟继承的抉择"><a href="#虚拟继承的抉择" class="headerlink" title="虚拟继承的抉择"></a>虚拟继承的抉择</h4><ol><li>非必要不用虚拟继承，就用non-virtual 继承</li><li>必须使用virtual base classes，尽可能避免再其中放置数据</li></ol><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>✦Multiple inheritance is more complex than single inheritance. It canlead to new ambiguity issues and to the need for virtual inheritance. </p><p>✦Virtual  inheritance  imposes  costs  in  size,  speed,  and  complexity  ofinitialization and assignment. It’s most practical when virtual baseclasses have no data.</p><p>✦Multiple  inheritance  does  have  legitimate  uses.  One  scenario  in-volves  combining  public  inheritance  from  an  Interface  class  withprivate inheritance from a class that helps with implementation.CPersonIPersonPersonInfo{private}</p><hr><h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p><code>Understand implicit interfaces and compile-time polymorphism</code></p><h3 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h3><ul><li>提供显示接口</li><li>运行期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;<span class="comment">// see Item25</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//and this (equally meaningless) function,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">( Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ul><li>显示接口：在本例中我们在<code>doProcessing</code>中调用w的接口，我们可以在源文件中找到这些接口(.h文件)，必须知道接口的实现。</li><li>运行期多态：在条款37中有动态类型绑定，widget中virtual函数表现出来的为运行期多态</li></ul><h3 id="Template以及泛型编程-generic-programming"><a href="#Template以及泛型编程-generic-programming" class="headerlink" title="Template以及泛型编程( generic programming )"></a>Template以及泛型编程( generic programming )</h3><blockquote><p>面对对象的规则依然存在但是被弱化了</p></blockquote><ul><li>隐式接口</li><li>编译期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>w所支持的接口，是由template中的w身上的操作来决定，w需要提供一系列的隐式接口</li><li>w的任何函数的调用，入operator&gt; and operator!=,有可能造成template的据具现化(instantiated),这些函数的调用都是具现化在编译期。通俗来讲就是，通过模板类型T去判断T中是否有以下行为(接口)，如果没有则会编译失败，如果存在则进行选择</li></ul><h3 id="运行期多态与编译期多态"><a href="#运行期多态与编译期多态" class="headerlink" title="运行期多态与编译期多态"></a>运行期多态与编译期多态</h3><blockquote><p>区别</p></blockquote><ul><li>运行期多态：那个virtual函数被选择</li><li>编译期多态：那个重载函数被调用</li></ul><h3 id="隐式接口与显式接口"><a href="#隐式接口与显式接口" class="headerlink" title="隐式接口与显式接口"></a>隐式接口与显式接口</h3><blockquote><p>显式接口</p></blockquote><p>通常是由函数的签名式(函数名称、参数类型、返回类型)构成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上public接口有一个构造函数、析构函数、各个成员函数及其参数类型、返回类型、常量性构成。</p><blockquote><p>隐式接口</p></blockquote><p>它不基于函数签名式，是由有效表达式(valid expression)组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上：</p><p>T的隐式接口有一系列的约束</p><ul><li>必须提供size函数</li><li>必须提供operator !=的类型比较函数(假设<code>someNastyWidget</code>的类型为T)</li></ul><p><strong>隐式接口同样需要支持T类型</strong></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>✦Both classes and templates support interfaces and polymorphism.</p><p> ✦For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions. </p><p>✦For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution.</p><hr><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p><code>Understand the two meaning of typename</code></p><h3 id="class-and-typename-声明"><a href="#class-and-typename-声明" class="headerlink" title="class and typename 声明"></a>class and typename 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br></pre></td></tr></table></figure><p>class 与 typename没有任何不同。当声明template类型参数，class和typename的意义完全相同</p><h3 id="typename的另一重意义"><a href="#typename的另一重意义" class="headerlink" title="typename的另一重意义"></a>typename的另一重意义</h3><blockquote><p>声明“类型”</p></blockquote><p>当有static成员变量与T::~定义的类型命名冲突时会造成编译器的警告，因此需要typename的显式的声明这是命名为一个<strong>类型</strong>，而不是<strong>变量</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;<span class="comment">// typename allowed (as is “class”)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">const</span> C&amp; container,<span class="comment">// typename not allowed</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">typename</span> C::iterator iter)</span></span>;<span class="comment">// typename required</span></span><br></pre></td></tr></table></figure><p>上述的C不是嵌套从属类型名称，所以声明container时并不需要typename为签到，但C::iterator是个嵌套从属类型因此需要typename作为前置声明</p><blockquote><p>例外</p></blockquote><p>typename不能出现在base classes list内的嵌套从属类型名称之前，也不可以在member initalization list中作为base class修饰符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;<span class="comment">// base class list: typename not</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x)// base class identifier in mem.&#123;</span></span><br><span class="line">        <span class="comment">// init. list: typename not allowed</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;     <span class="comment">// use of nested dependent type</span></span><br><span class="line">        ...<span class="comment">// name not in a base class list or</span></span><br><span class="line">&#125;<span class="comment">// as a base class identifier in a </span></span><br><span class="line">...<span class="comment">// mem. init. list: typename required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>typename 与 typedef连用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>✦When declaring template parameters, class  and typename  are  inter-changeable.</p><p>✦Use typename  to  identify  nested  dependent  type  names,  except  inbase class lists or as a base class identifier in a member initializa-tion list</p><hr><h2 id="条款43-：学习处理模板化基类内的名称"><a href="#条款43-：学习处理模板化基类内的名称" class="headerlink" title="条款43 ：学习处理模板化基类内的名称"></a>条款43 ：学习处理模板化基类内的名称</h2><p><code>Know how to access names in templatized base classes</code></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>假设一个程序可以发送消息给不同公司，信息可以以密文或则明文的方式发送，用类模板这可以在编译期对公司进行选择</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...<span class="comment">// classes for other companies</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;<span class="comment">// class for holding information</span></span><br><span class="line"><span class="comment">// used to create a message</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        std::string msg;<span class="comment">//create msg from info;</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span><span class="comment">// similar to sendClear, except</span></span></span><br><span class="line"><span class="function">    </span>&#123; ... &#125;<span class="comment">// calls c.sendEncrypted</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>MsgSender类的调用不会用任何的问题</p><p>添加派生类LoggingMsgSender</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//write &quot;before sending&quot; info to the log;</span></span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// call base class function;</span></span><br><span class="line">                        <span class="comment">// this code will not compile!</span></span><br><span class="line">        <span class="comment">//write &quot;after sending&quot; info to the log;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:ice_cream: 这个派生类在新的一个non-virtual member函数中调用了父类的non-virtual member函数,这个函数解决了(条款33和条款36)non-virtual函数在派生类中出现的一系列问题，但是这个代码在不同的编译器是<strong>不能编译的</strong></p><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220518220901314.png" alt="image-20220518220901314"></p><blockquote><p>问题所在</p></blockquote><p>编译器遇到LoggingMsgSender的模板定义，不知道它是继承的那个类。</p><p>因为Company是一个模板参数，它是不确定的一个参数，只有当LoggingMsgSender被实例化后Company才会确定，因此在MsgSender&lt; Company &gt;的派生类中会出现无法确定继承的父类的问题。</p><p>更加明确的说是不知道Company中是否有sendClear这个函数</p><blockquote><p>模板全特化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123;<span class="comment">// this class offers no</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// sendCleartext function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// a total specialization of </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;<span class="comment">// MsgSender; the same as the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// general template, except </span></span><br><span class="line">    ...<span class="comment">// sendClear is omitted</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通用的MsgSender模板是不适用于CompanyZ的，因为模板提供的sendClear函数是对CompanyZ没有意义的。因此在仍然会出现上述问题，在Company中找不到sendClear的声明(因为CompanyZ的特例化没有定义sendClear函数)</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><blockquote><p>方案一:在base class函数调用动作之前加上this-&gt;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that// sendClear will be inherited</span></span><br><span class="line">        write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案二：使用using声明</p></blockquote><p>在条款33中找不到基类重载继承下来的隐藏的函数，是因为被派生类所隐藏</p><p>在本例中是编译器不搜索基类作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<span class="comment">// tell compilers to assume</span></span><br><span class="line">    ...<span class="comment">// that sendClear is in the// base class</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">            ...<span class="comment">// sendClear will be inherited</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案三：显式的指定你的函数位于base class中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">        ...<span class="comment">// sendClear will be </span></span><br><span class="line">    &#125;<span class="comment">// inherited</span></span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这是一个不太好的方法，因为被调用的是virtual函数会导致virtual函数的绑定行为被关闭</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>✦In  derived  class  templates,  refer  to  names  in  base  class  templatesvia  a  “this-&gt;”  prefix,  via using  declarations,  or  via  an  explicit  base class qualification.</p><hr><h2 id="条款44：将于参数无关的代码抽离templates"><a href="#条款44：将于参数无关的代码抽离templates" class="headerlink" title="条款44：将于参数无关的代码抽离templates"></a>条款44：将于参数无关的代码抽离templates</h2><p>Factor parameter -independent code out of templates</p><blockquote><p>不恰当的使用template可能会导致代码膨胀(code bloat):其二进制带着重复的代码、数据</p></blockquote><p>解决方法：当两个函数实现的实质相同</p><p>抽离两个函数中共同的部分，将他放入第三个函数中，然后将他们调用这个新函数。class也是同样的道理，使用继承或则复合</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>用固定尺寸的方阵编写一个template。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="comment">// template for n x n matrices of</span></span><br><span class="line">            std::<span class="type">size_t</span> n&gt;<span class="comment">// objects of type T; see below for info</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;<span class="comment">// on the size_t parameter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span></span>;<span class="comment">// invert the matrix in place</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的类型为size_t的参数是一个非类型参数(non-type parameter)。</p><p>对上述代码进行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>上述代码中，将会具现化两份invert函数，但这两份函数是完全相同，因为其中一个操作的5<em>5矩阵而另一个是10 </em>10的矩阵，除了常量5和10其他部分完全相同，这将是一个典型的代码膨胀示例</p><blockquote><p>解决方案一</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// size-independent base class for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;<span class="comment">// square matrices</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;<span class="comment">// invert matrix of the given size</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;<span class="comment">// make base class version of invert</span></span><br><span class="line">                                    <span class="comment">// visible in this class; see Items 33</span></span><br><span class="line">                                    <span class="comment">// and 43</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span> </span>&#123;<span class="built_in">invert</span>(n); &#125;<span class="comment">// make inline call to base class</span></span><br><span class="line">&#125;;<span class="comment">// version of invert</span></span><br></pre></td></tr></table></figure><p>上述解决方案中</p><p>在所有方阵实体中只会共享一个父类的invert实现，这样就有效的防止的代码膨胀</p><ul><li>避免derived class代码重复：父类使用了protect代替了public。注<code>在调用时会如果时public(实体对象仍然可以调用该接口)的话也同样会产生不同版本的代码</code></li><li>调用其代码的成本为0，因为derived classes的inverts调用base clas的版本是inline调用</li><li>this-&gt;调用表示模板化基类反之函数名称被隐盖</li><li>使用private的继承关系表现的是一种is-a关系</li></ul><p><strong>问题</strong>：在该方案中没有解决父类与子类之间联系的问题，因为在子类中需要带入矩阵的相关数据，因此需要加入一个指针或者引用。但是反复的传参，这样也会影响效率</p><blockquote><p>解决方案二：父类中存储一个指针，指向所在的内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T *pMem)<span class="comment">// store matrix size and a</span></span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123; &#125;<span class="comment">// ptr to matrix values</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">( T *ptr)</span> </span>&#123; pData = ptr; &#125;<span class="comment">// reassign pData</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;<span class="comment">// size of matrix</span></span><br><span class="line">    T *pData;<span class="comment">// pointer to matrix values</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="built_in">SquareMatrix</span>( )<span class="comment">// send matrix size and </span></span><br><span class="line">        : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123; &#125;<span class="comment">// data ptr to base class</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法在子类中调用了父类的构造函数，用来初始父类中的数据成员</p><p>当数据成员特别大的时候可以使用<strong>动态内存分配</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>( )<span class="comment">// set base class data ptr to null,</span></span><br><span class="line">        :   <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),<span class="comment">// allocate memory for matrixpData(new T[n*n])</span></span><br><span class="line">                                        <span class="comment">// values, save a ptr to the</span></span><br><span class="line">    &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>( )); &#125;<span class="comment">// memory, and give a copy of it</span></span><br><span class="line">    ...<span class="comment">// to the base classprivate:boost::scoped_array&lt;T&gt; pData;</span></span><br><span class="line">        <span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>✦Templates generate multiple classes and multiple functions, so anytemplate code not dependent on a template parameter causes bloat.</p><p>✦Bloat due to non-type template parameters can often be eliminatedby replacing template parameters with function parameters or classdata members.</p><p>✦Bloat due to type parameters can be reduced by sharing implemen-tations for instantiation types with identical binary representations.</p><hr><h2 id="条款45：使用成员函数template接受所有可以兼容的类型"><a href="#条款45：使用成员函数template接受所有可以兼容的类型" class="headerlink" title="条款45：使用成员函数template接受所有可以兼容的类型"></a>条款45：使用成员函数template接受所有可以兼容的类型</h2><p><code>Use member function template to accept “all compatible type”</code></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>行为像指针的对象，并提供指针没有的技能。STL容器几乎都是用到智能指针，但是我们不会使用“++”的运算符将一个内置的指针从link list的节点移动到另一个节点，所以需要用到迭代器</p><h3 id="真实指针-raw-pointer"><a href="#真实指针-raw-pointer" class="headerlink" title="真实指针(raw pointer)"></a>真实指针(raw pointer)</h3><p>支持隐式转换。例如：Derived class 指针可以隐式的转换为base class指针(提供多态的选择)，“指向non-const对象”的指针可以转为”const对象”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top *pt1 = <span class="keyword">new</span> Middle;<span class="comment">// convert Middle*⇒  Top*</span></span><br><span class="line">Top *pt2 = <span class="keyword">new</span> Bottom;<span class="comment">// convert Bottom*⇒  Top*</span></span><br><span class="line"><span class="type">const</span> Top *pct2 = pt1;<span class="comment">// convert Top*⇒  const Top*</span></span><br></pre></td></tr></table></figure><h3 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// smart pointers are typically</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">( T *realPtr)</span></span>;<span class="comment">// initialized by built-in pointers </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =<span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =<span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;<span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></span><br><span class="line">                            <span class="comment">//SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure><p>上述同一个template的不同具现体(instantiation)之间不存在继承关系，所以SmartPtr&lt; Top &gt;与SmartPtr&lt; Middle &gt;是完全不同的class</p><h3 id="Templates和泛型编程-Generic-Programming"><a href="#Templates和泛型编程-Generic-Programming" class="headerlink" title="Templates和泛型编程(Generic Programming)"></a>Templates和泛型编程(Generic Programming)</h3><blockquote><p>生产需求:自定义指针构造函数的编写</p></blockquote><p>当我们添加一个新继承关系的对象时，那没有添加转型的构造函数的情况下，就会反复的在SmartPtr中添加构造函数</p><p><code>class BelowBottom: public Bottom &#123; ... &#125;;</code></p><blockquote><p>member function tempaltes——泛化copy构造函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">// member template </span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);<span class="comment">// for a ”generalized</span></span><br><span class="line">    ...<span class="comment">// copy constructor”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中对于任意类型T与任意类型U，可以根据SmartPtr&lt; U &gt;生成一个SmartPtr&lt; T &gt;——因为SmartPtr&lt; T &gt;有个构造函数接受有个SmartPtr&lt; U &gt;参数。</p><p>泛化的copy构造函数并未被声明为explicit，因为原始指针之间(base class与derived class之间)的转换是隐式的转换，无需明白的写出转型动作(cast)</p><blockquote><p>提供原始资源的成员函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span><span class="comment">// initialize this held ptr: </span></span></span><br><span class="line"><span class="function">    <span class="title">heldPtr</span><span class="params">(other.get( ))</span> </span>&#123; ... &#125;<span class="comment">// with other’s held ptr</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// built-in pointer held</span></span><br><span class="line">    T*heldPtr;<span class="comment">// by the SmartPtr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用成员初始化列表来初始化SmartPtr&lt; T &gt;之内类型为T<em>的成员变量，并以类型为U</em>的指针作为初值。</p><p><code>member initialization templates</code>成员初始化列表的作用不限于构造函数，另一个作用是支持赋值操作</p><blockquote><p>摘录</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// construct from</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y * p)</span></span>;<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; <span class="comment">// built-in pointer,</span></span><br><span class="line">           <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// shared_ptr,</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// weak_ptr, or</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;<span class="comment">// auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp; r)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// assign from</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// shared_ptr or</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);<span class="comment">// auto_ptr...&#125;;</span></span><br></pre></td></tr></table></figure><p>上述所有构造函数都是explicit，唯有”泛化copy构造函数”除外，那么从<strong>某个shared_ptr类型隐式转为另一个shared_ptr</strong>是允许的，但是从某个内置指针或从其他智能指针进行隐式转换则是不允许的(显示的转换倒是可以)。</p><h3 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h3><p>✦Use member function templates to generate functions that accept allcompatible types.</p><p>✦If  you  declare  member  templates  for  generalized  copy  constructionor  generalized  assignment,  you’ll  still  need  to  declare  the  normalcopy constructor and copy assignment operator, too</p><hr><h2 id="条款46：需要类型转换是请为模板定义非成员函数"><a href="#条款46：需要类型转换是请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换是请为模板定义非成员函数"></a>条款46：需要类型转换是请为模板定义非成员函数</h2><p><code>Define non-member function inside templates when type conversion are desired</code></p><p>这个条款换个说法是：<strong>当我们需要进行模板函数参数类型需要隐式转换时，将模板函数定义为friend函数</strong></p><h3 id="示例：条款24的例子转为模板"><a href="#示例：条款24的例子转为模板" class="headerlink" title="示例：条款24的例子转为模板"></a>示例：条款24的例子转为模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// see Item28 for why returnconst </span></span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// values are still passed by value,</span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>进行以下混合式(mixed-mode)运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">// this example is from Item24,</span></span><br><span class="line">                            <span class="comment">// except Rational is now a template</span></span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;<span class="comment">// error! won’t compile</span></span><br></pre></td></tr></table></figure><p>出现以下问题：</p><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\2022-06-03-17-34-47-image.png" alt=""></p><blockquote><p>分析</p></blockquote><p>以上问题是因为没有找对应的operator * 操作符对应的函数，也就是推导失败。</p><p>以上代码中operator*这个non-member函数的两个参数进行隐式类型推导时出现了问题:</p><ul><li>第一个实参是onehalf，所以T一定是int，能够顺利的推导出</li><li>第二个实参是2，编译器无法将其推导为Rational&lt; int &gt;</li></ul><p>经过以上考虑，因该是将隐式转换类型转换函数出现调用失败的问题,无法将non-member函数指定为operator*</p><h3 id="friend函数声明"><a href="#friend函数声明" class="headerlink" title="friend函数声明"></a>friend函数声明</h3><p>template class中friend声明式可以指定特定的函数，Rational&lt; T &gt;可以声明operator<em>是<em>*class的一个friend函数</em></em></p><p>class template并不依赖template的<strong>实参推导</strong>，所以能够在class Rational&lt; T &gt;具现化时得知T,<strong>换句话说就是T的类型被确定后，就已经指定调用operator*函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">    <span class="keyword">friend</span><span class="comment">// declare operator*</span></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="comment">// function (see </span></span><br><span class="line">                             <span class="type">const</span> Rational&amp; rhs);<span class="comment">// below for details)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>此时混合式调用可以通过编译，当对象onehalf被声明为一个Rational&lt; int &gt;，class Rational&lt; int &gt;被具现化出来了。而作为过程的一部分，friend函数operator<em>(接受Rational&lt; int &gt; 参数)也就被<strong>自动声明出来</strong>。后者身为<em>*一个函而非函数模板</em></em>，因此编译器可以调用它时使用隐式转换函数。</p><p>上述friend函数同样可以声明为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\image-20220603221112025.png" alt="image-20220603221112025"></p><p>虽然经过修改我们能过通过编译，但是在链接时会出现上述问题了，因为friend函数只有一个声明式存在，并没有被定义，因此会导致连接器无法找到对应的实现</p><h3 id="函数本体与声明式结合-简单版"><a href="#函数本体与声明式结合-简单版" class="headerlink" title="函数本体与声明式结合(简单版)"></a>函数本体与声明式结合(简单版)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="friend特殊意义"><a href="#friend特殊意义" class="headerlink" title="friend特殊意义"></a>friend特殊意义</h3><p> 在本条款中虽然使用了friend却和它的<strong>传统意义</strong>不同(访问non-public成分)，但是在此的意义却是让类型转换发生于所有实参身上，我们需要一个<strong>non-member函数</strong>(条款24)；为了使这个函数<strong>自动具现化</strong>(隐式转换构造函数的指定)，我们需要将它<strong>声明在class内部</strong>；而在class内部声明non-member函数的唯一方法就是将其声明为<strong>friend函数</strong></p><h3 id="non-member与friend-member合作"><a href="#non-member与friend-member合作" class="headerlink" title="non-member与friend member合作"></a>non-member与friend member合作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(T numerator = <span class="number">0</span>,</span><br><span class="line">    T denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> d;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs,rhs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n;</span><br><span class="line">    T d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>✦When  writing  a  class  template  that  offers  functions  related  to  thetemplate  that  support  implicit  type  conversions  on  all  parameters,define those functions as friends inside the class template.</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab:KVRaft</title>
      <link href="/2023/01/13/KVRaft/"/>
      <url>/2023/01/13/KVRaft/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab3-KVRaft"><a href="#Lab3-KVRaft" class="headerlink" title="Lab3:KVRaft"></a>Lab3:KVRaft</h1><p>lab3 的内容是要在 lab2 的基础上实现一个高可用的 KV 存储服务，算是要将 raft 真正的用起来。相关协调服务可以参考OngaroPhD的作者的博士论文或者是ZooKeeper 论文笔记的协调服务,另外Chain Replicate 论文笔记的设计中同样满足了高性能读的服务</p><h1 id="PartA-Key-value-service-without-snapshots"><a href="#PartA-Key-value-service-without-snapshots" class="headerlink" title="PartA:Key/value service without snapshots"></a>PartA:Key/value service without snapshots</h1><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="Client创建"><a href="#Client创建" class="headerlink" title="Client创建"></a>Client创建</h3><p>创建client自动生成ID号(使用nrand()函数生成)用于Session来记录lastRequest的回复,用LeaderID快速连接server，减少重试leader时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">    ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">    ck.servers = servers</span><br><span class="line">    <span class="comment">// You&#x27;ll have to add code here.</span></span><br><span class="line">    ck.LeaderId = <span class="number">0</span></span><br><span class="line">    ck.ClientId = nrand()</span><br><span class="line">    ck.CommandId = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetryToLeader()</strong> ：重连leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> RetryToLeader() &#123;</span><br><span class="line">  oneRound := <span class="number">0</span></span><br><span class="line">  args := &amp;GetArgs&#123;Key: <span class="string">&quot;&quot;</span>, ClientId: ck.ClientId, CommandId: ck.CommandId&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">      oneRound++</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      reply.Err = <span class="string">&quot;&quot;</span></span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line"><span class="comment">//在分区后client可能无法连接到该失联分区的server，发送失败则更换server进行连接</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line"></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          <span class="keyword">if</span> oneRound == <span class="built_in">len</span>(ck.servers) &#123;</span><br><span class="line">              oneRound = <span class="number">0</span></span><br><span class="line">              time.Sleep(<span class="number">700</span> * time.Millisecond)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client发送读写"><a href="#Client发送读写" class="headerlink" title="Client发送读写"></a>Client发送读写</h3><h4 id="读操作-Get"><a href="#读操作-Get" class="headerlink" title="读操作:Get()"></a>读操作:Get()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  ck.CommandId++</span><br><span class="line">  args := &amp;GetArgs&#123;</span><br><span class="line">      Key:       key,</span><br><span class="line">      CommandId: ck.CommandId,</span><br><span class="line">      ClientId:  ck.ClientId,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You will have to modify this function.</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line">          <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">          ck.RetryToLeader()</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == ErrNoKey &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">          <span class="keyword">return</span> reply.Value</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写操作-PutAppend"><a href="#写操作-PutAppend" class="headerlink" title="写操作:PutAppend()"></a>写操作:PutAppend()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">    ck.CommandId++</span><br><span class="line">    args := &amp;PutAppendArgs&#123;</span><br><span class="line">        Key:       key,</span><br><span class="line">        Value:     value,</span><br><span class="line">        Op:        op,</span><br><span class="line">        CommandId: ck.CommandId,</span><br><span class="line">        ClientId:  ck.ClientId,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">for</span> !ok &#123;</span><br><span class="line">            <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">            ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.RetryToLeader()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><h3 id="创建服务器-StartKVServer"><a href="#创建服务器-StartKVServer" class="headerlink" title="创建服务器:StartKVServer():"></a>创建服务器:StartKVServer():</h3><ul><li><strong>服务器数据结构</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    rf      *raft.Raft</span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    servers     <span class="type">int</span></span><br><span class="line">    lastapplied <span class="type">int</span></span><br><span class="line">    Term        <span class="type">int</span></span><br><span class="line">    sm          KVStateMachine</span><br><span class="line">    Session     <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond       <span class="comment">// （clientId, lastRespond）record last command&#x27;s id ,respond</span></span><br><span class="line">    NotifyChans <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond <span class="comment">// (client , Chan Respond) ansynchoron to notif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read only check whether all log are applied</span></span><br><span class="line">    isRecovery <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建kv-server 与 下层raft进行交互,到达共识提高容错</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">    labgob.Register(Op&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    kv := <span class="built_in">new</span>(KVServer)</span><br><span class="line">    kv.me = me</span><br><span class="line">    kv.maxraftstate = maxraftstate</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">    <span class="comment">//creat raft layer</span></span><br><span class="line">    kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.lastapplied = kv.rf.GetFirstLogEntry().Index</span><br><span class="line">    kv.Term = <span class="number">0</span></span><br><span class="line">    kv.sm.mkv = NewMemoryKV()</span><br><span class="line">    kv.Session = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]LastRespond)</span><br><span class="line">    kv.NotifyChans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond)</span><br><span class="line">    kv.servers = <span class="built_in">len</span>(servers)</span><br><span class="line">    <span class="comment">//handle with recovery</span></span><br><span class="line">    kv.isRecovery = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    kv.recovery()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> kv.applier()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateMachine的内存模型："><a href="#StateMachine的内存模型：" class="headerlink" title="StateMachine的内存模型："></a>StateMachine的内存模型：</h3><blockquote><p>主要是创建一个kv-table，以一种内存模型的方式进行记录client端发来的修改信息,后续用于生成快照</p></blockquote><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mkv *MemoryKV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemoryKV <span class="keyword">struct</span> &#123;<span class="comment">//键值表的定义</span></span><br><span class="line">    KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemoryKV</span><span class="params">()</span></span> *MemoryKV &#123;<span class="comment">//申请堆内存</span></span><br><span class="line">    <span class="keyword">return</span> &amp;MemoryKV&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kv-table的内存模型的接口："><a href="#kv-table的内存模型的接口：" class="headerlink" title="kv-table的内存模型的接口："></a>kv-table的内存模型的接口：</h4><ul><li><strong>Append()  Put() Get()</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mkv.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mkv.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mkv.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mkv.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkv.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用日志操作到状态机"><a href="#应用日志操作到状态机" class="headerlink" title="应用日志操作到状态机"></a>应用日志操作到状态机</h4><p> 处理request信息并记录其respond:将ApplyCh中的op msg应用至kvserver状态机中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *KVStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = sm.mkv.KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Append(op.Key, op.Value)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Put(op.Key, op.Value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><ol><li><p>使用<strong>NotifyChans</strong>去通知处理request的接口，raft的op以及apply，以channel的方式进行异步的处理</p></li><li><p>用<strong>Session</strong>记录(clientID,LastRespond)，将每个client的request的响应消息进行记录，用于防止client retry多次将命令应用于state machine，以及快速响应</p></li></ol><p><strong>applier()</strong>:异步的接收raft层apply channel所传递上来的消息</p><ol><li><p><strong>防止日志回滚</strong> msg.CommandIndex &lt;= kv.lastapplied</p></li><li><p><strong>处理duplicate消息</strong> </p></li><li><p><strong>Apply</strong> 将apply的消息应用到状态机中</p></li><li><p><strong>回复客户端</strong> leader需要通过<strong>NotifyChan</strong>将状态机<strong>应用命令后回复的消息</strong>传递给该消息所调用的Put/Get,从而回复给Client,leader只能通知当前周期的命令,非当前周期的命令没有接收者从而导致阻塞</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">//avoid log rollback</span></span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> msg.CommandIndex &lt;= kv.lastapplied &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d discard outdate msg&quot;</span>, kv.me)</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            kv.lastapplied = msg.CommandIndex</span><br><span class="line">            <span class="keyword">var</span> respond CommandRespond</span><br><span class="line">            op := msg.Command.(Op)</span><br><span class="line">            <span class="comment">//apply msg -&gt; kv machine</span></span><br><span class="line">            <span class="keyword">if</span> kv.isRedundantRequest(op.ClientId, op.CommandId) &#123;</span><br><span class="line">                respond = kv.Session[op.ClientId].Respond</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                respond = kv.sm.ApplyToStateMachine(op)</span><br><span class="line">                _, isLeader := kv.rf.GetState()</span><br><span class="line">                <span class="keyword">if</span> isLeader &amp;&amp; op.opt != <span class="string">&quot;Get&quot;</span> &#123;</span><br><span class="line">                    kv.Session[op.ClientId] = LastRespond&#123;op.CommandId, respond&#125;</span><br><span class="line">                    DPrintf(<span class="string">&quot;S%d -&gt; C%d LastRequest type:%v K:%v V:%v CmdId:%d CMI:%d T:%d&quot;</span>,</span><br><span class="line">                        kv.me, op.ClientId%<span class="number">50</span>, op.Opt, op.Key, op.Value,</span><br><span class="line">                            op.CommandId, msg.CommandIndex, op.CommandTerm)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentTerm, isLeader := kv.rf.GetState(); isLeader &amp;&amp;</span><br><span class="line">                currentTerm == op.CommandTerm &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d Notify%v to C%d index %d&quot;</span>, kv.me, respond,</span><br><span class="line">                    op.ClientId%<span class="number">50</span>, msg.CommandIndex)</span><br><span class="line">                ch := kv.GetNotifyChan(msg.CommandIndex)</span><br><span class="line">                ch &lt;- respond</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作:"></a>读写操作:</h3><blockquote><p>读写操作需要满足线性一致性:[[ZooKeeper 论文笔记#线性一致性：Linearizability]]</p></blockquote><ul><li><strong>PutAppend()</strong>:处理client的修改请求</li></ul><ol><li><p>Client请求该方法</p></li><li><p>冗余检测</p></li><li><p>调用Start将Command传递到下层达到共识</p></li><li><p>创建Notifychan等待applier将response消息push</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        reply.Err = err</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d PutAppend request is redundant(PA)&quot;</span>, args.ClientId%<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       args.Op,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        Value:     args.Value,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d PutAppendRequest CmdId %d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err = cr.Err</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeOut</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Get()</strong>:将read操作记录至log，主要是防止分区时向minority partition的leader请求返回stale data导致线性不一致，<strong>缺陷</strong>：将read操作同步会导致浪费磁盘空间以及同步写入read log的时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="comment">//DPrintf(&quot;S%d is not KVLeader cmdID%d&quot;, kv.me, args.CommandId)</span></span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        value := kv.Session[args.ClientId].respond.Value</span><br><span class="line">        reply.Err, reply.Value = err, value</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d Get request is redundant(Get) cmdId %d&quot;</span>, args.ClientId%<span class="number">5</span>, args.CommandId)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       <span class="string">&quot;Get&quot;</span>,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d GetRequest LI:%d CmdId:%d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, index, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err, reply.Value = cr.Err, cr.Value</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Read-Only-Query"><a href="#Read-Only-Query" class="headerlink" title="Read-Only Query:"></a>Read-Only Query:</h2><blockquote><p>Read-only Query不讲读日志写入磁盘，因为read本就是幂等操作(idempotent),不会影响状态机的状态，因此可以不用写入磁盘同步</p></blockquote><h3 id="challenge-共识"><a href="#challenge-共识" class="headerlink" title="challenge:共识"></a>challenge:共识</h3><ul><li><p><strong>分区容错性(Partition-torlerance)</strong>：由于不写入只读日志到raft层，无法使server到达<strong>共识</strong>(强一致性)，因此当前leader无法知道是否处于<strong>大多数分区中</strong>,可能会导致分区时少部分区域的leader回复给client旧的数据。</p><p><strong>解决方案:</strong> 因此在回复client时需要<strong>确认自己的leader状态</strong>,发送heartbeat能否获得大多数的server响应</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-------------raft.<span class="keyword">go</span>----------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> KV_Sendheartbeat() <span class="type">bool</span> &#123;</span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">        Term:         rf.currentTerm,</span><br><span class="line">        LeadId:       rf.me,</span><br><span class="line">        LeaderCommit: rf.commitIndex,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            _, ok := rf.CallAE(server, args)</span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                wg.Done()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">            num++</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">//majority of peers can rececive</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------kvraft.<span class="keyword">go</span>-----------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ConfirmLeadership() <span class="type">bool</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> _, isLeader := kv.rf.GetState(); isLeader &#123;</span><br><span class="line">        isMajority = kv.rf.KV_Sendheartbeat()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Leader日志applied到最新(Leader completeness guarantee)</strong> :出现分区等问题时新的Leader没有收到当前任期的Log因此之前的任期的log也不会提交并应用，导致当leader进行在处理只读操作时leader并没有同步所有日志，例如：Leader的currentTerm = 5，自己含有term=3或4的log没有applied，导致此时leader会返回旧数据。</p><p><strong>解决方案</strong>:当任期<strong>更改</strong>时<strong>添加no-op</strong>,添加一个空的log使peers达到共识，并使leader的日志同步到达最新</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  &#123;</span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, kv.Term)</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Keep Log Completeness:Send no-op log let leader applied all log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> getCompleteness(CommandId <span class="type">int64</span>, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        CommandId:   CommandId,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">        Opt:         <span class="string">&quot;no-op&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d send no-op index %d &quot;</span>, kv.me, index)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        DPrintf(<span class="string">&quot;no-op Channel is timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>recovery的时候进行Read-only操作(Recovery Reading)</strong>：因为read-only操作不写入log(正在recovery的leader也可以返回只读操作)，所以不会等待其applied后进行返回，会导致recovery的leader将正在replay的数据返回给client。</p><p><strong>解决方案</strong>：加入一个<strong>isRecovery</strong>变量，当service重启时赋值，只读操作需要让正在恢复的leader应用到所有的log,才能执行只读操作，因此当检测到本次只读操作时leader正在recovery就需要发送no-op让leader强制同步</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  || kv.isRecovery&#123;</span><br><span class="line"></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, term)</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="comment">//将isRecovery、term放置在getCompletness</span></span><br><span class="line">        <span class="comment">//防止并发客户端的只读请求跳过no-op操作</span></span><br><span class="line">        <span class="comment">//例如：讲Term与Recovery放置在</span></span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.isRecovery = <span class="literal">false</span></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Read-Only-Query-More-efficiency："><a href="#Read-Only-Query-More-efficiency：" class="headerlink" title="Read-Only Query More efficiency："></a>Read-Only Query More efficiency：</h2><p><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a></p><p>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给 Client。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。                                                                                                                                                                                                                                                         </p><p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的 系统中是无法被接受的，通常都不会使用。                            </p><p>在 Raft 里面，节点有三个状态：Leader，Candidate 和 Follower，任何 Raft 的写入操作都必须经过 Leader，只有 Leader 将对应的 Raft Log 复制到 Majority 的节点上面认为此次写入是成功的。所以如果当前 Leader 能确定一定是 Leader，那么能够直接在此 Leader 上面读取数据，因为对于 Leader 来说，如果确认一个 Log 已经提交到大多数节点，在 t1 的时候 apply 写入到状态机，那么在 t1 后的 Read 就一定能读取到这个新写入的数据。</p><p>那么如何确认 Leader 在处理这次 Read 的时候一定是 Leader 呢？在 Raft 论文里面，提到两种方法：</p><ul><li>ReadIndex Read</li><li>Lease Read</li></ul><h3 id="ReadIndex-Read"><a href="#ReadIndex-Read" class="headerlink" title="ReadIndex Read"></a>ReadIndex Read</h3><p>第一种是 ReadIndex Read，当 Leader 需要处理 Read 请求时，Leader 与过半机器交换心跳信息确定自己仍然是 Leader 后可提供线性一致读：</p><ol><li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li><li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li><li>Leader 执行 Read 请求，将结果返回给 Client。</li></ol><p>使用 ReadIndex Read 提供 Follower Read 的功能，很容易在 Followers 节点上面提供线性一致读，Follower 收到 Read 请求之后：</p><ol><li>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li><li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li><li>Follower 执行 Read 请求，将结果返回给 Client。</li></ol><p>不同于通过 Raft Log 的 Read，ReadIndex Read 使用 Heartbeat 方式来让 Leader 确认自己是 Leader，省去 Raft Log 流程。相比较于走 Raft Log 方式，ReadIndex Read 省去磁盘的开销，能够大幅度提升吞吐量。虽然仍然会有网络开销，但是 Heartbeat 本来就很小，所以性能还是非常好的。</p><h3 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h3><p>虽然 ReadIndex Read 比原来的 Raft Log Read 快很多，但毕竟还是存在 Heartbeat 网络开销，所以考虑做更进一步的优化。Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start+Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start+Election Timeout/Clock Drift Bound 时间点。Lease Read 与 ReadIndex 类似但更进一步优化，不仅节省 Log，而且省掉网络交互，大幅提升读的吞吐量并且能够显著降低延时。</p><p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p><p>Lease Read 实现方式包括：</p><ol><li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li><li>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤(2)；</li><li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read。</li></ol><h1 id="PartB-Key-value-service-with-snapshots"><a href="#PartB-Key-value-service-with-snapshots" class="headerlink" title="PartB: Key/value service with snapshots"></a>PartB: Key/value service with snapshots</h1><h2 id="服务层使用快照-Snapshot-："><a href="#服务层使用快照-Snapshot-：" class="headerlink" title="服务层使用快照(Snapshot)："></a>服务层使用快照(Snapshot)：</h2><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p><strong>SnapShot正常执行</strong></p><ol><li><strong>调用Snapshot()</strong> :KV-Server在applier中应用日志时要判断,raft_State是否超过规定值,超过maxraftstate使用<strong>snapshot(sm_state)</strong> 拍摄状态机的状态快照,也就是将服务器的数据库、Session最后一次响应进行快照拍摄</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> needSnapshot() <span class="type">bool</span> &#123;</span><br><span class="line">    size := kv.rf.Persister.RaftStateSize()</span><br><span class="line">    <span class="keyword">if</span> kv.maxraftstate == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kv.maxraftstate &lt;= size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> takeSnapshot(CommandIndex <span class="type">int</span>) &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d Taking Snapshot CommandIndex %d&quot;</span>, kv.me, CommandIndex)</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(kv.sm.mkv)</span><br><span class="line">    e.Encode(kv.Session)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    kv.rf.Snapshot(CommandIndex, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Think about when a kvserver should snapshot its state and what should be included in the snapshot.</p><p>Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots.</p></blockquote><p><strong>snapshot包含的信息</strong>:数据库+Session</p><ul><li><p>数据库:键值表</p></li><li><p>Session:客户端与服务端会话的最后一次request的响应</p></li></ul><ol><li><strong>压缩日志持久化snapshot:</strong> snapshot中会对当前commitIndex进行压缩日志,将raft_state(压缩后的日志)</li></ol><p><strong>Crash后恢复</strong></p><ol><li>当所有Server重启后，服务端需要读取snapshot，调用ReadSnapshot(),快速恢复状态机</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> recovery() &#123;</span><br><span class="line">    data := kv.rf.Persister.ReadSnapshot()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> mkv *MemoryKV</span><br><span class="line">    <span class="keyword">var</span> session <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;mkv) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;session) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.sm.mkv = mkv</span><br><span class="line">        kv.Session = session</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理滞后Follower</strong></p><ol><li><p><strong>raft层:</strong> Leader调用InstallSnapshot()发送snapshot给滞后的follower，follower处理此条消息用将<strong>snapshot消息</strong> push到channel中</p></li><li><p><strong>服务层:</strong> 检测本条channel的snap消息，使用CondInstallSnapshot() 对raft的日志进行调整,返回正确后，读取snapshot,将已有的SM_State覆盖</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            ...apply log to SM_State</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> kv.needSnapshot() &#123;</span><br><span class="line">                kv.takeSnapshot(msg.CommandIndex)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.rf.CondInstallSnapshot(msg.SnapshotTerm, msg.SnapshotIndex, msg.Snapshot) &#123;</span><br><span class="line">                kv.lastapplied = msg.SnapshotIndex</span><br><span class="line">                <span class="comment">//updata snapshot to Sm_machine</span></span><br><span class="line">                kv.recovery()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3B.png" alt=""></p><h3 id="调试中的bug"><a href="#调试中的bug" class="headerlink" title="调试中的bug"></a>调试中的bug</h3><p><strong>问题描述</strong></p><p>服务层与raft层ch通讯延时导致服务层applied信息过慢(可能是锁的原因)，而raft_State的logs已经增长的过多。</p><p>导致服务层对于raft 通过channel传递上来的消息都要调用一次Snapshot(),但是此时的索引却又很小,一次压缩可能就是压缩一个长度的log,因此下一条命令处理后raft_State仍是很大,又是重复此流程，程序的运行的则会报出<code>logs were not trimmed 日志未裁剪的错误,改报错是超过了指定的测试指定的大小</code></p><h3 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志:"></a>调试日志:</h3><h4 id="12-1日常"><a href="#12-1日常" class="headerlink" title="12-1日常"></a>12-1日常</h4><p>呀今天改完raft的2D后，突然就把3B的实验测试点全过了，好耶！！！想着去多跑几遍看看有没有bug，突然出现一堆<strong>channel阻塞</strong>与<strong>锁的问题</strong>，调了一个晚上尚且把recover3B的测试点过了</p><h4 id="12-2日常"><a href="#12-2日常" class="headerlink" title="12-2日常"></a>12-2日常</h4><p>今天接着昨天的调试，调试今天的RecoverConcurrentPartition的并发问题，发现了一个特奇怪的现象，非leader的服务器居然在返回Get_RO操作！！！跑了很多遍了真的没办法了</p><p>于是我将Get_RO操作换回了Get操作，就全没毛病了，后面进行改进吧，555~~~</p><h3 id="12-3日常"><a href="#12-3日常" class="headerlink" title="12-3日常"></a>12-3日常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Start Partiton</span><br><span class="line">partition servers into: [1 2 4] [0 3]</span><br><span class="line">#S1是leader</span><br><span class="line">722 S1 &lt;- C13 PutAppendRequest K:3 V:x 3 3 y CmdId 11 T:25</span><br><span class="line">S1 Create Notifychan index 84</span><br><span class="line">#Commit -&gt; Applied</span><br><span class="line">S1 -&gt; C13 LastRequest type:Append K:3 V:x 3 3 y CmdId:11 CMI:84 T:25</span><br><span class="line">S1 Notify&#123; OK&#125; to C13 index 84</span><br><span class="line">#S0 之前是leader,index82的log并未提交</span><br><span class="line">S0 -&gt; C27 respond Timeout(PA) index:82</span><br><span class="line"></span><br><span class="line">partition servers into: [2 3] [0 1 4]</span><br><span class="line">#此时s1应该是leader出现华点S0回复了只读消息</span><br><span class="line">可能1,对比之前的S0为leader时T:24,S0在处理此条消息时T并未和Leader相同</span><br><span class="line">因此可能时阻塞的问题</span><br><span class="line">S0 &lt;- C13 GetRequest K:3 CmdId:12 T:24</span><br><span class="line"></span><br><span class="line">S0 -&gt; C13 CmdID:12 respond:&#123;x 3 0 yx 3 1 yx 3 2 y OK&#125;</span><br><span class="line">S0 Raft_State is 1006</span><br><span class="line">S0 Taking Snapshot CommandIndex 82 </span><br><span class="line">S0 LII 72 index 82(Compact) len(logs) 15</span><br><span class="line"></span><br><span class="line">dtest -p 5 -r -n 10 ConcurrentPartition3 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S1 &lt;- C46 PutAppendRequest K:4 V:x 4 6 y CmdId 13 T:36</span><br><span class="line">S1 Create Notifychan index 174</span><br><span class="line">partition servers into: [0 1] [2 3 4]</span><br><span class="line">S1 -&gt; C46 LastRequest type:Append K:4 V:x 4 6 y CmdId:13 CMI:174 T:36</span><br><span class="line">S1 Notify&#123; OK&#125; to C46 index 174</span><br><span class="line"># 变更leader</span><br><span class="line">S1 -&gt; C46 respond OK(PA)</span><br><span class="line">S1 &lt;- C46 GetRequest K:4 CmdId:14 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">C22 PutAppend request is redundant(PA)</span><br><span class="line">S1 &lt;- C22 GetRequest K:0 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">#S2为leader</span><br><span class="line">S2 &lt;- C40 GetRequest K:2 CmdId:44 T:34 ,Raft_T:38</span><br><span class="line">S2 Create Notifychan index 175</span><br><span class="line">S2 send no-op index 175 </span><br><span class="line">partition servers into: [3] [0 1 2 4]</span><br><span class="line">S2 &lt;- C46 GetRequest K:4 CmdId:14 T:38 ,Raft_T:38</span><br><span class="line">S2 Get peer 3</span><br><span class="line">S2 -&gt; C46 CmdID:14 respond:&#123;x 4 0 yx 4 1 yx 4 2 yx 4 3 yx 4 4 yx 4 5 y OK&#125;</span><br><span class="line">#S2的同步请求后面才applied</span><br><span class="line">S2 Applied no-op index 175</span><br><span class="line">S2 Notify&#123; &#125; to C0 index 175</span><br></pre></td></tr></table></figure><ul><li><p>由此条日志可知,与isRecovery同理，在修改kv.term后，其他请求又可以继续处理并且不需要继续发送no-op所以会导致返回旧数据</p><p>解决方案：处理完no-op后才可以修改term与isrecovery变量</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验完成了KVRaft的所有测试点，对于Raft的博士论文中的讲解对于只读操作进行了实现，但是对于只读操作的调试过程是相对于比较困难的，还好最后完成了只读操作的实现，对于follower读取(Read-Only Query More effieciency)并没有打算进行实现(主要是只读操作花费太多精力了)，如果你想要对该操作进行实现可以参考<a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a>.</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> 线性一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab2:Raft</title>
      <link href="/2023/01/13/Raft%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/01/13/Raft%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-Raft-—-实验过程记录"><a href="#Lab-2-Raft-—-实验过程记录" class="headerlink" title="Lab 2: Raft — 实验过程记录"></a>Lab 2: Raft — 实验过程记录</h1><blockquote><p>在MapReduce 、GFS、Fault-Tolerate VM 中都存在一个主要的管理机器(Cooridator 、master、primary) ，集中的去管理、分配任务、复制、同步信息。Raft是基于共识算法而实现的一个对 fault-tolerant test-and-set service</p></blockquote><h1 id="Lab-2A-Leader-Election"><a href="#Lab-2A-Leader-Election" class="headerlink" title="Lab 2A : Leader Election"></a>Lab 2A : Leader Election</h1><h2 id="Leader-Election-共识算法"><a href="#Leader-Election-共识算法" class="headerlink" title="Leader Election(共识算法)"></a>Leader Election(共识算法)</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Leader%20Election.PNG" alt=""></p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Leader%20Election%202.PNG" alt=""></p><h2 id="实现implement"><a href="#实现implement" class="headerlink" title="实现implement"></a>实现implement</h2><h3 id="1-Figure2"><a href="#1-Figure2" class="headerlink" title="1.Figure2"></a>1.Figure2</h3><p> 按照raft figure 2 的操作将其Raft结构体完善，添加相应的RPC结构体、将State转换封装为rf的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToFollower() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Follower</span><br><span class="line">    rf.votedFor = <span class="number">-1</span></span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToCandidate() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Candidate</span><br><span class="line">    rf.votedFor = rf.me</span><br><span class="line">    rf.currentTerm++</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToLeader() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Leader</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ticker-中实现Leader-Election-demo"><a href="#2-ticker-中实现Leader-Election-demo" class="headerlink" title="2.ticker()中实现Leader Election(demo)"></a>2.ticker()中实现Leader Election(demo)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration((rand.Intn(<span class="number">100</span>))+electionInterval) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isReceive &amp;&amp; rf.State != Leader &#123;</span><br><span class="line">        <span class="keyword">go</span> rf.StartElection()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> State == Follower &#123;</span><br><span class="line">        <span class="comment">//reset timer </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选举-startElection"><a href="#3-选举-startElection" class="headerlink" title="3.选举(startElection)"></a>3.选举(startElection)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartElection() &#123;</span><br><span class="line">    rf.ConvertToCandidate()</span><br><span class="line">    VoteCounter := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="comment">//go routine 向其他server发送RequestVote RPC</span></span><br><span class="line">        <span class="keyword">if</span> VoteCounter 超过一半&#123;</span><br><span class="line">            rf.ConverToLeade()</span><br><span class="line">            <span class="comment">//发送heartbeat</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-完善RPC处理函数-接收方"><a href="#4-完善RPC处理函数-接收方" class="headerlink" title="4.完善RPC处理函数(接收方)"></a>4.完善RPC处理函数(接收方)</h3><p>S1：sendRPC -&gt; S2</p><p>S2:  RPChandler 处理sendRPC的请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">true</span></span><br><span class="line">    State := rf.State</span><br><span class="line">    Term := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt;= Term &#123;</span><br><span class="line">        <span class="keyword">if</span> State != Follower &#123;</span><br><span class="line">            rf.ConvertToFollower()</span><br><span class="line">        &#125;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.Term = Term</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">true</span></span><br><span class="line">    Term := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; Term &#123;</span><br><span class="line">        reply.Term = Term</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Term &gt; Term &#123;</span><br><span class="line">        rf.ConvertToFollower()</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>在条件判断(if)中去读取变量会导致读取速度慢或是死锁问题，因此应该将共享变量在判断前用临时变量保存</p><p>例：将ticker修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration((rand.Intn(<span class="number">100</span>))+electionInterval) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    State := rf.State<span class="comment">//将共享变量枷锁读取用临时变量保存防止race</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isReceive &amp;&amp; State != Leader &#123;</span><br><span class="line">        rf.StartElection()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> State == Follower &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.votedFor = <span class="number">-1</span></span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>测试-race flag</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Lab%202%20-race.png" alt="Lab 2 -race"></p><h1 id="Lab-2B-Log-Replicated"><a href="#Lab-2B-Log-Replicated" class="headerlink" title="Lab 2B : Log Replicated"></a>Lab 2B : Log Replicated</h1><p>根据Raft论文的figure 2完成AE与Start部分的代码</p><h3 id="1-AE-接收方Follower的处理log的方式"><a href="#1-AE-接收方Follower的处理log的方式" class="headerlink" title="1.AE(接收方Follower的处理log的方式)"></a>1.AE(接收方Follower的处理log的方式)</h3><ol><li>更新log</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//condition args.Term = Term is to avoid appearing two leader with same term</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.State != Follower &#123; <span class="comment">//discover a Leader conver To Follower</span></span><br><span class="line">            rf.ConvertToFollower(args.Term)</span><br><span class="line">            Debug(dClient, <span class="string">&quot;S%d ConvertTo Follower T:%d(AE)&quot;</span>, rf.me, rf.currentTerm)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.isReceive = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123; <span class="comment">//In new Term Empty votedFor</span></span><br><span class="line">            rf.currentTerm, rf.votedFor = args.Term, <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//change Leader Term</span></span><br><span class="line">        reply.Term, reply.Success, rf.isReceive = rf.currentTerm, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update commitIndex</span></span><br><span class="line">    LastlogEntry := rf.GetLastLogEntry()</span><br><span class="line">    <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &amp;&amp; args.Term == LastlogEntry.Term &#123;</span><br><span class="line">        rf.commitIndex = min(args.LeaderCommit, LastlogEntry.Index)</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d update CI:%d&quot;</span>, rf.me, rf.commitIndex)</span><br><span class="line">        rf.applyCond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Entries == <span class="literal">nil</span> &#123; <span class="comment">//which RPC is heatbeat</span></span><br><span class="line">        Debug(dTimer, <span class="string">&quot;S%d receive heartbeat from S%d T:%d&quot;</span>, rf.me, args.LeadId, args.Term)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isMatchLog(args.PrevlogIndex, args.PrevlogTerm) &#123;</span><br><span class="line">        Debug(dLog2, <span class="string">&quot;S%d can&#x27;t match the PLI:%d&quot;</span>, rf.me, args.PrevlogIndex)</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    LastAppendEntry := args.Entries[<span class="built_in">len</span>(args.Entries)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> LastlogEntry.Term == args.Term &amp;&amp;</span><br><span class="line">        LastlogEntry.Index &gt;= LastAppendEntry.Index &#123;</span><br><span class="line">        <span class="comment">//Leader won&#x27;t delete current leader&#x27;s replicate Logs</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Debug(dLog2, &quot;S%d match prevLog from S%d&quot;, rf.me, args.LeadId)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//concurrent Start for network latency delete exist Log</span></span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Index</span><br><span class="line">    rf.logs = rf.logs[:args.PrevlogIndex-lastIncludedIndex+<span class="number">1</span>]</span><br><span class="line">    rf.logs = <span class="built_in">append</span>(rf.logs, args.Entries...)</span><br><span class="line"></span><br><span class="line">    LastlogEntry = rf.GetLastLogEntry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">        rf.commitIndex = min(args.LeaderCommit, LastlogEntry.Index)</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d update CI:%d&quot;</span>, rf.me, rf.commitIndex)</span><br><span class="line">        rf.applyCond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">    Debug(dPersist, <span class="string">&quot;S%d save T:%d VF:%d LastLog:%v&quot;</span>, rf.me, rf.currentTerm,</span><br><span class="line">        rf.votedFor, args.Entries[<span class="built_in">len</span>(args.Entries)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> LastlogEntry.Term == args.Term &amp;&amp;</span><br><span class="line">    LastlogEntry.Index &gt;= LastAppendEntry.Index &#123;</span><br><span class="line">    <span class="comment">//Leader won&#x27;t delete current leader&#x27;s replicate Logs</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>该条件是在于网络延迟AE包的到达乱序导致follower的log 被误删(相同prevIndex但是Entries更多的比Entries更少的先到)，由于在同一周期的Leader的已经添加的Log不能被删除以及，不同周期内leader不能被删除commit Log，因此有以下判断条件可以将LastlogEntry.Term更换为rf.currentTerm</code></pre><ol><li><strong>updatecommit</strong></li></ol><p>更新follower的commitIndex以heartbeat与AppendEntry中携带的信息进行更新即可</p><h3 id="2-Start-（发送方-Leader）"><a href="#2-Start-（发送方-Leader）" class="headerlink" title="2.Start （发送方 Leader）"></a>2.Start （发送方 Leader）</h3><blockquote><p>必要的函数处理</p></blockquote><p>1.log commit后发送ApplyMsg到applyCh</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendApply(index <span class="type">int</span>, command <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    applyMsg := ApplyMsg&#123;&#125;</span><br><span class="line">    applyMsg.Command = command</span><br><span class="line">    applyMsg.CommandIndex = index</span><br><span class="line">    applyMsg.CommandValid = <span class="literal">true</span></span><br><span class="line">    rf.ApplySend &lt;- applyMsg</span><br><span class="line">    <span class="comment">//Debug(dLog2, &quot;S%d saved log.Command %v, Index:%d&quot;, rf.me, applyMsg.Command, applyMsg.CommandIndex)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取N也就是更具matchIndex来判断更新commitIndex的索引</p><p>这里先将代码排序后取中位数的方法就可以获取最大的已提交的Index</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMid</span><span class="params">(matchIndex []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    tMatchArr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(matchIndex))</span><br><span class="line">    <span class="built_in">copy</span>(tMatchArr, matchIndex)</span><br><span class="line">    sort.Sort(sort.Reverse(sort.IntSlice(tMatchArr)))</span><br><span class="line"></span><br><span class="line">    N := tMatchArr[<span class="built_in">len</span>(tMatchArr)/<span class="number">2</span>]</span><br><span class="line">    Debug(dCommit, <span class="string">&quot;N :%d,tmatchArr:%v&quot;</span>, N, tMatchArr)</span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.大跨步原则快速更新NextIndex</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> OptimizeReduce(server <span class="type">int</span>, Args *AppendEntriesArgs) &#123;</span><br><span class="line">    PrevIndex := Args.PrevlogIndex</span><br><span class="line">    <span class="keyword">for</span> PrevIndex &gt; <span class="number">0</span> &amp;&amp; rf.log[PrevIndex].Term == Args.PrevlogTerm &#123;</span><br><span class="line">        PrevIndex--</span><br><span class="line">    &#125;</span><br><span class="line">    rf.nextIndex[server] = PrevIndex + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.获取最后一个log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetLastLogEntry() LogEntry &#123;</span><br><span class="line">    LastIndex := <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">    logEntry := rf.log[LastIndex]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>replicate log</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> rf.nextIndex[server] &lt; <span class="number">1</span> &#123;</span><br><span class="line">    rf.nextIndex[server] = <span class="number">1</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="keyword">if</span> LastlogEntry.Index &gt;= rf.nextIndex[server] &#123;</span><br><span class="line">    Success, ok := rf.CallAE(server, Args)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.OptimizeReduce(server, Args)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handReply...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong> :发送RPC的过程不能加锁</p><p>在发送callAE时不能进行加锁操作，因为当follower失联后会导致server收到回复十分的缓慢，这样的话锁资源不能及时释放会导致sendheartbeat等需要锁资源的活动停止行动</p><blockquote><p>更新commitIndex以及应用apply</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">//原理同AE中网络包返回的时序问题</span></span><br><span class="line"><span class="keyword">if</span> Args.PrevlogIndex+<span class="built_in">len</span>(Args.Entries) &gt; rf.matchIndex[server] &#123;</span><br><span class="line">    rf.matchIndex[server] = Args.PrevlogIndex + <span class="built_in">len</span>(Args.Entries)</span><br><span class="line">    rf.nextIndex[server] = rf.atchIndex[server] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">N := GetMid(rf.matchIndex)</span><br><span class="line">cond.Broadcast()</span><br><span class="line"><span class="keyword">if</span> rf.log[N].Term == rf.currentTerm &amp;&amp; N &gt; rf.commitIndex &#123;</span><br><span class="line">    rf.commitIndex = N</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.peers[rf.me] == p &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">        rf.lastApplied++</span><br><span class="line">        rf.SendApply(rf.lastApplied, rf.log[rf.lastApplied].Command)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure><h3 id="3-实现Election-striction（-5-41）"><a href="#3-实现Election-striction（-5-41）" class="headerlink" title="3.实现Election striction（#5.41）"></a>3.实现Election striction（#5.41）</h3><blockquote><p>RV</p></blockquote><p>follower只会给比自己日志更新(up-to-date)的candidate授予票</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.LastlogTerm != LogEntry.Term &#123;</span><br><span class="line">    reply.VoteGranted = args.LastlogTerm &gt; LogEntry.Term</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reply.VoteGranted = args.LastlogIndex &gt;= LogEntry.Index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">    rf.votedFor = args.CandidateId</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Debug(dVote, <span class="string">&quot;S%d Log is more new than S%d reject vote&quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的在startElection处RPC参数中添加上LastlogTerm参数即可</p><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2Bpass.png" alt="2Bpass.png"></p><h1 id="Lab-2C：Persistent-State"><a href="#Lab-2C：Persistent-State" class="headerlink" title="Lab 2C：Persistent State"></a>Lab 2C：Persistent State</h1><h3 id="1-Persist-函数完善"><a href="#1-Persist-函数完善" class="headerlink" title="1.Persist 函数完善"></a>1.Persist 函数完善</h3><p>persist():将Persist state写入磁盘，根据figure2 中所述将currentTerm、votedFor、log状态写入磁盘(本次实验实际上是序列化与反序列化)，此函数需要在Persist State修改后插入此函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(rf.currentTerm)</span><br><span class="line">    e.Encode(rf.votedFor)</span><br><span class="line">    e.Encode(rf.log)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    rf.persister.SaveRaftState(data)<span class="comment">//Persist.go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readpersist():在Server Crash后重启调用Make(…)，将Crash前保存的状态进行读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> Log []LogEntry</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;currentTerm) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;Log) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.currentTerm = currentTerm</span><br><span class="line">        rf.votedFor = votedFor</span><br><span class="line">        rf.log = <span class="literal">nil</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, Log...)</span><br><span class="line">        Debug(dPersist, <span class="string">&quot;S%d Read State T:%d VF:%d Log:%v&quot;</span>, rf.me,</span><br><span class="line">            rf.currentTerm, rf.votedFor, rf.log)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-RPC：失败重传"><a href="#2-RPC：失败重传" class="headerlink" title="2.RPC：失败重传"></a>2.RPC：失败重传</h3><p>任何RPC都要保证传送成功，只有当前节点状态发生改变或是传送成功时才停止</p><blockquote><p>RV</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ok &#123; <span class="comment">//follower crash re-send RV</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.State != Candidate &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    VoteGranted, ok = rf.CallRV(server, Args)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AE</p></blockquote><p>1.replicate log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Success, ok := rf.CallAE(server, Args)</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">    Debug(dDrop, <span class="string">&quot;S%d -&gt; S%d can&#x27;t replicated log&quot;</span>, rf.me, server)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Update CommitIndex</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ok &#123; <span class="comment">// re-send if follower crash</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    _, ok = rf.CallAE(server, Args)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-终止僵尸进程-heartbeat-（使用rf-killed-）"><a href="#3-终止僵尸进程-heartbeat-（使用rf-killed-）" class="headerlink" title="3.终止僵尸进程(heartbeat)（使用rf.killed()）"></a>3.终止僵尸进程(heartbeat)（使用rf.killed()）</h3><p>Debug：在发送heartbeat时leader crash后重启，该heartbeat进程尚未终止，因此当heartbeat全部都发送失败时则将状态转变为follower</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> LeaderWork() &#123;</span><br><span class="line">    heartbeatInterval := <span class="number">35</span> <span class="comment">// dont set too low to pass Count2B</span></span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//reinitialized volatile  state on leader</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sendheatbeat</span></span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        _, ok = rf.GetState()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            rf.Sendheartbeat(args)</span><br><span class="line">            time.Sleep(time.Duration(heartbeatInterval) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Unreliable：网络中的复杂通信问题"><a href="#4-Unreliable：网络中的复杂通信问题" class="headerlink" title="4.Unreliable：网络中的复杂通信问题"></a>4.Unreliable：网络中的复杂通信问题</h3><blockquote><p>Figure8Unreliable2C的测试点中的fail to reachment</p></blockquote><p>该测试点就是模拟了网络中的复杂的情况，它将包的传输顺序打乱然后随机的增加网络的传输延迟</p><blockquote><p>问题分析</p></blockquote><p>在log中的显示实际上是，在最后的cfg.one(..)中要求在一定时间内将所有的log commitIndex更新到一致</p><p>在处理包的实际中存在延迟问题，需要加以优化</p><p>Students’ Guide to Raft:<strong>不要随意重置election</strong></p><blockquote><p>Make sure you reset your election timer <em>exactly</em> when Figure 2 says you should. Specifically, you should <em>only</em> restart your election timer if a) you get an <code>AppendEntries</code> RPC from the <em>current</em> leader (i.e., if the term in the <code>AppendEntries</code> arguments is outdated, you should <em>not</em> reset your timer); b) you are starting an election; or c) you <em>grant</em> a vote to another peer</p></blockquote><p>a) 过期的RPC包不重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; args.Term&#123;</span><br><span class="line">    reply.Term = Term <span class="comment">//change Leader Term</span></span><br><span class="line">    reply.Success = <span class="literal">false</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 开始election可以重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span>StartElection()&#123;</span><br><span class="line">    ...</span><br><span class="line">    rf.isReceive = <span class="literal">true</span> <span class="comment">//在选举结束前都不会开启下一次选举</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c) RV:给另一个peer投票后才重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">    rf.votedFor = args.CandidateId</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Debug(dVote, <span class="string">&quot;S%d Log is more new than S%d reject vote&quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-实验结果："><a href="#5-实验结果：" class="headerlink" title="5.实验结果："></a>5.实验结果：</h3><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\Persist.png" alt="Persist.png"></p><h2 id="性能优化ReplicateLog"><a href="#性能优化ReplicateLog" class="headerlink" title="性能优化ReplicateLog"></a>性能优化ReplicateLog</h2><h3 id="Batch-and-PipelineTikv"><a href="#Batch-and-PipelineTikv" class="headerlink" title="Batch and PipelineTikv"></a>Batch and Pipeline<a href="https://pingcap.com/zh/blog/optimizing-raft-in-tikv">Tikv</a></h3><p>对于服务请求会多次的调用Start()去添加log，但是若每次添加Log都去触发ReplicateLog的话，那么会导致性能上的浪费。</p><ul><li><strong>Batch:</strong> 我们可以等待Start()添加log到达一定数量时去唤醒Relicate协程，将一批次的Log进行ReplicateLog</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BatchMaxSize = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BatchInterval = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> BatchMutex sync.Mutex</span><br><span class="line"><span class="keyword">var</span> batchNum <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateInBatch() &#123;</span><br><span class="line">    BatchMutex.Lock()</span><br><span class="line">    batchNum++</span><br><span class="line">    <span class="keyword">if</span> batchNum &gt;= BatchMaxSize &#123; <span class="comment">//achive batchsize,in fact the BatchMaxSize should be Set larger</span></span><br><span class="line">        batchNum = <span class="number">0</span> <span class="comment">//so is BatchInterval</span></span><br><span class="line">        BatchMutex.Unlock()</span><br><span class="line">        rf.replicateTopeers()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BatchMutex.Unlock()</span><br><span class="line">        time.Sleep(time.Duration(BatchInterval) * time.Millisecond)</span><br><span class="line">        batchNum = <span class="number">0</span></span><br><span class="line">        rf.replicateTopeers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Pipeline:</strong> 如果只是用 batch，Leader 还是需要等待 Follower 返回才能继续后面的流程，我们这里还可以使用 Pipeline 来进行加速。Leader 会维护一个 NextIndex 的变量来表示下一个给 Follower 发送的 log 位置，只负责多发，保证速率，包的顺序由接收方Follower去控制，不用在意Follower的返回。(接收方能够确保包的序列，保存或者丢弃无用的包，例如TCP中的pipeline)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateTopeers() &#123; <span class="comment">//pipeline</span></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.peers[rf.me] == p &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> rf.replicate(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicate(server <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastlogIndex := rf.GetLastLogEntry().Index</span><br><span class="line">        <span class="keyword">if</span> lastlogIndex &gt;= rf.nextIndex[server] &#123;</span><br><span class="line">            args := rf.GetAppendArgs(server)</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            Success, ok := rf.CallAE(server, args)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">                time.Sleep(time.Duration((rand.Intn(<span class="number">30</span>))+electionInterval) * time.Millisecond)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                lastIncludedIndex = rf.GetFirstLogEntry().Index</span><br><span class="line">                <span class="comment">//Pervlog(=firstIndex) can&#x27;t match the follower log that means follower is lag</span></span><br><span class="line">                <span class="keyword">if</span> args.PrevlogIndex &lt;= lastIncludedIndex &#123;</span><br><span class="line">                    rf.mu.Unlock()</span><br><span class="line">                    rf.Install(server, lastIncludedIndex)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.OptimizeReduce(server, args)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            rf.handleAEReply(server, args)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Asynchronous-Apply"><a href="#Asynchronous-Apply" class="headerlink" title="Asynchronous Apply"></a>Asynchronous Apply</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rf.applyCond = sync.NewCond(&amp;rf.mu)<span class="keyword">go</span> rf.applier()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> rf.applier()</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="comment">//asynchronous apply the command</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">            rf.applyCond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        commitIndex := rf.commitIndex</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">var</span> Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">            rf.lastApplied++</span><br><span class="line">            Command = rf.log[rf.lastApplied-rf.LastIncludedIndex].Command</span><br><span class="line">            rf.SendApply(rf.lastApplied, Command)</span><br><span class="line">        &#125;</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d LAI:%d LCI:%d&quot;</span>, rf.me, rf.lastApplied, rf.commitIndex)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Tikv.jpg" alt="Tikv.jpg"></p><h3 id="SofaRaft"><a href="#SofaRaft" class="headerlink" title="SofaRaft"></a><a href="(https://mp.weixin.qq.com/s/jzqhLptmgcNix6xYWYL01Q">SofaRaft</a></h3><ul><li>开启Replicator协程：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">    rf.matchIndex[i], rf.nextIndex[i] = <span class="number">0</span>, rf.GetLastLogEntry().Index+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.replicateCond[i] = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">        <span class="comment">//replicate log entries in batch</span></span><br><span class="line">        <span class="keyword">go</span> rf.replicator(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Replicator</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(server <span class="type">int</span>) &#123;</span><br><span class="line">    rf.replicateCond[server].L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.replicateCond[server].L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> rf.nextIndex[server] &gt; rf.GetLastLogEntry().Index &#123;</span><br><span class="line">            rf.replicateCond[server].Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pipeline</span></span><br><span class="line">        rf.replicate(server)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知协程</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastToReplicate() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.me == i &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// just Broadcast To signal go routine</span></span><br><span class="line">        rf.replicateCond[i].Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Replicate向follower发送AE</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicate(server <span class="type">int</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.GetFirstLogEntry().Index &gt; rf.nextIndex[server] &#123;</span><br><span class="line">        Args := &amp;InstallSnapshotArgs&#123;&#125;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        rf.CallISS(server, Args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        args := rf.GetAppendArgs(server)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        Success, ok := rf.CallAE(server, args)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">            <span class="comment">//Debug(dDrop, &quot;S%d -&gt; S%d can&#x27;t replicated log&quot;, rf.me, server)</span></span><br><span class="line">            rf.replicateCond[server].Signal()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">            rf.OptimizeReduce(server, args)</span><br><span class="line">            rf.replicateCond[server].Signal()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.handleAEReply(server, args)</span><br><span class="line">        rf.replicateCond[server].Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SofaRaft.jpg" alt="SofaRaft.jpg"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>Tikv</li></ul><p>batch的使用会导致测试时间加长，因为在实验中并没有大量的数据用以测试，而且在有时会用one()来要求所有peer的数据强制统一，这强制共识会花费一定的时间，并且设置了一个<strong>batchInterval</strong>的时间间隔，只有batchtime超时后才进行replicate，导致时间加长。而且对于2B的最后一个测试点，batch操作也会导致发送过多的heartbeat导致无法通过。</p><ul><li>SofaRaft</li></ul><p>时间延迟等问题还未太过研究</p><h1 id="Lab-2D-Compaction-Log"><a href="#Lab-2D-Compaction-Log" class="headerlink" title="Lab 2D: Compaction Log"></a>Lab 2D: Compaction Log</h1><blockquote><p>在实验二中并不会去实现快照只是实现日志压缩，快照的相关实现会在Lab3中实现</p></blockquote><h2 id="Snapshot的作用："><a href="#Snapshot的作用：" class="headerlink" title="Snapshot的作用："></a>Snapshot的作用：</h2><ol><li><p><strong>raft层裁剪日志</strong>：该服务属于服务层的应用接口(在VM ware 中就有该功能)，当客户端或者服务层发现log的size到达一定数量时会导致<strong>磁盘空间膨胀</strong>，因此，我们将使用snapshot对于一定的log进行<strong>裁剪删除</strong>。</p></li><li><p><strong>服务层保存状态机状态</strong>：对于服务层来说，日志到达指定大小后服务端调用Snapshot()会将<strong>applied</strong>的日志的状态机的<strong>状态(数据库…)</strong> 进行快照拍摄,并将改状态之前的日志压缩也即是丢弃，当服务端crash后可以读取改快照时的状态到达快速恢复的作用</p></li></ol><h2 id="Snapshot的接口："><a href="#Snapshot的接口：" class="headerlink" title="Snapshot的接口："></a>Snapshot的接口：</h2><ul><li>service接口</li></ul><p><strong>snapshot():</strong> log到达一定数量后进行裁剪和压缩</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Inde</span><br><span class="line">    <span class="keyword">if</span> index &lt;= lastIncludedIndex &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.CompactLog(index, snapshot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CompactLog(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Index</span><br><span class="line">    <span class="comment">//将log裁剪到lastIncludedindex,不包括该点,用以替代之前的空log[0],</span></span><br><span class="line">    <span class="comment">//更容易去进行匹配与snapshot的安装</span></span><br><span class="line">    rf.logs = rf.logs[index-lastIncludedIndex:]</span><br><span class="line">    rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span></span><br><span class="line">    rf.snapshotpersist(snapshot)</span><br><span class="line">    <span class="keyword">go</span> rf.SendApplySnapshot(index, rf.logs[<span class="number">0</span>].Term, snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>condInstallsnapshot():</strong> 服务层进行协调log与snapshot,主动调用该函数判断是否需要安装快照，服务层发现Applych发送过来的snapshot消息来判断是否还是需要重新调用snapshot()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="comment">// outdated snapshot,can&#x27;t compact uncommitted log</span></span><br><span class="line">    <span class="keyword">if</span> lastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行日志压缩</span></span><br><span class="line">    <span class="keyword">if</span> lastIncludedIndex &gt; rf.GetLastLogEntry().Index &#123;</span><br><span class="line">        rf.logs = <span class="literal">nil</span></span><br><span class="line">        rf.logs = <span class="built_in">make</span>([]LogEntry, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> rf.SendApplySnapshot(lastIncludedIndex, lastIncludedTerm, snapshot)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.CompactLog(lastIncludedIndex, snapshot)</span><br><span class="line">    &#125;</span><br><span class="line">    rf.logs[<span class="number">0</span>].Term, rf.logs[<span class="number">0</span>].Index = lastIncludedTerm, lastIncludedIndex</span><br><span class="line">    rf.lastApplied, rf.commitIndex = lastIncludedIndex, lastIncludedIndex</span><br><span class="line"></span><br><span class="line">    rf.snapshotpersist(snapshot)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>raft接口</li></ul><p><strong>saveStateAndSnapshot()</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> snapshotpersist(snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(rf.currentTerm)</span><br><span class="line">    e.Encode(rf.votedFor)</span><br><span class="line">    e.Encode(rf.logs)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    rf.persister.SaveStateAndSnapshot(data, snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReadSnapshot()</strong>：服务层恢复后读取snapshot进行恢复</p><h2 id="InstallSnapshot-RPC"><a href="#InstallSnapshot-RPC" class="headerlink" title="InstallSnapshot RPC"></a>InstallSnapshot RPC</h2><ol><li><p>Leader对滞后的follower进行发送snapshot RPC，follower在处理InstallSnapshot时，让follower直接更新到Leader的SM_state，并将其log全部删除(因为leader最小的日志索引都大于了follower)，</p></li><li><p>将其SM_state传输到服务层进行同步，因为follower时滞后的状态通过传送applyCh给服务层进行判断并存储即可</p></li></ol><blockquote><p>发送时机:</p></blockquote><ul><li>当nextIndex[server] &lt;= firstIndex(LastIncluded)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.nextIndex[server] &lt;= lastIncludedIndex &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            rf.Install(server, lastIncludedIndex)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>当发送此次RPC时最开始的index(lastIncludedIndex)都与follower匹配不上</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    lastIncludedIndex = rf.GetFirstLogEntry().Index</span><br><span class="line">    <span class="comment">//Pervlog(=firstIndex) can&#x27;t match the follower log that means follower is lag</span></span><br><span class="line">    <span class="keyword">if</span> args.PrevlogIndex &lt;= lastIncludedIndex &#123;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    rf.Install(server, lastIncludedIndex)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.OptimizeReduce(server, args)</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送InstallRPC：SnapshotRPC中的offset与done的参数也不需要完成</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Install(server <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    Debug(dSnap, <span class="string">&quot;S%d -&gt; S%d Send ISS&quot;</span>, rf.me, server)</span><br><span class="line">    lastIncludedTerm := rf.GetFirstLogEntry().Term</span><br><span class="line">    snapshot := rf.persister.ReadSnapshot()</span><br><span class="line">    args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">        Term:              rf.currentTerm,</span><br><span class="line">        LeaderId:          rf.me,</span><br><span class="line">        LastIncludedIndex: lastIncludedIndex,</span><br><span class="line">        LastIncludedTerm:  lastIncludedTerm,</span><br><span class="line">        Data:              snapshot,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rf.CallISS(server, args) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.nextIndex[server] = rf.GetLastLogEntry().Index</span><br><span class="line">        Debug(dTrace, <span class="string">&quot;S%d -&gt; S%d (ISS)update nextIndex:%d&quot;</span>, rf.me, server, rf.nextIndex[server])</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RPC处理</p></blockquote><p>若传送过来的LastIncludeIndex &lt;= rf.commitIndex则可以说明follower已经同步snapshot中的状态，不需要用此条消息中的snapshot去更新上层状态机，因此不需要处理这条消息</p><p>既然follower的log已经滞后，那么将其长度进行判断后删除log和旧的snapshot，然后args中的data[]作为snapshot持久化后再通过channel上传到service层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapShot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//handle Term as same as RequestVote</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.LastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Debug(dSnap, <span class="string">&quot;S%d &lt;- S%d InstallSnap LII:%d&quot;</span>, rf.me, args.LeaderId, args.LastIncludedIndex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> rf.SendApplySnapshot(args.LastIncludedIndex, args.LastIncludedTerm, args.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2D.png" alt="2D.png"></p><h2 id="Lab2测试结果"><a href="#Lab2测试结果" class="headerlink" title="Lab2测试结果"></a>Lab2测试结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash">go <span class="built_in">test</span> -run 2</span></span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">  ... Passed --   3.0  3  152   37666    0</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">  ... Passed --   5.6  3  363   72800    0</span><br><span class="line">Test (2A): multiple elections ...</span><br><span class="line">  ... Passed --   5.5  7 1322  276420    0</span><br><span class="line">Test (2B): basic agreement ...</span><br><span class="line">  ... Passed --   0.4  3   23    5697    3</span><br><span class="line">Test (2B): RPC byte count ...</span><br><span class="line">  ... Passed --   0.6  3   75  119217   11</span><br><span class="line">Test (2B): agreement after follower reconnects ...</span><br><span class="line">  ... Passed --   5.1  3  290   69423    8</span><br><span class="line">Test (2B): no agreement if too many followers disconnect ...</span><br><span class="line">  ... Passed --   3.5  5  415   87611    3</span><br><span class="line">Test (2B): concurrent Start()s ...</span><br><span class="line">  ... Passed --   0.5  3   21    5239    6</span><br><span class="line">Test (2B): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   6.1  3  493  107841    4</span><br><span class="line">Test (2B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --   9.2  5 3107 1524763  102</span><br><span class="line">Test (2B): RPC counts aren&#x27;t too high ...</span><br><span class="line">  ... Passed --   2.0  3  126   31740   12</span><br><span class="line">Test (2C): basic persistence ...</span><br><span class="line">  ... Passed --   8.3  3  453  110028    6</span><br><span class="line">Test (2C): more persistence ...</span><br><span class="line">  ... Passed --  14.3  5 2031  421054   16</span><br><span class="line">Test (2C): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.3  3   59   14177    4</span><br><span class="line">Test (2C): Figure 8 ...</span><br><span class="line">  ... Passed --  32.8  5 1919  414186   49</span><br><span class="line">Test (2C): unreliable agreement ...</span><br><span class="line">  ... Passed --   1.6  5 1547  462287  246</span><br><span class="line">Test (2C): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  41.1  5 15167 15643471  441</span><br><span class="line">Test (2C): churn ...</span><br><span class="line">  ... Passed --  16.2  5 21731 148707193 2309</span><br><span class="line">Test (2C): unreliable churn ...</span><br><span class="line">  ... Passed --  16.1  5 6125 5732595  603</span><br><span class="line">Test (2D): snapshots basic ...</span><br><span class="line">  ... Passed --   1.8  3  651  177508  206</span><br><span class="line">Test (2D): install snapshots (disconnect) ...</span><br><span class="line">  ... Passed --  47.6  3 3687 1268045  303</span><br><span class="line">Test (2D): install snapshots (disconnect+unreliable) ...</span><br><span class="line">  ... Passed --  74.8  3 5734 2004161  359</span><br><span class="line">Test (2D): install snapshots (crash) ...</span><br><span class="line">  ... Passed --  37.7  3 2951 1224282  365</span><br><span class="line">Test (2D): install snapshots (unreliable+crash) ...</span><br><span class="line">  ... Passed --  66.3  3 4643 1664199  355</span><br><span class="line">Test (2D): crash and restart all servers ...</span><br><span class="line">  ... Passed --   3.5  3  386   98139   57</span><br><span class="line">PASS</span><br><span class="line">ok      6.824/raft    404.893s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spanner论文笔记</title>
      <link href="/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spanner-全球化分布式数据库"><a href="#Spanner-全球化分布式数据库" class="headerlink" title="Spanner 全球化分布式数据库"></a>Spanner 全球化分布式数据库</h1><blockquote><p><strong>Title:</strong> Google’s Globally-Distributed Database,Spanner is Google’s scalable, multi-version, globallydistributed, and synchronously-replicated database</p></blockquote><p>论文中实现了广域的<strong>事务</strong>服务，也是在Google广泛使用的一种技术</p><ul><li><strong>R/W Transaction</strong>: 2PC + 2PL + Paxos Group</li><li><strong>R/O Transaction</strong>: Snapshot isolation + Synchronized Clocks</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Spanner部署"><a href="#Spanner部署" class="headerlink" title="Spanner部署"></a>Spanner部署</h3><p>Spanner的部署叫做<strong>universe</strong>，可以让Spanne全球性的管理数据，谷歌中使用了三套Spanner部署分别用于:测试、研发、上线</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/universe.png" alt=""></p><p>如上图Spanner server的结构图中，Spanner由多个<strong>Zone</strong>(管理部署的单元、物理隔离的单元)组成。一个数据中心中可以由一个或者多个Zone<br>上图中的一个Zone有一个<strong>zonemaster(分配数据给spanserver)</strong> 和100-1000个<strong>spanserver(服务与客户端)</strong>，用户使用<strong>localtion proxies</strong> 定位每个Zone中分配数据服务的<strong>spanservers</strong></p><ul><li><p><strong>universe master</strong>:主要是一个控制台，它显示了关于 zone 的各种状态信息，可以用于相互之间的调试</p></li><li><p><strong>Placement driver</strong>: 会周期性地与 spanserver 进行交互，来发现那些需要被转移的数据，或者是为了满足新的副本约束条件，或者是为了进行负载均衡</p><h3 id="Spanserver-SoftWare-Stack"><a href="#Spanserver-SoftWare-Stack" class="headerlink" title="Spanserver SoftWare Stack"></a>Spanserver SoftWare Stack</h3></li></ul><blockquote><p>每个Spanserver的副本部署以及软件栈</p></blockquote><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/SpannerSoftware.png" alt=""></p><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li><strong>Colossus</strong>:放置tablet的文件系统,GFS的升级版</li></ul><ul><li><p><strong>tablet</strong>:类似于bigtable中的tablet，实现如下映射<code>(key:string, timestamp:int64)-&gt;string</code> </p></li><li><p><strong>Paxos</strong>:共识算法于raft类似</p></li><li><p><strong>replica</strong>:Paxos的上层状态机</p></li><li><p><strong>locktable</strong>:实现并发控制,与分布式事务([[Distribute Transaction 笔记#两阶段锁（Two-Phase Locking）——悲观并发]])的二阶段锁相同</p></li><li><p><strong>Transaction manager</strong>：每个Paxos组中的支持分布式事务的软件</p></li><li><h4 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h4></li></ul><blockquote><p>universe的结构中展示了多个Zone中都含有100-1000个Spanserver，Zone可以理解为一个区域(地域)的数据中心。而每个SpanServer都是由一个Paxos状态机和Paxos协议组成(但是一个Paxos Group的Paxos副本不一定在一个Zone中),不同Zone之间的数据复制也是通过Paxos Group</p></blockquote><p>Spanner于bigtable不同之处在于，Spanner分配Timestamp给数据作为版本号，是其更像是一个多版本数据库，而不是键值对的存储，tablet的状态存储在B-tree类似的文件与WAL中</p><p>tablet的上层则是一个paxos的状态机方便复制(Paxos的一些细节我也没有研究过，复制过程可以参考[[Raft实验#Lab 2B : Log Replicated]])。每次写操作都需要写入两次：1.写入tablet的log中 2.写入Paxos的日志中。写操作必须在领导者上初始化 Paxos 协议，读操作可以直接从底层的任何副本的 tablet 中访问状态信息，只要这个副本足够新。副本的集合被称为一个 Paxos group。</p><p>对于每个是领导者的副本而言，每个 spanserver 会实现一个锁表来实现并发控制。对于那些需要同步的操作，比如事务型的读操作，需要获得锁表中的锁，而其他类型的操作则可以不理会锁表。</p><p>对于每个Paxos Group中都会有Leader会开启Transaction manager功能，每个拥有该功能的副本就称为一个<strong>Participant Leader</strong>，其余副本称为<strong>Participant slave</strong>。如果只有一个Paxos组如果一个事务只包含一个 Paxos 组(对于许多事务而言都是如此)，它就可以<font color="#00b0f0">绕过事务管理器</font>，因为锁表和 Paxos 二者一起可以保证事务性。如果一个事务包含了多 于一个 Paxos 组，那些组的领导者之间会彼此协调合作完成<font color="#00b0f0">两阶段提交</font>。其中一个参与者组，会被选为协调者，该组的 participant leader 被称为 <strong>coordinator leader</strong>，该组的 participant slaves 被称为 <strong>coordinator slaves</strong>。</p><h3 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h3><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/directory.png" alt=""></p><p>Spanner 对具有公共前缀的键做了一个抽象，称为 <strong>directory</strong>。目前一个 directory 是数据存放的基本单位。属于一个目录的所有数据，都具有相同的副本配置。 当数据在不同的 Paxos 组之间进行移动时，会一个目录一个目录地转移，如上图所示。Spanner 可能会移动一个目录从而减轻一个 Paxos 组的负担，也可能会把那些被频繁地一起访问的目录都放置到同一个组中，或者会把一个目录转移到距离访问者更近的地方。当客户端操作正在进行时，也可以进行目录的转移。我们可以预期在几秒内转移 50MB 的目录。</p><p>directory 是数据复制和placement配置的基本单位。spanner中负载均衡的最小单位也是 directory，同时提供方法 MoveDir 可以手动将一个 directory 移动到指定的zone</p><h3 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h3><p>spanner的行模型是 <code>(key:string, timestamp:int64) -&gt; row content</code>，可以看到跟big table的模型最大的不同是这里强化了row的概念，不再突出column；这样spanner的timestamp是赋给整行数据的，是有物理意义的，这使得spanner更像一个实现多版本并发的数据库，而在big table中，timestamp仅仅用于保存多个版本的key-value，跟并发完全无关；我觉得这也是为什么spanner称自己为semi-relational 数据库，而big table只称自己是semi-structure 数据库的原因。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/spannerDataModel.png" alt=""></p><p>Spanner 的数据模型不是纯粹关系型的，它的行必须有名称。更准确地说，每个表都需 要有包含一个或多个主键列的排序集合。这种需求，让 Spanner 看起来仍然有点像键值存储: 主键形成了一个行的名称，每个表都定义了从主键列到非主键列的映射。当一个行存在时，必须要求已经给行的一些键定义了一些值(即使是 NULL)。采用这种结构是很有用的，因为这可以让应用通过选择键来控制数据的局部性。</p><h3 id="High-level-Organization"><a href="#High-level-Organization" class="headerlink" title="High-level Organization"></a>High-level Organization</h3><p>考虑下图3个数据中心的A、B、C(存在于不同的地域中)，数据存储在分片中,包含了数据库的行和一些键值对，例如A的分片中有键A-M的。现将该分片复制到B、C数据中心中，即使整个数据中心出现故障也可以继续。</p><p>位于不同数据中心的spanserver形成了Paxos Group 如Figure3中所示，也就是一个Paxos Group中的副本可以存在于不同数据中心中。三个键A-M的shard是通过日志复制使状态机去更新键值对</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerShard.jpg" alt=""></p><h4 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h4><ul><li><p>多个分片是为了获得更好的并行性</p></li><li><p>每个分片有一个Paxos组用于复制，若a-c的距离远复制开销大，也只需要a、b之间获得majority即可</p></li><li><p>数据中心的容错，速率过慢</p></li><li><p>副本靠近客户端，客户可以获得高性能的只读事务,其原理[[KVRaft#Read-Only Query:]]</p></li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><h3 id="Read-of-local-Relipca-yield-latest-write"><a href="#Read-of-local-Relipca-yield-latest-write" class="headerlink" title="Read of local Relipca yield latest write"></a>Read of local Relipca yield latest write</h3><p>追求更强的一致性，在ZooKeeper中实现的fast-read是弱的线性一致性。本地副本需要读到最新的写，在本文中将会用到</p><h3 id="Trasaction-across-shard"><a href="#Trasaction-across-shard" class="headerlink" title="Trasaction across shard"></a>Trasaction across shard</h3><p>支持跨分片的事务，例如转账事务中一个分片是一个账户、另一个分片是目标账户，当我们要执行转账操作时可以像事务一样执行，并且具有ACID的语义</p><h3 id="Transaction-must-be-serializable"><a href="#Transaction-must-be-serializable" class="headerlink" title="Transaction must be serializable"></a>Transaction must be serializable</h3><p>读取多条记录的事务必须是可序列化的。但是本地碎片可能反映已提交事务的不同子集!</p><h2 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h2><div class="table-container"><table><thead><tr><th><strong>Method</strong></th><th><strong>return</strong></th></tr></thead><tbody><tr><td>TT.now()</td><td>TTinterval: [earliest, latest]</td></tr><tr><td>TT.after(t)</td><td>true if t has definitely passed</td></tr><tr><td>TT.before(t)</td><td>true if t has definitely not arrived</td></tr></tbody></table></div><p>TrueTime API 是一个非常有创意的东西，可以同步全球的时间。</p><ul><li><p>TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。</p></li><li><p>TT.after(t)和TT.before(t)是基于TT.now()实现的。</p></li></ul><p>那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。实际部署的时候。每个数据中心需要部署一些Master机器，其他机器上需要有一个slave进程来从Master同步。有的Master用GPS，有的Master用原子钟。</p><blockquote><p>Denote the absolute time of an event e by the function t<sub>abs</sub>(e). In more formal terms, TrueTime guarantees that for an invocation tt = TT.now(), tt.earliest ≤ t<sub>abs</sub>(e<sub>now</sub>) ≤ tt.latest, where enow is the invocation event.</p></blockquote><h2 id="Concurrent-control"><a href="#Concurrent-control" class="headerlink" title="Concurrent control"></a>Concurrent control</h2><h3 id="Timestamp-Management"><a href="#Timestamp-Management" class="headerlink" title="Timestamp Management"></a>Timestamp Management</h3><p>Spanner使用TrueTime来控制并发，实现外部一致性。支持以下几种事务。</p><ul><li>读写事务：读写操作的集合</li><li>只读事务：只有读操作，并且提供的<strong>snapshot isolation</strong>的功能，保证强一致性</li><li>快照读,只读事务由客户端提供时间戳：可以读取stale data</li><li>快照读,客户端提供时间范围<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerTransaction.png" alt=""></li></ul><p>上表是Spanner现在支持的事务。单独的写操作都被实现为读写事务 ； 单独的非快照被实现为只读事务。事务总有失败的时候，如果失败，对于这两种操作会自己重试，无需应用自己实现重试循环。</p><p>时间戳的设计大大提高了只读事务的性能。事务开始的时候，要声明这个事务里没有写操作，只读事务可不是一个简单的没有写操作的读写事务。它会用一个系统时间戳去读，所以对于同时的其他的写操作是没有Block的(只读事务是lock free的)。而且只读事务可以在任意一台已经更新过的replica上面读。</p><p>对于快照读操作，可以读取以前的数据，需要客户端指定一个时间戳或者一个时间范围。Spanner会找到一个已经充分更新好的replica上读取。</p><p>还有一个<strong>有趣的特性</strong>的是，对于只读事务，如果执行到一半，该replica出现了错误。客户端没有必要在本地缓存刚刚读过的时间，因为是根据时间戳读取的。只要再用刚刚的时间戳读取，就可以获得一样的结果。</p><h3 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h3><h4 id="RW-Transaction-without-TS"><a href="#RW-Transaction-without-TS" class="headerlink" title="RW Transaction without TS"></a>RW Transaction without TS</h4><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerRW.png" alt=""></p><p>A、B是两个不同的数据中心，客户端最开始的请求的读操作并不是事务操作，目的是为了找到Paxos Group的leader，并且Leader在锁表中分配该数据的锁，当client获得返回值时进行提交(commit)，该实现与Lab3中的读操作服务本质相同。后续执行二段提交部分，提交完成后并释放锁。</p><p>这种实现与[[Distribute Transaction 笔记]]中实现的2PC+2PL的实现方法相同，只不过加入了Paxos的容错设计</p><h4 id="Assigning-Timestamp-to-RW-Transaction"><a href="#Assigning-Timestamp-to-RW-Transaction" class="headerlink" title="Assigning Timestamp to RW Transaction"></a>Assigning Timestamp to RW Transaction</h4><p>事务的读写将会用到二段锁，当所有的锁都已经获得以后，在任何锁被释放之前(也就是持有所有锁期间)，就可以给事务分配时间戳。对于一个给定的事务，Spanner 会为事务分配时间戳，这个时间戳是 Paxos 分配给 Paxos 写操作的，它代表了<font color="#00b0f0">事务提交的时间</font>。</p><p>Spanner 依赖下面这些单调性:在每个 Paxos 组内，Spanner 会以单调增加的顺序给每个 Paxos 写操作分配时间戳，即使在跨越多个领导者时也是如此。一个单个的领导者副本，可以很容易地以单调增加的方式分配时间戳。在多个领导者之间就会强制实现彼此隔离的不连 贯:一个领导者必须只能分配属于它自己租约时间区间内的时间戳。要注意到，一旦一个时间戳 S 被分配，S<sub>max</sub> 就会被增加到 s，从而保证彼此隔离性(不连贯性)。</p><ul><li>S<sub>i</sub>：一个读写事务的时间戳，当S<sub>i</sub>被分配，S<sub>max</sub>就会增长到S</li><li>T<sub>i</sub>：表示一个事务</li><li>e<sub>i</sub>：代表一个事务的一些事件如开始或结束</li><li>e<sub>i</sub><sup>server</sup> ：表示写事务T<sub>i</sub>的Commit请求到达Coordinator的时间</li><li>t<sub>abs</sub>：一个时间的绝对时间</li></ul><p><strong>External consistency</strong> -&gt; 不变性(invariant)：如果事务T2开始发生在T1提交事务之前，T2的时间戳就必须大于T1的提交事务的时间戳———-tabs(e<sub>1</sub><sup>commit</sup>)<tabs(e<sub>2&lt;/sub&gt;<sup>start</sup>)=&gt;S<sub>1</sub> &lt; S<sub>2 </sub></p><p><strong>Start</strong>：为一个事务 T<sub>i </sub>担任协调者的领导者分配一个提交时间戳 s<sub>i</sub>，不会小于 TT.now().latest 的值，TT.now().latest的值是在e<sub>i</sub><sup>server</sup>事件之后计算得到的。要注意，担任参与者的领导者， 在这里不起作用。第 4.2.1 节描述了这些担任参与者的领导者是如何参与下一条规则的实现的。</p><p><strong>Commit Wait</strong>：担任协调者的领导者，必须确保客户端不能看到任何被 T<sub>i</sub> 提交的数据，直到 TT.after(s<sub>i</sub>)为真。提交等待，就是要确保 s<sub>i</sub> 会比 T<sub>i</sub> 的绝对提交时间小。Commit Wait 的证明如下图所示(只针对于R/W 事物)</p><ul><li>commit wait：T1的时间戳小于其commit提交开始的绝对时间</li><li>assumption：T2的开始时间大于T1 commit的事件的事件</li><li>causality： T2开始的时间小于或等于其commit消息到coordinator的时间</li><li>start：commit消息到达coordinator的时间小于等于T2的时间戳则事物开始</li><li>transitivity：可以得到s1发生在s2之前</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerProof.png" alt=""></p><h4 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h4><p>Spanner在2PC开始之前读操作将会发生在transaction中被Client缓存，这样的话读操作就不会看见同一事务中写入的影响了</p><p><strong>读写操作的实现细节</strong><br>读操作在读写事务中使用wound-wait方法去避免死锁。Client发起读操作到合适Paxos Group的leader副本，获取读锁并且读取最近的数据，在客户端事务存活的时候会不断的向leader发心跳，防止超时。当客户端完成了所有的读操作，并且缓存了所有的写操作，就开始了两阶段提交。客户端选择一个coordinator group，并给每一个leader发送coordinator的id和缓存的写数据。(由客户端驱动二段提交避免两次广域的链接)</p><p><strong>写操作开始</strong><br>non-coordinator-leader首先会获取一个写锁，选择一个prepare时间戳大于之前事务已经分配时间戳的，通过Paxos记录prepare日志。每一个Participant的都要给coordinator发送他自己prepare的那个时间戳。</p><p>coordinator leader首先获得写锁但是需要<font color="#00b0f0">跳过Prepare阶段</font>，在收到(hearing,应该是类似与心跳的机制)所有Participant的Prepare消息后，它需要准备一个时间戳给整个事务，并且commit timestamp S必须大于或等于所有的prepare的时间戳(满足4.1.3中的限制)，大于TT.now().lastest，同一时间coordinator收到commit消息(Participant回复Prepare消息是commit/abort形式)并且大于leader分配给之前事务的时间戳</p><p>在coordinator的副本apply commit的日志记录之前，为了遵循commit-wait规则coordinator leader需要等待TT.after(S)。因为coordinator leader需拿着S基于TT.now().lastest,并且。在commit-wait之后coordinator leader会commit的时间戳发送给client和所有Participant leader</p><h3 id="只读事务-高性能读"><a href="#只读事务-高性能读" class="headerlink" title="只读事务:高性能读"></a>只读事务:高性能读</h3><ul><li>快速的读从本地的(邻近的)分片中``</li><li>不需要<strong>二段锁</strong></li><li>不需要<strong>二段提交</strong></li></ul><h4 id="Corretness"><a href="#Corretness" class="headerlink" title="Corretness"></a>Corretness</h4><p><strong>Serializeble:</strong> R/W<sub>1</sub>（T1）  R/O   R/W<sub>2 </sub>（T2） R/W</p><p><strong>External consistency(外部一致性)</strong><br>Serializable+Real time，与线性一致性相似只不过Extenal consisitency是<font color="#00b0f0">事务级别的属性</font></p><p><strong>示例</strong>：下一个事务必须看见上一个事务的写入</p><ol><li>如果事务T1再另一个事务T2开始之前提交, 则T1提交的时间戳会小于T2提交的时间戳</li><li>如果T1&lt; T2  ，则T2 必须看见T1的写入</li></ol><h4 id="Bad-Plan-只读操作读取最新提交的值"><a href="#Bad-Plan-只读操作读取最新提交的值" class="headerlink" title="Bad Plan 只读操作读取最新提交的值"></a>Bad Plan 只读操作读取最新提交的值</h4><p>由于R/O操作是不加锁的，T3在只读操作时Ry会读取到T2提交的值，因此违背了事务的隔离性也不是串行化。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Bad_Read.png" alt=""></p><h4 id="R-O-with-Snapshot-isolation"><a href="#R-O-with-Snapshot-isolation" class="headerlink" title="R/O with Snapshot isolation"></a>R/O with Snapshot isolation</h4><ol><li>分配时间戳给事务:<ul><li><strong>R/W:</strong> commit 提交开始(coordinator leader分配)</li><li><strong>R/O:</strong> Start 事务开始(paxos leader分配)</li></ul></li><li>执行事务按照时间戳的顺序</li><li>每个副本的数据存储都需要有时间戳作为版本号(MVCC,multiple version concurrent control)</li></ol><blockquote><p>In both Bigtable and Spanner, we designed for long-lived transactions (for example, for report generation, which might take on the order of minutes), which perform poorly under optimistic concurrency control in the presence of conflicts</p></blockquote><p>论文中所讲到Spanner在事务(<strong>实际上是只读事务，读写事务还是需要加锁</strong>)上使用了乐观并发控制，对于只读事务我们是不加锁的，因此对于只读事务我们使用乐观并发控制。</p><p>PS: 在FaRM论文中实现了对与读写事务的OCC，对于读操作是不加锁的</p><p>DDIA中说到：Serilaizability + Snapshot isolation = Optimistic concurrent control </p><p>如下图：T1提交的时间戳为@10，T2提交的时间戳为@20，T3只读事务开始的时间戳为@15，读取y值，会按照时间戳的顺序，因此读取y值会现读@15以前的数据，满足了快照隔离性与可串行性</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Snapshot_isolation.png" alt=""></p><h4 id="R-O-from-Local-Replica-non-Leader-of-Paxos"><a href="#R-O-from-Local-Replica-non-Leader-of-Paxos" class="headerlink" title="R/O from Local Replica(non-Leader of Paxos)"></a>R/O from Local Replica(non-Leader of Paxos)</h4><p>从当地副本进行只读事务，有可能只读事务之前写入还没有同步复制到该副本。例如：副本中没有W@10的操作</p><p><strong>解决方案</strong></p><ul><li>Saft Time ：所有副本中会跟踪这个t<sub>safe</sub>值是所有副本中最大的时间戳，以此来保证副本是最新的。若读操作时间戳为@t,一个副本需要满足t&lt;=t<sub>saft</sub> ,才能进行读写。</li><li>Paxos按照时间戳的顺序发送写操作给副本</li><li>在Rx@15执行前，需要等待大于@15的时间戳写入(与no-op操作道理是一样的)</li><li>等待prepared但是未commit的事务执行</li></ul><h4 id="Clock-must-be-perfect"><a href="#Clock-must-be-perfect" class="headerlink" title="Clock must be perfect"></a>Clock must be perfect</h4><ul><li><p>对只读事务很重要</p></li><li><p>只读事务的时间戳过大 =&gt; 等待时间过长</p></li><li><p>只读事务的时间戳过小 =&gt; 分配给T3更小的时间戳例如为5</p></li></ul><p>Example of problem if r/o xaction’s TS is too small:<br>  r/w T1 @  0: Wx1 C<br>  r/w T2 @ 10:         Wx2 C<br>  r/o T3 @  5:                   Rx?<br>(C for commit)</p><p>根据上述情形我们只会看见T1@0写入的x=1的值，但是实际上T3开始在T2提交过后，根据external consistency：T3必须看见T2的写入x=2。该问题就是不正确时钟导致的分配时间戳错误的问题,</p><p>下述方案中将会解决不正确时钟导致时间戳过小的问题</p><h4 id="Timestamp-are-interval"><a href="#Timestamp-are-interval" class="headerlink" title="Timestamp are interval"></a>Timestamp are interval</h4><p>  Time service yields a TTinterval = [ earliest, latest ].<br>  The correct time is guaranteed to be somewhere in the interval.<br>  Interval width computed from measured network delays,<br>    clock drift assumptions, GPS specs.<br>  Figure 6: intervals are usually microseconds, but sometimes 10+ milliseconds.<br>  So: server clocks aren’t exactly synchronized, but TrueTime<br>    bounds how wrong a server’s clock can be.</p><p>如何保证R/O Txn不会的时间戳不会太小导致读写错误<br>4.12节两个规则[[#Assigning Timestamp to RW Transaction]]</p><ul><li><strong>Start rule</strong>:<br>  事务的时间戳<font color="#00b0f0"> TS = TT.now().latest</font><br>  对于只读事务来说时间戳TS就是开始时间<br>  对于读写事务来说时间戳TS就是事务提交开始(commit begin)的时间，也就是prepared完成时间。</li><li><strong>Commit wait</strong>, for r/w xaction:<br> 在完成提交前, 延迟直到TS &lt; TS.now().earliest，保证该时间戳已经过去，因此只读操作永远不会选择在commit事务开始之前的时间戳。</li></ul><h4 id="update-example-with-interval"><a href="#update-example-with-interval" class="headerlink" title="update example with interval"></a>update example with interval</h4><p>该方案是T1提交然后T2开始，T2必须看见T1的写入，需要TS1 &lt; TS2<br>  r/w T0 @  1: Wx1 C<br>                   |1—————-10| |11———————20|<br>  r/w T1 @ 10:         Wx2 P          C<br>                                 |10————12|<br>  r/o T2 @ 12:                           Rx?<br>(P for T1’s Prepare, C for T1 finishing Commit)</p><p>在P中T2选择了TS2 = TT.now().lastest = 10，Commit-Wait确保C发生在TS2之后(@10过去)，C开始读取时钟获得间隔为11-20 (CommitWait TS.now().earliest =11 &gt;10)。</p><p>T3开始在C之后通过Commit-wait规则我们已经直到@10这个真实时间已经过去(assumption条件)，因此T3在@10之后，T2选择TS3=TT.now().latest=12,这个值是在当前时间之后所以是在@10之后,我们将会读到T2写入的值。</p><blockquote><p>为什么当T2在提交时，T3并发执行能够获得会得到T2的值? 因为根据lab3中只有committed的log才会应用(applied)到状态机，从而修改数据库的值。如果在处理只读事务T3时，并状态机没有应用T2@10写入的数据，会导致T3读取不到T2的值。</p></blockquote><p>我的猜想是<strong>saft time</strong>的机制解决该问题，等待大于@12的值写入数据库之后才能处理只读。因为我们已经分配了为@12的时间戳给了只读事务T3，执行顺序也不会出错，现在就是保证replica中一定由@10的写入。</p><blockquote><p>Commit-Wait的规则是保证序列化与时间戳的正确性。</p></blockquote><p>该例子只是解释了commit-wait+True Time的机制可以防止时钟的错误导致违背外部一致性，因此是否能够读写的T2的写入我想是必然的(因为读取不到T1的写入也违背外部一致性)，但是如何解决T2事务commit与T3并发处理的机制，还是取决于设计者。</p><p>最后可得TS3&gt;TS2,因此T3的可以读到T2写入的X的值</p><blockquote><p>Why this provides external consistency for r/o transactions:<br>  Given that T1 finishes before T2 starts.Commit wait means TS1 is <strong>guaranteed to be in the past.</strong> TS2 = TT.now().latest is guaranteed to be &gt;= correct time thus &gt;= TS of any previous committed transaction (due to its commit wait)</p></blockquote><h4 id="detail-1"><a href="#detail-1" class="headerlink" title="detail"></a>detail</h4><p>分配时间戳需要参与到读事务的Paxos groups的协商，这样的话，Spanner需要一个Scope的表示每一个只读操作，可以描述整个读事务的键(PS：应该不需要coordinator的参加)</p><p><strong>single Paxos</strong>：scop的值只被一个Paxos Group提供，client提交只读事务到leader。leader分配一个S<sub>read</sub>的时间戳并执行读操作。LastTS()是Paxos Group最后一次comitted的读操作，如果没有任何的已经准备的事务，S<sub>read</sub>=LastTS()满足了external-consistency:事务将会看见最后一次写入的结果，因此只读事务将会安排到之后一次提交写事务完成之后</p><p><strong>multiple Paxos</strong>：拥有多个的选项，最复杂的选项是所有groups的leader协商完基于LastTS()的S<sub>read</sub>，一个更简单的选着是clent避免协商的回合，当满足Sread = TT.now().lastest。所有的读操作将会发送到up-to-date的副本</p><h3 id="discussion"><a href="#discussion" class="headerlink" title="discussion"></a>discussion</h3><ul><li>R/W Txn =&gt; 2PC + 2PL</li><li>R/O Txn =&gt; Snapshot isolation + serializablity</li><li>extenal consistency  =&gt; timestamp order + time interval</li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt">https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt</a></p><h4 id="Q-原子时钟是什么"><a href="#Q-原子时钟是什么" class="headerlink" title="Q: 原子时钟是什么?"></a>Q: 原子时钟是什么?</h4><p>A: 一个非常稳定的振荡器。有两种主要的技术被称为“原子钟”:铷钟和铯钟。两者都利用了外层电子状态的变化，这涉及到特定的能量量子和波长。人们可以通过观察电子的兴奋程度来精确地将信号发生器调节到那个波长。原子钟只是时钟的振荡器部分:它产生一个频率，使时钟以正确的频率滴答作响，但它自己不知道它是什么时间。为了提供时间，原子钟最初必须与时间同步，通常是通过GPS(它本身是由一堆原子钟提供时间的)。</p><h4 id="Q-Spanner使用什么种类的原子时钟"><a href="#Q-Spanner使用什么种类的原子时钟" class="headerlink" title="Q: Spanner使用什么种类的原子时钟?"></a>Q: Spanner使用什么种类的原子时钟?</h4><p>A: 遗憾的是，论文没有说明。铷时钟通常是几千美元(e.g. <a href="https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP">https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP</a> 5071A就是一个很好的例子。铯钟不会漂移。当然，任何一个时钟都可能发生故障或电源故障，所以即使有完美的铯时钟，你仍然需要多个铯时钟，并能够同步到UTC。我猜，基于价格，Spanner使用的是与GPS接收器同步的铷时钟。</p><h4 id="Q-TrueTime如何以一种保证包含正确时间的方式选择间隔"><a href="#Q-TrueTime如何以一种保证包含正确时间的方式选择间隔" class="headerlink" title="Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?"></a>Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?</h4><p>A: 这里有一个简单的例子来说明它所使用的推理方法。</p><p>假设主时间服务器S1拥有正确的时间(来自GPS或原子钟)。S2向S1发送请求，询问时间，并得到响应。响应显示“10:00:00 AM”，它在S2发送请求后两秒到达(可以合理地假设S2可以计算事情所花费的时间，即使它不知道绝对时间)。由于整个请求/响应花费了两秒，S2可以推断网络可能将请求延迟了两秒;或者将响应延迟两秒;但仅此而已。因此S2可以得出结论，在它接收到响应的那一刻，正确的时间必须在09:59:58和10:00:02之间。</p><h4 id="Q-外部一致性与线性一致性和序列化有什么关系"><a href="#Q-外部一致性与线性一致性和序列化有什么关系" class="headerlink" title="Q: 外部一致性与线性一致性和序列化有什么关系?"></a>Q: 外部一致性与线性一致性和序列化有什么关系?</h4><p>A: 外部一致性似乎等同于线性化，但应用于整个事务，而不是单个的读写。外部一致性似乎也等同于严格的串行性，这是添加了等效串行顺序必须服从实时顺序的约束的串行性。关键属性是，如果事务T1完成，然后(随后实时)事务T2开始，T2必须看到T1的写入。</p><h4 id="Q-为什么外部一致性是可取的"><a href="#Q-为什么外部一致性是可取的" class="headerlink" title="Q: 为什么外部一致性是可取的?"></a>Q: 为什么外部一致性是可取的?</h4><p>A: 假设哈特谢普苏特通过圣何塞数据中心的网络服务器修改了她的工作组共享的一个帐户的密码。她低声说把新密码隔着隔间告诉了她的同事卡桑德拉。卡桑德拉通过位于圣马特奥的另一个数据中心的网络服务器登录了这个账户。外部一致性保证Cassandra将观察到密码的更改，而不是，例如，看到一个陈旧的副本。</p><h4 id="Q-云Spanner使用Raft而不是Paxos"><a href="#Q-云Spanner使用Raft而不是Paxos" class="headerlink" title="Q: 云Spanner使用Raft而不是Paxos?"></a>Q: 云Spanner使用Raft而不是Paxos?</h4><p>A: 是的。在这篇论文的层面上没有区别。在Spanner构建的时候，Raft还不存在，谷歌已经有了一个调优的可靠的Paxos实现。看看Chandra等人的论文Paxos Made Live。</p><h4 id="Q-Spanner的Commit-Wait有什么目的"><a href="#Q-Spanner的Commit-Wait有什么目的" class="headerlink" title="Q: Spanner的Commit Wait有什么目的?"></a>Q: Spanner的Commit Wait有什么目的?</h4><p>A: 提交等待确保读/写事务在其时间戳中保证已经过时才完成。这意味着在读/写事务完成后启动的只读事务保证具有更高的时间戳，从而可以看到读/写事务的写操作。这有助于实现外部一致性的保证:如果T1在T2开始之前完成，T2将以相同的串行顺序在T1之后完成(即T2将看到T1的写入)。</p><h4 id="Q-什么地方使用Spanner"><a href="#Q-什么地方使用Spanner" class="headerlink" title="Q: 什么地方使用Spanner?"></a>Q: 什么地方使用Spanner?</h4><p>A: 据说有数百个谷歌服务依赖于Spanner。本文介绍了谷歌广告系统对其的使用。谷歌的Zanzibar授权系统使用Spanner。它以云Spanner的形式提供给谷歌的云客户。CockroachDB开源数据库是基于Spanner设计的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://int64.me/2017/Spanner%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.html">Spanner 论文笔记 | Life is magic. Coding is art.</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">spanner论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">MIT6.824 Spanner讲义</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Spanner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab1:MapReduce</title>
      <link href="/2023/01/13/MapReduce/"/>
      <url>/2023/01/13/MapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1：MAPREDUCE"><a href="#Lab1：MAPREDUCE" class="headerlink" title="Lab1：MAPREDUCE"></a>Lab1：MAPREDUCE</h1><h2 id="一、基础框架"><a href="#一、基础框架" class="headerlink" title="一、基础框架"></a>一、基础框架</h2><blockquote><p>paper中的mapreduce概念模型</p></blockquote><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\image-20220521154605632.png" alt="image-20220521154605632"></p><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\image-20220521154644882.png" alt="image-20220521154644882"></p><h3 id="程序调用"><a href="#程序调用" class="headerlink" title="程序调用"></a>程序调用</h3><blockquote><p>coordinator(master)及worker的调用框架</p></blockquote><p>lab1中的主要是把单进程的map-reduce分开执行并且使用coordinator作为master进行调用</p><p>1.工具链(静态库)</p><p>将map与reduce的方法放置于wc.go中，然后生成工具链</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -race -buildmode=plugin ../mrapps/wc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>2.挂起coordinator例程</p><p>coordinator运行时挂起，打开监听socket，等待worker的请求，并作出响应(返回文件名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run -race mrcoordinator.<span class="keyword">go</span> pg-*.txt</span><br></pre></td></tr></table></figure><p>第二个参数为pg-*.txt，为输入文件</p><p>mrcoordinator中调用mr/coordinator.go中的Makecoordinator并传入<strong>input文件名与reduce的任务数量</strong></p><p>3.打开worker例程(可以打开多个)</p><p>mrworker调用mr/worker.go ，mrworker中获取工具链中的mapf-reducef传入worker.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run -race mrworker.<span class="keyword">go</span> wc.so</span><br></pre></td></tr></table></figure><p>worker.go中需要向coordinator发出请求</p><p>worker.go 调用map程序输出intermediate文件</p><p>将intermediate文件传递给reduce完成工作</p><h2 id="二、实验分析"><a href="#二、实验分析" class="headerlink" title="二、实验分析"></a>二、实验分析</h2><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\1653357858623.jpeg" alt=""></p><p>上述为一部分网络上的mapduce的流程</p><blockquote><p>实验心得</p></blockquote><p>刚开始做本次实验，由于没有go语言基础以及做项目的基础，导致做本次实验十分的吃力，一共完成了三版</p><ol><li>通过上述思路图的实验第一版较为粗糙以及复杂(结构体套结构体的版本，传递一些无效参数)，但是没有处理并发问题，导致很多测试点过不了(踩了Struct成员需要首字母大写的坑)</li><li>实验第二版，实验简化了很多无效使调用关系以及无效参数，调用关系更加明确，但是没有处理<strong>并行问题</strong>导致出现了任务量达超标的问题。但是莫名其妙的过了Crash测试</li><li>实验第三版，参考了一点别人的代码，修改了请求任务阶段(<strong>使用了Channel</strong>)，并行问题导致了超标的任务量</li></ol><h3 id="并行问题-实验第二版"><a href="#并行问题-实验第二版" class="headerlink" title="并行问题(实验第二版)"></a>并行问题(实验第二版)</h3><blockquote><p>并发实现</p></blockquote><p>在Coordianor中将每个Worker申请的服务例程放入goroutine中，多个Worker就是多线程</p><p><code>go http.Serve(l, nil)</code></p><blockquote><p>在分配Map以及Reduce任务时Coordinate的并行调度问题</p></blockquote><p>用GetMapTask进行示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> c.Mt &#123;</span><br><span class="line">        <span class="keyword">if</span> !m.State &#123;</span><br><span class="line">            c.MapMu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> c.MapMu.Unlock()</span><br><span class="line">            reply.Inputfile = m.Inputfile</span><br><span class="line">            reply.ID = m.ID</span><br><span class="line"></span><br><span class="line">            reply.Nreduce = c.Nreduce</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始想法</p></blockquote><p>遍历MapTask结构体的数组，去判断哪些任务还未被分配，然后将输入文件和文件ID传给Worker</p><p>这个方法偶尔会通过Crash测试，分析应该是任务未完成，State是未被置为true导致，因为Coordinator不断去遍历MapTask数组，就能够发现哪些任务未被完成</p><blockquote><p>Jobcount测试</p></blockquote><p>在该测试中，发现了原本为只需要8个Worker去完成的工作，居然出现了16个！通过查看测试脚本发现了，Jobcount中开启了两个Worker,那么回想并行的状态，一定是两个Worker去读了MapTask数组，又同时去更新了任务，导致了出现了两倍的任务量。</p><blockquote><p>解决并行问题</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reply.ID = &lt;-c.MapID:</span><br><span class="line">        reply.Inputfile = c.Mt[reply.ID].Inputfile</span><br><span class="line">        reply.Nreduce = c.Nreduce</span><br><span class="line">            <span class="comment">/*go func(ID int) &#123;//Crash测试</span></span><br><span class="line"><span class="comment">                time.Sleep(10 * time.Second)</span></span><br><span class="line"><span class="comment">                c.MapMu.Lock()</span></span><br><span class="line"><span class="comment">                defer c.MapMu.Unlock()</span></span><br><span class="line"><span class="comment">                if !c.Mt[reply.ID].State &#123;</span></span><br><span class="line"><span class="comment">                    c.MapID &lt;- ID</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;(reply.ID)*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        reply.ID = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程初始化Coordinator</span></span><br><span class="line">c.MapID = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, c.Mapnum)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Mt &#123;</span><br><span class="line">    c.Mt[i].Inputfile = files[i]</span><br><span class="line">    c.Mt[i].State = <span class="literal">false</span></span><br><span class="line">    c.MapID &lt;- i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p><p>在实验的第二版中出现了并行问题在于同时这个点，解决方案就是在于同步的问题，当一个线程读取了数据后，另一个线程不能访问，或是及时将另一个线程阻塞或是告知它读取下个任务</p></blockquote><p>使用了Go语言中的Channel的语法，主例程发送一个ID，就会导致阻塞，然后当有Worker调用GetMapTasK将ID读入，才会又下一个ID发送。<strong>读写会相互阻塞</strong>，这导致在多个Worker中不会去<strong>同时读入一个ID</strong>，解决了并发问题</p><h3 id="Worker与Coordinator之间的关系"><a href="#Worker与Coordinator之间的关系" class="headerlink" title="Worker与Coordinator之间的关系"></a>Worker与Coordinator之间的关系</h3><blockquote><p> Coordinator(RPC的Server机)</p></blockquote><ol><li>在Coordinator中需要完成的是<strong>定义RPC的方法</strong>来完成Worker的请求</li><li>Coordinator结构体中是与<strong>Worker通信</strong>中需要传递的参数，以及<strong>分配任务的一些判断依据</strong>，以及多线程中的保护<strong>共享数据需的互斥锁(Mutex)</strong></li><li>由于是多线程并行问题，Coordiantor需要合适去调度任务</li></ol><blockquote><p>Worker(RPC的客户机)</p></blockquote><ol><li>在实验中我们可以用一个或则多个(<strong>并行</strong>)的去向Coordinator申请任务(在多个终端中开启Worker)</li></ol><p><code>go run -race mrworker.go wc.so</code></p><ol><li>Worker需要去完成Map与Reduce两种任务，Map与Reduce的工具在mrapps中有所定义，所以我们只需定义一些请求任务所需的参数(需要在rpc.go中定义)，将这许传回的参数进行相应的任务</li><li>一个Worker是<strong>双线程</strong>去完成相应的任务，Worker需要判断任务是否完成，执行怎样的任务，<strong>不断的</strong>向Coordinator申请任务</li><li>多个Worker是多线线程<strong>并行的</strong>去完成相应的任务(<strong>任务量</strong>测试点)</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>结构体成员需要以<strong>大写字母</strong>开始，否则会出现定义为private对象，无法初始化字</p><h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><blockquote><p>rpc中的参数以及回复</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求Map</span></span><br><span class="line"><span class="keyword">type</span> MapArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MapReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    Inputfile <span class="type">string</span></span><br><span class="line">    Nreduce   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求reduce</span></span><br><span class="line"><span class="keyword">type</span> ReduceArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReduceReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span></span><br><span class="line">    Mapnum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查map任务的是否全部完成</span></span><br><span class="line"><span class="keyword">type</span> MapfinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MapfinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Finished <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check state of map task</span></span><br><span class="line"><span class="keyword">type</span> FinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> FinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Finished <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>coordinator对象</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nreduce    <span class="type">int</span></span><br><span class="line">    MapID      <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    Mt         []MapTask</span><br><span class="line">    Mapnum     <span class="type">int</span> <span class="comment">//the number of map task</span></span><br><span class="line">    ReduceID   <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    Rt         []ReduceTask</span><br><span class="line">    Finished   <span class="type">bool</span></span><br><span class="line">    MapMu      sync.Mutex <span class="comment">//map task mutex</span></span><br><span class="line">    ReduceMu   sync.Mutex <span class="comment">//reduce task mutex</span></span><br><span class="line">    FinishedMu sync.Mutex <span class="comment">//Done Mutex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    Inputfile <span class="type">string</span> <span class="comment">//bind file and ID</span></span><br><span class="line">    State     <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    State <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><blockquote><p>主要框架</p></blockquote><ol><li>一个for死循环，不断的去向主例程申请任务</li><li>先判断所有任务是否完成也就是判断(向Coordinator询问Reduce任务是否全部完成)，完成的话则执行break结束Worker例程，</li><li>否则进入Map或者Reduce任务，(向Coordinator询问所有Map任务是否完成)，Map所有任务完成的话就执行Reduce任务，否则执行Map剩余的Map任务</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">    reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//finished?</span></span><br><span class="line">        <span class="keyword">if</span> !AllFinished() &#123;</span><br><span class="line">            <span class="keyword">if</span> !Mapfinished() &#123; <span class="comment">//tasktype</span></span><br><span class="line">                <span class="comment">//do map</span></span><br><span class="line">                <span class="comment">//update worker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do reduce    </span></span><br><span class="line">                <span class="comment">//update task</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>定义Worker例程的调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> UpdateMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> MapTaskFinished(args *FinishArgs, reply *FinishReply) <span class="type">error</span></span><br><span class="line"><span class="comment">//RedueceTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetReduceTask(args *ReduceArgs, reply *ReduceReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> UpdateReduceTask(args *ReduceArgs, reply *ReduceReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> ReduceTaskFinished(args *FinishArgs, reply *FinishReply) <span class="type">error</span></span><br><span class="line"><span class="comment">//Init Coordinator Object </span></span><br></pre></td></tr></table></figure><p>Crash开启判断例程(GetMapTask)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reply.ID = &lt;-c.MapID:</span><br><span class="line">        reply.Inputfile = c.Mt[reply.ID].Inputfile</span><br><span class="line">        reply.Nreduce = c.Nreduce</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">            c.MapMu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> c.MapMu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !c.Mt[reply.ID].State &#123;</span><br><span class="line">                c.MapID &lt;- ID<span class="comment">//未完成重复读入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(reply.ID)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        reply.Inputfile = <span class="string">&quot;&quot;</span></span><br><span class="line">        reply.Nreduce = <span class="number">0</span></span><br><span class="line">        reply.ID = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>首先知道Worker是一个并行的线程，而这个GetMapTask可以作为Worker线程的一部分，于是Channel可以当作通信的一部分。</p><p>设置一个协程，当一个任务Crash掉后，我们要知道是那个任务失败，还要设置一个判断时间，当这个时间过去后判断该状态还未完成，就重新将ID发送，让GetTask能够再次读入并重新执行</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MapRedcue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
