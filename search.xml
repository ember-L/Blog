<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KVRaft</title>
      <link href="/2023/01/13/KVRaft/"/>
      <url>/2023/01/13/KVRaft/</url>
      
        <content type="html"><![CDATA[<p>lab3 的内容是要在 lab2 的基础上实现一个高可用的 KV 存储服务，算是要将 raft 真正的用起来。相关协调服务可以参考OngaroPhD.pdf的作者的博士论文或者是ZooKeeper 论文笔记的协调服务,另外Chain Replicate 论文笔记的设计中同样满足了高性能读的服务</p><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="Client创建"><a href="#Client创建" class="headerlink" title="Client创建"></a>Client创建</h3><p>创建client自动生成ID号(使用nrand()函数生成)用于Session来记录lastRequest的回复,用LeaderID快速连接server，减少重试leader时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">    ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">    ck.servers = servers</span><br><span class="line">    <span class="comment">// You&#x27;ll have to add code here.</span></span><br><span class="line">    ck.LeaderId = <span class="number">0</span></span><br><span class="line">    ck.ClientId = nrand()</span><br><span class="line">    ck.CommandId = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetryToLeader()</strong> ：重连leader</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> RetryToLeader() &#123;</span><br><span class="line">  oneRound := <span class="number">0</span></span><br><span class="line">  args := &amp;GetArgs&#123;Key: <span class="string">&quot;&quot;</span>, ClientId: ck.ClientId, CommandId: ck.CommandId&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">      oneRound++</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      reply.Err = <span class="string">&quot;&quot;</span></span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line"><span class="comment">//在分区后client可能无法连接到该失联分区的server，发送失败则更换server进行连接</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line"></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          <span class="keyword">if</span> oneRound == <span class="built_in">len</span>(ck.servers) &#123;</span><br><span class="line">              oneRound = <span class="number">0</span></span><br><span class="line">              time.Sleep(<span class="number">700</span> * time.Millisecond)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client发送读写"><a href="#Client发送读写" class="headerlink" title="Client发送读写"></a>Client发送读写</h3><h4 id="读操作-Get"><a href="#读操作-Get" class="headerlink" title="读操作:Get()"></a>读操作:Get()</h4>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  ck.CommandId++</span><br><span class="line">  args := &amp;GetArgs&#123;</span><br><span class="line">      Key:       key,</span><br><span class="line">      CommandId: ck.CommandId,</span><br><span class="line">      ClientId:  ck.ClientId,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You will have to modify this function.</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line">          <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">          ck.RetryToLeader()</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == ErrNoKey &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">          <span class="keyword">return</span> reply.Value</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写操作-PutAppend"><a href="#写操作-PutAppend" class="headerlink" title="写操作:PutAppend()"></a>写操作:PutAppend()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">    ck.CommandId++</span><br><span class="line">    args := &amp;PutAppendArgs&#123;</span><br><span class="line">        Key:       key,</span><br><span class="line">        Value:     value,</span><br><span class="line">        Op:        op,</span><br><span class="line">        CommandId: ck.CommandId,</span><br><span class="line">        ClientId:  ck.ClientId,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">for</span> !ok &#123;</span><br><span class="line">            <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">            ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.RetryToLeader()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="创建服务器-StartKVServer"><a href="#创建服务器-StartKVServer" class="headerlink" title="创建服务器:StartKVServer():"></a>创建服务器:StartKVServer():</h3><ul><li><strong>服务器数据结构</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    rf      *raft.Raft</span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    servers     <span class="type">int</span></span><br><span class="line">    lastapplied <span class="type">int</span></span><br><span class="line">    Term        <span class="type">int</span></span><br><span class="line">    sm          KVStateMachine</span><br><span class="line">    Session     <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond       <span class="comment">// （clientId, lastRespond）record last command&#x27;s id ,respond</span></span><br><span class="line">    NotifyChans <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond <span class="comment">// (client , Chan Respond) ansynchoron to notif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read only check whether all log are applied</span></span><br><span class="line">    isRecovery <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建kv-server 与 下层raft进行交互,到达共识提高容错</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">    labgob.Register(Op&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    kv := <span class="built_in">new</span>(KVServer)</span><br><span class="line">    kv.me = me</span><br><span class="line">    kv.maxraftstate = maxraftstate</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">    <span class="comment">//creat raft layer</span></span><br><span class="line">    kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.lastapplied = kv.rf.GetFirstLogEntry().Index</span><br><span class="line">    kv.Term = <span class="number">0</span></span><br><span class="line">    kv.sm.mkv = NewMemoryKV()</span><br><span class="line">    kv.Session = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]LastRespond)</span><br><span class="line">    kv.NotifyChans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond)</span><br><span class="line">    kv.servers = <span class="built_in">len</span>(servers)</span><br><span class="line">    <span class="comment">//handle with recovery</span></span><br><span class="line">    kv.isRecovery = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    kv.recovery()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> kv.applier()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateMachine的内存模型："><a href="#StateMachine的内存模型：" class="headerlink" title="StateMachine的内存模型："></a>StateMachine的内存模型：</h3><blockquote><p>主要是创建一个kv-table，以一种内存模型的方式进行记录client端发来的修改信息,后续用于生成快照</p></blockquote><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mkv *MemoryKV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemoryKV <span class="keyword">struct</span> &#123;<span class="comment">//键值表的定义</span></span><br><span class="line">    KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemoryKV</span><span class="params">()</span></span> *MemoryKV &#123;<span class="comment">//申请堆内存</span></span><br><span class="line">    <span class="keyword">return</span> &amp;MemoryKV&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kv-table的内存模型的接口："><a href="#kv-table的内存模型的接口：" class="headerlink" title="kv-table的内存模型的接口："></a>kv-table的内存模型的接口：</h4><ul><li><strong>Append()  Put() Get()</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mkv.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mkv.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mkv.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mkv.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkv.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用日志操作到状态机"><a href="#应用日志操作到状态机" class="headerlink" title="应用日志操作到状态机"></a>应用日志操作到状态机</h4><p> 处理request信息并记录其respond:将ApplyCh中的op msg应用至kvserver状态机中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *KVStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = sm.mkv.KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Append(op.Key, op.Value)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Put(op.Key, op.Value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><ol><li><p>使用<strong>NotifyChans</strong>去通知处理request的接口，raft的op以及apply，以channel的方式进行异步的处理</p></li><li><p>用<strong>Session</strong>记录(clientID,LastRespond)，将每个client的request的响应消息进行记录，用于防止client retry多次将命令应用于state machine，以及快速响应</p></li></ol><p><strong>applier()</strong>:异步的接收raft层apply channel所传递上来的消息</p><ol><li><p><strong>防止日志回滚</strong> msg.CommandIndex &lt;= kv.lastapplied</p></li><li><p><strong>处理duplicate消息</strong> </p></li><li><p><strong>Apply</strong> 将apply的消息应用到状态机中</p></li><li><p><strong>回复客户端</strong> leader需要通过<strong>NotifyChan</strong>将状态机<strong>应用命令后回复的消息</strong>传递给该消息所调用的Put/Get,从而回复给Client,leader只能通知当前周期的命令,非当前周期的命令没有接收者从而导致阻塞</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">//avoid log rollback</span></span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> msg.CommandIndex &lt;= kv.lastapplied &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d discard outdate msg&quot;</span>, kv.me)</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            kv.lastapplied = msg.CommandIndex</span><br><span class="line">            <span class="keyword">var</span> respond CommandRespond</span><br><span class="line">            op := msg.Command.(Op)</span><br><span class="line">            <span class="comment">//apply msg -&gt; kv machine</span></span><br><span class="line">            <span class="keyword">if</span> kv.isRedundantRequest(op.ClientId, op.CommandId) &#123;</span><br><span class="line">                respond = kv.Session[op.ClientId].Respond</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                respond = kv.sm.ApplyToStateMachine(op)</span><br><span class="line">                _, isLeader := kv.rf.GetState()</span><br><span class="line">                <span class="keyword">if</span> isLeader &amp;&amp; op.opt != <span class="string">&quot;Get&quot;</span> &#123;</span><br><span class="line">                    kv.Session[op.ClientId] = LastRespond&#123;op.CommandId, respond&#125;</span><br><span class="line">                    DPrintf(<span class="string">&quot;S%d -&gt; C%d LastRequest type:%v K:%v V:%v CmdId:%d CMI:%d T:%d&quot;</span>,</span><br><span class="line">                        kv.me, op.ClientId%<span class="number">50</span>, op.Opt, op.Key, op.Value,</span><br><span class="line">                            op.CommandId, msg.CommandIndex, op.CommandTerm)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentTerm, isLeader := kv.rf.GetState(); isLeader &amp;&amp;</span><br><span class="line">                currentTerm == op.CommandTerm &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d Notify%v to C%d index %d&quot;</span>, kv.me, respond,</span><br><span class="line">                    op.ClientId%<span class="number">50</span>, msg.CommandIndex)</span><br><span class="line">                ch := kv.GetNotifyChan(msg.CommandIndex)</span><br><span class="line">                ch &lt;- respond</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作:"></a>读写操作:</h4><blockquote><p>读写操作需要满足线性一致性:[[ZooKeeper 论文笔记#线性一致性：Linearizability]]</p></blockquote><ul><li><p><strong>PutAppend()</strong>:处理client的修改请求</p><ol><li><p>Client请求该方法</p></li><li><p>冗余检测</p></li><li><p>调用Start将Command传递到下层达到共识</p></li><li><p>创建Notifychan等待applier将response消息push</p></li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        reply.Err = err</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d PutAppend request is redundant(PA)&quot;</span>, args.ClientId%<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       args.Op,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        Value:     args.Value,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d PutAppendRequest CmdId %d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err = cr.Err</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeOut</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Get()</strong>:将read操作记录至log，主要是防止分区时向minority partition的leader请求返回stale data导致线性不一致，<strong>缺陷</strong>：将read操作同步会导致浪费磁盘空间以及同步写入read log的时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="comment">//DPrintf(&quot;S%d is not KVLeader cmdID%d&quot;, kv.me, args.CommandId)</span></span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        value := kv.Session[args.ClientId].respond.Value</span><br><span class="line">        reply.Err, reply.Value = err, value</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d Get request is redundant(Get) cmdId %d&quot;</span>, args.ClientId%<span class="number">5</span>, args.CommandId)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       <span class="string">&quot;Get&quot;</span>,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d GetRequest LI:%d CmdId:%d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, index, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err, reply.Value = cr.Err, cr.Value</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Only-Query"><a href="#Read-Only-Query" class="headerlink" title="Read-Only Query:"></a>Read-Only Query:</h3><blockquote><p>Read-only Query不讲读日志写入磁盘，因为read本就是幂等操作(idempotent),不会影响状态机的状态，因此可以不用写入磁盘同步</p></blockquote><h4 id="challenge-共识"><a href="#challenge-共识" class="headerlink" title="challenge:共识"></a>challenge:共识</h4><ul><li><p><strong>分区容错性(Partition-torlerance)</strong>：由于不写入只读日志到raft层，无法使server到达<strong>共识</strong>(强一致性)，因此当前leader无法知道是否处于<strong>大多数分区中</strong>,可能会导致分区时少部分区域的leader回复给client旧的数据。</p><p><strong>解决方案:</strong> 因此在回复client时需要<strong>确认自己的leader状态</strong>,发送heartbeat能否获得大多数的server响应</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-------------raft.<span class="keyword">go</span>----------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> KV_Sendheartbeat() <span class="type">bool</span> &#123;</span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">        Term:         rf.currentTerm,</span><br><span class="line">        LeadId:       rf.me,</span><br><span class="line">        LeaderCommit: rf.commitIndex,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            _, ok := rf.CallAE(server, args)</span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                wg.Done()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">            num++</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">//majority of peers can rececive</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------kvraft.<span class="keyword">go</span>-----------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ConfirmLeadership() <span class="type">bool</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> _, isLeader := kv.rf.GetState(); isLeader &#123;</span><br><span class="line">        isMajority = kv.rf.KV_Sendheartbeat()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Leader日志applied到最新(Leader completeness guarantee)</strong> :出现分区等问题时新的Leader没有收到当前任期的Log因此之前的任期的log也不会提交并应用，导致当leader进行在处理只读操作时leader并没有同步所有日志，例如：Leader的currentTerm = 5，自己含有term=3或4的log没有applied，导致此时leader会返回旧数据。</p><p><strong>解决方案</strong>:当任期<strong>更改</strong>时<strong>添加no-op</strong>,添加一个空的log使peers达到共识，并使leader的日志同步到达最新</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  &#123;</span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, kv.Term)</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Keep Log Completeness:Send no-op log let leader applied all log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> getCompleteness(CommandId <span class="type">int64</span>, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        CommandId:   CommandId,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">        Opt:         <span class="string">&quot;no-op&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d send no-op index %d &quot;</span>, kv.me, index)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        DPrintf(<span class="string">&quot;no-op Channel is timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>recovery的时候进行Read-only操作(Recovery Reading)</strong>：因为read-only操作不写入log(正在recovery的leader也可以返回只读操作)，所以不会等待其applied后进行返回，会导致recovery的leader将正在replay的数据返回给client。</p><p><strong>解决方案</strong>：加入一个<strong>isRecovery</strong>变量，当service重启时赋值，只读操作需要让正在恢复的leader应用到所有的log,才能执行只读操作，因此当检测到本次只读操作时leader正在recovery就需要发送no-op让leader强制同步</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  || kv.isRecovery&#123;</span><br><span class="line"></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, term)</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="comment">//将isRecovery、term放置在getCompletness</span></span><br><span class="line">        <span class="comment">//防止并发客户端的只读请求跳过no-op操作</span></span><br><span class="line">        <span class="comment">//例如：讲Term与Recovery放置在</span></span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.isRecovery = <span class="literal">false</span></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Only-Query-More-efficiency："><a href="#Read-Only-Query-More-efficiency：" class="headerlink" title="Read-Only Query More efficiency："></a>Read-Only Query More efficiency：</h3><p><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a></p><p>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给 Client。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。                                                                                                                                                                                                                                                         </p><p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的 系统中是无法被接受的，通常都不会使用。                            </p><p>在 Raft 里面，节点有三个状态：Leader，Candidate 和 Follower，任何 Raft 的写入操作都必须经过 Leader，只有 Leader 将对应的 Raft Log 复制到 Majority 的节点上面认为此次写入是成功的。所以如果当前 Leader 能确定一定是 Leader，那么能够直接在此 Leader 上面读取数据，因为对于 Leader 来说，如果确认一个 Log 已经提交到大多数节点，在 t1 的时候 apply 写入到状态机，那么在 t1 后的 Read 就一定能读取到这个新写入的数据。</p><p>那么如何确认 Leader 在处理这次 Read 的时候一定是 Leader 呢？在 Raft 论文里面，提到两种方法：</p><ul><li>ReadIndex Read</li><li>Lease Read</li></ul><h4 id="ReadIndex-Read"><a href="#ReadIndex-Read" class="headerlink" title="ReadIndex Read"></a>ReadIndex Read</h4><p>第一种是 ReadIndex Read，当 Leader 需要处理 Read 请求时，Leader 与过半机器交换心跳信息确定自己仍然是 Leader 后可提供线性一致读：</p><ol><li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li><li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li><li>Leader 执行 Read 请求，将结果返回给 Client。</li></ol><p>使用 ReadIndex Read 提供 Follower Read 的功能，很容易在 Followers 节点上面提供线性一致读，Follower 收到 Read 请求之后：</p><ol><li>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li><li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li><li>Follower 执行 Read 请求，将结果返回给 Client。</li></ol><p>不同于通过 Raft Log 的 Read，ReadIndex Read 使用 Heartbeat 方式来让 Leader 确认自己是 Leader，省去 Raft Log 流程。相比较于走 Raft Log 方式，ReadIndex Read 省去磁盘的开销，能够大幅度提升吞吐量。虽然仍然会有网络开销，但是 Heartbeat 本来就很小，所以性能还是非常好的。</p><h4 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h4><p>虽然 ReadIndex Read 比原来的 Raft Log Read 快很多，但毕竟还是存在 Heartbeat 网络开销，所以考虑做更进一步的优化。Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start+Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start+Election Timeout/Clock Drift Bound 时间点。Lease Read 与 ReadIndex 类似但更进一步优化，不仅节省 Log，而且省掉网络交互，大幅提升读的吞吐量并且能够显著降低延时。</p><p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p><p>Lease Read 实现方式包括：</p><ol><li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li><li>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤(2)；</li><li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read。</li></ol><h2 id="服务层使用快照-Snapshot-："><a href="#服务层使用快照-Snapshot-：" class="headerlink" title="服务层使用快照(Snapshot)："></a>服务层使用快照(Snapshot)：</h2><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p><strong>SnapShot正常执行</strong></p><ol><li><strong>调用Snapshot()</strong> :KV-Server在applier中应用日志时要判断,raft_State是否超过规定值,超过maxraftstate使用<strong>snapshot(sm_state)</strong> 拍摄状态机的状态快照,也就是将服务器的数据库、Session最后一次响应进行快照拍摄</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> needSnapshot() <span class="type">bool</span> &#123;</span><br><span class="line">    size := kv.rf.Persister.RaftStateSize()</span><br><span class="line">    <span class="keyword">if</span> kv.maxraftstate == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kv.maxraftstate &lt;= size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> takeSnapshot(CommandIndex <span class="type">int</span>) &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d Taking Snapshot CommandIndex %d&quot;</span>, kv.me, CommandIndex)</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(kv.sm.mkv)</span><br><span class="line">    e.Encode(kv.Session)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    kv.rf.Snapshot(CommandIndex, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Think about when a kvserver should snapshot its state and what should be included in the snapshot.</p><p>Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots.</p></blockquote><p><strong>snapshot包含的信息</strong>:数据库+Session</p><ul><li><p>数据库:键值表</p></li><li><p>Session:客户端与服务端会话的最后一次request的响应</p></li></ul><ol><li><strong>压缩日志持久化snapshot:</strong> snapshot中会对当前commitIndex进行压缩日志,将raft_state(压缩后的日志)</li></ol><p><strong>Crash后恢复</strong></p><ol><li>当所有Server重启后，服务端需要读取snapshot，调用ReadSnapshot(),快速恢复状态机</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> recovery() &#123;</span><br><span class="line">    data := kv.rf.Persister.ReadSnapshot()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> mkv *MemoryKV</span><br><span class="line">    <span class="keyword">var</span> session <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;mkv) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;session) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.sm.mkv = mkv</span><br><span class="line">        kv.Session = session</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理滞后Follower</strong></p><ol><li><p><strong>raft层:</strong> Leader调用InstallSnapshot()发送snapshot给滞后的follower，follower处理此条消息用将<strong>snapshot消息</strong> push到channel中</p></li><li><p><strong>服务层:</strong> 检测本条channel的snap消息，使用CondInstallSnapshot() 对raft的日志进行调整,返回正确后，读取snapshot,将已有的SM_State覆盖</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            ...apply log to SM_State</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> kv.needSnapshot() &#123;</span><br><span class="line">                kv.takeSnapshot(msg.CommandIndex)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.rf.CondInstallSnapshot(msg.SnapshotTerm, msg.SnapshotIndex, msg.Snapshot) &#123;</span><br><span class="line">                kv.lastapplied = msg.SnapshotIndex</span><br><span class="line">                <span class="comment">//updata snapshot to Sm_machine</span></span><br><span class="line">                kv.recovery()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/3B.png" alt=""></p><h3 id="调试中的bug"><a href="#调试中的bug" class="headerlink" title="调试中的bug"></a>调试中的bug</h3><p><strong>问题描述</strong></p><p>服务层与raft层ch通讯延时导致服务层applied信息过慢(可能是锁的原因)，而raft_State的logs已经增长的过多。</p><p>导致服务层对于raft 通过channel传递上来的消息都要调用一次Snapshot(),但是此时的索引却又很小,一次压缩可能就是压缩一个长度的log,因此下一条命令处理后raft_State仍是很大,又是重复此流程，程序的运行的则会报出<code>logs were not trimmed 日志未裁剪的错误,改报错是超过了指定的测试指定的大小</code></p><h3 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志:"></a>调试日志:</h3><h4 id="12-1日常"><a href="#12-1日常" class="headerlink" title="12-1日常"></a>12-1日常</h4><p>呀今天改完raft的2D后，突然就把3B的实验测试点全过了，好耶！！！想着去多跑几遍看看有没有bug，突然出现一堆<strong>channel阻塞</strong>与<strong>锁的问题</strong>，调了一个晚上尚且把recover3B的测试点过了</p><h4 id="12-2日常"><a href="#12-2日常" class="headerlink" title="12-2日常"></a>12-2日常</h4><p>今天接着昨天的调试，调试今天的RecoverConcurrentPartition的并发问题，发现了一个特奇怪的现象，非leader的服务器居然在返回Get_RO操作！！！跑了很多遍了真的没办法了</p><p>于是我将Get_RO操作换回了Get操作，就全没毛病了，后面进行改进吧，555~~~</p><h3 id="12-3日常"><a href="#12-3日常" class="headerlink" title="12-3日常"></a>12-3日常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Start Partiton</span><br><span class="line">partition servers into: [1 2 4] [0 3]</span><br><span class="line">#S1是leader</span><br><span class="line">722 S1 &lt;- C13 PutAppendRequest K:3 V:x 3 3 y CmdId 11 T:25</span><br><span class="line">S1 Create Notifychan index 84</span><br><span class="line">#Commit -&gt; Applied</span><br><span class="line">S1 -&gt; C13 LastRequest type:Append K:3 V:x 3 3 y CmdId:11 CMI:84 T:25</span><br><span class="line">S1 Notify&#123; OK&#125; to C13 index 84</span><br><span class="line">#S0 之前是leader,index82的log并未提交</span><br><span class="line">S0 -&gt; C27 respond Timeout(PA) index:82</span><br><span class="line"></span><br><span class="line">partition servers into: [2 3] [0 1 4]</span><br><span class="line">#此时s1应该是leader出现华点S0回复了只读消息</span><br><span class="line">可能1,对比之前的S0为leader时T:24,S0在处理此条消息时T并未和Leader相同</span><br><span class="line">因此可能时阻塞的问题</span><br><span class="line">S0 &lt;- C13 GetRequest K:3 CmdId:12 T:24</span><br><span class="line"></span><br><span class="line">S0 -&gt; C13 CmdID:12 respond:&#123;x 3 0 yx 3 1 yx 3 2 y OK&#125;</span><br><span class="line">S0 Raft_State is 1006</span><br><span class="line">S0 Taking Snapshot CommandIndex 82 </span><br><span class="line">S0 LII 72 index 82(Compact) len(logs) 15</span><br><span class="line"></span><br><span class="line">dtest -p 5 -r -n 10 ConcurrentPartition3 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S1 &lt;- C46 PutAppendRequest K:4 V:x 4 6 y CmdId 13 T:36</span><br><span class="line">S1 Create Notifychan index 174</span><br><span class="line">partition servers into: [0 1] [2 3 4]</span><br><span class="line">S1 -&gt; C46 LastRequest type:Append K:4 V:x 4 6 y CmdId:13 CMI:174 T:36</span><br><span class="line">S1 Notify&#123; OK&#125; to C46 index 174</span><br><span class="line"># 变更leader</span><br><span class="line">S1 -&gt; C46 respond OK(PA)</span><br><span class="line">S1 &lt;- C46 GetRequest K:4 CmdId:14 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">C22 PutAppend request is redundant(PA)</span><br><span class="line">S1 &lt;- C22 GetRequest K:0 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">#S2为leader</span><br><span class="line">S2 &lt;- C40 GetRequest K:2 CmdId:44 T:34 ,Raft_T:38</span><br><span class="line">S2 Create Notifychan index 175</span><br><span class="line">S2 send no-op index 175 </span><br><span class="line">partition servers into: [3] [0 1 2 4]</span><br><span class="line">S2 &lt;- C46 GetRequest K:4 CmdId:14 T:38 ,Raft_T:38</span><br><span class="line">S2 Get peer 3</span><br><span class="line">S2 -&gt; C46 CmdID:14 respond:&#123;x 4 0 yx 4 1 yx 4 2 yx 4 3 yx 4 4 yx 4 5 y OK&#125;</span><br><span class="line">#S2的同步请求后面才applied</span><br><span class="line">S2 Applied no-op index 175</span><br><span class="line">S2 Notify&#123; &#125; to C0 index 175</span><br></pre></td></tr></table></figure><ul><li><p>由此条日志可知,与isRecovery同理，在修改kv.term后，其他请求又可以继续处理并且不需要继续发送no-op所以会导致返回旧数据</p><p>解决方案：处理完no-op后才可以修改term与isrecovery变量</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验完成了KVRaft的所有测试点，对于Raft的博士论文中的讲解对于只读操作进行了实现，但是对于只读操作的调试过程是相对于比较困难的，还好最后完成了只读操作的实现，对于follower读取(Read-Only Query More effieciency)并没有打算进行实现(主要是只读操作花费太多精力了)，如果你想要对该操作进行实现可以参考<a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a>.</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验笔记 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spanner论文笔记</title>
      <link href="/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spanner-全球化分布式数据库"><a href="#Spanner-全球化分布式数据库" class="headerlink" title="Spanner 全球化分布式数据库"></a>Spanner 全球化分布式数据库</h1><h1 id="Spanner-分布式数据库-分布式事务-Shard"><a href="#Spanner-分布式数据库-分布式事务-Shard" class="headerlink" title="Spanner #分布式数据库 #分布式事务 #Shard"></a>Spanner #分布式数据库 #分布式事务 #Shard</h1><blockquote><p>[!md] <strong>Title:</strong> Google’s Globally-Distributed Database,Spanner is Google’s scalable, multi-version, globallydistributed, and synchronously-replicated database</p></blockquote><p>论文中实现了广域的<strong>事务</strong>服务，也是在Google广泛使用的一种技术</p><ul><li><strong>R/W Transaction</strong>: 2PC + 2PL + Paxos Group</li><li><strong>R/O Transaction</strong>: Snapshot isolation + Synchronized Clocks</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Spanner部署"><a href="#Spanner部署" class="headerlink" title="Spanner部署"></a>Spanner部署</h3><p>Spanner的部署叫做<strong>universe</strong>，可以让Spanne全球性的管理数据，谷歌中使用了三套Spanner部署分别用于:测试、研发、上线</p><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/universe.png" alt=""></p><p>如上图Spanner server的结构图中，Spanner由多个<strong>Zone</strong>(管理部署的单元、物理隔离的单元)组成。一个数据中心中可以由一个或者多个Zone<br>上图中的一个Zone有一个<strong>zonemaster(分配数据给spanserver)</strong> 和100-1000个<strong>spanserver(服务与客户端)</strong>，用户使用<strong>localtion proxies</strong> 定位每个Zone中分配数据服务的<strong>spanservers</strong></p><ul><li><strong>universe master</strong>:主要是一个控制台，它显示了关于 zone 的各种状态信息，可以用于相互之间的调试</li><li><strong>Placement driver</strong>: 会周期性地与 spanserver 进行交互，来发现那些需要被转移的数据，或者是为了满足新的副本约束条件，或者是为了进行负载均衡<h3 id="Spanserver-SoftWare-Stack"><a href="#Spanserver-SoftWare-Stack" class="headerlink" title="Spanserver SoftWare Stack"></a>Spanserver SoftWare Stack</h3><blockquote><p>每个Spanserver的副本部署以及软件栈<br><img src="../../img/spannersoftware.png" alt=""></p></blockquote></li></ul><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li><strong>Colossus</strong>:放置tablet的文件系统,GFS的升级版</li></ul><ul><li><p><strong>tablet</strong>:类似于bigtable中的tablet，实现如下映射<code>(key:string, timestamp:int64)-&gt;string</code> </p></li><li><p><strong>Paxos</strong>:共识算法于raft类似</p></li><li><p><strong>replica</strong>:Paxos的上层状态机</p></li><li><p><strong>locktable</strong>:实现并发控制,与分布式事务([[Distribute Transaction 笔记#两阶段锁（Two-Phase Locking）——悲观并发]])的二阶段锁相同</p></li><li><p><strong>Transaction manager</strong>：每个Paxos组中的支持分布式事务的软件</p></li><li><h4 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h4></li></ul><blockquote><p>universe的结构中展示了多个Zone中都含有100-1000个Spanserver，Zone可以理解为一个区域(地域)的数据中心。而每个SpanServer都是由一个Paxos状态机和Paxos协议组成(但是一个Paxos Group的Paxos副本不一定在一个Zone中),不同Zone之间的数据复制也是通过Paxos Group</p></blockquote><p>Spanner于bigtable不同之处在于，Spanner分配Timestamp给数据作为版本号，是其更像是一个多版本数据库，而不是键值对的存储，tablet的状态存储在B-tree类似的文件与WAL中</p><p>tablet的上层则是一个paxos的状态机方便复制(Paxos的一些细节我也没有研究过，复制过程可以参考[[Raft实验#Lab 2B : Log Replicated]])。每次写操作都需要写入两次：1.写入tablet的log中 2.写入Paxos的日志中。写操作必须在领导者上初始化 Paxos 协议，读操作可以直接从底层的任何副本的 tablet 中访问状态信息，只要这个副本足够新。副本的集合被称为一个 Paxos group。</p><p>对于每个是领导者的副本而言，每个 spanserver 会实现一个锁表来实现并发控制。对于那些需要同步的操作，比如事务型的读操作，需要获得锁表中的锁，而其他类型的操作则可以不理会锁表。</p><p>对于每个Paxos Group中都会有Leader会开启Transaction manager功能，每个拥有该功能的副本就称为一个<strong>Participant Leader</strong>，其余副本称为<strong>Participant slave</strong>。如果只有一个Paxos组如果一个事务只包含一个 Paxos 组(对于许多事务而言都是如此)，它就可以<font color="#00b0f0">绕过事务管理器</font>，因为锁表和 Paxos 二者一起可以保证事务性。如果一个事务包含了多 于一个 Paxos 组，那些组的领导者之间会彼此协调合作完成<font color="#00b0f0">两阶段提交</font>。其中一个参与者组，会被选为协调者，该组的 participant leader 被称为 <strong>coordinator leader</strong>，该组的 participant slaves 被称为 <strong>coordinator slaves</strong>。</p><h3 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h3><p><img src="../../img/directory.png" alt=""></p><p>Spanner 对具有公共前缀的键做了一个抽象，称为 <strong>directory</strong>。目前一个 directory 是数据存放的基本单位。属于一个目录的所有数据，都具有相同的副本配置。 当数据在不同的 Paxos 组之间进行移动时，会一个目录一个目录地转移，如上图所示。Spanner 可能会移动一个目录从而减轻一个 Paxos 组的负担，也可能会把那些被频繁地一起访问的目录都放置到同一个组中，或者会把一个目录转移到距离访问者更近的地方。当客户端操作正在进行时，也可以进行目录的转移。我们可以预期在几秒内转移 50MB 的目录。</p><p>directory 是数据复制和placement配置的基本单位。spanner中负载均衡的最小单位也是 directory，同时提供方法 MoveDir 可以手动将一个 directory 移动到指定的zone</p><h3 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h3><p>spanner的行模型是 <code>(key:string, timestamp:int64) -&gt; row content</code>，可以看到跟big table的模型最大的不同是这里强化了row的概念，不再突出column；这样spanner的timestamp是赋给整行数据的，是有物理意义的，这使得spanner更像一个实现多版本并发的数据库，而在big table中，timestamp仅仅用于保存多个版本的key-value，跟并发完全无关；我觉得这也是为什么spanner称自己为semi-relational 数据库，而big table只称自己是semi-structure 数据库的原因。<br><img src="../../img/spannerDataModel.png" alt=""></p><p>Spanner 的数据模型不是纯粹关系型的，它的行必须有名称。更准确地说，每个表都需 要有包含一个或多个主键列的排序集合。这种需求，让 Spanner 看起来仍然有点像键值存储: 主键形成了一个行的名称，每个表都定义了从主键列到非主键列的映射。当一个行存在时，必须要求已经给行的一些键定义了一些值(即使是 NULL)。采用这种结构是很有用的，因为这可以让应用通过选择键来控制数据的局部性。</p><h3 id="High-level-Organization"><a href="#High-level-Organization" class="headerlink" title="High-level Organization"></a>High-level Organization</h3><p>考虑下图3个数据中心的A、B、C(存在于不同的地域中)，数据存储在分片中,包含了数据库的行和一些键值对，例如A的分片中有键A-M的。现将该分片复制到B、C数据中心中，即使整个数据中心出现故障也可以继续。</p><p>位于不同数据中心的spanserver形成了Paxos Group 如Figure3中所示，也就是一个Paxos Group中的副本可以存在于不同数据中心中。三个键A-M的shard是通过日志复制使状态机去更新键值对</p><p><img src="../../img/SpannerShard.jpg" alt=""></p><h4 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h4><ul><li><p>多个分片是为了获得更好的并行性</p></li><li><p>每个分片有一个Paxos组用于复制，若a-c的距离远复制开销大，也只需要a、b之间获得majority即可</p></li><li><p>数据中心的容错，速率过慢</p></li><li><p>副本靠近客户端，客户可以获得高性能的只读事务,其原理[[KVRaft#Read-Only Query:]]</p></li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><h3 id="Read-of-local-Relipca-yield-latest-write"><a href="#Read-of-local-Relipca-yield-latest-write" class="headerlink" title="Read of local Relipca yield latest write"></a>Read of local Relipca yield latest write</h3><p>追求更强的一致性，在ZooKeeper中实现的fast-read是弱的线性一致性。本地副本需要读到最新的写，在本文中将会用到</p><h3 id="Trasaction-across-shard"><a href="#Trasaction-across-shard" class="headerlink" title="Trasaction across shard"></a>Trasaction across shard</h3><p>支持跨分片的事务，例如转账事务中一个分片是一个账户、另一个分片是目标账户，当我们要执行转账操作时可以像事务一样执行，并且具有ACID的语义</p><h3 id="Transaction-must-be-serializable"><a href="#Transaction-must-be-serializable" class="headerlink" title="Transaction must be serializable"></a>Transaction must be serializable</h3><p>读取多条记录的事务必须是可序列化的。但是本地碎片可能反映已提交事务的不同子集!</p><h2 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h2><div class="table-container"><table><thead><tr><th><strong>Method</strong></th><th><strong>return</strong></th></tr></thead><tbody><tr><td>TT.now()</td><td>TTinterval: [earliest, latest]</td></tr><tr><td>TT.after(t)</td><td>true if t has definitely passed</td></tr><tr><td>TT.before(t)</td><td>true if t has definitely not arrived</td></tr></tbody></table></div><p>TrueTime API 是一个非常有创意的东西，可以同步全球的时间。</p><ul><li><p>TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。</p></li><li><p>TT.after(t)和TT.before(t)是基于TT.now()实现的。</p></li></ul><p>那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。实际部署的时候。每个数据中心需要部署一些Master机器，其他机器上需要有一个slave进程来从Master同步。有的Master用GPS，有的Master用原子钟。</p><blockquote><p>Denote the absolute time of an event e by the function t<sub>abs</sub>(e). In more formal terms, TrueTime guarantees that for an invocation tt = TT.now(), tt.earliest ≤ t<sub>abs</sub>(e<sub>now</sub>) ≤ tt.latest, where enow is the invocation event.</p></blockquote><h2 id="Concurrent-control"><a href="#Concurrent-control" class="headerlink" title="Concurrent control"></a>Concurrent control</h2><h3 id="Timestamp-Management"><a href="#Timestamp-Management" class="headerlink" title="Timestamp Management"></a>Timestamp Management</h3><p>Spanner使用TrueTime来控制并发，实现外部一致性。支持以下几种事务。</p><ul><li>读写事务：读写操作的集合</li><li>只读事务：只有读操作，并且提供的<strong>snapshot isolation</strong>的功能，保证强一致性</li><li>快照读,只读事务由客户端提供时间戳：可以读取stale data</li><li>快照读,客户端提供时间范围<br><img src="../../img/SpannerTransaction.png" alt=""></li></ul><p>上表是Spanner现在支持的事务。单独的写操作都被实现为读写事务 ； 单独的非快照被实现为只读事务。事务总有失败的时候，如果失败，对于这两种操作会自己重试，无需应用自己实现重试循环。</p><p>时间戳的设计大大提高了只读事务的性能。事务开始的时候，要声明这个事务里没有写操作，只读事务可不是一个简单的没有写操作的读写事务。它会用一个系统时间戳去读，所以对于同时的其他的写操作是没有Block的(只读事务是lock free的)。而且只读事务可以在任意一台已经更新过的replica上面读。</p><p>对于快照读操作，可以读取以前的数据，需要客户端指定一个时间戳或者一个时间范围。Spanner会找到一个已经充分更新好的replica上读取。</p><p>还有一个<strong>有趣的特性</strong>的是，对于只读事务，如果执行到一半，该replica出现了错误。客户端没有必要在本地缓存刚刚读过的时间，因为是根据时间戳读取的。只要再用刚刚的时间戳读取，就可以获得一样的结果。</p><h3 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h3><h4 id="RW-Transaction-without-TS"><a href="#RW-Transaction-without-TS" class="headerlink" title="RW Transaction without TS"></a>RW Transaction without TS</h4><p><img src="../../img/SpannerRW.png" alt=""></p><p>A、B是两个不同的数据中心，客户端最开始的请求的读操作并不是事务操作，目的是为了找到Paxos Group的leader，并且Leader在锁表中分配该数据的锁，当client获得返回值时进行提交(commit)，该实现与Lab3中的读操作服务本质相同。后续执行二段提交部分，提交完成后并释放锁。</p><p>这种实现与[[Distribute Transaction 笔记]]中实现的2PC+2PL的实现方法相同，只不过加入了Paxos的容错设计</p><h4 id="Assigning-Timestamp-to-RW-Transaction"><a href="#Assigning-Timestamp-to-RW-Transaction" class="headerlink" title="Assigning Timestamp to RW Transaction"></a>Assigning Timestamp to RW Transaction</h4><p>事务的读写将会用到二段锁，当所有的锁都已经获得以后，在任何锁被释放之前(也就是持有所有锁期间)，就可以给事务分配时间戳。对于一个给定的事务，Spanner 会为事务分配时间戳，这个时间戳是 Paxos 分配给 Paxos 写操作的，它代表了<font color="#00b0f0">事务提交的时间</font>。</p><p>Spanner 依赖下面这些单调性:在每个 Paxos 组内，Spanner 会以单调增加的顺序给每个 Paxos 写操作分配时间戳，即使在跨越多个领导者时也是如此。一个单个的领导者副本，可以很容易地以单调增加的方式分配时间戳。在多个领导者之间就会强制实现彼此隔离的不连 贯:一个领导者必须只能分配属于它自己租约时间区间内的时间戳。要注意到，一旦一个时间戳 S 被分配，S<sub>max</sub> 就会被增加到 s，从而保证彼此隔离性(不连贯性)。</p><ul><li>S<sub>i</sub>：一个读写事务的时间戳，当S<sub>i</sub>被分配，S<sub>max</sub>就会增长到S</li><li>T<sub>i</sub>：表示一个事务</li><li>e<sub>i</sub>：代表一个事务的一些事件如开始或结束</li><li>e<sub>i</sub><sup>server</sup> ：表示写事务T<sub>i</sub>的Commit请求到达Coordinator的时间</li><li>t<sub>abs</sub>：一个时间的绝对时间</li></ul><p><strong>External consistency</strong> -&gt; 不变性(invariant)：如果事务T2开始发生在T1提交事务之前，T2的时间戳就必须大于T1的提交事务的时间戳———-tabs(e<sub>1</sub><sup>commit</sup>)<tabs(e<sub>2&lt;/sub&gt;<sup>start</sup>)=&gt;S<sub>1</sub> &lt; S<sub>2 </sub></p><p><strong>Start</strong>：为一个事务 T<sub>i </sub>担任协调者的领导者分配一个提交时间戳 s<sub>i</sub>，不会小于 TT.now().latest 的值，TT.now().latest的值是在e<sub>i</sub><sup>server</sup>事件之后计算得到的。要注意，担任参与者的领导者， 在这里不起作用。第 4.2.1 节描述了这些担任参与者的领导者是如何参与下一条规则的实现的。</p><p><strong>Commit Wait</strong>：担任协调者的领导者，必须确保客户端不能看到任何被 T<sub>i</sub> 提交的数据，直到 TT.after(s<sub>i</sub>)为真。提交等待，就是要确保 s<sub>i</sub> 会比 T<sub>i</sub> 的绝对提交时间小。Commit Wait 的证明如下图所示(只针对于R/W 事物)</p><ul><li>commit wait：T1的时间戳小于其commit提交开始的绝对时间</li><li>assumption：T2的开始时间大于T1 commit的事件的事件</li><li>causality： T2开始的时间小于或等于其commit消息到coordinator的时间</li><li>start：commit消息到达coordinator的时间小于等于T2的时间戳则事物开始</li><li>transitivity：可以得到s1发生在s2之前</li></ul><p><img src="../../img/SpannerProof.png" alt=""></p><h4 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h4><p>Spanner在2PC开始之前读操作将会发生在transaction中被Client缓存，这样的话读操作就不会看见同一事务中写入的影响了</p><p><strong>读写操作的实现细节</strong><br>读操作在读写事务中使用wound-wait方法去避免死锁。Client发起读操作到合适Paxos Group的leader副本，获取读锁并且读取最近的数据，在客户端事务存活的时候会不断的向leader发心跳，防止超时。当客户端完成了所有的读操作，并且缓存了所有的写操作，就开始了两阶段提交。客户端选择一个coordinator group，并给每一个leader发送coordinator的id和缓存的写数据。(由客户端驱动二段提交避免两次广域的链接)</p><p><strong>写操作开始</strong><br>non-coordinator-leader首先会获取一个写锁，选择一个prepare时间戳大于之前事务已经分配时间戳的，通过Paxos记录prepare日志。每一个Participant的都要给coordinator发送他自己prepare的那个时间戳。</p><p>coordinator leader首先获得写锁但是需要<font color="#00b0f0">跳过Prepare阶段</font>，在收到(hearing,应该是类似与心跳的机制)所有Participant的Prepare消息后，它需要准备一个时间戳给整个事务，并且commit timestamp S必须大于或等于所有的prepare的时间戳(满足4.1.3中的限制)，大于TT.now().lastest，同一时间coordinator收到commit消息(Participant回复Prepare消息是commit/abort形式)并且大于leader分配给之前事务的时间戳</p><p>在coordinator的副本apply commit的日志记录之前，为了遵循commit-wait规则coordinator leader需要等待TT.after(S)。因为coordinator leader需拿着S基于TT.now().lastest,并且。在commit-wait之后coordinator leader会commit的时间戳发送给client和所有Participant leader</p><h3 id="只读事务-高性能读"><a href="#只读事务-高性能读" class="headerlink" title="只读事务:高性能读"></a>只读事务:高性能读</h3><ul><li>快速的读从本地的(邻近的)分片中``</li><li>不需要<strong>二段锁</strong></li><li>不需要<strong>二段提交</strong></li></ul><h4 id="Corretness"><a href="#Corretness" class="headerlink" title="Corretness"></a>Corretness</h4><p><strong>Serializeble:</strong> R/W<sub>1</sub>（T1）  R/O   R/W<sub>2 </sub>（T2） R/W</p><p><strong>External consistency(外部一致性)</strong><br>Serializable+Real time，与线性一致性相似只不过Extenal consisitency是<font color="#00b0f0">事务级别的属性</font></p><p><strong>示例</strong>：下一个事务必须看见上一个事务的写入</p><ol><li>如果事务T1再另一个事务T2开始之前提交, 则T1提交的时间戳会小于T2提交的时间戳</li><li>如果T1&lt; T2  ，则T2 必须看见T1的写入</li></ol><h4 id="Bad-Plan-只读操作读取最新提交的值"><a href="#Bad-Plan-只读操作读取最新提交的值" class="headerlink" title="Bad Plan 只读操作读取最新提交的值"></a>Bad Plan 只读操作读取最新提交的值</h4><p>由于R/O操作是不加锁的，T3在只读操作时Ry会读取到T2提交的值，因此违背了事务的隔离性也不是串行化。</p><p><img src="../../img/Bad_Read.png" alt=""></p><h4 id="R-O-with-Snapshot-isolation"><a href="#R-O-with-Snapshot-isolation" class="headerlink" title="R/O with Snapshot isolation"></a>R/O with Snapshot isolation</h4><ol><li>分配时间戳给事务:<ul><li><strong>R/W:</strong> commit 提交开始(coordinator leader分配)</li><li><strong>R/O:</strong> Start 事务开始(paxos leader分配)</li></ul></li><li>执行事务按照时间戳的顺序</li><li>每个副本的数据存储都需要有时间戳作为版本号(MVCC,multiple version concurrent control)</li></ol><blockquote><p>In both Bigtable and Spanner, we designed for long-lived transactions (for example, for report generation, which might take on the order of minutes), which perform poorly under optimistic concurrency control in the presence of conflicts</p></blockquote><p>论文中所讲到Spanner在事务(<strong>实际上是只读事务，读写事务还是需要加锁</strong>)上使用了乐观并发控制，对于只读事务我们是不加锁的，因此对于只读事务我们使用乐观并发控制。</p><p>PS: 在FaRM论文中实现了对与读写事务的OCC，对于读操作是不加锁的</p><p>DDIA中说到：Serilaizability + Snapshot isolation = Optimistic concurrent control </p><p>如下图：T1提交的时间戳为@10，T2提交的时间戳为@20，T3只读事务开始的时间戳为@15，读取y值，会按照时间戳的顺序，因此读取y值会现读@15以前的数据，满足了快照隔离性与可串行性</p><p><img src="../../img/Snapshot_isolation.png" alt=""></p><h4 id="R-O-from-Local-Replica-non-Leader-of-Paxos"><a href="#R-O-from-Local-Replica-non-Leader-of-Paxos" class="headerlink" title="R/O from Local Replica(non-Leader of Paxos)"></a>R/O from Local Replica(non-Leader of Paxos)</h4><p>从当地副本进行只读事务，有可能只读事务之前写入还没有同步复制到该副本。例如：副本中没有W@10的操作</p><p><strong>解决方案</strong></p><ul><li>Saft Time ：所有副本中会跟踪这个t<sub>safe</sub>值是所有副本中最大的时间戳，以此来保证副本是最新的。若读操作时间戳为@t,一个副本需要满足t&lt;=t<sub>saft</sub> ,才能进行读写。</li><li>Paxos按照时间戳的顺序发送写操作给副本</li><li>在Rx@15执行前，需要等待大于@15的时间戳写入(与no-op操作道理是一样的)</li><li>等待prepared但是未commit的事务执行</li></ul><h4 id="Clock-must-be-perfect"><a href="#Clock-must-be-perfect" class="headerlink" title="Clock must be perfect"></a>Clock must be perfect</h4><ul><li><p>对只读事务很重要</p></li><li><p>只读事务的时间戳过大 =&gt; 等待时间过长</p></li><li><p>只读事务的时间戳过小 =&gt; 分配给T3更小的时间戳例如为5</p></li></ul><p>Example of problem if r/o xaction’s TS is too small:<br>  r/w T1 @  0: Wx1 C<br>  r/w T2 @ 10:         Wx2 C<br>  r/o T3 @  5:                   Rx?<br>(C for commit)</p><p>根据上述情形我们只会看见T1@0写入的x=1的值，但是实际上T3开始在T2提交过后，根据external consistency：T3必须看见T2的写入x=2。该问题就是不正确时钟导致的分配时间戳错误的问题,</p><p>下述方案中将会解决不正确时钟导致时间戳过小的问题</p><h4 id="Timestamp-are-interval"><a href="#Timestamp-are-interval" class="headerlink" title="Timestamp are interval"></a>Timestamp are interval</h4><p>  Time service yields a TTinterval = [ earliest, latest ].<br>  The correct time is guaranteed to be somewhere in the interval.<br>  Interval width computed from measured network delays,<br>    clock drift assumptions, GPS specs.<br>  Figure 6: intervals are usually microseconds, but sometimes 10+ milliseconds.<br>  So: server clocks aren’t exactly synchronized, but TrueTime<br>    bounds how wrong a server’s clock can be.</p><p>如何保证R/O Txn不会的时间戳不会太小导致读写错误<br>4.12节两个规则[[#Assigning Timestamp to RW Transaction]]</p><ul><li><strong>Start rule</strong>:<br>  事务的时间戳<font color="#00b0f0"> TS = TT.now().latest</font><br>  对于只读事务来说时间戳TS就是开始时间<br>  对于读写事务来说时间戳TS就是事务提交开始(commit begin)的时间，也就是prepared完成时间。</li><li><strong>Commit wait</strong>, for r/w xaction:<br> 在完成提交前, 延迟直到TS &lt; TS.now().earliest，保证该时间戳已经过去，因此只读操作永远不会选择在commit事务开始之前的时间戳。</li></ul><h4 id="update-example-with-interval"><a href="#update-example-with-interval" class="headerlink" title="update example with interval"></a>update example with interval</h4><p>该方案是T1提交然后T2开始，T2必须看见T1的写入，需要TS1 &lt; TS2<br>  r/w T0 @  1: Wx1 C<br>                   |1—————-10| |11———————20|<br>  r/w T1 @ 10:         Wx2 P          C<br>                                 |10————12|<br>  r/o T2 @ 12:                           Rx?<br>(P for T1’s Prepare, C for T1 finishing Commit)</p><p>在P中T2选择了TS2 = TT.now().lastest = 10，Commit-Wait确保C发生在TS2之后(@10过去)，C开始读取时钟获得间隔为11-20 (CommitWait TS.now().earliest =11 &gt;10)。</p><p>T3开始在C之后通过Commit-wait规则我们已经直到@10这个真实时间已经过去(assumption条件)，因此T3在@10之后，T2选择TS3=TT.now().latest=12,这个值是在当前时间之后所以是在@10之后,我们将会读到T2写入的值。</p><blockquote><p>为什么当T2在提交时，T3并发执行能够获得会得到T2的值? 因为根据lab3中只有committed的log才会应用(applied)到状态机，从而修改数据库的值。如果在处理只读事务T3时，并状态机没有应用T2@10写入的数据，会导致T3读取不到T2的值。</p></blockquote><p>我的猜想是<strong>saft time</strong>的机制解决该问题，等待大于@12的值写入数据库之后才能处理只读。因为我们已经分配了为@12的时间戳给了只读事务T3，执行顺序也不会出错，现在就是保证replica中一定由@10的写入。</p><blockquote><p>Commit-Wait的规则是保证序列化与时间戳的正确性。</p></blockquote><p>该例子只是解释了commit-wait+True Time的机制可以防止时钟的错误导致违背外部一致性，因此是否能够读写的T2的写入我想是必然的(因为读取不到T1的写入也违背外部一致性)，但是如何解决T2事务commit与T3并发处理的机制，还是取决于设计者。</p><p>最后可得TS3&gt;TS2,因此T3的可以读到T2写入的X的值</p><blockquote><p>Why this provides external consistency for r/o transactions:<br>  Given that T1 finishes before T2 starts.Commit wait means TS1 is <strong>guaranteed to be in the past.</strong> TS2 = TT.now().latest is guaranteed to be &gt;= correct time thus &gt;= TS of any previous committed transaction (due to its commit wait)</p></blockquote><h4 id="detail-1"><a href="#detail-1" class="headerlink" title="detail"></a>detail</h4><p>分配时间戳需要参与到读事务的Paxos groups的协商，这样的话，Spanner需要一个Scope的表示每一个只读操作，可以描述整个读事务的键(PS：应该不需要coordinator的参加)</p><p><strong>single Paxos</strong>：scop的值只被一个Paxos Group提供，client提交只读事务到leader。leader分配一个S<sub>read</sub>的时间戳并执行读操作。LastTS()是Paxos Group最后一次comitted的读操作，如果没有任何的已经准备的事务，S<sub>read</sub>=LastTS()满足了external-consistency:事务将会看见最后一次写入的结果，因此只读事务将会安排到之后一次提交写事务完成之后</p><p><strong>multiple Paxos</strong>：拥有多个的选项，最复杂的选项是所有groups的leader协商完基于LastTS()的S<sub>read</sub>，一个更简单的选着是clent避免协商的回合，当满足Sread = TT.now().lastest。所有的读操作将会发送到up-to-date的副本</p><h3 id="discussion"><a href="#discussion" class="headerlink" title="discussion"></a>discussion</h3><ul><li>R/W Txn =&gt; 2PC + 2PL</li><li>R/O Txn =&gt; Snapshot isolation + serializablity</li><li>extenal consistency  =&gt; timestamp order + time interval</li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt">https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt</a></p><h4 id="Q-原子时钟是什么"><a href="#Q-原子时钟是什么" class="headerlink" title="Q: 原子时钟是什么?"></a>Q: 原子时钟是什么?</h4><p>A: 一个非常稳定的振荡器。有两种主要的技术被称为“原子钟”:铷钟和铯钟。两者都利用了外层电子状态的变化，这涉及到特定的能量量子和波长。人们可以通过观察电子的兴奋程度来精确地将信号发生器调节到那个波长。原子钟只是时钟的振荡器部分:它产生一个频率，使时钟以正确的频率滴答作响，但它自己不知道它是什么时间。为了提供时间，原子钟最初必须与时间同步，通常是通过GPS(它本身是由一堆原子钟提供时间的)。</p><h4 id="Q-Spanner使用什么种类的原子时钟"><a href="#Q-Spanner使用什么种类的原子时钟" class="headerlink" title="Q: Spanner使用什么种类的原子时钟?"></a>Q: Spanner使用什么种类的原子时钟?</h4><p>A: 遗憾的是，论文没有说明。铷时钟通常是几千美元(e.g. <a href="https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP">https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP</a> 5071A就是一个很好的例子。铯钟不会漂移。当然，任何一个时钟都可能发生故障或电源故障，所以即使有完美的铯时钟，你仍然需要多个铯时钟，并能够同步到UTC。我猜，基于价格，Spanner使用的是与GPS接收器同步的铷时钟。</p><h4 id="Q-TrueTime如何以一种保证包含正确时间的方式选择间隔"><a href="#Q-TrueTime如何以一种保证包含正确时间的方式选择间隔" class="headerlink" title="Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?"></a>Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?</h4><p>A: 这里有一个简单的例子来说明它所使用的推理方法。</p><p>假设主时间服务器S1拥有正确的时间(来自GPS或原子钟)。S2向S1发送请求，询问时间，并得到响应。响应显示“10:00:00 AM”，它在S2发送请求后两秒到达(可以合理地假设S2可以计算事情所花费的时间，即使它不知道绝对时间)。由于整个请求/响应花费了两秒，S2可以推断网络可能将请求延迟了两秒;或者将响应延迟两秒;但仅此而已。因此S2可以得出结论，在它接收到响应的那一刻，正确的时间必须在09:59:58和10:00:02之间。</p><h4 id="Q-外部一致性与线性一致性和序列化有什么关系"><a href="#Q-外部一致性与线性一致性和序列化有什么关系" class="headerlink" title="Q: 外部一致性与线性一致性和序列化有什么关系?"></a>Q: 外部一致性与线性一致性和序列化有什么关系?</h4><p>A: 外部一致性似乎等同于线性化，但应用于整个事务，而不是单个的读写。外部一致性似乎也等同于严格的串行性，这是添加了等效串行顺序必须服从实时顺序的约束的串行性。关键属性是，如果事务T1完成，然后(随后实时)事务T2开始，T2必须看到T1的写入。</p><h4 id="Q-为什么外部一致性是可取的"><a href="#Q-为什么外部一致性是可取的" class="headerlink" title="Q: 为什么外部一致性是可取的?"></a>Q: 为什么外部一致性是可取的?</h4><p>A: 假设哈特谢普苏特通过圣何塞数据中心的网络服务器修改了她的工作组共享的一个帐户的密码。她低声说把新密码隔着隔间告诉了她的同事卡桑德拉。卡桑德拉通过位于圣马特奥的另一个数据中心的网络服务器登录了这个账户。外部一致性保证Cassandra将观察到密码的更改，而不是，例如，看到一个陈旧的副本。</p><h4 id="Q-云Spanner使用Raft而不是Paxos"><a href="#Q-云Spanner使用Raft而不是Paxos" class="headerlink" title="Q: 云Spanner使用Raft而不是Paxos?"></a>Q: 云Spanner使用Raft而不是Paxos?</h4><p>A: 是的。在这篇论文的层面上没有区别。在Spanner构建的时候，Raft还不存在，谷歌已经有了一个调优的可靠的Paxos实现。看看Chandra等人的论文Paxos Made Live。</p><h4 id="Q-Spanner的Commit-Wait有什么目的"><a href="#Q-Spanner的Commit-Wait有什么目的" class="headerlink" title="Q: Spanner的Commit Wait有什么目的?"></a>Q: Spanner的Commit Wait有什么目的?</h4><p>A: 提交等待确保读/写事务在其时间戳中保证已经过时才完成。这意味着在读/写事务完成后启动的只读事务保证具有更高的时间戳，从而可以看到读/写事务的写操作。这有助于实现外部一致性的保证:如果T1在T2开始之前完成，T2将以相同的串行顺序在T1之后完成(即T2将看到T1的写入)。</p><h4 id="Q-什么地方使用Spanner"><a href="#Q-什么地方使用Spanner" class="headerlink" title="Q: 什么地方使用Spanner?"></a>Q: 什么地方使用Spanner?</h4><p>A: 据说有数百个谷歌服务依赖于Spanner。本文介绍了谷歌广告系统对其的使用。谷歌的Zanzibar授权系统使用Spanner。它以云Spanner的形式提供给谷歌的云客户。CockroachDB开源数据库是基于Spanner设计的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://int64.me/2017/Spanner%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.html">Spanner 论文笔记 | Life is magic. Coding is art.</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">spanner论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">MIT6.824 Spanner讲义</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
