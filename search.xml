<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可调用对象</title>
      <link href="/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="std-function-and-bind"><a href="#std-function-and-bind" class="headerlink" title="std::function and bind"></a>std::function and bind</h1><h2 id="可调用对象-Callable-Object"><a href="#可调用对象-Callable-Object" class="headerlink" title="可调用对象(Callable Object)"></a>可调用对象(Callable Object)</h2><ol><li><p>函数指针</p></li><li><p>具有operator()成员函数的类对象(仿函数)</p></li><li><p>可被转换为函数指针的类对象</p></li><li><p>类成员函数指针</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;函数指针&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;仿函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">fr_t</span> = <span class="built_in">void</span>(*)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;指向函数的类对象&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">fr_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;成员函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">void</span>) = func;</span><br><span class="line">    <span class="built_in">func_ptr</span>();</span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (A::*mem_func_ptr)(<span class="type">void</span>) = A::mem_func;</span><br><span class="line">    <span class="type">int</span> A::*mem_obj_ptr = &amp;A::a;</span><br><span class="line"></span><br><span class="line">    A aa;</span><br><span class="line"></span><br><span class="line">    (aa.*mem_func_ptr)();</span><br><span class="line"></span><br><span class="line">    aa.*mem_obj_ptr = <span class="number">123</span>;</span><br><span class="line">    std::cout&lt;&lt;aa.a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可调用对象的包装器-std-function"><a href="#可调用对象的包装器-std-function" class="headerlink" title="可调用对象的包装器-std::function"></a>可调用对象的包装器<code>-std::function</code></h2><blockquote><p>简介</p></blockquote><p>它是一个类模板，可以容纳类成员(函数)指针(<strong>需要用bind该函数将实际对象绑定</strong>)之外的所有可调用对象。通过指定他的模板参数，它可以统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</p><blockquote><p>弹性更强</p></blockquote><ul><li>对于函数对象的返回值可以进行适当隐式转换(short and float -&gt; int)(兼容性)</li><li>对于函数对象的参数可以被隐式转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> f_int = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">foo_func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;    </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">f_int</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo_func;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f</span><span class="params">()</span></span>&#123;</span><br><span class="line">       std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr1 = func;</span><br><span class="line">    <span class="built_in">fr1</span>();</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr2 = Foo::foo_func;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr2</span>(<span class="number">2</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//隐式转换类型</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr3 = <span class="built_in">Foo</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr3</span>(<span class="number">3</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr4 = <span class="built_in">Bar</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr4</span>(<span class="number">4</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind和function联合</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----bind and function---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> bf1 = std::<span class="built_in">bind</span>(&amp;A::mem_func,&amp;a);<span class="comment">//第二个引用可有可无</span></span><br><span class="line">    <span class="keyword">auto</span> bp1 = std::<span class="built_in">bind</span>(&amp;A::a,a);<span class="comment">//第二个取引用只是指向该类的对象</span></span><br><span class="line">    <span class="built_in">bp1</span>() = <span class="number">123</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">bp1</span>()&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;a.a&lt;&lt;std::endl;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr5 = bf1;</span><br><span class="line">    <span class="built_in">fr5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test_f</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">call_when_even</span>(i,output);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind用来将可调用对象与其参数一起进行绑定，绑定后的结构可以使用std::function进行保存，并延迟调用到任何我们需要的时候</p><blockquote><p>作用</p></blockquote><ol><li><p>将可调用对象与其参数一起帮定成一个仿函数</p></li><li><p>将多元参数可调用对象转成一元或者(n-1)元金额调用对象，及只绑定部分参数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FuncEntity</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">eFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FuncEntity e;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">bind</span>(&amp;FuncEntity::eFunc,e,std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">a</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add_2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x+<span class="number">2</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output_add_2,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>        <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::bind</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();                           <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);      <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);      <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="comment">// error: 调用时没有第二个参数</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>);</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 输出: 2 2</span></span><br><span class="line">   <span class="comment">// 调用时的第一个参数被吞掉了</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1,std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_2,std::placeholders::_1)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind简化和增强bind1st和bind2nd"><a href="#bind简化和增强bind1st和bind2nd" class="headerlink" title="bind简化和增强bind1st和bind2nd"></a>bind简化和增强bind1st和bind2nd</h3><p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道，bind1st和bind2nd的作用是将一个二元算子转换成一个一元算子，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><hr><p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，并且还要想想到底是用bind1st还是bind2nd，用起来十分不便。</p><p>现在我们有了bind，就可以以统一的方式去实现了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>这样就不用关心到底是用bind1st还是bind2nd，只需要使用bind即可。</p><p>2.使用组合bind函数</p><p>bind还有一个强大之处就是可以组合多个函数。假设要找出集合中大于5小于10的元素个数应该怎么做呢？</p><p>首先，需要一个用来判断是否大于5的功能闭包，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这里std：：bind返回的仿函数只有一个int参数。当输入了这个int参数后，输入的int值将直接和5进行大小比较，并在大于5时返回true。</p><p>然后，我们需要一个判断是否小于10的功能闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>有了这两个闭包之后，只需要用逻辑与把它们连起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>然后就可以复合多个函数（或者说闭包）的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// 查找集合中大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>小于</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素个数</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), f);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effect C++笔记</title>
      <link href="/2023/01/20/Effective%20C++/"/>
      <url>/2023/01/20/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><blockquote><p>Effective学习笔记</p></blockquote><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h2><p>C++高效编程时情况而变，取决于你使用C++的那一部分</p><hr><h2 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h2><p><code>Perfer consts enum and inlines to #define</code></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>✦For simple constants, prefer const objects or enums to #defines.</p><p>✦For function-like macros, prefer inline functions to #defines.</p><hr><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p><code>Use const whenever possible</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><blockquote><p>优点</p></blockquote><ol><li><p>他们使class接口比较容易被理解，可以得知那个函数可以改动对象成员，那个不能</p></li><li><p>他们使用“操作const对象”成为可能。</p></li></ol><blockquote><p>constness</p></blockquote><p>当两个成员函数如果只是常量性不同，就可以用const来重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">                         <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// const objects</span></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position)  </span><br><span class="line">                        <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// non-const objects</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">//TextBlock’s operator[]s can be used like this:</span></span><br><span class="line">TextBlock <span class="built_in">tb</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];    <span class="comment">// calls non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">// calls const TextBlock::operator[]</span></span><br></pre></td></tr></table></figure><h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>✦Declaring something const helps compilers detect usage errors. constcan be applied to objects at any scope, to function parameters andreturn types, and to member functions as a whole.</p><p>✦Compilers enforce bitwise constness, but you should program usinglogical constness.</p><p>✦When const and non-const member functions have essentially identi-cal implementations, code duplication can be avoided by having thenon-const version call the const version.</p><hr><h2 id="条款04：确定对象被使用前已经先被初始化"><a href="#条款04：确定对象被使用前已经先被初始化" class="headerlink" title="条款04：确定对象被使用前已经先被初始化"></a>条款04：确定对象被使用前已经先被初始化</h2><p><code>Make sure that object are initialized before they&#39;re used</code></p><h3 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h3><blockquote><p>规则</p></blockquote><p>永远在使用对象之前将它初始化。对于内置内省必须要手工完成初始化</p><p>对于自定义类型来说，初始化职责放在构造函数上</p><blockquote><p>赋值与初始化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;<span class="comment">// ABEntry = “Address Book Entry”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">            <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;<span class="comment">// these are all assignments,</span></span><br><span class="line">    theAddress = address;<span class="comment">// not initializations</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化</p></blockquote><p>成员变量初始化动作发生在进入构造函数本体之前，相对于赋值来说发生时间更早。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones): </span><br><span class="line">        <span class="built_in">theName</span>(name),</span><br><span class="line">        <span class="built_in">theAddress</span>(address),<span class="comment">// these are now all initializations</span></span><br><span class="line">        <span class="built_in">thePhones</span>(phones),</span><br><span class="line">        <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;<span class="comment">// the ctor body is now empty</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化优点</p></blockquote><p>通常效率较高；</p><p><strong>赋值版本</strong>：先调用构造函数为成员变量赋予初值，然后立刻在对他们赋予新值（传入的实参）。因此会浪费一部分时间</p><p><strong>初始化版本</strong>：成员初始列中针对各个成员变量而设的实参，被拿去作为各成员之构造函数的实参。</p><blockquote><p>必须初始化的情况</p></blockquote><p>例如：成员变量为const或references，必须要进行成员初始列表</p><p><strong>综述：</strong> 一般情况总是使用成员初始列表，可以针对普遍的变量，而且比赋值更高效</p><h3 id="成员初始化次序"><a href="#成员初始化次序" class="headerlink" title="成员初始化次序"></a>成员初始化次序</h3><ul><li><p>base class -&gt; derived class </p></li><li><p><strong>成员变量以被声明的次序进行初始化</strong>因此对于示例ABEntry 中theName 最先被初始化，然后是theAddress，再是thePhone，最后是numTimesConsulted.</p></li></ul><h3 id="static对象"><a href="#static对象" class="headerlink" title="static对象"></a>static对象</h3><blockquote><p>生命周期</p></blockquote><p>从被构造出来直到程序结束，因此不是堆栈对象。</p><blockquote><p>定义</p></blockquote><p>一般这种对象被定义为global对象、定于于namspace作用域、classes、函数内、以及file作用内声明为static的对象</p><blockquote><p>local static与non-local static对象</p></blockquote><p><strong>long static对象</strong>：定义域函数内，因为它对于函数而言是local</p><p><strong>non-local static对象</strong>：其他剩余的static对象</p><h3 id="多源文件跨编译单元编译"><a href="#多源文件跨编译单元编译" class="headerlink" title="多源文件跨编译单元编译"></a>多源文件跨编译单元编译</h3><p>一般至少应该non-local static对象</p><blockquote><p>问题</p></blockquote><p>某编译单元内的某个non-local static对象初始化动作使用了另一个编译单元内的某个编译单元内的某个non-local static对象，它所用到的这个对象可能没有被初始化，因为c++对于 <strong>”定义在不同编译单元的non-local对象那个“初始化次序没有明确的规定</strong></p><h4 id="non-local-static-对象初始化次序问题"><a href="#non-local-static-对象初始化次序问题" class="headerlink" title="non-local static 对象初始化次序问题"></a>non-local static 对象初始化次序问题</h4><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;<span class="comment">// from your library’s header file</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// one of many member functions</span></span><br><span class="line">...</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">// declare object for clients to use// (“tfs” = “the file system” ); definition// is in some .cpp file in your library</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;<span class="comment">// created by library client</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Directory</span>( params );...&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>( );<span class="comment">// use the tfs object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：用户决定创建应该Directory对象，用来放置临时文件</p><p>Directory tempDir{params}；</p><blockquote><p>初始化次序的重要性</p></blockquote><p>除非tfs在tempDir先被初始化，否则tempDir会用到尚未初始化的tfs。（但是tfs和tempDir是被不同人在不同时间创建的），他们是不同编译单元的non-local对象</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>将每个non-local对象搬到总结专属的函数内（函数也要声明为static）、</p><p>这些函数返回应该reference指向它所含的对象。然后用户调用这些函数</p><blockquote><p> C++保证</p></blockquote><p>函数内的local static对象会在<u>”该函数调用期间“”首次遇到该对象的定义式”</u>时被初始化。</p><p>因此如果用”函数调用“(返回应该reference指向local static对象)替换”直接访问non-local static对象“，就获得了保证，保证你所获得reference将指向应该历经初始化的对象。</p><blockquote><p>优点</p></blockquote><p>从未调用non-local static对象的”仿真函数“，就绝不会引发构造和析构成本</p><blockquote><p>优化代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;; <span class="comment">// as before</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">( )</span><span class="comment">// this replaces the tfs object; it could be</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static in the FileSystem class</span></span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">// define and initialize a local static object</span></span><br><span class="line">    <span class="keyword">return</span> fs;<span class="comment">// return a reference to it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;<span class="comment">// as before</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )<span class="comment">// as before, except references to tfs are </span></span><br><span class="line">&#123;<span class="comment">// now to tfs( )</span></span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>( );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">( )</span><span class="comment">// this replaces the tempDir object; it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="comment">// could be static in the Directory class</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>;<span class="comment">// define/initialize local static object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> td;<span class="comment">// return reference to it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>✦Manually initialize objects of built-in type, because C++ only some-times initializes them itself.</p><p>✦In  a  constructor,  prefer  use  of  the  member  initialization  list  to  assignment  inside  the  body  of  the  constructor.  List  data  members  in the initialization list in the same order they’re declared in the class.</p><p>✦Avoid  initialization  order  problems  across  translation  units  by  re-placing non-local static objects with local static objects.</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="条款05：了解C-默认编写和调用了哪些函数"><a href="#条款05：了解C-默认编写和调用了哪些函数" class="headerlink" title="条款05：了解C++默认编写和调用了哪些函数"></a>条款05：了解C++默认编写和调用了哪些函数</h2><p><code>Know what functions C++silently writes and calls.</code></p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>✦Compilers may implicitly generate a class’s default constructor, copyconstructor, copy assignment operator, and destructor</p><hr><h2 id="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"></a>条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝</h2><p><code>Explicitly disallow the use of compiler-generated functions you do not want.</code></p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>✦To disallow functionality automatically provided by compilers, declare the corresponding member functions private and give no imple-mentations. Using a base class like private is one way to do this.</p><hr><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        D d;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//多态</span></span><br><span class="line">    &#123;</span><br><span class="line">        B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        B* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">D destrutor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">B destrutor</span><br></pre></td></tr></table></figure><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>✦Polymorphic base classes should declare virtual destructors. If aclass has any virtual functions, it should have a virtual destructor.</p><p>✦Classes not designed to be base classes or not designed to be usedpolymorphically should not declare virtual destructors.</p><hr><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><code>prevent exception from leaving destruction</code></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>✦Destructors should never emit exceptions. If functions called in adestructor may throw, the destructor should catch any exceptions,then swallow them or terminate the program.</p><p>✦If class clients need to be able to re act to exceptions thrown duringan operation, the class should provide a regular (i.e., non-destruc-tor) function that performs the operation.</p><hr><h2 id="条款11：在operator-中“自我赋值”"><a href="#条款11：在operator-中“自我赋值”" class="headerlink" title="条款11：在operator=中“自我赋值”"></a>条款11：在operator=中“自我赋值”</h2><p><code>Handle assignment to self in operator=</code></p><p>以widget窗口类为示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    Bit* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w = w; 自我赋值 </span><br></pre></td></tr></table></figure><h3 id="方法一：证同测试"><a href="#方法一：证同测试" class="headerlink" title="方法一：证同测试"></a>方法一：证同测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)                <span class="comment">//证同测试</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb；</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);    <span class="comment">//防止浅拷贝问题</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>异常问题：</p></blockquote><p>new Bitmap出现异常（分配内存错误导致错误）this-&gt;pb会指向一块被删除的内存</p><h3 id="方法二：异常安全性"><a href="#方法二：异常安全性" class="headerlink" title="方法二：异常安全性"></a>方法二：异常安全性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;                 <span class="comment">//创建*this一个副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);           <span class="comment">//pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig                          <span class="comment">//删除副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>证同测试效率问题</p></blockquote><p>应用证同测试会导致代码效率变低，if分支导致执行速度下降</p><blockquote><p>副本：</p></blockquote><p>不是指向一个对象只是一个<strong>值容器</strong>，如函数传参</p><h3 id="方法三：copy-swap（异常安全性）—-条款29"><a href="#方法三：copy-swap（异常安全性）—-条款29" class="headerlink" title="方法三：copy-swap（异常安全性）—-条款29"></a>方法三：copy-swap（异常安全性）—-条款29</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">//一个副本修改它不会修改其本身</span></span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);       <span class="comment">//rhs数据副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A variation on this theme takes advantage of the facts that</p><p> (1) a class’scopy assignment operator may be declared to take its argument byvalue and</p><p> (2) passing something by value makes a copy of it (seeItem20)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=( Widget rhs)<span class="comment">//一个副本修改它不会修改其对象本身</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);            <span class="comment">//pass by value 将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦Make sure operator= is well-behaved when an object is assigned to itself. Techniques include comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.</p><p>✦Make sure that any function operating on more than one object be-haves correctly if two or more of the objects are the same.</p></blockquote><hr><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p><code>think carefully about copying behavior in resource-managing classes</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm)</span></span><br><span class="line"><span class="function">        &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;<span class="comment">// acquire resource</span></span><br><span class="line">    ~<span class="built_in">Lock</span>( )</span><br><span class="line">        &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;<span class="comment">// release resource</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Clients use Lock in the conventional RAII fashion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;<span class="comment">// define the mutex you need to use</span></span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// create block to define critical sectionLock </span></span><br><span class="line"><span class="built_in">ml</span>(&amp;m);    <span class="comment">// lock the mutex</span></span><br><span class="line">...    <span class="comment">// perform critical section operations</span></span><br><span class="line">&#125;    <span class="comment">// automatically unlock mutex at end</span></span><br><span class="line">    <span class="comment">// of block</span></span><br></pre></td></tr></table></figure><h3 id="RAII对象copied的选择"><a href="#RAII对象copied的选择" class="headerlink" title="RAII对象copied的选择"></a>RAII对象copied的选择</h3><ul><li><p>禁止复制（prohibit copying）</p></li><li><p>对底层资源使用“引用计数法”</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>✦ 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</p><p>✦普遍而常见的RAII classes copying 行为时：一直copying、实行引用计数法。</p><h2 id="条款15：在资源类中提供对原始资源的访问"><a href="#条款15：在资源类中提供对原始资源的访问" class="headerlink" title="条款15：在资源类中提供对原始资源的访问"></a>条款15：在资源类中提供对原始资源的访问</h2><p><code>provide access to raw resources in resource-managing classes</code></p><p><strong>原因：</strong> 编译器无法将RAII类(shared_ptr)作为指针,会将其作为一个对象，无法发生隐式转换而报错</p><blockquote><p><strong>示例</strong> ：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daysHeld</span><span class="params">(<span class="type">const</span> Investment *pi)</span></span>;<span class="comment">// return number of days</span></span><br><span class="line">                                    <span class="comment">// investment has been held</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);<span class="comment">// error!</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>解决方案：</strong> </p></blockquote><p><code>convert an object of the RAII class (in this case,tr1::shared_ptr) into the raw resource</code></p><p>(1)<strong>explicit conversion:</strong></p><p>smart_ptr offer a get number function to perform explicit conversion to return a raw pointer inside this smart_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>( ));<span class="comment">// fine, passes the raw pointer</span></span><br><span class="line">                                <span class="comment">// in pInv to daysHeld</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string* str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//explicit</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">test_string</span>(ptr);<span class="comment">//error can`t convert RAII to string</span></span><br><span class="line">    <span class="built_in">test_string</span>(ptr.<span class="built_in">get</span>());<span class="comment">//offer raw resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)<strong>implicit conversion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Str</span><span class="params">(<span class="type">const</span> string&amp; str)</span>:m_str(str)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_str;&#125;<span class="comment">//implicit convertion</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_str;&#125;</span><br><span class="line">    ~<span class="built_in">Str</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_implicit_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">a</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">test_string</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>✦APIs often require access to raw resources, so each RAII classshould offer a way to get at the resource it manages.</p><p>✦Access may be via explicit conversion or implicit conversion. In gen-eral, explicit conversion is safer, but implicit conversion is more con-venient for clients.</p><hr><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款20：宁以pass-by-reference-to-const-替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; a):<span class="built_in">p_name</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;P&quot;</span>&lt;&lt;st::endl;<span class="keyword">return</span> p_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string p_name;</span><br><span class="line">    string p_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; a):<span class="built_in">s_name</span>(a)&#123;std::cout&lt;&lt;<span class="string">&quot;S construct\n&quot;</span>;&#125;</span><br><span class="line">    <span class="comment">//Student(const Student&amp; other)&#123;std::cout&lt;&lt;&quot;S copy construct\n&quot;;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;std::endl;<span class="keyword">return</span> s_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Student</span>()&#123;std::cout &lt;&lt; <span class="string">&quot;S destruct\n&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s_name;</span><br><span class="line">    string s_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;p.<span class="built_in">printN</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用pass-by-reference-to-const的好处"><a href="#用pass-by-reference-to-const的好处" class="headerlink" title="用pass-by-reference-to-const的好处"></a>用pass-by-reference-to-const的好处</h3><ol><li><p><strong>高效</strong>，不会创建临时对象，因此不会再次调用construt和deconstruct。</p></li><li><p><strong>准确且正确的多态</strong>，pass-by-value无法识别准确的object，如test1中，real object 都是person无法调用student的多态，pass-by-reference-to-const是可以准确调用student对象</p></li></ol><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>✦Prefer pass-by-reference-to-const over pass-by-value. It’s typicallymore efficient and it avoids the slicing problem.</p><p>✦The rule doesn’t apply to built-in types and STL iterator and func-tion object types. For them, pass-by-value is usually appropriat</p><hr><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p><code>Don&#39;t try return a reference when you must return an object</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span> ()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">double</span> x, <span class="type">double</span> y):<span class="built_in">x_</span>(x),<span class="built_in">y_</span>(y)</span><br><span class="line">    &#123;cout&lt;&lt;<span class="string">&quot;construt&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该段代码描述有理数的相乘的类的设计</p><h3 id="当以reference作为返回值时的几大误区"><a href="#当以reference作为返回值时的几大误区" class="headerlink" title="当以reference作为返回值时的几大误区"></a>当以reference作为返回值时的几大误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">==================on the stack===================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational <span class="built_in">result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================on the heap======================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational *result =  <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line">=================<span class="type">static</span> local====================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result</span><br><span class="line">    result = <span class="built_in">Result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>on the stack</strong> :reference作为返回值时，result对象是一个stack值，当其返回时离开了作用域，result对象会被销毁，reference返回时会导致其指向了一个被销毁的值</p></li><li><p><strong>on the heap</strong> :heap分配的内存，new出来的对象，无法得知合适对该对象进行delete，因此会导致内存泄漏</p></li><li><p><strong>static local</strong> :会引起多线程问题，例如数据共享问题</p></li></ol><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.x_*lhs.y_,rhs.x_*rhs.y_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：虽然会付出一点点的成本代价（construct和deconstruct），但从长远的角度和综合对比可知，此方法是最合适的做法</p><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>✦Never return a pointer or reference to a local stack object, a refer-ence to a heap-allocated object, or a pointer or reference to a localstatic object if there is a chance that more than one such object willbe needed. (Item4 provides an example of a design where returninga reference to a local static is reasonable, at least in single-threadedenvironments.)</p><hr><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p><code>Declare data member private</code></p><h3 id="private（提供封装）和其他（提供封装）"><a href="#private（提供封装）和其他（提供封装）" class="headerlink" title="private（提供封装）和其他（提供封装）"></a>private（提供封装）和其他（提供封装）</h3><p>对于protect声明的成员变量，当其出现问题后或是被取消后，将会影响整个派生类</p><h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><p>✦Declare data members private. It gives clients syntactically uniformaccess to data, affords fine-grained access control, allows invariantsto be enforced, and offers class authors implementation flexibility.</p><p>✦protected is no more encapsulated than public（protect 与 public 差不多）</p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p><code>Perfer non-member、non-friend to member function</code> </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>示例 :</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrower</span></span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">==================member================</span><br><span class="line"><span class="keyword">class</span> WebBrower&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">clearEverything</span>();<span class="comment">//调用clearCache、clearHistory、</span></span><br><span class="line">                           <span class="comment">//removeCookies</span></span><br><span class="line">&#125;</span><br><span class="line">=================non-member============</span><br><span class="line"><span class="type">void</span> <span class="built_in">clearBrowser</span>(WebBrowser&amp; wb)</span><br><span class="line">&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>我们更愿意使用non-member代替member函数</code></p><blockquote><p>原因</p></blockquote><p>1.non-member的封装性比member函数的更强</p><p>2.non-member对类的相关机能有较大的包裹弹性</p><blockquote><p><strong>封装</strong>：它使我们能够改变事物而只影响有限客户</p></blockquote><p>愈多东西被封装，愈少人能看见它，因此能够有愈大的弹性去改变它</p><p>愈多函数可以访问封装的函数，数据的封装性越低</p><p><strong>条款22</strong>：成员变量应该是private，以为如果他们不是，就有无数的函数可以去访问他们，没有封装可言</p><blockquote><p>访问限制</p></blockquote><p>能够访问private成员变量的函数只有class和member函数与friend函数可以访问</p><h3 id="程序设计问题"><a href="#程序设计问题" class="headerlink" title="程序设计问题"></a>程序设计问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设计特点</p></blockquote><ul><li><p>namespace 与classes不同，<strong>namespace可以支持跨多个源码文件</strong>而class不能</p></li><li><p>non-member、non-friend函数为用户提供较好的程序机能以及封装性</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowsers。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">//核心机能，提供所有的non-member函数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowserbookmarks。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">//声明与书签相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowsercookies</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowerStuff</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//声明与cookies相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例运用了namespace的跨越多个源码文件的特点</p><blockquote><p>标准库组织方式</p></blockquote><p>在STL头文件中std命名空间内的每一个东西，每个头文件声明std的某些机能</p><p>例如只想用vector，那就只用vector头文件，这允许客户支队他们所用的<strong>小部分系统形成编译依赖</strong>，但该方法不能适用于member函数，以为class必须整体定义，不可分割</p><p>将所有便利函数放在多个头文件内但隶属同一命名空间，意味用户可以轻松的扩展。需要只做到则是，在该命名空间<strong>添加non-member、non-friend函数</strong>。</p><h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Prefer non-member non-friend functions to member functions. Do-ing so increases encapsulation, packaging flexibility, and functionalextensibility.</p></blockquote><hr><h2 id="条款24：-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24：-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24： 若所有参数皆需类型转换,请为此采用non-member函数"></a>条款24： 若所有参数皆需类型转换,请为此采用non-member函数</h2><p><code>Declare non-member functions when type conversions should apply to all parameters</code></p><blockquote><p>示例：Rational</p></blockquote><p>运用条款3，20，21书写正确的operator*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">float</span> numerator = <span class="number">0</span>,<span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;<span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">    <span class="comment">// conversions</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// accessors for numerator and</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// denominator — see Item22private:</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Rational <span class="title">result</span><span class="params">((n*rhs.n),(d*rhs.d))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    <span class="type">float</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">r1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Rational r3 = r1 * r2;<span class="comment">//right</span></span><br><span class="line"></span><br><span class="line">    r3  = r1 * <span class="number">2</span>;<span class="comment">//right</span></span><br><span class="line">    r3  = <span class="number">2</span> * r1;<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;r3&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li><p>在隐式转换时，构造函数需要写出默认参数，不然不能进行隐式转换，因为Rational类构造函数有两个参数;</p></li><li><p>在构造函数加上explicit就可以防止隐式转换</p></li><li><p>2 *  r1 不能成功运行，是不是不满足交换律？</p></li></ul><blockquote><p>重写上述例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = r1.<span class="keyword">operator</span>*(<span class="number">2</span>);</span><br><span class="line">result = <span class="number">2.</span>opeator*(r1);<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">result = opeator*(<span class="number">2</span>,r1);</span><br></pre></td></tr></table></figure><p>因为r1内含一个operator<em>函数的class的对象，并且将2进行隐式转换r1.operator </em> (Rational(2))</p><p>对于2.operator(r1)显然时错误的,没有这个重载函数</p><h3 id="将operator写为non-member函数"><a href="#将operator写为non-member函数" class="headerlink" title="将operator写为non-member函数"></a>将operator写为non-member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        rhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><ul><li><p>non-member函数如条款23所述封装性更强</p></li><li><p>支持所有参数的隐式类型转换</p></li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦If you need type conversions on all parameters to a function (includ-ing the one that would otherwise be pointed to by the this pointer),the function must be a non-member.</p></blockquote><hr><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p><code>consider support a no-throwing swap</code></p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="无法交换值、无法交换指针"><a href="#无法交换值、无法交换指针" class="headerlink" title="无法交换值、无法交换指针"></a>无法交换值、无法交换指针</h4><p>普通swap函数实现细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br><span class="line">========================</span><br><span class="line">地址不变，值不变</span><br></pre></td></tr></table></figure><blockquote><p>陷阱</p></blockquote><p>对于c/c++的初学者来说，犯下一个很大的陷阱，那就是我们只传过去一个地址对于者个地址值只是一个<strong>副本信息</strong>，并不是原对象，导致无法交换地址值更无法交换指针值。我们只是通过传参过来的一个 <strong>(地址)值(副本)</strong>,这是我们只是对原对象的指针副本做了交换</p><h4 id="无法交换地址、可以交换指针"><a href="#无法交换地址、可以交换指针" class="headerlink" title="无法交换地址、可以交换指针"></a>无法交换地址、可以交换指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>解引用后，此时<em>a、</em>b是a、b地址对应内存的值，也就是原对象值，改操作进行的是<strong>对(原对象)内存的进行置换</strong>，但此时并不会改变地址值，地址值仍是一个副本</p><h4 id="可以交换值和地址"><a href="#可以交换值和地址" class="headerlink" title="可以交换值和地址"></a>可以交换值和地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>** a,<span class="type">int</span>** b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>p1和p2是一个地址</p><p>我们用双层指针，写出一个swap的置换函数，我们传入地址进去，此时a、b的值是指向p1和p2的地址。对a、b进行解引用，则<strong>对应的<em>a 、</em>b是对应p1、p2的地址原对象</strong>。</p><p>进行置换则<strong>交换的是p1和p2的值</strong>，那么地址交换，相应改变的是p1和p2的对象名所对应的地址而已，而实际的内存并没有置换而已。</p><h4 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法既可以改值也可以改地址，因为引用的本身就是<strong>绑定一个原对象</strong>，并不是副本</p><h3 id="标准库swap"><a href="#标准库swap" class="headerlink" title="标准库swap"></a>标准库swap</h3><blockquote><p> std::swap</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// typical implementation of </span></span><br><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换</p><h3 id="示例：swap"><a href="#示例：swap" class="headerlink" title="示例：swap"></a>示例：swap</h3><blockquote><p>实践Widget类</p></blockquote><ul><li>用pimpl手法将Widget的数据成员封装到WidgetImpl中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;<span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// details are unimportant...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// possibly lots of data —</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;<span class="comment">// expensive to copy!...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;<span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">    &#123;        <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">        ...<span class="comment">// details on implementing</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);<span class="comment">// operator= in general,</span></span><br><span class="line">        ...<span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;<span class="comment">// ptr to object with this </span></span><br><span class="line">&#125;;<span class="comment">// Widget’s data</span></span><br></pre></td></tr></table></figure><blockquote><p>设计问题</p></blockquote><ul><li><p>置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl)</p></li><li><p>可以直接交换指针的地址，改变指针指向的内存</p></li></ul><h4 id="置换其impl指针"><a href="#置换其impl指针" class="headerlink" title="置换其impl指针"></a>置换其impl指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)<span class="comment">//std::swap的全特化版本只能对</span></span><br><span class="line">           <span class="comment">//&lt;Widget&gt;表示这一特例化版本只是针对指针交换而设计</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl,b.pImpl);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下：</p><h4 id="声明public成员函数置换"><a href="#声明public成员函数置换" class="headerlink" title="声明public成员函数置换"></a>声明public成员函数置换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// addition of the swap mem func</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;<span class="comment">// the need for this declaration</span></span><br><span class="line">                    <span class="comment">// is explained later in this Item</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pImpl pointers</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// revised specialization of</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,<span class="comment">// std::swap</span></span><br><span class="line">                        Widget&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);<span class="comment">// to swap Widgets, call their</span></span><br><span class="line">&#125;<span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本</p><blockquote><p>缺点</p></blockquote><p>对于Widget class templates而非classes 将数据类型加以参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,<span class="comment">// error! illegal code!</span></span><br><span class="line">        Widget&lt;T&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">     a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>错误分析</p></blockquote><p>企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化，在function templates身上时不能偏特化的。因此无法编译。</p><h4 id="偏特化function-template"><a href="#偏特化function-template" class="headerlink" title="偏特化function template"></a>偏特化function template</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// an overloading of std::swap </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// (note the lack of “&lt;...&gt;” after</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Widget&lt;T&gt;&amp; b)</span><span class="comment">// “swap”), but see below for</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;<span class="comment">// why this isn’t valid code&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>重载function templates是没问题的，但std是一个特殊的命名空间：</p><ul><li><p>可以全特化std内的templates</p></li><li><p>不可以添加新的templates(class或function)到std里面</p></li></ul><h3 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h3><blockquote><p>高效正确的做法：non-member的swap、member的swap函数相结合</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...<span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// as before, including the swapclass </span></span><br><span class="line">Widget &#123; ... &#125;;<span class="comment">// member function</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// non-member swap function;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>swap实现效率不足的解决(class或template运用了pimpl手法)</p></blockquote><ol><li><p>提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常</p></li><li><p>在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数</p></li><li><p>如果编写一个<strong>class(而非class template)</strong>，为你的class特化一个std::swap，并令他调用你的swap的成员函数</p></li><li><p>必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符</p></li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>✦Provide a swap member function when std::swap would be inefficientfor your type. Make sure your swap doesn’t throw exceptions.</p><p>✦If you offer a member swap, also offer a non-member swap that callsthe member. For classes (not templates), specialize std::swap, too.</p><p>✦When calling swap, employ a using declaration for std::swap, then callswap without namespace qualification.</p><p>✦It’s fine to totally specialize std templates for user-defined types, butnever try to add something completely new to std.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="条款26：尽量将变量的声明置后"><a href="#条款26：尽量将变量的声明置后" class="headerlink" title="条款26：尽量将变量的声明置后"></a>条款26：尽量将变量的声明置后</h2><p><code>Postpone variable definitions as long as possible</code></p><h3 id="变量声明前置示例"><a href="#变量声明前置示例" class="headerlink" title="变量声明前置示例"></a>变量声明前置示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...            <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                   <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>使用：正常执行的时候需要用到encrypted</p><p>未使用：当异常抛出时，encrypted对象的构造成本已经造成，而析构要离开作用域后才会启用。</p><h3 id="变量置后"><a href="#变量置后" class="headerlink" title="变量置后"></a>变量置后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted’s definition until it’s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...          <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环中的变量声明"><a href="#循环中的变量声明" class="headerlink" title="循环中的变量声明"></a>循环中的变量声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    w = some value dependent on i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach B: define inside loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方法的成本对比</p></blockquote><p>■Approach A: 1 constructor + 1 destructor + n assignments.</p><p>■Approach B: n constructors + n destructors.</p><blockquote><p>效率分析</p></blockquote><p>■Approach A:可见性强，当n较大时效率更好</p><p>■Approach B:n小时效率高</p><p>(1) assignment相比constructor-destruction(对)更加便宜</p><p>(2) 如果您正在处理代码中对性能敏感的部分，则应默认使用方法B。</p><h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p>✦Postpone variable definitions as long as possible. It increases pro-gram clarity and improves program efficiency.</p><hr><h2 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款27：尽量少做转型操作</h2><p><code>Minimize casting</code></p><h3 id="C语言转型语法"><a href="#C语言转型语法" class="headerlink" title="C语言转型语法"></a>C语言转型语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C风格的转型</span></span><br><span class="line">(T) expression<span class="comment">// cast expression to be of type T</span></span><br><span class="line"><span class="comment">//函数风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression)<span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure><h3 id="C-新式转型-new-style"><a href="#C-新式转型-new-style" class="headerlink" title="C++新式转型(new-style)"></a>C++新式转型(new-style)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><p>const_cast通常被用来将对象的常量性去除</p></li><li><p>dynamic_cast 主要用来执行“向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，不可以移植。例如将pointer to int 转型为一个int。</p></li><li><p>static_cast用来强制隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derivered。但它无法将cosnt转为non-const——这个只有const_cast才能办到。</p></li></ul><h3 id="新式转换的优点"><a href="#新式转换的优点" class="headerlink" title="新式转换的优点"></a>新式转换的优点</h3><ul><li><p>在代码中容易被识别出来(grep工具和人工识别)，找出类型系统在那个地点被破坏</p></li><li><p>各转型动作的目标越窄化，编译器越可能诊断错误地点，例如将constness去除，除非使用新式转型中的const_cast否之无法通过编译</p></li></ul><h3 id="旧式类型转换的使用场景："><a href="#旧式类型转换的使用场景：" class="headerlink" title="旧式类型转换的使用场景："></a>旧式类型转换的使用场景：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                        <span class="comment">// with function-style </span></span><br><span class="line"><span class="built_in">castdoSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                                        <span class="comment">// with C++-style cast</span></span><br></pre></td></tr></table></figure><p>在function-style看起来更像类型转换。可进行显式构造函数中类型转换。</p><h3 id="RTII-Run-Time-Type-Identification"><a href="#RTII-Run-Time-Type-Identification" class="headerlink" title="RTII(Run Time Type Identification)"></a>RTII(Run Time Type Identification)</h3><blockquote><p>含义</p></blockquote><p>令编译器编译出运行期间执行的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)/y;</span><br></pre></td></tr></table></figure><p>将int 转型为double会产生一些代码，因为int与double的底层描述不相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span>:<span class="keyword">public</span> Base&#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;<span class="comment">// implicitly convert Derived*⇒  Base*</span></span><br></pre></td></tr></table></figure><p>上述两个指针的值并不相同(&amp;d,pb)，这个时候会又一个偏移量运行期施加在Derived*指针上取得正确的指针值。</p><h3 id="转型容易写出似是而非的代码"><a href="#转型容易写出似是而非的代码" class="headerlink" title="转型容易写出似是而非的代码"></a>转型容易写出似是而非的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;<span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;<span class="comment">// base onResize impl</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// derived onResize impl;</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">// cast *this to Window,</span></span><br><span class="line">                                         <span class="comment">// then call its onResize;</span></span><br><span class="line">                                        <span class="comment">// this doesn’t work!</span></span><br><span class="line">    ...<span class="comment">// do SpecialWindow-</span></span><br><span class="line">    &#125;<span class="comment">// specific stuff</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题所在</p></blockquote><p>static_cast(<em>this).onResize()，调用的onResize并不是当前对象上的函数，而是稍早转型动作所建立的一个 “</em>this对象的base class成分” 的<strong>暂时副本</strong>身上的onResize。</p><p>(函数就是函数，它只是一个成员仅此一份，关键在于成员函数都含有个隐藏的this指针，因此会影响成员操作数据)</p><p><strong>换句话来说就是会丢失在当前对象base-class中对数据的操作</strong></p><p><code>it does not invoke that function on the current object! Instead, the cast creates a new, temporary copy of the base class part of *this, then invokes onResize on the copy!</code> </p><blockquote><p>实际示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>():<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ++size; </span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>():<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;A&gt;(*<span class="keyword">this</span>).<span class="built_in">get_size</span>();  <span class="comment">//error</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如上述例子，我们的操作仅仅只是在*this指针强转得到一个副本上调用了函数，因此在当前对象上并没有调用base-class的成员函数，所有A::get_size中的size++不会在当前对象上作用，所以得到的结果为1.</p><blockquote><p>解决办法：去除类型转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>( );<span class="comment">// call Window::onResize</span></span><br><span class="line">    ...<span class="comment">// on *this</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic__cast"></a>dynamic__cast</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有指向base-class的一个pointer或reference时，想要去操作认定为derived-class对象身上执行derived-class操作函数，依靠该dynamic__cast转型方法实现</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>dynamic_cast的执行速度<strong>相当的慢</strong>，而且<strong>向下转型</strong>本就是一个<strong>不安全的行为</strong>，因此有两个办法用来取代dynamic__cast</p><h4 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h4><p>使用容器并在请汇总存储直接指向derived-class对象的指针(通常为只能指针)，消除了”通过base-class接口处理对象函数“的需要。</p><blockquote><p>示例</p></blockquote><p>假设先前的window/specialwindow继承体系只有specialwindows才支持闪烁效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span><span class="comment">// see Item13 for info</span></span><br><span class="line">std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;  </span><br><span class="line"><span class="comment">// on tr1::shared_ptr</span></span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// undesirable code:</span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// uses dynamic_cast++iter) </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;</span><br><span class="line">                                (iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// better code: uses </span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// no dynamic_cast++iter)</span></span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure><p>缺陷在于无法在同一容器内存储指向window的任何派生类。处理多窗口需要多个容器，他们都具备类型安全性</p><h4 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h4><p>通过base-class接口处理所有window的所有派生类，就是在base-class内提供virtual函数做任何想多window派生类做的时</p><blockquote><p>示例</p></blockquote><p>虽然specialwindow可以闪烁，但或许将闪烁函数声明在base-class中并提供一份空的默认函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">// default impl is no-op;</span></span><br><span class="line">    ...                    <span class="comment">// see Item34 for why</span></span><br><span class="line">&#125;;<span class="comment">// a default impl may be</span></span><br><span class="line"><span class="comment">// a bad idea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;<span class="comment">// in this class, blink</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// does something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;<span class="comment">// container holds// (ptrs to) all possible</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Window types</span></span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>( );iter != winPtrs.<span class="built_in">end</span>( );</span><br><span class="line">                ++iter)<span class="comment">// note lack of </span></span><br><span class="line">        (*iter)-&gt;<span class="built_in">blink</span>( );<span class="comment">// dynamic_cast</span></span><br></pre></td></tr></table></figure><p>无论是那种做法——”类安全容器“还是”virtual函数往继承体系上方移动“，都只是一个可行方案，需要靠自己判断</p><h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><p>✦Avoid casts whenever practical, especially dynamic_casts in perfor-mance-sensitive code. If a design requires casting, try to develop acast-free alternative. </p><p>✦When casting is necessary, try to hide it inside a function. Clientscan then call the function instead of putting casts in their own code.</p><p>✦Prefer C++-style casts to old-style casts. They are easier to see, andthey are more specific about what they do.</p><hr><h2 id="条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分"><a href="#条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分" class="headerlink" title="条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分"></a>条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分</h2><p><code>Avoid returning “handles” to object internals</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设您正在处理一个涉及矩形的应用程序，每个矩形可以由其左上角和右下角表示。要使矩形对象保持较小，可以决定定义其范围的点不应存储在矩形本身中，而应存储在矩形指向的辅助结构中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;<span class="comment">// Point data for a Rectangl</span></span><br><span class="line">    ePoint ulhc;<span class="comment">// ulhc = “ upper left-hand corner”</span></span><br><span class="line">    Point lrhc;<span class="comment">// lrhc = “ lower right-hand corner”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;RectData&gt; pData;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>对于Rectangle类我们添加两个const-reference member function，为何使用const-reference在<code>条款20</code>中有说明。但因此会导致以下问题。</p><h3 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;<span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                    <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">// now rec goes from</span></span><br><span class="line">                        <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure><p>由上述代码可以得知，我们不仅仅能对矩形的点进行读，并且能够进行修改，那么我们<strong>定义的数据成员与public就没有什么两样</strong>。(虽然我们在upperLeft()函数添加了const定义，但我们只是不能对指向Rectdata的智能指针进行修改，可以对该对象内部的值进行修改)</p><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过将返回值加上const我们可以让const成员限定符不在是个fake，我们只能对数据进行读写。</p><p>但是这种方式仍然会引起下述问题</p><h3 id="dangling-handles-所指对象不存在"><a href="#dangling-handles-所指对象不存在" class="headerlink" title="dangling handles 所指对象不存在"></a>dangling handles 所指对象不存在</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rectangle                <span class="comment">// returns a rectangle by</span></span><br><span class="line"><span class="built_in">boundingBox</span>(<span class="type">const</span> GUIObject&amp; obj);<span class="comment">// value; see Item3 for why</span></span><br><span class="line">                                <span class="comment">//  return type is const</span></span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//Now consider how a client might use this function:</span></span><br><span class="line">GUIObject *pgo;<span class="comment">// make pgo point to</span></span><br><span class="line">...            <span class="comment">// some GUIObject</span></span><br><span class="line"><span class="type">const</span> Point *pUpperLeft =            <span class="comment">// get a ptr to the upper </span></span><br><span class="line">    &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>( ));<span class="comment">// left point of its</span></span><br><span class="line">                                       <span class="comment">// bounding box</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析</p></blockquote><p>上述问题中会调用boundingBox(*pgo)函数对象，它所返回的值是一个临时的Rectangle副本(temp)，当我们用upperLeft去作用与temp身上，返回一个reference指向temp的一个内部成分</p><blockquote><p>错误</p></blockquote><p>当我们结束这段语句是会产生一个问题，就是我们的boundBox的返回值(temp)，将会被析构，也就是这个temp对象的内部成员都不复存在，那么我们的pUpperLeft就指向了一个<strong>不复存在的值</strong>。</p><h3 id="例外：operator"><a href="#例外：operator" class="headerlink" title="例外：operator[]"></a>例外：operator[]</h3><p>在vector和string容器中有个成员函数operator[]可以选择个别的元素，这个函数就是返回reference指向“容器内的数据”，但那些数据会随着容器的销毁而销毁。这仅仅只是有个例外。</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>✦Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helpsconst member functions act const, and minimizes the creation of dangling handles.</p><hr><h2 id="条款29：为”异常安全“而努力是值得的"><a href="#条款29：为”异常安全“而努力是值得的" class="headerlink" title="条款29：为”异常安全“而努力是值得的"></a>条款29：为”异常安全“而努力是值得的</h2><p><code>Strive for exception-safe code</code></p><blockquote><p>异常问题</p></blockquote><p>以class用来表现夹带背景图案的GUI菜单，运用于多线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;</span><br><span class="line">    ...  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image* bgImage;</span><br><span class="line">    <span class="type">int</span> imagechages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++ imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="”异常安全“的条件"><a href="#”异常安全“的条件" class="headerlink" title="”异常安全“的条件"></a>”异常安全“的条件</h3></blockquote><ol><li><p><strong>不泄漏任何资源</strong>：new Image(imgSrc)导致异常，对unlock的调用就绝不会执行。</p></li><li><p><strong>不允许数据败坏</strong>：new Iamge(imgSrc)抛出异常，bgImage就是指向一个被删除的对象，imageChanges以及被累加，而其实并没有新的图像被成功安装起来</p></li></ol><blockquote><p>RAII解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prettMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChages++;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>不在需要调用unlock</code></p><blockquote><h3 id="”异常安全函数“保证"><a href="#”异常安全函数“保证" class="headerlink" title="”异常安全函数“保证"></a>”异常安全函数“保证</h3></blockquote><ul><li><p><strong>基本承诺</strong>：异常抛出时，不会使对象或数据结构会因此而破坏，就数据保持异常抛出钱的状态</p></li><li><p><strong>强烈保证</strong>：异常抛出使，程序状态不会改变。(函数失败恢复到”调用函数之前“的状态)</p></li><li><p><strong>不抛掷保证</strong>：它们总能完成总能的原先承诺的功能</p></li></ul><h3 id="异常安全函数解决问题"><a href="#异常安全函数解决问题" class="headerlink" title="异常安全函数解决问题"></a>异常安全函数解决问题</h3><blockquote><h4 id="智能指针解决问题："><a href="#智能指针解决问题：" class="headerlink" title="智能指针解决问题："></a>智能指针解决问题：</h4></blockquote><p>1.引用智能指针类管理内存</p><p>2.将计数器的次序交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));<span class="comment">//以”new Image“;</span></span><br><span class="line">                                    <span class="comment">//设定bgImage内部指针</span></span><br><span class="line">    ++imageChagnes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><p>不需手动delete旧图像，而且删除操作是在对象被成功创建的之后，因此new成功后才会成功调用reset函数，Image（imgSrc）的临时对象也会在reset中释放掉（delete）</p><p><strong>问题</strong>：</p><p>Image构造函数会抛出异常（输出流的读取记号已经被移走）</p><h3 id="Copy-and-Swap"><a href="#Copy-and-Swap" class="headerlink" title="Copy and Swap"></a>Copy and Swap</h3><blockquote><p><strong>原则介绍</strong>：</p></blockquote><p>为你打造修改的对象（原件）做出一个副本，然后再那副本身上做一切的修改。若修改发生错误，源对象仍能保存原始状态。修改成功，则原件和副本做置换操作。</p><p>修改对象数据副本，一个<strong>不会抛出异常的函数</strong>（swap）中将修改后的数据和原件置换</p><blockquote><p>”隶属对象数据“ <strong>pimpi idiom</strong></p></blockquote><p>从原对象放进一个另一个对象内，然后赋予原对象一个指针，指向那个实现对象（副本）、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>&#123;<span class="comment">//pImpl是一个private成员具有封装性</span></span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changeBackground</span><span class="params">(std::istream pImpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">//设计copy副本（值对象），保存原始数据</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;PMImpl&gt; <span class="title">ptemp</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    <span class="comment">//修改副本</span></span><br><span class="line">    ptemp-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line"></span><br><span class="line">    ptemp-&gt;imageChanges++;</span><br><span class="line">    <span class="comment">//原始对象与副本交换</span></span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);<span class="comment">//置换数据，释放mutex·</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Exception-safe functions leak no resources and allow no data struc-tures to become corrupted, even when exceptions are thrown. Suchfunctions offer the basic, strong, or nothrow guarantees.</p><p>✦The strong guarantee can often be implemented via copy-and-swap,but the strong guarantee is not practical for all functions.</p><p>✦A function can usually offer a guarantee no stronger than the weak-est guarantee of the functions it calls. </p></blockquote><hr><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><code>Understand the ins and outs of inlining</code></p><h3 id="inline的细节"><a href="#inline的细节" class="headerlink" title="inline的细节"></a>inline的细节</h3><ol><li>inline函数代码量不易过大会导致程序体积过大，导致代码膨胀以至于额外的换页行为</li><li>inline只是对编译器的申请并不是强制命令，class内的函数被隐喻的称为inline</li><li>inline通常被置于头文件，在编译过程中进行inlining，而为将一个“函数调用”替换为“被调用函数的本体”</li></ol><h3 id="inline的声明"><a href="#inline的声明" class="headerlink" title="inline的声明"></a>inline的声明</h3><blockquote><p>隐式声明为inline的函数</p></blockquote><ul><li>member函数</li><li>friend函数</li></ul><blockquote><p>不应被声明为inline的函数</p></blockquote><ul><li>构造以及析构函数</li></ul><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>✦Limit most inlining to small, frequently called functions. This facili-tates debugging and binary upgradability, minimizes potential codebloat, and maximizes the chances of greater program speed.</p><p>✦Don’t declare function templates inline just because they appear inheader files.</p><hr><h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p><code>Minimize compilation dependdencies between files</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>( <span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr);</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;<span class="comment">// implementation detail</span></span><br><span class="line">Date theBirthDate;<span class="comment">// implementation detail</span></span><br><span class="line">Address theAddress;<span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要想让Person class编译需要加入以下头文件的类或函数声明式</p><h1 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="include &lt; string &gt;"></a>include &lt; string &gt;</h1><h1 id="include-“date-h”"><a href="#include-“date-h”" class="headerlink" title="include “date.h”"></a>include “date.h”</h1><h1 id="include-“address-h”"><a href="#include-“address-h”" class="headerlink" title="include “address.h”"></a>include “address.h”</h1><p>但这样会导致这些文件中形成一种编译的<strong>依存关系</strong>，所依赖的头文件发生改变都会让Person class的头文件进行重新文件</p><blockquote><p>将class的实现细目至于class的定义式中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">string</span>;<span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// one — see below)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><ol><li><p>string前置声明错误，正确的也复杂</p></li><li><p>前置声明每一个东西困难的是，编译器必须知道对象的大小</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(params)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器清楚的知道int需要多大，而Person需要询问class的定义式。</p><p>针对于Person类可以用以下方法：将Person分割为两个classes，一个只<strong>提供接口</strong>，一个只负责<strong>实现该接口</strong>。将负责实现的Implementation class取名为PersonImpl，Person将定义如下</p><h3 id="pimpl-idiom-pointer-to-implementation"><a href="#pimpl-idiom-pointer-to-implementation" class="headerlink" title="pimpl idiom(pointer to implementation)"></a>pimpl idiom(pointer to implementation)</h3><p><em>pimpl 惯例</em>是一种新式 C++ 技术，用于<strong>隐藏实现、最小化耦合和分离接口</strong>。 Pimpl 对于”指向实现的指针”是短的。你可能已熟悉概念，但通过其他名称（如 Che一 cat 或编译器防火墙惯例）了解它。</p><p>下面是 pimpl 惯例如何改进软件开发生命周期：</p><ul><li><p>最大程度地减少编译依赖项。</p></li><li><p>接口和实现分离。</p></li><li><p>可移植性。</p></li></ul><blockquote><p>优点</p></blockquote><p>有较好的封装性以及减少客户端的文件依赖性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pimpl</span></span><br><span class="line"><span class="comment">// 在头文件person.hpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Person类的实现细节放置在该前向声明的实现类中。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  <span class="comment">// 指向实现类Impl的私有指针</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源文件person.cpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;basic_info.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>::Impl &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string id;</span><br><span class="line">  BasicInfo basic_info;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>() : <span class="built_in">pimpl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>1.减少了需要包含的头文件；2.当内部实现发生变化时，客户端的代码不需要重新编译。例如：客户端在gcc编译中只需要连接上其动态连接库或者静态库文件，这时候服务端已经将所需的文件的编译完了，可以减少客户端编译的时间</p><p>由此修改以上Person代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="comment">// standard library components</span></span></span><br><span class="line"><span class="comment">// shouldn’t be forward-declared</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for tr1::shared_ptr; see belowclass PersonImpl;</span></span></span><br><span class="line"><span class="comment">// forward decl of Person impl. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward decls of classes used in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                    <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// ptr to implementation;</span></span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// std::tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>上述代码main class中内涵一个</p><p>这样的设计下，Person的客户就完全与Dataes，Address以及Persons的实现的细目分离。因此哪些classes的任何实现修改都不需要Person客户断重新编译。“接口与实现分离”</p><blockquote><p>关键</p></blockquote><p>这个分离在于以“声明的依存性”替换为“定义的依存性”，编译最小化的本质：现实中让头文件尽可能的自我满足，万一做不到，则让他与其他文件内的声明式(并非定义式)相依</p><h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>■Avoid using objects when object references and pointers will do</p><p>■Depend on class declarations instead of class definitions whenever you can.</p><p>声明函数而它用到某个class式，你并不需要改class的定义：纵使函数以by value方式传递改类型的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// class declaration</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// fine — no definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;<span class="comment">// of Date is needed</span></span><br></pre></td></tr></table></figure><p>声明这两个函数的无需Date的定义式，但是当有人调用哪些函数式，调用之前需要让Date的定义式曝光</p><p>如果将”提供class定义式“（通过#include完成）的义务冲”<strong>函数声明所在</strong>“之头文件转移到”<strong>内涵函数调用</strong>“之客户文件，便可将”<strong>并非真正必要的类型定义</strong>“与客户端之间的<strong>编译依存</strong>去除掉</p><p>■Provide separate header files for declarations and definitions</p><p>需要两个头文件，一个用于声明式，一个用于定义式。文件必须保持一致性，如果声明式被改变，两个文件都需要改变。<strong>#include一个声明文件</strong>而非前置声明若干函数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span><span class="comment">// header file declaring (but not</span></span></span><br><span class="line">                    <span class="comment">// defining) </span></span><br><span class="line"><span class="function"><span class="keyword">class</span> DateDate <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>C++中提供关键字export，允许将template声明式和template定义式分割与不同的文件内，但式这个关键字在有些编译器里不支持</p><h3 id="Handle-classses"><a href="#Handle-classses" class="headerlink" title="Handle classses"></a>Handle classses</h3><p>像Person这样使用pimpl idiom的classes，被称为Handle classes。</p><blockquote><p>方法一</p></blockquote><p>将他们的所有函数转交给一个相应的实验类并由后者完成实际工作。例如卖弄Person的两个成员函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span><span class="comment">// we must also #include PersonImpl’s class</span></span></span><br><span class="line"><span class="comment">// definition, otherwise we couldn’t call </span></span><br><span class="line"><span class="comment">// its member functions; note that </span></span><br><span class="line"><span class="comment">// PersonImpl has exactly the same public</span></span><br><span class="line"><span class="comment">// member functions as Person — their</span></span><br><span class="line"><span class="comment">// interfaces are identical</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">            <span class="type">const</span> Address&amp; addr): </span><br><span class="line">                        <span class="built_in">pImpl</span>(<span class="keyword">new</span> </span><br><span class="line">                            <span class="built_in">PersonImpl</span>(name, birthday, addr))&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">( )</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调PersonImpl::name，让Person百年城一个Handle class但不会改变他做的事，只会改变它做事的方法</p><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>令Person称为一个特殊的抽象基类，称为interface class。这汇总class的目的事猫叔derived的接口，因此他通常不带有成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtal函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>class的用户必须以Person的pointer和reference来写应用程序，因为他不可能针对”内含pure virtual函数“的person classes具体出实体。</p><p>interface class的客户必须有办法为这种class创建新的对象。</p><p>如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt;</span><br><span class="line">                    <span class="comment">// return a tr1::shared_ptr to a new</span></span><br><span class="line">    <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,<span class="comment">// Person initialized with the</span></span><br><span class="line">            <span class="type">const</span> Date&amp; birthday,<span class="comment">// given params; see Item18 for</span></span><br><span class="line">            <span class="type">const</span> Address&amp; addr);<span class="comment">// why a tr1::shared_ptr is returned</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户将会这样使用这些接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;Address address;</span><br><span class="line">...<span class="comment">// create an object supporting the Person interface</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 address))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>( )</span><br><span class="line">                            <span class="comment">// use the object via the</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot; was born on &quot;</span></span><br><span class="line">                            <span class="comment">// Person interface</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>( )</span><br><span class="line">    &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">address</span>( );</span><br><span class="line">    ...                    <span class="comment">// the object is automatically </span></span><br><span class="line">                            <span class="comment">// deleted when pp goes out of </span></span><br><span class="line">                            <span class="comment">// scope </span></span><br></pre></td></tr></table></figure><p>支持interface class接口的那个concrete class 必须被定义出来，而其真正的构造函数必须被调用。一切都在virtual构造函数实现所在的文件内放生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr):   <span class="built_in">theName</span>(name), </span><br><span class="line"><span class="built_in">theBirthDate</span>(birthday), </span><br><span class="line"><span class="built_in">theAddress</span>(addr)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>( ) &#123; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// implementations of these </span></span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// functions are not shown, but </span></span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// they are easy to imagineprivate:</span></span><br><span class="line">std::string theName;Date theBirthDate;Address theAddress;&#125;;</span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">//Given RealPerson, it is truly trivial to write Person::create:</span></span><br><span class="line">std::tr1::shared_ptr&lt;Person&gt; Person::</span><br><span class="line">                        <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">                                    <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> </span><br><span class="line">                        <span class="built_in">RealPerson</span>( name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更现实的Person::create实现代码会创建不同类型的derived class对象。取决于额外参数值、读自文件或数据库的数据、环境变量。</p><p>RealPerson示范实现了Interface class 的两个最常见的机制之一：从Interface class继承接口规格，然后实现出接口所覆盖的函数。第二点则是多重继承</p><h3 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h3><p>✦The general idea behind minimizing compilation dependencies is todepend on declarations instead of definitions. Two approachesbased on this idea are Handle classes and Interface classes.</p><p>✦Library header files should exist in full and declaration-only forms.This applies regardless of whether templates are involved.</p><hr><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑造出的is-a关系"><a href="#条款32：确定你的public继承塑造出的is-a关系" class="headerlink" title="条款32：确定你的public继承塑造出的is-a关系"></a>条款32：确定你的public继承塑造出的is-a关系</h2><p><code>Make sure public inheritance models &quot;is-a&quot;</code></p><p>通过public继承出的关系为“is-a”关系，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// fine, s is a Student,</span></span><br><span class="line">        <span class="comment">// and a Student is-a Person</span></span><br><span class="line"><span class="built_in">study</span>(s);<span class="comment">// fine</span></span><br><span class="line"><span class="built_in">study</span>(p);<span class="comment">// error! p isn’t a Student</span></span><br></pre></td></tr></table></figure><p>如上述关系可以表述出学生是人，但人这个抽象类却不一定是人</p><h3 id="is-a的误区"><a href="#is-a的误区" class="headerlink" title="is-a的误区"></a>is-a的误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="comment">// birds can fly</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    <span class="comment">// penguins are birds</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>错误</p></blockquote><p>这个继承体系中说明企鹅是鸟的派生类，那么它应该含有鸟类的所有行为，但是企鹅却不会飞，这点显得不是特别的严谨。我们应该让is-a有较佳的真实性</p><h3 id="方法一-双class继承体系"><a href="#方法一-双class继承体系" class="headerlink" title="方法一:双class继承体系"></a>方法一:双class继承体系</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二：运行期错误"><a href="#方法二：运行期错误" class="headerlink" title="方法二：运行期错误"></a>方法二：运行期错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;<span class="comment">// defined elsewhere</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Attempt to make a penguin fly!&quot;</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处声明出企鹅是不会飞的，那么说企鹅会飞则是一种错误的认知，在运行期的时候会被检测出来</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结:"></a>总结:</h3><p>✦Public inheritance means “is-a.” Everything that applies to baseclasses must also apply to derived classes, because every derivedclass object is a base class object.</p><hr><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p><code>Avoid hiding inherited names</code></p><h3 id="命名查找规则-作用域"><a href="#命名查找规则-作用域" class="headerlink" title="命名查找规则(作用域)"></a>命名查找规则(作用域)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>&#123;<span class="built_in">mf2</span>();&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-30-29-image.png" alt=""></p><p>Base的作用域大于Derived的作用域，根据命名查找法，当我们在Derived类中查找mf2时，选择方向Derived-&gt;Base-&gt;global。小一级的作用域会将其覆盖。</p><h3 id="名称可视性-name-visibility"><a href="#名称可视性-name-visibility" class="headerlink" title="名称可视性(name visibility)"></a>名称可视性(name visibility)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-37-52-image.png" alt=""></p><p>Base内名为mf1和mf3的重载函数都被Derived内的mf1和mf3函数所遮掩。从名称查找观点来看Base::mf1和Base::mf3不在被Derived继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1d.mf1(x);</span></span><br><span class="line">        <span class="comment">// error! Derived::mf1 hides Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );<span class="comment">// fine, calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// error! Derived::mf3 hides Base::mf3</span></span><br></pre></td></tr></table></figure><p>更具以上代码可知，当我们在重载函数时，在子类中就只能对Derived作用域的函数名可见，但是对于重载函数是不可见的。不论是virtual还是non-virtual都是一样。</p><h3 id="解决继承来的名称的遮掩行为"><a href="#解决继承来的名称的遮掩行为" class="headerlink" title="解决继承来的名称的遮掩行为"></a>解决继承来的名称的遮掩行为</h3><blockquote><p>违反is-a关系</p></blockquote><p>当public继承而又不继承哪些重载函数就是违反base和deriver class之间的<strong>is-a关系</strong> </p><blockquote><p>using声明表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1;<span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line"><span class="keyword">using</span> Base::mf3;<span class="comment">// visible (and public) in Derived’s scope</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-12-47-00-image.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// still fine, still calls Derived::mf1d.mf1(x);</span></span><br><span class="line"><span class="comment">// now okay, calls Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );</span><br><span class="line"><span class="comment">// still fine, still calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// now okay, calls Base::mf3 (The int x is </span></span><br><span class="line">        <span class="comment">// implicitly converted to a double so that</span></span><br><span class="line">        <span class="comment">// the call to Base::mf3 is valid.</span></span><br></pre></td></tr></table></figure><p>用using声明，derived类继承了base并加上了重载函数，此时也可以重写一部分重载函数将base的函数给覆盖。</p><h3 id="forward-function转交函数"><a href="#forward-function转交函数" class="headerlink" title="forward function转交函数"></a>forward function转交函数</h3><blockquote><p>使用场景</p></blockquote><p>不想继承base的所有函数，在“is-a”中会违背其含义</p><blockquote><p>private继承</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">...<span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span>    <span class="comment">// forwarding function; implicitly</span></span></span><br><span class="line"><span class="function"></span>&#123; Base::<span class="built_in">mf1</span>( ); &#125;    <span class="comment">// inline — see Item30. (For info...</span></span><br><span class="line">                    <span class="comment">// on calling a pure virtual</span></span><br><span class="line"><span class="comment">//-------继承private----------</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="comment">//---------------------------</span></span></span><br><span class="line"><span class="function">&#125;</span>;<span class="comment">// function, see Item34.)</span></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">// error! Base::mf1( ) is hidden</span></span><br></pre></td></tr></table></figure><blockquote><p>inline转交函数的用途</p></blockquote><p>哪些不支持using声明式，将继承而得的名称汇入derived作用域</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>✦Names in derived classes hide names in base classes. Under publicinheritance, this is never desirable. </p><p>✦To make hidden names visible again, employ using declarations orforwarding functions.</p><hr><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p><code>Difference between inheritance of interface and inheritance of implementation</code></p><blockquote><p>public继承概念</p></blockquote><p><strong>函数接口继承</strong>和<strong>函数实现继承</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数的接口总是会被继承"><a href="#成员函数的接口总是会被继承" class="headerlink" title="成员函数的接口总是会被继承"></a>成员函数的接口总是会被继承</h3><p>public为is-a关系继承，所有对Base class为真的事件对于Derived class也为真。</p><blockquote><p>接口与实现</p></blockquote><ul><li>接口：是(对外或者对继承)可视的，定义一个的对象实体可以通过(对外可视的)接口去访问该对象</li><li>实现：是一个实体，可以看作是接口所要做到事，对外不一定可见，对内一定可见</li></ul><blockquote><p>pure virtual函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>pure virtual函数的特性：</p></blockquote><ul><li><p>必须被他们所继承的具象类所<strong>重新声明</strong></p></li><li><p>抽象类中通常没有对该函数的定义</p></li></ul><h3 id="pure-virtual函数-子类必须重写"><a href="#pure-virtual函数-子类必须重写" class="headerlink" title="pure virtual函数(子类必须重写)"></a>pure virtual函数(子类必须重写)</h3><blockquote><p><strong>让derived class只继承接口</strong></p></blockquote><p>shape class无法对shape::draw函数提供合理的默认实现，比较其模棱两可(椭圆和矩形的画法)，因此在具象derived class 中<strong>必须提供</strong>一个draw函数，并且不干涉如何实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape;<span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;<span class="comment">// fine 多态</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Rectangle::draw</span></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;<span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls base class pure virtual函数也可以有实现</span></span><br><span class="line">Shape::drawps2-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure><h3 id="impure-virtual函数-可选是否重写"><a href="#impure-virtual函数-可选是否重写" class="headerlink" title="impure virtual函数(可选是否重写)"></a>impure virtual函数(可选是否重写)</h3><blockquote><p><strong>让derived class继承函数的接口和默认实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Shaped::error的声明式要求derived classes必须<strong>支持一个error函数</strong>，但如果不想自己写一个，那么就可以使用<strong>Shaped class提供的默认版本</strong></p><h3 id="non-virtual函数-不能重写"><a href="#non-virtual函数-不能重写" class="headerlink" title="non-virtual函数(不能重写)"></a>non-virtual函数(不能重写)</h3><blockquote><p><strong>让derived class继承函数的接口及一份强制性实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>non-virtual函数：并不打算在derived classes中有不同的行为。实际上non-virtual函数表现的不变性(invariant)大于其特异性(specialization)。</p><p>例如：Shape::objectID是有特定计算ID的一个函数，该方法是由其定义式决定的，任何derived class都<strong>不应该修改其行为</strong>，<strong>不应该在derived class中被重新定义</strong>。(<strong>破坏多态性</strong>)</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>✦Inheritance of interface is different from inheritance of implementa-tion.  Under  public  inheritance,  derived  classes  always  inherit  baseclass interfaces.</p><p>✦Pure virtual functions specify inheritance of interface only. </p><p>✦Simple  (impure)  virtual  functions  specify  inheritance  of  interfaceplus inheritance of a default implementation. </p><p>✦Non-virtual  functions  specify  inheritance  of  interface  plus  inherit-ance of a mandatory implementation.</p><h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><p><code>Consider alternatives to virtual function</code></p><p>设计一个计算人物生命值的函数healthValue()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// return character’s health rating;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// derived classes may redefine this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们一impure virtual函数去声明函数，那么当子类不提供函数重写那么人物将采用默认的声明值的计算方法</p><h3 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h3><p>Non-virtual interface实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span><span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// this — see Item36</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “before” stuff — see below</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>( );<span class="comment">// do the real work </span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “after” stuff — see below</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// default algorithm for calculating&#125;</span></span><br><span class="line">    <span class="comment">// character’s health</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本设计</p></blockquote><p>令客户通过public non-virtual成员函数去间接的调用private virtual函数，因此称为non-virtual(NVI)手法。</p><blockquote><p>优点</p></blockquote><p>NVI手法的优点在于“do ‘before’ stuff”和“do ‘after’ stuff”在上述的注释代码中，在Wrapper（healthValue）中设定好virtual函数的<strong>应用场景</strong></p><ul><li><p>“do ‘before’ stuff”：locking a mutex, making a log entry(日志记录项), verifying that class invariants and function preconditions aresatisfied, etc</p></li><li><p>“do ‘after’ stuff”：unlocking a mutex, veri-fying function postconditions, reverifying class invariants(再次验证class的约束条件), etc.</p></li></ul><blockquote><p>疑问</p></blockquote><p>NVI手法中涉及到derived class时base class private virtual 函数我们无法调用，但是我们需要redefining这些我们不会调用的private virtual 函数，看起来十分的矛盾。但时调用virtual函数表示它在”何时“被完成，但重定义virtual函数表示”如何“完成，这两者并不冲突。</p><p>NVI允许derived重新定义virtual函数，从而赋予了它如何具体实现的机能，但base class仍然保留函数合适被调用的权力</p><blockquote><p>特别的</p></blockquote><p>NVI手法中的virtual函数并不是非得是private。某些继承体要求在derived class中对应的实现必须调用器base class的对应兄弟，为了合法，那么就必须的设置为protect。</p><h3 id="Strategy-Pattern-via-Function-Pointers"><a href="#Strategy-Pattern-via-Function-Pointers" class="headerlink" title="Strategy Pattern via Function Pointers"></a>Strategy Pattern via Function Pointers</h3><blockquote><p>设计主张</p></blockquote><p>”人物的健康指数的计算与每个人物的类型无关“，这样的计算不需要人物这个成分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; </span><br><span class="line"><span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// function for the default health calculation algorithm</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                    healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>相比virtual函数继承，这种设计模式提供了更好的弹性</p><blockquote><p>实例</p></blockquote><ul><li>在<strong>同一类型的不同的实体</strong>中应用不同的计算函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                        GameCharacter(hcf )</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculationint lose</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// funcs with different</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;<span class="comment">// same-type charac-</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;<span class="comment">// ters with different// health-related</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br></pre></td></tr></table></figure><ul><li>已知人物的健康指数计算函数可在运行期变更。例如：base类可以提供一个成员函数setHealthCalculator，用来替换当前的健康计算函数</li></ul><h3 id="Strategy-Pattern-via-tr1-function"><a href="#Strategy-Pattern-via-tr1-function" class="headerlink" title="Strategy Pattern via tr1::function"></a>Strategy Pattern via tr1::function</h3><blockquote><p>函数指针的限制</p></blockquote><p>对template以及他们的的隐式接口的使用，基于函数的指针的做法就十分的死板。不够灵活，例如返回类型只能是int，函数对象不能是member function</p><blockquote><p>tr1::function</p></blockquote><p>改用tr1::function的对象替代函数指针，这样的对象可持有任何可调用物(callable entity 函数指针、函数对象、成员函数指针)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;<span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// HealthCalcFunc is any callable entity that can be called with</span></span><br><span class="line"><span class="comment">// anything compatible with a GameCharacter and that returns anything</span></span><br><span class="line"><span class="comment">// compatible with an int; see below for details</span></span><br><span class="line"><span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:</span></span><br><span class="line"><span class="function">                                             healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个实例中我们用tr1::function instantiation来代替目标签名式。那个签名代表的函数时”接受一个reference 指向const GamCharacter“，并返回int。这个tr1::function类型产生的对象可持有任何与此签名式兼容的可调用物。例如可调用物的<strong>参数可以被隐式的转换为const GameCharacters&amp;</strong>，其<strong>返回类型可以被隐式转换为int</strong></p><p>tr1::function对象相当于指向函数的泛化指针。</p><blockquote><p>更具与弹性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculation</span></span><br><span class="line"><span class="comment">// function; note </span></span><br><span class="line"><span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class for health</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span><span class="comment">// calculation function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;<span class="comment">// objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// health calculation</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mem function; note</span></span><br><span class="line">&#125;;<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// another character</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// type; assume same</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constructor as // EvilBadGuy</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;<span class="comment">// character using a</span></span><br><span class="line">                <span class="comment">// health calculation// function</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator( ))</span></span>;<span class="comment">// character using a </span></span><br><span class="line">                <span class="comment">// health calculation// function object</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// see below for details);</span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>解析ebg2 -&gt; bind</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function"> std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br></pre></td></tr></table></figure><p>GameLevel::health接受两个参数，一个是隐式参数currentLevel，也就是this指向的那个、另一个是reference指向GameCharactor。</p><p>GameCharacters的健康计算函数值接受单一参数：GameCharacters。</p><p>使用GameLevel::health作为ebg2的健康计算函数，我们需要以特殊方式转换，取出GameLevel其中的健康计算函数。</p><p>本例中用currentLevel作为ebg2的健康函数所需的GameLevel的对象。_1意味着用currenLevel作为GamLevel的对象</p><h3 id="the-“Classic”-Strategy-Pattern"><a href="#the-“Classic”-Strategy-Pattern" class="headerlink" title="the “Classic” Strategy Pattern"></a>the “Classic” Strategy Pattern</h3><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-06-21-21-05-image.png" alt=""></p><p>在该图中指示了GameCharacte是某个继承体系的根类，EviBadGuy与EyeCandyCharacter都是derived classes：HealthCalcFunc是另一个继承体系的根类。</p><blockquote><p>实现代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                                pHealthCalc(phcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>✦Alternatives to virtual functions include the NVI idiom and variousforms of the Strategy design pattern. The NVI idiom is itself an ex-ample of the Template Method design pattern.</p><p>✦A disadvantage of moving functionality from a member function to afunction outside the class is that the non-member function lacks ac-cess to the class’s non-public members.</p><p>✦tr1::function objects act like generalized function pointers. Such ob-jects support all callable entities compatible with a given target sig-nature.</p><hr><h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p><code>Never redefine an inherited non-virtual function</code></p><blockquote><p>non-virtual性质</p></blockquote><p>在条款34中描述了non-virtual函数会给class建立一个<strong>不变性</strong>(invariant),凌驾其<strong>特异性</strong>(specialization)</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">                <span class="comment">//Even without knowing anything about B, D, or mf, given an object x of</span></span><br><span class="line">                <span class="comment">//type D,</span></span><br><span class="line">D x;            <span class="comment">// x is an object of type D</span></span><br><span class="line">                <span class="comment">//you would probably be quite surprised if this,</span></span><br><span class="line">B *pB = &amp;x;      <span class="comment">// get pointer to xp</span></span><br><span class="line">B-&gt;<span class="built_in">mf</span>( );        <span class="comment">// call mf through pointerbehaved differently from this:</span></span><br><span class="line">D *pD = &amp;x;     <span class="comment">// get pointer to xp</span></span><br><span class="line">D-&gt;<span class="built_in">mf</span>( );      <span class="comment">// call mf through pointer</span></span><br></pre></td></tr></table></figure><p>上述示例中我们都会调用<strong>B::mf()</strong> 版函数，但是如果我们在D class中重写mf()那么我们会发现以下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;    <span class="comment">// hides B::mf; see Item33</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls D::mf should call B::mf</span></span><br></pre></td></tr></table></figure><blockquote><p>non-virtual函数是一种<strong>静态绑定</strong>(statically bound)</p></blockquote><pre><code>    在子类中重写non-virutal函数，它会根据其**声明式** (也就是D* ,B*)来选取函数执行，但实际上pB与pD指向都是**同一对象**，按理来说应该调用同一对象的函数，因此重写non-virtual函数会**导致破坏多态性**。</code></pre><blockquote><p>public继承关系</p></blockquote><p>public继承关系”is-a”关系，那么non-vitual函数的作用(不变性凌驾于特异性):</p><ol><li><p>适用于B对象的每一件事，也适用与D对象</p></li><li><p>B的derived classes一定会继承mf的接口与实现，因为mf是B的一个non-virutal函数</p></li></ol><blockquote><p>多态性的虚构问题</p></blockquote><p>   条款7： virtual析构函数，对于B<em> pd = new D();由于声明的是non-virtual的析构函数，那么执行的时候会根据<em>*声明式来定义</em></em> 静态绑定调用函数，因此在多态中只会使用B的析构函数，对于D的析构则不会调用，这时候有些D类的成员不能被析构，会导致内存泄漏问题</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited non-virtual function.</p><hr><h2 id="条款37：绝不重新定义继承而来的默认参数值"><a href="#条款37：绝不重新定义继承而来的默认参数值" class="headerlink" title="条款37：绝不重新定义继承而来的默认参数值"></a>条款37：绝不重新定义继承而来的默认参数值</h2><p><code>Never redefine a function&#39;s inherited default parameter value</code></p><p><strong>virtual函数系动态绑定，然而默认的却是静态绑定</strong></p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><blockquote><p>静态绑定义</p></blockquote><pre><code>    在程序中被**声明时**所采用的类型,静态绑定容易造成的问题如：继承类重写non-virtual函数</code></pre><p>简单来说就是调用对象是采用声明对象的一部分行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// a class for geometric shapes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="comment">// all shapes must offer a function to draw themselves</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Shape::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// notice the different default parameter value — bad!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Rectangle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Circle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shape *ps;                    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pc = <span class="keyword">new</span> <span class="built_in">Circle</span>();    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();<span class="comment">// static type = Shape*</span></span><br><span class="line">    ps = pc;</span><br><span class="line">    ps = pr;</span><br><span class="line">   <span class="comment">// ps-&gt;draw();</span></span><br><span class="line">    pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>();<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承关系</p></blockquote><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-07-20-28-31-image.png" alt=""></p><blockquote><p>指针(静态类型)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;    <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;<span class="comment">// static type = Shape*</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><blockquote><p>动态绑定定义</p></blockquote><pre><code>   普遍的来说是多态性，由一个**静态类型**的对象指针(引用)指向一个子类对象，在运行其就会将行为于其指向的对象进行绑定，调用子类对象的行为。    简单来说就是调用指向对象的行为</code></pre><blockquote><p>动态类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc;<span class="comment">// ps’s dynamic type is// now Circle*</span></span><br><span class="line">ps = pr;<span class="comment">// ps’s dynamic type is// now Rectangle*</span></span><br></pre></td></tr></table></figure><blockquote><p>调用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">====================</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Circle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析:动态绑定与静态绑定冲突</p></blockquote><pre><code>    在pr-&gt;draw();中出现了问题，pr的动态类型为Rectangle调用为virtual函数，但Rectangle::draw默认参数为应该时GREEN，但由于pr的静态类型为Shape*，所以此一调用的默认阐述时来自于Shape class，而不是来之于Rectangle class。这个函数时两个类共同完成的</code></pre><h3 id="NVI解决方案"><a href="#NVI解决方案" class="headerlink" title="NVI解决方案"></a>NVI解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span><span class="comment">// now non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);<span class="comment">// calls a virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">                                    <span class="comment">// the actual work is</span></span><br><span class="line">&#125;;<span class="comment">// done in this func</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;<span class="comment">// note lack of a</span></span><br><span class="line">    ...<span class="comment">// default param val.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>    non-virtual 函数一个不会被derived classes重写(条款36)，所以这个设计很清楚地使用了color的默认值为Red，相当于强制性不让动态绑定选择静态绑定的参数，NVI手法将动态绑定和静态绑定通过**private在继承中可见性**，进行了巧妙的结合</code></pre><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited default parameter value, because defaultparameter values are statically bound, while virtual functions — theonly functions you should be redefining — are dynamically bound.</p><hr><h2 id="条款38：通过复合塑造出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑造出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑造出has-a或“根据某物实现出”"></a>条款38：通过复合塑造出has-a或“根据某物实现出”</h2><p><code>Model &quot;has-a&quot;or&quot;is-implement-in-terms-of&quot; throught composition</code></p><blockquote><p>复合类型</p></blockquote><p>在一个类中的数据成员是一个或者多个自定义数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;<span class="comment">// where someone lives</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name;<span class="comment">// composed object</span></span><br><span class="line">Address address;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber voiceNumber;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber faxNumber;<span class="comment">// ditto</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>has-a与is-a</p></blockquote><p>在上述Person中定义了name、address、voiceNumber、faxNumber，我们都很容易说，这个人有一个名字、地址、号码，但我们不能说这个人是一个名字，另外is-a是一种继承关系</p><h3 id="复合类型中的has-a和“根据某物实现出”区分"><a href="#复合类型中的has-a和“根据某物实现出”区分" class="headerlink" title="复合类型中的has-a和“根据某物实现出”区分"></a>复合类型中的has-a和“根据某物实现出”区分</h3><ul><li><p>has-a是应用域</p></li><li><p>is-implement-in-terms-of是实现域</p></li></ul><p>用Set&lt; T &gt;继承list&lt; T &gt;声明如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//将list应用于Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:<span class="keyword">public</span> std::list&lt;T&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>根据上述继承关系很容易区分出错误，list可以插入相同元素，Set不能含有相同元素，因此在逻辑上，Set不适用于list的逻辑，因此也不是is-a关系，所以对于这两种关系不能用public来实现.</p><blockquote><p>正确做法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">// the right way to use list for Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;<span class="comment">// representation for Set data </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过复合类型可以很明显的看出关系，Set只是依赖list来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="type">const</span> T&amp; item) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item) != rep.<span class="built_in">end</span>( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; item)&#123; </span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::iterator it =<span class="comment">// see Item42 for info on</span></span><br><span class="line">    std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item);<span class="comment">// “typename” here</span></span><br><span class="line">                <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>( )) rep.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>✦Composition has meanings completely different from that of publicinheritance. </p><p>✦In the application domain, composition means has-a. In the imple-mentation domain, it means is-implemented-in-terms-of.</p><hr><h2 id="条款39：谨慎的使用“private”继承"><a href="#条款39：谨慎的使用“private”继承" class="headerlink" title="条款39：谨慎的使用“private”继承"></a>条款39：谨慎的使用“private”继承</h2><p><code>use private inheritance judiciously</code></p><h3 id="Private-继承"><a href="#Private-继承" class="headerlink" title="Private 继承"></a>Private 继承</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;; <span class="comment">// inheritance is now private</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// error! a Student isn’t a Person</span></span><br></pre></td></tr></table></figure><blockquote><p>private继承</p></blockquote><p>根据以上代码的展示，我们会发现private继承与public继承不是同一个含义，同样的public继承会产生一些逻辑上的错误，例如学生不是人</p><ul><li>private继承不会有隐式转换，同样<strong>不能多态</strong></li><li>private的语义为根据某物实现( is-implemented-in-terms-of),不会对外呈现父类的接口</li><li>private继承中base的成员都会变为private无论是protected还是public</li></ul><p>因此，private只在软件的实现中会有意义，在软件的设计中毫无意义</p><h3 id="复合与private继承的抉择"><a href="#复合与private继承的抉择" class="headerlink" title="复合与private继承的抉择"></a>复合与private继承的抉择</h3><p>private继承与复合都有根据某物实现( is-implemented-in-terms-of)的概念。</p><blockquote><p>取舍</p></blockquote><p>尽可能的选择复合，必要时才会使用private(当protected成员或virtual函数被牵扯进来)</p><h3 id="使用Private继承"><a href="#使用Private继承" class="headerlink" title="使用Private继承"></a>使用Private继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// automatically called for each tick</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// look at Widget usage data, etc</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于virtual函数，我们需要用private继承</p><p>上述代码当我们需要对一个Widget类进行计时，在运行期中周期性的检查Widget类。对于Timer这一个计时器，Widget中可以重新定义Timer内的virtual函数，但用public检查就说明Widget是一个Timer那肯定是不符合实际的。对于private继承确实是完美的选择：</p><ul><li>Widget会拥有Timer的一些实现,因此也是根据某物实现。</li><li>用户也不会造成接口的滥用，该此Timer实现也是对Widget对象内可见的。</li></ul><h3 id="复合实现"><a href="#复合实现" class="headerlink" title="复合实现"></a>复合实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;; </span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用复合类的方法实现private继承同样也是可以的，但是略显复杂</p><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-10-10-05-01-image.png" alt=""></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>✦Private  inheritance  means  is-implemented-in-terms  of.  It’s  usually inferior  to  composition,  but  it  makes  sense  when  a  derived  classneeds access to protected base class members or needs to redefineinherited virtual functions.</p><p>✦Unlike composition, private inheritance can enable the empty baseoptimization. This can be important for library developers who strive to minimize object sizes</p><hr><h2 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款40：明智而谨慎地使用多重继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;<span class="comment">// something a library lets you borrow</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;<span class="comment">// check the item out from the library</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// perform self-test, return whether</span></span><br><span class="line">    ...<span class="comment">// test succeeds</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>:<span class="comment">// note MI here</span></span><br><span class="line">        <span class="keyword">public</span> BorrowableItem,<span class="comment">// (some libraries loan MP3 players)</span></span><br><span class="line">        <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123; ... &#125;;                    <span class="comment">// class definition is unimportant</span></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>();<span class="comment">// ambiguous! which checkOut?</span></span><br></pre></td></tr></table></figure><blockquote><p>解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure><p>因为在MP3player中又两个相同的接口，因此在调用是会无法识别到底调用那个，因此只能指定数据成员</p><p>但是会得到一个尝试调用private成员的错误</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220511205507673.png" alt="image-20220511205507673"></p><p>以上的继承路线有两个条那么，假设File有一个filename数据成员分别继承到InputFile和OutputFile，当IOFile进行多重继承，那么我们会得到两份filename(InputFile::filename,Output::filename)。</p><p>得到的IOFile中如果要操作filename这<strong>数据成员要指定来自于那个父类</strong>同上。但再逻辑上这是不符合逻辑，一个文件不可能拥有两个名字。这时候就需要<strong>虚拟继承</strong>。</p><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><blockquote><p>含义</p><p>解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员。</p></blockquote><p>防止二义性问题，共享Top-Base类数据。</p><blockquote><p>虚拟继承与普通继承的区别</p></blockquote><p><strong>时间</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。(虚拟就是运行期进行选择)</p><p><strong>空间</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之 多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证 这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这样的做法就会使得再最终的outputFile中仅有一个一份filename，且不会产生二义性</p><h4 id="虚拟继承的成本"><a href="#虚拟继承的成本" class="headerlink" title="虚拟继承的成本"></a>虚拟继承的成本</h4><blockquote><p>空间</p></blockquote><p>virtual继承的class产生的non-virtual的继承体积大</p><blockquote><p>时间</p></blockquote><p>访问virtual继承的成员变量时，比访问non-virtual base classe的速度慢</p><h4 id="虚拟继承的初始化规则更复杂"><a href="#虚拟继承的初始化规则更复杂" class="headerlink" title="虚拟继承的初始化规则更复杂"></a>虚拟继承的初始化规则更复杂</h4><blockquote><p>初始化职责有继承中的最底层承担</p></blockquote><ol><li>classes若派生自virtual bases而需要初始化，必须要知道其virtual bases</li><li>当一个新的derived class加入继承体系中，它必须承当其virtual bases的初始化职责</li></ol><h4 id="虚拟继承的抉择"><a href="#虚拟继承的抉择" class="headerlink" title="虚拟继承的抉择"></a>虚拟继承的抉择</h4><ol><li>非必要不用虚拟继承，就用non-virtual 继承</li><li>必须使用virtual base classes，尽可能避免再其中放置数据</li></ol><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>✦Multiple inheritance is more complex than single inheritance. It canlead to new ambiguity issues and to the need for virtual inheritance. </p><p>✦Virtual  inheritance  imposes  costs  in  size,  speed,  and  complexity  ofinitialization and assignment. It’s most practical when virtual baseclasses have no data.</p><p>✦Multiple  inheritance  does  have  legitimate  uses.  One  scenario  in-volves  combining  public  inheritance  from  an  Interface  class  withprivate inheritance from a class that helps with implementation.CPersonIPersonPersonInfo{private}</p><hr><h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p><code>Understand implicit interfaces and compile-time polymorphism</code></p><h3 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h3><ul><li>提供显示接口</li><li>运行期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;<span class="comment">// see Item25</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//and this (equally meaningless) function,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">( Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ul><li>显示接口：在本例中我们在<code>doProcessing</code>中调用w的接口，我们可以在源文件中找到这些接口(.h文件)，必须知道接口的实现。</li><li>运行期多态：在条款37中有动态类型绑定，widget中virtual函数表现出来的为运行期多态</li></ul><h3 id="Template以及泛型编程-generic-programming"><a href="#Template以及泛型编程-generic-programming" class="headerlink" title="Template以及泛型编程( generic programming )"></a>Template以及泛型编程( generic programming )</h3><blockquote><p>面对对象的规则依然存在但是被弱化了</p></blockquote><ul><li>隐式接口</li><li>编译期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>w所支持的接口，是由template中的w身上的操作来决定，w需要提供一系列的隐式接口</li><li>w的任何函数的调用，入operator&gt; and operator!=,有可能造成template的据具现化(instantiated),这些函数的调用都是具现化在编译期。通俗来讲就是，通过模板类型T去判断T中是否有以下行为(接口)，如果没有则会编译失败，如果存在则进行选择</li></ul><h3 id="运行期多态与编译期多态"><a href="#运行期多态与编译期多态" class="headerlink" title="运行期多态与编译期多态"></a>运行期多态与编译期多态</h3><blockquote><p>区别</p></blockquote><ul><li>运行期多态：那个virtual函数被选择</li><li>编译期多态：那个重载函数被调用</li></ul><h3 id="隐式接口与显式接口"><a href="#隐式接口与显式接口" class="headerlink" title="隐式接口与显式接口"></a>隐式接口与显式接口</h3><blockquote><p>显式接口</p></blockquote><p>通常是由函数的签名式(函数名称、参数类型、返回类型)构成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上public接口有一个构造函数、析构函数、各个成员函数及其参数类型、返回类型、常量性构成。</p><blockquote><p>隐式接口</p></blockquote><p>它不基于函数签名式，是由有效表达式(valid expression)组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上：</p><p>T的隐式接口有一系列的约束</p><ul><li>必须提供size函数</li><li>必须提供operator !=的类型比较函数(假设<code>someNastyWidget</code>的类型为T)</li></ul><p><strong>隐式接口同样需要支持T类型</strong></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>✦Both classes and templates support interfaces and polymorphism.</p><p> ✦For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions. </p><p>✦For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution.</p><hr><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p><code>Understand the two meaning of typename</code></p><h3 id="class-and-typename-声明"><a href="#class-and-typename-声明" class="headerlink" title="class and typename 声明"></a>class and typename 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br></pre></td></tr></table></figure><p>class 与 typename没有任何不同。当声明template类型参数，class和typename的意义完全相同</p><h3 id="typename的另一重意义"><a href="#typename的另一重意义" class="headerlink" title="typename的另一重意义"></a>typename的另一重意义</h3><blockquote><p>声明“类型”</p></blockquote><p>当有static成员变量与T::~定义的类型命名冲突时会造成编译器的警告，因此需要typename的显式的声明这是命名为一个<strong>类型</strong>，而不是<strong>变量</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;<span class="comment">// typename allowed (as is “class”)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">const</span> C&amp; container,<span class="comment">// typename not allowed</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">typename</span> C::iterator iter)</span></span>;<span class="comment">// typename required</span></span><br></pre></td></tr></table></figure><p>上述的C不是嵌套从属类型名称，所以声明container时并不需要typename为签到，但C::iterator是个嵌套从属类型因此需要typename作为前置声明</p><blockquote><p>例外</p></blockquote><p>typename不能出现在base classes list内的嵌套从属类型名称之前，也不可以在member initalization list中作为base class修饰符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;<span class="comment">// base class list: typename not</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x)// base class identifier in mem.&#123;</span></span><br><span class="line">        <span class="comment">// init. list: typename not allowed</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;     <span class="comment">// use of nested dependent type</span></span><br><span class="line">        ...<span class="comment">// name not in a base class list or</span></span><br><span class="line">&#125;<span class="comment">// as a base class identifier in a </span></span><br><span class="line">...<span class="comment">// mem. init. list: typename required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>typename 与 typedef连用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>✦When declaring template parameters, class  and typename  are  inter-changeable.</p><p>✦Use typename  to  identify  nested  dependent  type  names,  except  inbase class lists or as a base class identifier in a member initializa-tion list</p><hr><h2 id="条款43-：学习处理模板化基类内的名称"><a href="#条款43-：学习处理模板化基类内的名称" class="headerlink" title="条款43 ：学习处理模板化基类内的名称"></a>条款43 ：学习处理模板化基类内的名称</h2><p><code>Know how to access names in templatized base classes</code></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>假设一个程序可以发送消息给不同公司，信息可以以密文或则明文的方式发送，用类模板这可以在编译期对公司进行选择</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...<span class="comment">// classes for other companies</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;<span class="comment">// class for holding information</span></span><br><span class="line"><span class="comment">// used to create a message</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        std::string msg;<span class="comment">//create msg from info;</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span><span class="comment">// similar to sendClear, except</span></span></span><br><span class="line"><span class="function">    </span>&#123; ... &#125;<span class="comment">// calls c.sendEncrypted</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>MsgSender类的调用不会用任何的问题</p><p>添加派生类LoggingMsgSender</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//write &quot;before sending&quot; info to the log;</span></span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// call base class function;</span></span><br><span class="line">                        <span class="comment">// this code will not compile!</span></span><br><span class="line">        <span class="comment">//write &quot;after sending&quot; info to the log;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:ice_cream: 这个派生类在新的一个non-virtual member函数中调用了父类的non-virtual member函数,这个函数解决了(条款33和条款36)non-virtual函数在派生类中出现的一系列问题，但是这个代码在不同的编译器是<strong>不能编译的</strong></p><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220518220901314.png" alt="image-20220518220901314"></p><blockquote><p>问题所在</p></blockquote><p>编译器遇到LoggingMsgSender的模板定义，不知道它是继承的那个类。</p><p>因为Company是一个模板参数，它是不确定的一个参数，只有当LoggingMsgSender被实例化后Company才会确定，因此在MsgSender&lt; Company &gt;的派生类中会出现无法确定继承的父类的问题。</p><p>更加明确的说是不知道Company中是否有sendClear这个函数</p><blockquote><p>模板全特化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123;<span class="comment">// this class offers no</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// sendCleartext function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// a total specialization of </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;<span class="comment">// MsgSender; the same as the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// general template, except </span></span><br><span class="line">    ...<span class="comment">// sendClear is omitted</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通用的MsgSender模板是不适用于CompanyZ的，因为模板提供的sendClear函数是对CompanyZ没有意义的。因此在仍然会出现上述问题，在Company中找不到sendClear的声明(因为CompanyZ的特例化没有定义sendClear函数)</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><blockquote><p>方案一:在base class函数调用动作之前加上this-&gt;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that// sendClear will be inherited</span></span><br><span class="line">        write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案二：使用using声明</p></blockquote><p>在条款33中找不到基类重载继承下来的隐藏的函数，是因为被派生类所隐藏</p><p>在本例中是编译器不搜索基类作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<span class="comment">// tell compilers to assume</span></span><br><span class="line">    ...<span class="comment">// that sendClear is in the// base class</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">            ...<span class="comment">// sendClear will be inherited</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案三：显式的指定你的函数位于base class中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">        ...<span class="comment">// sendClear will be </span></span><br><span class="line">    &#125;<span class="comment">// inherited</span></span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这是一个不太好的方法，因为被调用的是virtual函数会导致virtual函数的绑定行为被关闭</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>✦In  derived  class  templates,  refer  to  names  in  base  class  templatesvia  a  “this-&gt;”  prefix,  via using  declarations,  or  via  an  explicit  base class qualification.</p><hr><h2 id="条款44：将于参数无关的代码抽离templates"><a href="#条款44：将于参数无关的代码抽离templates" class="headerlink" title="条款44：将于参数无关的代码抽离templates"></a>条款44：将于参数无关的代码抽离templates</h2><p>Factor parameter -independent code out of templates</p><blockquote><p>不恰当的使用template可能会导致代码膨胀(code bloat):其二进制带着重复的代码、数据</p></blockquote><p>解决方法：当两个函数实现的实质相同</p><p>抽离两个函数中共同的部分，将他放入第三个函数中，然后将他们调用这个新函数。class也是同样的道理，使用继承或则复合</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>用固定尺寸的方阵编写一个template。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="comment">// template for n x n matrices of</span></span><br><span class="line">            std::<span class="type">size_t</span> n&gt;<span class="comment">// objects of type T; see below for info</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;<span class="comment">// on the size_t parameter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span></span>;<span class="comment">// invert the matrix in place</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的类型为size_t的参数是一个非类型参数(non-type parameter)。</p><p>对上述代码进行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>上述代码中，将会具现化两份invert函数，但这两份函数是完全相同，因为其中一个操作的5<em>5矩阵而另一个是10 </em>10的矩阵，除了常量5和10其他部分完全相同，这将是一个典型的代码膨胀示例</p><blockquote><p>解决方案一</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// size-independent base class for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;<span class="comment">// square matrices</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;<span class="comment">// invert matrix of the given size</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;<span class="comment">// make base class version of invert</span></span><br><span class="line">                                    <span class="comment">// visible in this class; see Items 33</span></span><br><span class="line">                                    <span class="comment">// and 43</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span> </span>&#123;<span class="built_in">invert</span>(n); &#125;<span class="comment">// make inline call to base class</span></span><br><span class="line">&#125;;<span class="comment">// version of invert</span></span><br></pre></td></tr></table></figure><p>上述解决方案中</p><p>在所有方阵实体中只会共享一个父类的invert实现，这样就有效的防止的代码膨胀</p><ul><li>避免derived class代码重复：父类使用了protect代替了public。注<code>在调用时会如果时public(实体对象仍然可以调用该接口)的话也同样会产生不同版本的代码</code></li><li>调用其代码的成本为0，因为derived classes的inverts调用base clas的版本是inline调用</li><li>this-&gt;调用表示模板化基类反之函数名称被隐盖</li><li>使用private的继承关系表现的是一种is-a关系</li></ul><p><strong>问题</strong>：在该方案中没有解决父类与子类之间联系的问题，因为在子类中需要带入矩阵的相关数据，因此需要加入一个指针或者引用。但是反复的传参，这样也会影响效率</p><blockquote><p>解决方案二：父类中存储一个指针，指向所在的内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T *pMem)<span class="comment">// store matrix size and a</span></span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123; &#125;<span class="comment">// ptr to matrix values</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">( T *ptr)</span> </span>&#123; pData = ptr; &#125;<span class="comment">// reassign pData</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;<span class="comment">// size of matrix</span></span><br><span class="line">    T *pData;<span class="comment">// pointer to matrix values</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="built_in">SquareMatrix</span>( )<span class="comment">// send matrix size and </span></span><br><span class="line">        : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123; &#125;<span class="comment">// data ptr to base class</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法在子类中调用了父类的构造函数，用来初始父类中的数据成员</p><p>当数据成员特别大的时候可以使用<strong>动态内存分配</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>( )<span class="comment">// set base class data ptr to null,</span></span><br><span class="line">        :   <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),<span class="comment">// allocate memory for matrixpData(new T[n*n])</span></span><br><span class="line">                                        <span class="comment">// values, save a ptr to the</span></span><br><span class="line">    &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>( )); &#125;<span class="comment">// memory, and give a copy of it</span></span><br><span class="line">    ...<span class="comment">// to the base classprivate:boost::scoped_array&lt;T&gt; pData;</span></span><br><span class="line">        <span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>✦Templates generate multiple classes and multiple functions, so anytemplate code not dependent on a template parameter causes bloat.</p><p>✦Bloat due to non-type template parameters can often be eliminatedby replacing template parameters with function parameters or classdata members.</p><p>✦Bloat due to type parameters can be reduced by sharing implemen-tations for instantiation types with identical binary representations.</p><hr><h2 id="条款45：使用成员函数template接受所有可以兼容的类型"><a href="#条款45：使用成员函数template接受所有可以兼容的类型" class="headerlink" title="条款45：使用成员函数template接受所有可以兼容的类型"></a>条款45：使用成员函数template接受所有可以兼容的类型</h2><p><code>Use member function template to accept “all compatible type”</code></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>行为像指针的对象，并提供指针没有的技能。STL容器几乎都是用到智能指针，但是我们不会使用“++”的运算符将一个内置的指针从link list的节点移动到另一个节点，所以需要用到迭代器</p><h3 id="真实指针-raw-pointer"><a href="#真实指针-raw-pointer" class="headerlink" title="真实指针(raw pointer)"></a>真实指针(raw pointer)</h3><p>支持隐式转换。例如：Derived class 指针可以隐式的转换为base class指针(提供多态的选择)，“指向non-const对象”的指针可以转为”const对象”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top *pt1 = <span class="keyword">new</span> Middle;<span class="comment">// convert Middle*⇒  Top*</span></span><br><span class="line">Top *pt2 = <span class="keyword">new</span> Bottom;<span class="comment">// convert Bottom*⇒  Top*</span></span><br><span class="line"><span class="type">const</span> Top *pct2 = pt1;<span class="comment">// convert Top*⇒  const Top*</span></span><br></pre></td></tr></table></figure><h3 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// smart pointers are typically</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">( T *realPtr)</span></span>;<span class="comment">// initialized by built-in pointers </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =<span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =<span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;<span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></span><br><span class="line">                            <span class="comment">//SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure><p>上述同一个template的不同具现体(instantiation)之间不存在继承关系，所以SmartPtr&lt; Top &gt;与SmartPtr&lt; Middle &gt;是完全不同的class</p><h3 id="Templates和泛型编程-Generic-Programming"><a href="#Templates和泛型编程-Generic-Programming" class="headerlink" title="Templates和泛型编程(Generic Programming)"></a>Templates和泛型编程(Generic Programming)</h3><blockquote><p>生产需求:自定义指针构造函数的编写</p></blockquote><p>当我们添加一个新继承关系的对象时，那没有添加转型的构造函数的情况下，就会反复的在SmartPtr中添加构造函数</p><p><code>class BelowBottom: public Bottom &#123; ... &#125;;</code></p><blockquote><p>member function tempaltes——泛化copy构造函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">// member template </span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);<span class="comment">// for a ”generalized</span></span><br><span class="line">    ...<span class="comment">// copy constructor”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中对于任意类型T与任意类型U，可以根据SmartPtr&lt; U &gt;生成一个SmartPtr&lt; T &gt;——因为SmartPtr&lt; T &gt;有个构造函数接受有个SmartPtr&lt; U &gt;参数。</p><p>泛化的copy构造函数并未被声明为explicit，因为原始指针之间(base class与derived class之间)的转换是隐式的转换，无需明白的写出转型动作(cast)</p><blockquote><p>提供原始资源的成员函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span><span class="comment">// initialize this held ptr: </span></span></span><br><span class="line"><span class="function">    <span class="title">heldPtr</span><span class="params">(other.get( ))</span> </span>&#123; ... &#125;<span class="comment">// with other’s held ptr</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// built-in pointer held</span></span><br><span class="line">    T*heldPtr;<span class="comment">// by the SmartPtr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用成员初始化列表来初始化SmartPtr&lt; T &gt;之内类型为T<em>的成员变量，并以类型为U</em>的指针作为初值。</p><p><code>member initialization templates</code>成员初始化列表的作用不限于构造函数，另一个作用是支持赋值操作</p><blockquote><p>摘录</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// construct from</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y * p)</span></span>;<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; <span class="comment">// built-in pointer,</span></span><br><span class="line">           <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// shared_ptr,</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// weak_ptr, or</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;<span class="comment">// auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp; r)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// assign from</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// shared_ptr or</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);<span class="comment">// auto_ptr...&#125;;</span></span><br></pre></td></tr></table></figure><p>上述所有构造函数都是explicit，唯有”泛化copy构造函数”除外，那么从<strong>某个shared_ptr类型隐式转为另一个shared_ptr</strong>是允许的，但是从某个内置指针或从其他智能指针进行隐式转换则是不允许的(显示的转换倒是可以)。</p><h3 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h3><p>✦Use member function templates to generate functions that accept allcompatible types.</p><p>✦If  you  declare  member  templates  for  generalized  copy  constructionor  generalized  assignment,  you’ll  still  need  to  declare  the  normalcopy constructor and copy assignment operator, too</p><hr><h2 id="条款46：需要类型转换是请为模板定义非成员函数"><a href="#条款46：需要类型转换是请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换是请为模板定义非成员函数"></a>条款46：需要类型转换是请为模板定义非成员函数</h2><p><code>Define non-member function inside templates when type conversion are desired</code></p><p>这个条款换个说法是：<strong>当我们需要进行模板函数参数类型需要隐式转换时，将模板函数定义为friend函数</strong></p><h3 id="示例：条款24的例子转为模板"><a href="#示例：条款24的例子转为模板" class="headerlink" title="示例：条款24的例子转为模板"></a>示例：条款24的例子转为模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// see Item28 for why returnconst </span></span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// values are still passed by value,</span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>进行以下混合式(mixed-mode)运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">// this example is from Item24,</span></span><br><span class="line">                            <span class="comment">// except Rational is now a template</span></span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;<span class="comment">// error! won’t compile</span></span><br></pre></td></tr></table></figure><p>出现以下问题：</p><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\2022-06-03-17-34-47-image.png" alt=""></p><blockquote><p>分析</p></blockquote><p>以上问题是因为没有找对应的operator * 操作符对应的函数，也就是推导失败。</p><p>以上代码中operator*这个non-member函数的两个参数进行隐式类型推导时出现了问题:</p><ul><li>第一个实参是onehalf，所以T一定是int，能够顺利的推导出</li><li>第二个实参是2，编译器无法将其推导为Rational&lt; int &gt;</li></ul><p>经过以上考虑，因该是将隐式转换类型转换函数出现调用失败的问题,无法将non-member函数指定为operator*</p><h3 id="friend函数声明"><a href="#friend函数声明" class="headerlink" title="friend函数声明"></a>friend函数声明</h3><p>template class中friend声明式可以指定特定的函数，Rational&lt; T &gt;可以声明operator<em>是<em>*class的一个friend函数</em></em></p><p>class template并不依赖template的<strong>实参推导</strong>，所以能够在class Rational&lt; T &gt;具现化时得知T,<strong>换句话说就是T的类型被确定后，就已经指定调用operator*函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">    <span class="keyword">friend</span><span class="comment">// declare operator*</span></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="comment">// function (see </span></span><br><span class="line">                             <span class="type">const</span> Rational&amp; rhs);<span class="comment">// below for details)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>此时混合式调用可以通过编译，当对象onehalf被声明为一个Rational&lt; int &gt;，class Rational&lt; int &gt;被具现化出来了。而作为过程的一部分，friend函数operator<em>(接受Rational&lt; int &gt; 参数)也就被<strong>自动声明出来</strong>。后者身为<em>*一个函而非函数模板</em></em>，因此编译器可以调用它时使用隐式转换函数。</p><p>上述friend函数同样可以声明为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\image-20220603221112025.png" alt="image-20220603221112025"></p><p>虽然经过修改我们能过通过编译，但是在链接时会出现上述问题了，因为friend函数只有一个声明式存在，并没有被定义，因此会导致连接器无法找到对应的实现</p><h3 id="函数本体与声明式结合-简单版"><a href="#函数本体与声明式结合-简单版" class="headerlink" title="函数本体与声明式结合(简单版)"></a>函数本体与声明式结合(简单版)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="friend特殊意义"><a href="#friend特殊意义" class="headerlink" title="friend特殊意义"></a>friend特殊意义</h3><p> 在本条款中虽然使用了friend却和它的<strong>传统意义</strong>不同(访问non-public成分)，但是在此的意义却是让类型转换发生于所有实参身上，我们需要一个<strong>non-member函数</strong>(条款24)；为了使这个函数<strong>自动具现化</strong>(隐式转换构造函数的指定)，我们需要将它<strong>声明在class内部</strong>；而在class内部声明non-member函数的唯一方法就是将其声明为<strong>friend函数</strong></p><h3 id="non-member与friend-member合作"><a href="#non-member与friend-member合作" class="headerlink" title="non-member与friend member合作"></a>non-member与friend member合作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(T numerator = <span class="number">0</span>,</span><br><span class="line">    T denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> d;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs,rhs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n;</span><br><span class="line">    T d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>✦When  writing  a  class  template  that  offers  functions  related  to  thetemplate  that  support  implicit  type  conversions  on  all  parameters,define those functions as friends inside the class template.</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FaRM</title>
      <link href="/2023/01/20/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/20/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="FaRM高性能分布式事务"><a href="#FaRM高性能分布式事务" class="headerlink" title="FaRM高性能分布式事务"></a>FaRM高性能分布式事务</h1><blockquote><p><strong>Title:</strong> No compromises: distributed transactions with consistency, availability, and performance</p></blockquote><h2 id="FaRM-Overview"><a href="#FaRM-Overview" class="headerlink" title="FaRM Overview"></a>FaRM Overview</h2><blockquote><p><strong>FaRM</strong> = Fast + Remote + Memory</p></blockquote><h3 id="为何要学习FaRM"><a href="#为何要学习FaRM" class="headerlink" title="为何要学习FaRM"></a>为何要学习FaRM</h3><ul><li><p>另一种对transactions+replication+sharding的实现：这仍然在研究领域，没有投入实际生产。</p></li><li><p>乐观并发控制OOC(stric serializability)</p></li><li><p>利用了了RDAM NICs的巨大性能潜力。</p></li></ul><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><ul><li><p>FaRM全部通讯都在一个数据中心</p><ul><li>与Spanner不同的是，Spanner全球性的广域的设计</li></ul></li><li><p>configuration manager：使用ZooKeeper, 选择主从复制 primaries/backups</p></li><li><p>Shards采用主从复制(只有在恢复的时候会进行通信)<br>  P1 B1<br>  P2 B2<br>  …</p><ul><li>只要至少有一个shard的副本就能恢复</li><li>f+1的副本就容忍f次的故障</li></ul></li><li><p>事务代码充当两阶段提交的事务协调器(TC)</p></li></ul><h3 id="FaRM目标"><a href="#FaRM目标" class="headerlink" title="FaRM目标"></a>FaRM目标</h3><ul><li>每秒完成百万数量级的事务<ul><li>时间的预算是几十微妙</li></ul></li></ul><h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><h3 id="如何高性能"><a href="#如何高性能" class="headerlink" title="如何高性能"></a>如何高性能</h3><ul><li><p>在多个服务器上进行分片(在评估中是90个)</p></li><li><p>数据必须符合总RAM(因此没有磁盘读取)</p></li><li><p>降低CPU的利用率 </p><ul><li>非易失性RAM(因此没有磁盘写入)</li><li>one-sided RDMA(快速跨网络访问内存)</li></ul></li><li><p>快速用户级访问网卡</p></li><li><p>事务+复制协议，利用单边RDMA</p></li></ul><h3 id="NVRAM-non-volatile-RAM"><a href="#NVRAM-non-volatile-RAM" class="headerlink" title="NVRAM (non-volatile RAM)"></a>NVRAM (non-volatile RAM)</h3><p>FaRM 直接写入RAM不需要写入磁盘 — eliminates a huge bottleneck</p><ul><li>RAM write takes 200 ns, hard drive write takes 10 ms, SSD write 100 us<ul><li>ns = nanosecond, ms = millisecond, us = microsecond<br>但是当我们在电源故障后将会使RAM的内容丢失，RAM不能持久化。因此我们使用了UPS。</li></ul></li></ul><h4 id="UPS-distributed-uninterruptible-power-supply"><a href="#UPS-distributed-uninterruptible-power-supply" class="headerlink" title="UPS(distributed uninterruptible power supply)"></a>UPS(distributed uninterruptible power supply)</h4><p>装备电池在每个机架上，当服务器发生断电时，可以再让运行机器几分钟。具体执行过程如下</p><ul><li><p>电源硬件通知软件当主电源断电，软件停止所有事务，软件将FaRM的RAM的数据写入到SSD，可能几分钟后机器就会关机。</p></li><li><p>在重新启动时，FaRM从SSD读取保存的内存映像“非易失性RAM”</p></li></ul><h4 id="如果奔溃阻止了软件写入SSD"><a href="#如果奔溃阻止了软件写入SSD" class="headerlink" title="如果奔溃阻止了软件写入SSD?"></a>如果奔溃阻止了软件写入SSD?</h4><p>例如FaRM或内核中的bug或者cpu/内存/硬件错误，FaRM处理单机崩溃和复制崩溃(除了电源故障)必须是独立的!因此崩溃不会阻止FaRm写入将RAM的数据写入SSD</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>NVRAM消除了持久写入瓶颈，剩下的瓶颈是网络和CPU</p><h3 id="降低CPU使用率-Reduce-CPU-Utilization"><a href="#降低CPU使用率-Reduce-CPU-Utilization" class="headerlink" title="降低CPU使用率(Reduce CPU Utilization)"></a>降低CPU使用率(Reduce CPU Utilization)</h3><h4 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h4><p>为什么网络在通常情况下会是性能瓶颈？</p><ul><li>FaRM假设只有一个数据中心，因此具有较低的光速延迟</li><li>但网络数据处理的CPU成本往往很大</li></ul><p>网络交互：<br>从应用中将数据写入socket的缓存中通过TCP封装，传递给网卡的硬件驱动，通过网卡进行发送。如下述例子所述<br>    app                               app</p><pre><code>---                                 ---socket buffers               buffersTCP                               TCPNIC driver                     driverNIC  -------------------- NIC</code></pre><p>大量昂贵的CPU操作如系统调用、复制信息、中断、上下文转换。这些都会成为FaRM的性能瓶颈</p><h4 id="Kernel-bypass"><a href="#Kernel-bypass" class="headerlink" title="Kernel bypass"></a>Kernel bypass</h4><blockquote><p>NIC直接访问内存</p></blockquote><p>FaRM应用直接与网卡交互，<strong>没有系统调用与内核参与</strong> </p><ul><li><p>网卡使用DMA访问用户的RAM</p></li><li><p>FaRM轮询DMA(内存)区域检查收入的消息</p><ul><li>NIC会维持一个接收消息的队列 </li></ul></li><li><p>网卡轮询DMA(内存)区域检查发送的消息</p><ul><li>NIC会维持一个发送消息的队列</li></ul></li><li><p>轮询是一个线程，用于代替系统中断，直接访问消息队列</p></li></ul><h4 id="one-sided-RDMA"><a href="#one-sided-RDMA" class="headerlink" title="one-sided RDMA"></a>one-sided RDMA</h4><blockquote><p>remote NIC directly reads/writes memory：宏观来讲就是直接访问另一台机器的内存且接收方CPU不参与操作</p></blockquote><p><strong>RDMA</strong>：是一些现代网卡实现的特殊功能。网卡寻找通过网络到达的特殊命令包，并自行执行命令(<strong>而不将包交给CPU</strong>)。这些命令指定内存操作，例如将值写入地址或从地址读取并通过网络将值发回。</p><p>此外，RDMA网卡允许应用程序代码直接与NIC通信以发送特殊的RDMA命令包，并在“<strong>硬件ACK</strong>”包到达时收到通知，表明接收网卡已经执行了命令。</p><ul><li><p>“One-sided” “指的是一台计算机中的应用程序代码使用这些RDMA网卡直接读取或写入另一台计算机中的内存，而<strong>不涉及另一台计算机的CPU</strong>。</p></li><li><p>FaRM有时使用RDMA作为一种快速方法来实现类似rpc的方案，以便与接收计算机上运行的软件进行通信。</p></li><li><p>RDMA的好处是速度快。单向RDMA读写只需1/18微秒，而传统RPC可能需要10微秒。即使FaRM使用RDMA进行消息传递也比传统RPC快得多:接收器中的用户空间代码经常<strong>轮询传入的NIC队列</strong>，以便快速查看新消息，而不是涉及中断和用户/内核转换。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM4.PNG" alt=""><br>该图表示了FaRM应用通过Kernel bypass + RDMA降低了CPU的利用率。NIC是一个特殊的网卡同时支持kernel bypass与RDMA。</p><ul><li><p>通过Kernel bypass发送消息将直接发送包到NIC不需要CPU参与</p></li><li><p>通过one-sided RDMA，接收方的接收处理包也不需要CPU的参与</p></li><li><p><strong>RDMA Read：</strong> “Validate”阶段仅使用one-sided读取。</p><ul><li>将请求对象的包(头部设置为RDMA包)，加入NIC的发送队列，传送到目的主机的接收队列，进行定时轮询内存区域，FaRM应用将对象的数据再通过NIC回复给请求主机</li></ul></li><li><p><strong>RDMA Write：</strong> “Lock”阶段以这种方式使用RDMA。(不需要加入NIC队列)</p><ul><li>发送方使用RDMA将请求消息写入接收方FaRM软件轮询(定期检查)的内存区域，将请求消息放入消息队列进行处理、Record写入Log，接收方以同样的方式发送应答。 </li></ul></li></ul><h2 id="编程模型与架构"><a href="#编程模型与架构" class="headerlink" title="编程模型与架构"></a>编程模型与架构</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM5.PNG" alt=""></p><h4 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h4><ul><li><p><strong>Region：</strong> 可以看作一个2GB的字节数组，其中包含了多个Object。同时Region也对应着(Pi,Bi)的映射</p></li><li><p><strong>Object：</strong> 一个数据结构，用于存储数据。object有唯一的一个标识符为oid，oid对应了Region号与地址，并且object的头部包含了一个64为的整数，高1位表示的是否Lock，低63位标识版本号</p></li><li><p><strong>Zookeeper：</strong> 作为FaRM的服务协调，提供一个Coordinator Management</p></li><li><p><strong>SSD：</strong> 断电时存储RAM内的数据</p></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Txn BEGIN</span><br><span class="line"></span><br><span class="line">O &lt;------ Read(oid)</span><br><span class="line"></span><br><span class="line">O.f + 1 = 1</span><br><span class="line"></span><br><span class="line">write(oid,O)</span><br><span class="line"></span><br><span class="line">Txn COMMIT</span><br></pre></td></tr></table></figure><p>该例子中我们使用了两个API为read与write。我们通过调用read方法填入oid(object id)从而实现了获得数据对象O，在O的字段上+1并缓存到本地，之后再调用write方法将对象写入。(一个事务可能跨多个Region)</p><h2 id="分布式事务与复制"><a href="#分布式事务与复制" class="headerlink" title="分布式事务与复制"></a>分布式事务与复制</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM1.png" alt=""></p><p>图中虚线为处理读取，实线是写入，点线是硬件回复。其中P1、P2是处理读写事务，P3是只读事务。C为Zookeeper中的Coordinator[[ZooKeeper 论文笔记]]、P为Primary、B为Backup。黑色的方块为对象(副本中只有一个Backup，因此该副本只有一个容错)</p><ul><li><p>Coordiantor获取LOCK消息最后一条Ack消息的点为序列化点</p></li><li><p>Coordiantor获取VALIDATE消息的最后一条ACK消息的点为Decision点，<strong>事务开始提交</strong></p></li><li><p>Coordiantor获取COMMIT-PRIMARY的第一条ACK消息为开始提交的报告给应用，<strong>事务提交结束</strong></p></li></ul><h3 id="执行阶段-Execute-phase"><a href="#执行阶段-Execute-phase" class="headerlink" title="执行阶段(Execute phase)"></a>执行阶段(Execute phase)</h3><p>Coordinator进行操作</p><ul><li><p>one-sided RDMA对Primary进行读取(OCC)</p></li><li><p>将修改对象的内容缓存到本地</p></li><li><p>记录这些primary的<strong>地址</strong>以及读取并记录到的数据的<strong>版本号</strong>。</p><ul><li>如果Primary与backup与coordinator位于同一台机器上就不会使用RDMA进行读，而是使用本地内存进行访问(读取操作)</li></ul></li></ul><p>在Figure4中该阶段读取了三个分片，为S1，S2，S3</p><h3 id="提交阶段-Commit-phase"><a href="#提交阶段-Commit-phase" class="headerlink" title="提交阶段(Commit phase)"></a>提交阶段(Commit phase)</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li><p>原子性的分布式提交：全部写入或都没写入</p></li><li><p>序列化：每个事务都有先后顺序</p></li></ul><h4 id="五个步骤"><a href="#五个步骤" class="headerlink" title="五个步骤"></a>五个步骤</h4><ol><li><strong>Lock(写入日志).</strong> Coordinator通过<strong>RDMA Write</strong>发送一条Lock消息给每台读取对象的primary的日志中</li></ol><ul><li><p>Lock记录包含了这包含了oid、版本号和写对象的新值</p></li><li><p>Lock消息既是预读日志条目(Read-ahead log)，也是对主服务器的RPC请求。</p></li><li><p>日志将被加入到NVRAM中防止断电或者电源故障</p></li></ul><p><strong>收到LOCK后primary会做什么</strong>?</p><ul><li><p>FaRM软件轮询内存中的日志, 发现写入的日志</p><ul><li>检查日志，如果对象已经加锁了或者写入的对象的版本号与读取的不相同<ul><li>发送一个no的回复给coordinator</li></ul></li></ul></li><li><p>反之，将对象的Lock flag设置为1，回复一个yes给coordinator</p><ul><li><strong>并不会修改对象</strong>，也不会修改对象的版本号</li></ul></li><li><p>lock检查-&gt;版本号检查-&gt;lock的设置是原子性</p><ol><li>使用原子性的compare-and-swap指令将对象锁定在指定版本</li><li>防止其他CPU也在处理LOCK，或者客户端正在用RDMA读取</li></ol></li></ul><ol><li><strong>Validate(检查读取对象).</strong> Coordinator使用one-sided RDMA发送Validate消息给读取对象的primary，该消息只包含了oid以及版本号，执行读取验证(read Validate)。</li></ol><p><strong>Priamry处理</strong></p><p>检查Validate的版本号与primary内存中的版本号以及对象是否上锁</p><ul><li><p>如果冲突，则验证失败，发送no给coordinator，事务将会终止。</p></li><li><p>如果相同，则验证相同，发送yes给coordinator。</p></li><li><p>Validate默认使用的是one-side RDMA。</p></li></ul><ol><li><p><strong>Commit backups.(副本写入日志)</strong> Coordiantor写入一个COMMIT-BACKUP的记录(与Lock内容相同)到Backups的不易失的日志中，并等待不会让CPU中断的NIC硬件返送ACK消息。</p></li><li><p><strong>Commit primaries(处理日志).</strong> coordinator在接受到所有COMMIT-BACKUP的ACK消息后，Coordinator发送COMMIT-PRIMARY消息给每一台Primary中。</p></li></ol><ul><li>coordinator会等待硬件的ACK应答<ul><li>不会等待Primary处理日志</li><li>硬件应答意味着Primary的NVRAM很安全</li></ul></li></ul><p><strong>Primary处理日志</strong></p><ul><li><p>将新值拷贝到对象的内存中</p></li><li><p><strong>增加对象的版本号</strong></p></li><li><p>清除对象的lock flag，设置为0</p></li></ul><hr><ol><li><strong>Truncate.</strong> Primary与Backup中的日志会一直保存直到被截断。Coordinator接收到所有Primary的ACK后，将会阶段Primay与Backup的日志</li></ol><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><p>Q：为什么发现锁已经被其他锁占用后是中止而不是等待解除阻塞</p><p>A：Figure4中是读写事务，发现锁被其他事务占用说明我们读操作读取的数据的就已经被修改了，因此会破坏Strict Serializability，产生错误。</p><p>Q：Primary与Backup是主从复制，那为什么他们不直接通讯？</p><p>A：应用的设计是这样的，他们的一致性是由CM来保证(Lock与commit Backup消息内容相同)。只有在崩溃恢复时Primary与Backup会进行沟通。</p><p>Q：下述案例中，T2在T1完成Lock与Validate后，在T1提交前提交，这样会有什么样的错误(T1的validate阶段读取了T2修改的版本号)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1: Wx0 Wy0 Rz0 .....   L V .... C</span><br><span class="line"></span><br><span class="line">T2:             Rz0 Wz1 ... C</span><br></pre></td></tr></table></figure><p>A：T1 &lt; T2 ，T2在T1之后开始，因此根据严格序列化规则：T2必须看见T1的写入，因此根据该规则，T2的读也需要在T1提交之后才能执行。意思也就是T2比T1提前提交这种情况也是不会出现的。</p><h4 id="Log-Record-type"><a href="#Log-Record-type" class="headerlink" title="Log Record type"></a>Log Record type</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Log record type</th><th style="text-align:center">Content</th></tr></thead><tbody><tr><td style="text-align:center">LOCK</td><td style="text-align:center">transaction ID, IDs of all regions with objects written by the transaction, and addresses, versions, and values of all objects written by the transaction that the destination is primary for</td></tr><tr><td style="text-align:center">COMMIT-BACKUP</td><td style="text-align:center">contents are the same as lock record</td></tr><tr><td style="text-align:center">COMMIT-PRIMARY</td><td style="text-align:center">transaction ID to commit</td></tr><tr><td style="text-align:center">ABORT</td><td style="text-align:center">transaction ID to abort</td></tr><tr><td style="text-align:center">TRUNCATE</td><td style="text-align:center">low bound transaction ID for non-truncated transactions and transaction IDs to truncate</td></tr><tr><td style="text-align:center">表中展示了每条日志信息的类型以及对应的内容</td></tr></tbody></table></div><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><h4 id="乐观并发控制-OCC"><a href="#乐观并发控制-OCC" class="headerlink" title="乐观并发控制(OCC)"></a>乐观并发控制(OCC)</h4><blockquote><p><strong>OCC</strong>  = Serializability  + Snapshot isolation(MVCC)</p></blockquote><p> 对于读写事务中对于<strong>读操作是不需要加锁的</strong>，而写操作仍是需要加锁。读操作是通过Strict Serializaiblility来实现一致性。</p><p><strong>严格的序列化：</strong> 序列化点总是在开始执行和向应用程序报告完成之间(Figure4)</p><p>对于读操作我们在提交阶段加上了冲突检测版本号</p><ul><li>版本号冲突(写对象有锁或是版本号改变)的话事务中止(abort)</li><li>版本号相同则进行提交(commit)</li></ul><p>FaRM使用OCC的原因：</p><ul><li>使用了one-sided RDMA读取</li><li>服务器(CPU)不需要主动参与读取</li></ul><h4 id="Validate的作用"><a href="#Validate的作用" class="headerlink" title="Validate的作用"></a>Validate的作用</h4><p>当我们处理两事务：假设开始时X=0，y=0</p><ul><li>T1：if x == 0 ，set y = 1</li><li>T2：if y == 0 ，set x = 1</li></ul><p>我们假设可能产生的结果:绝不可能并发执行时产生x=1，y=1</p><ul><li>T1产生：x = 0 ，y = 1</li><li>T2产生：x = 1 ，y = 0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   excution   commit</span><br><span class="line">T1 Rx0 Ry0  | Ly Vx            Cy</span><br><span class="line"></span><br><span class="line">T2 Rx0 Ry0  |       Lx Vy(fail)   Cx</span><br></pre></td></tr></table></figure><p>当我们并发执行T1与T2：T1的x与T2的y都可以上锁</p><ol><li>首先T1先开始提交，将y上锁(不会增加对象版本号)，验证x；</li><li>然后T2开始提交，将x上锁，验证y，但是由于y已经上锁(说明y可能已经别其他对象修改)，因此需要中止T2事务</li></ol><h4 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h4><p>一个纯只读的FaRM事务只使用使用one-sided RDMA read：不需要写入、不需要日志、不需要锁。速率十分的快。(个人觉得不需要validate阶段像spanner的只读事务一样)</p><h4 id="提交时机"><a href="#提交时机" class="headerlink" title="提交时机"></a>提交时机</h4><ul><li>在<strong>最后一次读取</strong>后提交只读事务</li></ul><ul><li><p>在获取写锁时提交读写事务是<strong>可序列化的</strong></p><ul><li>在可序列化的点上的对象的版本号与执行阶段的相同</li></ul></li><li><p>Locking确定对象被写入，Validate确定对象为只读</p><ul><li>如果没有失败，这就相当于在<strong>序列化点原子地</strong>执行和提交整个事务。 </li></ul></li></ul><h4 id="提交协议"><a href="#提交协议" class="headerlink" title="提交协议"></a>提交协议</h4><ul><li><p><strong>传统两段提交协议：</strong> Participant可以在处理prepare消息时预留资源以提交事务，或者在没有足够的资源时拒绝准备事务。</p></li><li><p><strong>FaRM的提交协议：</strong></p><ul><li>在提交过程中避免Backup的CPU参加，Coordinator必须为所有参与者保留日志空间，以保证进度。</li><li>Coordinator为所有提交协议记录预留空间，包括在开始提交协议之前截断主日志和备份日志中的记录。<ul><li>如果截断被附加在另一条消息上，截断记录保留也会被释放 </li></ul></li></ul></li></ul><h2 id="Spanner-与-FaRM"><a href="#Spanner-与-FaRM" class="headerlink" title="Spanner 与 FaRM"></a>Spanner 与 FaRM</h2><h3 id="共同之处"><a href="#共同之处" class="headerlink" title="共同之处"></a>共同之处</h3><p>都是关于分片、复制和使用了事务的二段提交(2PC)</p><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><h4 id="Spanner"><a href="#Spanner" class="headerlink" title="Spanner:"></a>Spanner:</h4><ul><li><p>重点讨论由于地理复制而引起的网络延迟</p></li><li><p>Paxos提供容错延迟</p></li><li><p>TrueTime 让客户端读取当地的副本</p></li><li><p>性能方面: 读写事务处理花费10到100 ms (Tables 3 and 6)</p></li></ul><h4 id="FaRM"><a href="#FaRM" class="headerlink" title="FaRM"></a>FaRM</h4><ul><li><p>重点讨论减少CPU的利用率</p></li><li><p>RDMA、直接NIC获取、NVRAM去避免磁盘写入</p></li><li><p>RDMA让FaRM可以使用OCC</p></li><li><p>性能方面: 58微秒的时间处理简单的事务 (6.3, Figure 7)</p><ul><li>i.e. 比Spanner快100倍</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>超快速度的分布式事务</p></li><li><p>硬件是还处于研究阶段(NVRAM和RDMA)，但可能很快就会普及</p></li><li><p>使用OCC提高速度并允许快速One-sided RDMA读取</p></li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><h4 id="Q-目前使用FaRM的系统有哪些"><a href="#Q-目前使用FaRM的系统有哪些" class="headerlink" title="Q: 目前使用FaRM的系统有哪些?"></a>Q: 目前使用FaRM的系统有哪些?</h4><p>A: FaRM似乎是一个研究系统，而不是用于生产。我怀疑它会影响未来的设计，也许它本身会发展成一个生产系统。</p><h4 id="Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密"><a href="#Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密" class="headerlink" title="Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?"></a>Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?</h4><p>A: 这些公司发表的论文只涉及他们所编写软件的一小部分。他们发表文章的原因之一是，这些系统部分是由具有学术背景的人(即拥有博士学位的人)开发的，这些人认为他们人生的一部分使命是帮助世界理解他们发明的新思想。他们为自己的工作感到自豪，希望人们能欣赏他们的工作。另一个原因是，这些论文可能有助于公司吸引顶尖人才，因为这些论文是如何在那里进行智力上有趣的工作的。</p><h4 id="Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗"><a href="#Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗" class="headerlink" title="Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?"></a>Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?</h4><p>A: 论文的这一部分看起来更像是广告而不是科学。历史表明，没有哪个绩效水平高到没有人会想要更高的，而那些人很可能愿意在其他方面做出妥协，以获得他们所需的绩效。</p><h4 id="Q-FaRM的局限性是什么"><a href="#Q-FaRM的局限性是什么" class="headerlink" title="Q: FaRM的局限性是什么?"></a>Q: FaRM的局限性是什么?</h4><p>A: 数据必须符合RAM。如果事务冲突很多，OCC将产生大量中止。事务API(在他们的NSDI 2014论文中描述)看起来使用起来很尴尬，因为回复在回调中返回。应用程序代码必须紧密交织执行应用程序事务和轮询RDMA NIC队列和日志来自其他计算机的消息。应用程序代码在执行最终会中止的事务时可以看到不一致。应用程序可能不能为自己的目的免费使用线程，因为FaRM将线程固定到核心，并使用所有核心。FaRM需要特殊的网络硬件，但尚未广泛部署。只有当所有的计算机彼此靠近时，这种设计才有意义;它不是地理分布的秘方(因此容错能力有限)。当然，FaRM是一个旨在探索新想法的研究原型。它不是一般用途的成品。如果人们继续从事这项工作，我们最终可能会看到FaRM的后代没有那么多粗糙的地方。</p><h4 id="Q-为什么FaRM基于RDMA的RPC比传统RPC更快"><a href="#Q-为什么FaRM基于RDMA的RPC比传统RPC更快" class="headerlink" title="Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?"></a>Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?</h4><p>A: 传统RPC要求应用程序对本地内核进行系统调用，内核要求本地NIC发送一个数据包。在接收计算机上，NIC将数据包写入内存中的队列，并中断接收计算机的内核。内核将数据包复制到用户空间，然后上下文切换到接收应用程序。接收应用程序反向发送应答(系统调用内核，内核与NIC通话，另一端的NIC中断内核，等等)。这一点是为每个RPC执行大量的代码，而且速度不是很快。</p><p>相反，FaRM安排应用程序代码可以直接读写内存以与NIC通信，并将CPU内核(本文称之为硬件线程)专门用于轮询传入消息。这消除了中断、系统调用、在用户和内核之间复制数据以及上下文切换的成本。</p><h4 id="Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献"><a href="#Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献" class="headerlink" title="Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?"></a>Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?</h4><p>A: FaRM速度快的一个原因是硬件速度快。但是硬件已经存在了很多年了，但是还没有人知道如何将所有的部件组合在一起，从而真正发挥硬件的潜力。FaRM做得这么好的一个原因是他们同时投入了大量的精力来优化网络、持久存储和CPU的使用;许多以前的系统只优化了一个，而不是全部。一个特定的设计点是FaRM对许多交互使用快速单边RDMA(而不是较慢的完整RPC)的方式。</p><h4 id="Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储"><a href="#Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储" class="headerlink" title="Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?"></a>Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?</h4><p>A: 这种想法是古老的;例如，Harp复制文件服务在20世纪90年代早期就使用了它。许多存储系统以相关的方式使用电池(例如在RAID控制器中)来持续写入而不等待磁盘。然而，FaRM使用的这种电池设置并不是特别常见，所以必须通用的软件不能依赖它。如果您将自己的硬件配置为有电池，那么修改Raft(或k/v服务器)以利用电池是有意义的。</p><h4 id="Q-如果没有电池支持的RAM-FaRM的设计还有意义吗"><a href="#Q-如果没有电池支持的RAM-FaRM的设计还有意义吗" class="headerlink" title="Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?"></a>Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?</h4><p>A: 我不确定FaRM在没有非易失性RAM的情况下是否有意义，因为这样单方面的日志写入(例如图4中的COMMIT-BACKUP)就不会在电源故障时持续存在。您可以修改FaRM，以便在返回之前将所有日志更新写入SSD，但这样会大大降低性能。SSD写入大约需要100微秒，而FaRM的单边RDMA写入非易失性RAM只需要几微秒。</p><h4 id="Q-DRAM本身不是不稳定的吗"><a href="#Q-DRAM本身不是不稳定的吗" class="headerlink" title="Q: DRAM本身不是不稳定的吗?"></a>Q: DRAM本身不是不稳定的吗?</h4><p>A: 作者通过使用UPS使RAM“非易失性”，允许FaRM在电源故障时将RAM的内容写入SSD。但是，这确实不是完全非易失性的，因为如果计算机由于任何其他原因而崩溃，而不是电源故障，那么故障机器的内存内容就会丢失。这就是为什么他们在多台机器上复制每个区域，并具有快速恢复协议的原因。</p><h4 id="Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗"><a href="#Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗" class="headerlink" title="Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?"></a>Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?</h4><p>A: 他们使用ssd是因为它们速度快。他们本可以在不改变设计的情况下使用硬盘驱动器。然而，在断电期间将数据写入磁盘将花费大约10倍的时间，在恢复供电后将数据读入磁盘将花费大约10倍的时间。这需要更大的电池和更大的耐心。</p><h4 id="Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色"><a href="#Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色" class="headerlink" title="Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?"></a>Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?</h4><p>A: 数据在许多主/备份集之间进行分片。备份的目的是存储碎片数据和日志的副本，以防主服务器出现故障。主数据中心<strong>执行对分片中数据的所有读写操作</strong>，而备份数据中心<strong>只执行写操作</strong>(以保持它们的数据副本与主数据中心的副本相同)。只有一个配置管理器。它跟踪哪些主备份处于活动状态，并跟踪数据如何在它们之间进行分片。在较高的级别上，这种安排类似于GFS，后者也在许多主/备份集之间对数据进行分片，并且也有一个主系统来跟踪数据的存储位置。</p><h4 id="Q-FaRM在小范围内可行吗"><a href="#Q-FaRM在小范围内可行吗" class="headerlink" title="Q: FaRM在小范围内可行吗?"></a>Q: FaRM在小范围内可行吗?</h4><p>A: 我认为FaRM只有在需要每秒支持大量事务时才有意义。如果您只需要每秒处理几千个事务，您可以使用现成的成熟技术，如MySQL。您可以设置一个比作者的90台机器系统小得多的FaRM系统。但是FaRM没有意义，除非你是在分片和复制数据，这意味着你至少需要四个数据服务器(两个分片，每个分片两个服务器)和一些用于ZooKeeper的机器(尽管你可能可以在这四台机器上运行ZooKeeper)。然后，也许你有一个成本约为10,000美元的系统，每秒可以执行数百万个简单交易，这是非常好的。</p><h4 id="Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的"><a href="#Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的" class="headerlink" title="Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!"></a>Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!</h4><p>A:Farm仅保证提交的事务的可序列化性。如果事务看到了第3节所讨论的那种不一致，FaRM将中止事务。应用程序必须处理不一致，因为它们不应该崩溃，这样它们就可以请求提交，这样FaRM就可以中止它们。</p><h4 id="Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么"><a href="#Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么" class="headerlink" title="Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?"></a>Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?</h4><p>A: 这里有两个危险。首先，对于一个大对象，读取器可能会在并发事务写入它之前读取对象的前半部分，而在并发事务写入它之后读取后半部分，这可能会导致读取程序崩溃。其次，如果读事务不能与并发写事务串行化，则不允许提交它。</p><p>根据我对作者之前的NSDI 2014论文的阅读，第一个问题的解决方案是每个对象的每个缓存行都有一个版本号，单缓存行RDMA读写是原子的。读取事务的FaRM库获取对象的所有缓存行，然后检查它们是否都具有相同的版本号。如果是，标准库将对象的副本提供给应用程序;如果没有，库将通过RDMA再次读取它。第二个问题是由FaRM在第4节中描述的验证方案解决的。在VALIDATE步骤中，如果自我们的事务启动以来，另一个事务写入了由我们的事务读取的对象，那么我们的事务将被中止。</p><h4 id="Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗"><a href="#Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗" class="headerlink" title="Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?"></a>Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?</h4><p>A: 在TC看到主服务器和备份服务器的日志中都有一个COMMIT-PRIMARY或COMMIT-BACKUP后，TC告诉主服务器和备份服务器删除事务的日志条目。为了使恢复知道尽管截断了事务，但事务还是完成了，第62页提到，即使在截断之后，primary也会记住已完成的事务id。截断意味着删除截断点之前的所有日志条目;这是因为每个主/备份在每个TC上都有一个单独的日志。</p><h4 id="Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障"><a href="#Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障" class="headerlink" title="Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?"></a>Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?</h4><p>A: 我想是的。如果其中一个备份没有响应，并且TC崩溃，那么事务可能会在恢复期间中止。</p><h4 id="Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗"><a href="#Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗" class="headerlink" title="Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?"></a>Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?</h4><p>A:当多个事务同时修改同一个对象时，其中一些事务将在图4的LOCK阶段看到锁已经被持有。在VALIDATE阶段，读者可能会看到更改的版本或锁定标志。每个这样的事务都将中止并从头开始重新启动。如果这种情况经常发生，业绩确实会受到影响。“乐观并发控制”中的“乐观”指的是希望这样的冲突将很少发生，并且执行无锁读取的能力将产生高性能。事实上，对于作者测量的应用程序，FaRM获得了出色的性能。一个很可能的原因是，它们的应用程序具有相对较少的冲突事务，因此没有太多中止。</p><h4 id="Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢"><a href="#Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢" class="headerlink" title="Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?"></a>Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?</h4><p>A: 我怀疑服务器的极限是总共每秒只能处理大约1.4亿次操作。如果客户端发送操作的速度比这快，其中一些将不得不等待;这种等待会增加延迟。</p><h4 id="Q-什么是vertical-Paxos"><a href="#Q-什么是vertical-Paxos" class="headerlink" title="Q:什么是vertical Paxos?"></a>Q:什么是vertical Paxos?</h4><p>A: 它是Paxos协议的一种风格，其中外部主服务器执行重新配置，而Paxos组在进行重新配置时可以继续执行操作 (see <a href="https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf">https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf</a> for the details). 在FaRM论文中，作者使用术语“垂直Paxos”来松散地表示配置管理是由外部服务(Zookeeper和CM)完成的，事务的处理写是通过标准的主/备份协议完成的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-2015.pdf">FaRM论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-faq.txt">FaRM FQA</a></li><li><a href="https://pdos.csail.mit.edu/6.824/notes/l-farm.txt">FaRM Lecture</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> FaRM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVRaft</title>
      <link href="/2023/01/13/KVRaft/"/>
      <url>/2023/01/13/KVRaft/</url>
      
        <content type="html"><![CDATA[<p>lab3 的内容是要在 lab2 的基础上实现一个高可用的 KV 存储服务，算是要将 raft 真正的用起来。相关协调服务可以参考OngaroPhD.pdf的作者的博士论文或者是ZooKeeper 论文笔记的协调服务,另外Chain Replicate 论文笔记的设计中同样满足了高性能读的服务</p><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="Client创建"><a href="#Client创建" class="headerlink" title="Client创建"></a>Client创建</h3><p>创建client自动生成ID号(使用nrand()函数生成)用于Session来记录lastRequest的回复,用LeaderID快速连接server，减少重试leader时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">    ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">    ck.servers = servers</span><br><span class="line">    <span class="comment">// You&#x27;ll have to add code here.</span></span><br><span class="line">    ck.LeaderId = <span class="number">0</span></span><br><span class="line">    ck.ClientId = nrand()</span><br><span class="line">    ck.CommandId = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetryToLeader()</strong> ：重连leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> RetryToLeader() &#123;</span><br><span class="line">  oneRound := <span class="number">0</span></span><br><span class="line">  args := &amp;GetArgs&#123;Key: <span class="string">&quot;&quot;</span>, ClientId: ck.ClientId, CommandId: ck.CommandId&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">      oneRound++</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      reply.Err = <span class="string">&quot;&quot;</span></span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line"><span class="comment">//在分区后client可能无法连接到该失联分区的server，发送失败则更换server进行连接</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line"></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          <span class="keyword">if</span> oneRound == <span class="built_in">len</span>(ck.servers) &#123;</span><br><span class="line">              oneRound = <span class="number">0</span></span><br><span class="line">              time.Sleep(<span class="number">700</span> * time.Millisecond)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client发送读写"><a href="#Client发送读写" class="headerlink" title="Client发送读写"></a>Client发送读写</h3><h4 id="读操作-Get"><a href="#读操作-Get" class="headerlink" title="读操作:Get()"></a>读操作:Get()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  ck.CommandId++</span><br><span class="line">  args := &amp;GetArgs&#123;</span><br><span class="line">      Key:       key,</span><br><span class="line">      CommandId: ck.CommandId,</span><br><span class="line">      ClientId:  ck.ClientId,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You will have to modify this function.</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line">          <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">          ck.RetryToLeader()</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == ErrNoKey &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">          <span class="keyword">return</span> reply.Value</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写操作-PutAppend"><a href="#写操作-PutAppend" class="headerlink" title="写操作:PutAppend()"></a>写操作:PutAppend()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">    ck.CommandId++</span><br><span class="line">    args := &amp;PutAppendArgs&#123;</span><br><span class="line">        Key:       key,</span><br><span class="line">        Value:     value,</span><br><span class="line">        Op:        op,</span><br><span class="line">        CommandId: ck.CommandId,</span><br><span class="line">        ClientId:  ck.ClientId,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">for</span> !ok &#123;</span><br><span class="line">            <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">            ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.RetryToLeader()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="创建服务器-StartKVServer"><a href="#创建服务器-StartKVServer" class="headerlink" title="创建服务器:StartKVServer():"></a>创建服务器:StartKVServer():</h3><ul><li><strong>服务器数据结构</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    rf      *raft.Raft</span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    servers     <span class="type">int</span></span><br><span class="line">    lastapplied <span class="type">int</span></span><br><span class="line">    Term        <span class="type">int</span></span><br><span class="line">    sm          KVStateMachine</span><br><span class="line">    Session     <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond       <span class="comment">// （clientId, lastRespond）record last command&#x27;s id ,respond</span></span><br><span class="line">    NotifyChans <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond <span class="comment">// (client , Chan Respond) ansynchoron to notif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read only check whether all log are applied</span></span><br><span class="line">    isRecovery <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建kv-server 与 下层raft进行交互,到达共识提高容错</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">    labgob.Register(Op&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    kv := <span class="built_in">new</span>(KVServer)</span><br><span class="line">    kv.me = me</span><br><span class="line">    kv.maxraftstate = maxraftstate</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">    <span class="comment">//creat raft layer</span></span><br><span class="line">    kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.lastapplied = kv.rf.GetFirstLogEntry().Index</span><br><span class="line">    kv.Term = <span class="number">0</span></span><br><span class="line">    kv.sm.mkv = NewMemoryKV()</span><br><span class="line">    kv.Session = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]LastRespond)</span><br><span class="line">    kv.NotifyChans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond)</span><br><span class="line">    kv.servers = <span class="built_in">len</span>(servers)</span><br><span class="line">    <span class="comment">//handle with recovery</span></span><br><span class="line">    kv.isRecovery = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    kv.recovery()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> kv.applier()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateMachine的内存模型："><a href="#StateMachine的内存模型：" class="headerlink" title="StateMachine的内存模型："></a>StateMachine的内存模型：</h3><blockquote><p>主要是创建一个kv-table，以一种内存模型的方式进行记录client端发来的修改信息,后续用于生成快照</p></blockquote><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mkv *MemoryKV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemoryKV <span class="keyword">struct</span> &#123;<span class="comment">//键值表的定义</span></span><br><span class="line">    KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemoryKV</span><span class="params">()</span></span> *MemoryKV &#123;<span class="comment">//申请堆内存</span></span><br><span class="line">    <span class="keyword">return</span> &amp;MemoryKV&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kv-table的内存模型的接口："><a href="#kv-table的内存模型的接口：" class="headerlink" title="kv-table的内存模型的接口："></a>kv-table的内存模型的接口：</h4><ul><li><strong>Append()  Put() Get()</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mkv.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mkv.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mkv.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mkv.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkv.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用日志操作到状态机"><a href="#应用日志操作到状态机" class="headerlink" title="应用日志操作到状态机"></a>应用日志操作到状态机</h4><p> 处理request信息并记录其respond:将ApplyCh中的op msg应用至kvserver状态机中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *KVStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = sm.mkv.KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Append(op.Key, op.Value)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Put(op.Key, op.Value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><ol><li><p>使用<strong>NotifyChans</strong>去通知处理request的接口，raft的op以及apply，以channel的方式进行异步的处理</p></li><li><p>用<strong>Session</strong>记录(clientID,LastRespond)，将每个client的request的响应消息进行记录，用于防止client retry多次将命令应用于state machine，以及快速响应</p></li></ol><p><strong>applier()</strong>:异步的接收raft层apply channel所传递上来的消息</p><ol><li><p><strong>防止日志回滚</strong> msg.CommandIndex &lt;= kv.lastapplied</p></li><li><p><strong>处理duplicate消息</strong> </p></li><li><p><strong>Apply</strong> 将apply的消息应用到状态机中</p></li><li><p><strong>回复客户端</strong> leader需要通过<strong>NotifyChan</strong>将状态机<strong>应用命令后回复的消息</strong>传递给该消息所调用的Put/Get,从而回复给Client,leader只能通知当前周期的命令,非当前周期的命令没有接收者从而导致阻塞</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">//avoid log rollback</span></span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> msg.CommandIndex &lt;= kv.lastapplied &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d discard outdate msg&quot;</span>, kv.me)</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            kv.lastapplied = msg.CommandIndex</span><br><span class="line">            <span class="keyword">var</span> respond CommandRespond</span><br><span class="line">            op := msg.Command.(Op)</span><br><span class="line">            <span class="comment">//apply msg -&gt; kv machine</span></span><br><span class="line">            <span class="keyword">if</span> kv.isRedundantRequest(op.ClientId, op.CommandId) &#123;</span><br><span class="line">                respond = kv.Session[op.ClientId].Respond</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                respond = kv.sm.ApplyToStateMachine(op)</span><br><span class="line">                _, isLeader := kv.rf.GetState()</span><br><span class="line">                <span class="keyword">if</span> isLeader &amp;&amp; op.opt != <span class="string">&quot;Get&quot;</span> &#123;</span><br><span class="line">                    kv.Session[op.ClientId] = LastRespond&#123;op.CommandId, respond&#125;</span><br><span class="line">                    DPrintf(<span class="string">&quot;S%d -&gt; C%d LastRequest type:%v K:%v V:%v CmdId:%d CMI:%d T:%d&quot;</span>,</span><br><span class="line">                        kv.me, op.ClientId%<span class="number">50</span>, op.Opt, op.Key, op.Value,</span><br><span class="line">                            op.CommandId, msg.CommandIndex, op.CommandTerm)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentTerm, isLeader := kv.rf.GetState(); isLeader &amp;&amp;</span><br><span class="line">                currentTerm == op.CommandTerm &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d Notify%v to C%d index %d&quot;</span>, kv.me, respond,</span><br><span class="line">                    op.ClientId%<span class="number">50</span>, msg.CommandIndex)</span><br><span class="line">                ch := kv.GetNotifyChan(msg.CommandIndex)</span><br><span class="line">                ch &lt;- respond</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作:"></a>读写操作:</h4><blockquote><p>读写操作需要满足线性一致性:[[ZooKeeper 论文笔记#线性一致性：Linearizability]]</p></blockquote><ul><li><p><strong>PutAppend()</strong>:处理client的修改请求</p><ol><li><p>Client请求该方法</p></li><li><p>冗余检测</p></li><li><p>调用Start将Command传递到下层达到共识</p></li><li><p>创建Notifychan等待applier将response消息push</p></li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        reply.Err = err</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d PutAppend request is redundant(PA)&quot;</span>, args.ClientId%<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       args.Op,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        Value:     args.Value,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d PutAppendRequest CmdId %d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err = cr.Err</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeOut</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Get()</strong>:将read操作记录至log，主要是防止分区时向minority partition的leader请求返回stale data导致线性不一致，<strong>缺陷</strong>：将read操作同步会导致浪费磁盘空间以及同步写入read log的时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="comment">//DPrintf(&quot;S%d is not KVLeader cmdID%d&quot;, kv.me, args.CommandId)</span></span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        value := kv.Session[args.ClientId].respond.Value</span><br><span class="line">        reply.Err, reply.Value = err, value</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d Get request is redundant(Get) cmdId %d&quot;</span>, args.ClientId%<span class="number">5</span>, args.CommandId)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       <span class="string">&quot;Get&quot;</span>,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d GetRequest LI:%d CmdId:%d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, index, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err, reply.Value = cr.Err, cr.Value</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Only-Query"><a href="#Read-Only-Query" class="headerlink" title="Read-Only Query:"></a>Read-Only Query:</h3><blockquote><p>Read-only Query不讲读日志写入磁盘，因为read本就是幂等操作(idempotent),不会影响状态机的状态，因此可以不用写入磁盘同步</p></blockquote><h4 id="challenge-共识"><a href="#challenge-共识" class="headerlink" title="challenge:共识"></a>challenge:共识</h4><ul><li><p><strong>分区容错性(Partition-torlerance)</strong>：由于不写入只读日志到raft层，无法使server到达<strong>共识</strong>(强一致性)，因此当前leader无法知道是否处于<strong>大多数分区中</strong>,可能会导致分区时少部分区域的leader回复给client旧的数据。</p><p><strong>解决方案:</strong> 因此在回复client时需要<strong>确认自己的leader状态</strong>,发送heartbeat能否获得大多数的server响应</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-------------raft.<span class="keyword">go</span>----------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> KV_Sendheartbeat() <span class="type">bool</span> &#123;</span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">        Term:         rf.currentTerm,</span><br><span class="line">        LeadId:       rf.me,</span><br><span class="line">        LeaderCommit: rf.commitIndex,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            _, ok := rf.CallAE(server, args)</span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                wg.Done()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">            num++</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">//majority of peers can rececive</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------kvraft.<span class="keyword">go</span>-----------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ConfirmLeadership() <span class="type">bool</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> _, isLeader := kv.rf.GetState(); isLeader &#123;</span><br><span class="line">        isMajority = kv.rf.KV_Sendheartbeat()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Leader日志applied到最新(Leader completeness guarantee)</strong> :出现分区等问题时新的Leader没有收到当前任期的Log因此之前的任期的log也不会提交并应用，导致当leader进行在处理只读操作时leader并没有同步所有日志，例如：Leader的currentTerm = 5，自己含有term=3或4的log没有applied，导致此时leader会返回旧数据。</p><p><strong>解决方案</strong>:当任期<strong>更改</strong>时<strong>添加no-op</strong>,添加一个空的log使peers达到共识，并使leader的日志同步到达最新</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  &#123;</span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, kv.Term)</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Keep Log Completeness:Send no-op log let leader applied all log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> getCompleteness(CommandId <span class="type">int64</span>, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        CommandId:   CommandId,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">        Opt:         <span class="string">&quot;no-op&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d send no-op index %d &quot;</span>, kv.me, index)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        DPrintf(<span class="string">&quot;no-op Channel is timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>recovery的时候进行Read-only操作(Recovery Reading)</strong>：因为read-only操作不写入log(正在recovery的leader也可以返回只读操作)，所以不会等待其applied后进行返回，会导致recovery的leader将正在replay的数据返回给client。</p><p><strong>解决方案</strong>：加入一个<strong>isRecovery</strong>变量，当service重启时赋值，只读操作需要让正在恢复的leader应用到所有的log,才能执行只读操作，因此当检测到本次只读操作时leader正在recovery就需要发送no-op让leader强制同步</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  || kv.isRecovery&#123;</span><br><span class="line"></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, term)</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="comment">//将isRecovery、term放置在getCompletness</span></span><br><span class="line">        <span class="comment">//防止并发客户端的只读请求跳过no-op操作</span></span><br><span class="line">        <span class="comment">//例如：讲Term与Recovery放置在</span></span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.isRecovery = <span class="literal">false</span></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Only-Query-More-efficiency："><a href="#Read-Only-Query-More-efficiency：" class="headerlink" title="Read-Only Query More efficiency："></a>Read-Only Query More efficiency：</h3><p><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a></p><p>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给 Client。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。                                                                                                                                                                                                                                                         </p><p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的 系统中是无法被接受的，通常都不会使用。                            </p><p>在 Raft 里面，节点有三个状态：Leader，Candidate 和 Follower，任何 Raft 的写入操作都必须经过 Leader，只有 Leader 将对应的 Raft Log 复制到 Majority 的节点上面认为此次写入是成功的。所以如果当前 Leader 能确定一定是 Leader，那么能够直接在此 Leader 上面读取数据，因为对于 Leader 来说，如果确认一个 Log 已经提交到大多数节点，在 t1 的时候 apply 写入到状态机，那么在 t1 后的 Read 就一定能读取到这个新写入的数据。</p><p>那么如何确认 Leader 在处理这次 Read 的时候一定是 Leader 呢？在 Raft 论文里面，提到两种方法：</p><ul><li>ReadIndex Read</li><li>Lease Read</li></ul><h4 id="ReadIndex-Read"><a href="#ReadIndex-Read" class="headerlink" title="ReadIndex Read"></a>ReadIndex Read</h4><p>第一种是 ReadIndex Read，当 Leader 需要处理 Read 请求时，Leader 与过半机器交换心跳信息确定自己仍然是 Leader 后可提供线性一致读：</p><ol><li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li><li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li><li>Leader 执行 Read 请求，将结果返回给 Client。</li></ol><p>使用 ReadIndex Read 提供 Follower Read 的功能，很容易在 Followers 节点上面提供线性一致读，Follower 收到 Read 请求之后：</p><ol><li>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li><li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li><li>Follower 执行 Read 请求，将结果返回给 Client。</li></ol><p>不同于通过 Raft Log 的 Read，ReadIndex Read 使用 Heartbeat 方式来让 Leader 确认自己是 Leader，省去 Raft Log 流程。相比较于走 Raft Log 方式，ReadIndex Read 省去磁盘的开销，能够大幅度提升吞吐量。虽然仍然会有网络开销，但是 Heartbeat 本来就很小，所以性能还是非常好的。</p><h4 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h4><p>虽然 ReadIndex Read 比原来的 Raft Log Read 快很多，但毕竟还是存在 Heartbeat 网络开销，所以考虑做更进一步的优化。Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start+Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start+Election Timeout/Clock Drift Bound 时间点。Lease Read 与 ReadIndex 类似但更进一步优化，不仅节省 Log，而且省掉网络交互，大幅提升读的吞吐量并且能够显著降低延时。</p><p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p><p>Lease Read 实现方式包括：</p><ol><li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li><li>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤(2)；</li><li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read。</li></ol><h2 id="服务层使用快照-Snapshot-："><a href="#服务层使用快照-Snapshot-：" class="headerlink" title="服务层使用快照(Snapshot)："></a>服务层使用快照(Snapshot)：</h2><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p><strong>SnapShot正常执行</strong></p><ol><li><strong>调用Snapshot()</strong> :KV-Server在applier中应用日志时要判断,raft_State是否超过规定值,超过maxraftstate使用<strong>snapshot(sm_state)</strong> 拍摄状态机的状态快照,也就是将服务器的数据库、Session最后一次响应进行快照拍摄</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> needSnapshot() <span class="type">bool</span> &#123;</span><br><span class="line">    size := kv.rf.Persister.RaftStateSize()</span><br><span class="line">    <span class="keyword">if</span> kv.maxraftstate == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kv.maxraftstate &lt;= size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> takeSnapshot(CommandIndex <span class="type">int</span>) &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d Taking Snapshot CommandIndex %d&quot;</span>, kv.me, CommandIndex)</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(kv.sm.mkv)</span><br><span class="line">    e.Encode(kv.Session)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    kv.rf.Snapshot(CommandIndex, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Think about when a kvserver should snapshot its state and what should be included in the snapshot.</p><p>Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots.</p></blockquote><p><strong>snapshot包含的信息</strong>:数据库+Session</p><ul><li><p>数据库:键值表</p></li><li><p>Session:客户端与服务端会话的最后一次request的响应</p></li></ul><ol><li><strong>压缩日志持久化snapshot:</strong> snapshot中会对当前commitIndex进行压缩日志,将raft_state(压缩后的日志)</li></ol><p><strong>Crash后恢复</strong></p><ol><li>当所有Server重启后，服务端需要读取snapshot，调用ReadSnapshot(),快速恢复状态机</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> recovery() &#123;</span><br><span class="line">    data := kv.rf.Persister.ReadSnapshot()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> mkv *MemoryKV</span><br><span class="line">    <span class="keyword">var</span> session <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;mkv) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;session) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.sm.mkv = mkv</span><br><span class="line">        kv.Session = session</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理滞后Follower</strong></p><ol><li><p><strong>raft层:</strong> Leader调用InstallSnapshot()发送snapshot给滞后的follower，follower处理此条消息用将<strong>snapshot消息</strong> push到channel中</p></li><li><p><strong>服务层:</strong> 检测本条channel的snap消息，使用CondInstallSnapshot() 对raft的日志进行调整,返回正确后，读取snapshot,将已有的SM_State覆盖</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            ...apply log to SM_State</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> kv.needSnapshot() &#123;</span><br><span class="line">                kv.takeSnapshot(msg.CommandIndex)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.rf.CondInstallSnapshot(msg.SnapshotTerm, msg.SnapshotIndex, msg.Snapshot) &#123;</span><br><span class="line">                kv.lastapplied = msg.SnapshotIndex</span><br><span class="line">                <span class="comment">//updata snapshot to Sm_machine</span></span><br><span class="line">                kv.recovery()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/3B.png" alt=""></p><h3 id="调试中的bug"><a href="#调试中的bug" class="headerlink" title="调试中的bug"></a>调试中的bug</h3><p><strong>问题描述</strong></p><p>服务层与raft层ch通讯延时导致服务层applied信息过慢(可能是锁的原因)，而raft_State的logs已经增长的过多。</p><p>导致服务层对于raft 通过channel传递上来的消息都要调用一次Snapshot(),但是此时的索引却又很小,一次压缩可能就是压缩一个长度的log,因此下一条命令处理后raft_State仍是很大,又是重复此流程，程序的运行的则会报出<code>logs were not trimmed 日志未裁剪的错误,改报错是超过了指定的测试指定的大小</code></p><h3 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志:"></a>调试日志:</h3><h4 id="12-1日常"><a href="#12-1日常" class="headerlink" title="12-1日常"></a>12-1日常</h4><p>呀今天改完raft的2D后，突然就把3B的实验测试点全过了，好耶！！！想着去多跑几遍看看有没有bug，突然出现一堆<strong>channel阻塞</strong>与<strong>锁的问题</strong>，调了一个晚上尚且把recover3B的测试点过了</p><h4 id="12-2日常"><a href="#12-2日常" class="headerlink" title="12-2日常"></a>12-2日常</h4><p>今天接着昨天的调试，调试今天的RecoverConcurrentPartition的并发问题，发现了一个特奇怪的现象，非leader的服务器居然在返回Get_RO操作！！！跑了很多遍了真的没办法了</p><p>于是我将Get_RO操作换回了Get操作，就全没毛病了，后面进行改进吧，555~~~</p><h3 id="12-3日常"><a href="#12-3日常" class="headerlink" title="12-3日常"></a>12-3日常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Start Partiton</span><br><span class="line">partition servers into: [1 2 4] [0 3]</span><br><span class="line">#S1是leader</span><br><span class="line">722 S1 &lt;- C13 PutAppendRequest K:3 V:x 3 3 y CmdId 11 T:25</span><br><span class="line">S1 Create Notifychan index 84</span><br><span class="line">#Commit -&gt; Applied</span><br><span class="line">S1 -&gt; C13 LastRequest type:Append K:3 V:x 3 3 y CmdId:11 CMI:84 T:25</span><br><span class="line">S1 Notify&#123; OK&#125; to C13 index 84</span><br><span class="line">#S0 之前是leader,index82的log并未提交</span><br><span class="line">S0 -&gt; C27 respond Timeout(PA) index:82</span><br><span class="line"></span><br><span class="line">partition servers into: [2 3] [0 1 4]</span><br><span class="line">#此时s1应该是leader出现华点S0回复了只读消息</span><br><span class="line">可能1,对比之前的S0为leader时T:24,S0在处理此条消息时T并未和Leader相同</span><br><span class="line">因此可能时阻塞的问题</span><br><span class="line">S0 &lt;- C13 GetRequest K:3 CmdId:12 T:24</span><br><span class="line"></span><br><span class="line">S0 -&gt; C13 CmdID:12 respond:&#123;x 3 0 yx 3 1 yx 3 2 y OK&#125;</span><br><span class="line">S0 Raft_State is 1006</span><br><span class="line">S0 Taking Snapshot CommandIndex 82 </span><br><span class="line">S0 LII 72 index 82(Compact) len(logs) 15</span><br><span class="line"></span><br><span class="line">dtest -p 5 -r -n 10 ConcurrentPartition3 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S1 &lt;- C46 PutAppendRequest K:4 V:x 4 6 y CmdId 13 T:36</span><br><span class="line">S1 Create Notifychan index 174</span><br><span class="line">partition servers into: [0 1] [2 3 4]</span><br><span class="line">S1 -&gt; C46 LastRequest type:Append K:4 V:x 4 6 y CmdId:13 CMI:174 T:36</span><br><span class="line">S1 Notify&#123; OK&#125; to C46 index 174</span><br><span class="line"># 变更leader</span><br><span class="line">S1 -&gt; C46 respond OK(PA)</span><br><span class="line">S1 &lt;- C46 GetRequest K:4 CmdId:14 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">C22 PutAppend request is redundant(PA)</span><br><span class="line">S1 &lt;- C22 GetRequest K:0 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C8 GetRequest K:1 CmdId:20 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C40 GetRequest K:2 CmdId:44 T:36 ,Raft_T:36</span><br><span class="line">S1 &lt;- C35 GetRequest K:3 CmdId:19 T:36 ,Raft_T:36</span><br><span class="line">#S2为leader</span><br><span class="line">S2 &lt;- C40 GetRequest K:2 CmdId:44 T:34 ,Raft_T:38</span><br><span class="line">S2 Create Notifychan index 175</span><br><span class="line">S2 send no-op index 175 </span><br><span class="line">partition servers into: [3] [0 1 2 4]</span><br><span class="line">S2 &lt;- C46 GetRequest K:4 CmdId:14 T:38 ,Raft_T:38</span><br><span class="line">S2 Get peer 3</span><br><span class="line">S2 -&gt; C46 CmdID:14 respond:&#123;x 4 0 yx 4 1 yx 4 2 yx 4 3 yx 4 4 yx 4 5 y OK&#125;</span><br><span class="line">#S2的同步请求后面才applied</span><br><span class="line">S2 Applied no-op index 175</span><br><span class="line">S2 Notify&#123; &#125; to C0 index 175</span><br></pre></td></tr></table></figure><ul><li><p>由此条日志可知,与isRecovery同理，在修改kv.term后，其他请求又可以继续处理并且不需要继续发送no-op所以会导致返回旧数据</p><p>解决方案：处理完no-op后才可以修改term与isrecovery变量</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验完成了KVRaft的所有测试点，对于Raft的博士论文中的讲解对于只读操作进行了实现，但是对于只读操作的调试过程是相对于比较困难的，还好最后完成了只读操作的实现，对于follower读取(Read-Only Query More effieciency)并没有打算进行实现(主要是只读操作花费太多精力了)，如果你想要对该操作进行实现可以参考<a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a>.</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raft </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spanner论文笔记</title>
      <link href="/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/13/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spanner-全球化分布式数据库"><a href="#Spanner-全球化分布式数据库" class="headerlink" title="Spanner 全球化分布式数据库"></a>Spanner 全球化分布式数据库</h1><blockquote><p><strong>Title:</strong> Google’s Globally-Distributed Database,Spanner is Google’s scalable, multi-version, globallydistributed, and synchronously-replicated database</p></blockquote><p>论文中实现了广域的<strong>事务</strong>服务，也是在Google广泛使用的一种技术</p><ul><li><strong>R/W Transaction</strong>: 2PC + 2PL + Paxos Group</li><li><strong>R/O Transaction</strong>: Snapshot isolation + Synchronized Clocks</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Spanner部署"><a href="#Spanner部署" class="headerlink" title="Spanner部署"></a>Spanner部署</h3><p>Spanner的部署叫做<strong>universe</strong>，可以让Spanne全球性的管理数据，谷歌中使用了三套Spanner部署分别用于:测试、研发、上线</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/universe.png" alt=""></p><p>如上图Spanner server的结构图中，Spanner由多个<strong>Zone</strong>(管理部署的单元、物理隔离的单元)组成。一个数据中心中可以由一个或者多个Zone<br>上图中的一个Zone有一个<strong>zonemaster(分配数据给spanserver)</strong> 和100-1000个<strong>spanserver(服务与客户端)</strong>，用户使用<strong>localtion proxies</strong> 定位每个Zone中分配数据服务的<strong>spanservers</strong></p><ul><li><p><strong>universe master</strong>:主要是一个控制台，它显示了关于 zone 的各种状态信息，可以用于相互之间的调试</p></li><li><p><strong>Placement driver</strong>: 会周期性地与 spanserver 进行交互，来发现那些需要被转移的数据，或者是为了满足新的副本约束条件，或者是为了进行负载均衡</p><h3 id="Spanserver-SoftWare-Stack"><a href="#Spanserver-SoftWare-Stack" class="headerlink" title="Spanserver SoftWare Stack"></a>Spanserver SoftWare Stack</h3></li></ul><blockquote><p>每个Spanserver的副本部署以及软件栈</p></blockquote><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/SpannerSoftware.png" alt=""></p><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li><strong>Colossus</strong>:放置tablet的文件系统,GFS的升级版</li></ul><ul><li><p><strong>tablet</strong>:类似于bigtable中的tablet，实现如下映射<code>(key:string, timestamp:int64)-&gt;string</code> </p></li><li><p><strong>Paxos</strong>:共识算法于raft类似</p></li><li><p><strong>replica</strong>:Paxos的上层状态机</p></li><li><p><strong>locktable</strong>:实现并发控制,与分布式事务([[Distribute Transaction 笔记#两阶段锁（Two-Phase Locking）——悲观并发]])的二阶段锁相同</p></li><li><p><strong>Transaction manager</strong>：每个Paxos组中的支持分布式事务的软件</p></li><li><h4 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h4></li></ul><blockquote><p>universe的结构中展示了多个Zone中都含有100-1000个Spanserver，Zone可以理解为一个区域(地域)的数据中心。而每个SpanServer都是由一个Paxos状态机和Paxos协议组成(但是一个Paxos Group的Paxos副本不一定在一个Zone中),不同Zone之间的数据复制也是通过Paxos Group</p></blockquote><p>Spanner于bigtable不同之处在于，Spanner分配Timestamp给数据作为版本号，是其更像是一个多版本数据库，而不是键值对的存储，tablet的状态存储在B-tree类似的文件与WAL中</p><p>tablet的上层则是一个paxos的状态机方便复制(Paxos的一些细节我也没有研究过，复制过程可以参考[[Raft实验#Lab 2B : Log Replicated]])。每次写操作都需要写入两次：1.写入tablet的log中 2.写入Paxos的日志中。写操作必须在领导者上初始化 Paxos 协议，读操作可以直接从底层的任何副本的 tablet 中访问状态信息，只要这个副本足够新。副本的集合被称为一个 Paxos group。</p><p>对于每个是领导者的副本而言，每个 spanserver 会实现一个锁表来实现并发控制。对于那些需要同步的操作，比如事务型的读操作，需要获得锁表中的锁，而其他类型的操作则可以不理会锁表。</p><p>对于每个Paxos Group中都会有Leader会开启Transaction manager功能，每个拥有该功能的副本就称为一个<strong>Participant Leader</strong>，其余副本称为<strong>Participant slave</strong>。如果只有一个Paxos组如果一个事务只包含一个 Paxos 组(对于许多事务而言都是如此)，它就可以<font color="#00b0f0">绕过事务管理器</font>，因为锁表和 Paxos 二者一起可以保证事务性。如果一个事务包含了多 于一个 Paxos 组，那些组的领导者之间会彼此协调合作完成<font color="#00b0f0">两阶段提交</font>。其中一个参与者组，会被选为协调者，该组的 participant leader 被称为 <strong>coordinator leader</strong>，该组的 participant slaves 被称为 <strong>coordinator slaves</strong>。</p><h3 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h3><p><img src="https://ember-img-1308152850.cos.ap-chongqing.myqcloud.com/directory.png" alt=""></p><p>Spanner 对具有公共前缀的键做了一个抽象，称为 <strong>directory</strong>。目前一个 directory 是数据存放的基本单位。属于一个目录的所有数据，都具有相同的副本配置。 当数据在不同的 Paxos 组之间进行移动时，会一个目录一个目录地转移，如上图所示。Spanner 可能会移动一个目录从而减轻一个 Paxos 组的负担，也可能会把那些被频繁地一起访问的目录都放置到同一个组中，或者会把一个目录转移到距离访问者更近的地方。当客户端操作正在进行时，也可以进行目录的转移。我们可以预期在几秒内转移 50MB 的目录。</p><p>directory 是数据复制和placement配置的基本单位。spanner中负载均衡的最小单位也是 directory，同时提供方法 MoveDir 可以手动将一个 directory 移动到指定的zone</p><h3 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h3><p>spanner的行模型是 <code>(key:string, timestamp:int64) -&gt; row content</code>，可以看到跟big table的模型最大的不同是这里强化了row的概念，不再突出column；这样spanner的timestamp是赋给整行数据的，是有物理意义的，这使得spanner更像一个实现多版本并发的数据库，而在big table中，timestamp仅仅用于保存多个版本的key-value，跟并发完全无关；我觉得这也是为什么spanner称自己为semi-relational 数据库，而big table只称自己是semi-structure 数据库的原因。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/spannerDataModel.png" alt=""></p><p>Spanner 的数据模型不是纯粹关系型的，它的行必须有名称。更准确地说，每个表都需 要有包含一个或多个主键列的排序集合。这种需求，让 Spanner 看起来仍然有点像键值存储: 主键形成了一个行的名称，每个表都定义了从主键列到非主键列的映射。当一个行存在时，必须要求已经给行的一些键定义了一些值(即使是 NULL)。采用这种结构是很有用的，因为这可以让应用通过选择键来控制数据的局部性。</p><h3 id="High-level-Organization"><a href="#High-level-Organization" class="headerlink" title="High-level Organization"></a>High-level Organization</h3><p>考虑下图3个数据中心的A、B、C(存在于不同的地域中)，数据存储在分片中,包含了数据库的行和一些键值对，例如A的分片中有键A-M的。现将该分片复制到B、C数据中心中，即使整个数据中心出现故障也可以继续。</p><p>位于不同数据中心的spanserver形成了Paxos Group 如Figure3中所示，也就是一个Paxos Group中的副本可以存在于不同数据中心中。三个键A-M的shard是通过日志复制使状态机去更新键值对</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerShard.jpg" alt=""></p><h4 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h4><ul><li><p>多个分片是为了获得更好的并行性</p></li><li><p>每个分片有一个Paxos组用于复制，若a-c的距离远复制开销大，也只需要a、b之间获得majority即可</p></li><li><p>数据中心的容错，速率过慢</p></li><li><p>副本靠近客户端，客户可以获得高性能的只读事务,其原理[[KVRaft#Read-Only Query:]]</p></li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><h3 id="Read-of-local-Relipca-yield-latest-write"><a href="#Read-of-local-Relipca-yield-latest-write" class="headerlink" title="Read of local Relipca yield latest write"></a>Read of local Relipca yield latest write</h3><p>追求更强的一致性，在ZooKeeper中实现的fast-read是弱的线性一致性。本地副本需要读到最新的写，在本文中将会用到</p><h3 id="Trasaction-across-shard"><a href="#Trasaction-across-shard" class="headerlink" title="Trasaction across shard"></a>Trasaction across shard</h3><p>支持跨分片的事务，例如转账事务中一个分片是一个账户、另一个分片是目标账户，当我们要执行转账操作时可以像事务一样执行，并且具有ACID的语义</p><h3 id="Transaction-must-be-serializable"><a href="#Transaction-must-be-serializable" class="headerlink" title="Transaction must be serializable"></a>Transaction must be serializable</h3><p>读取多条记录的事务必须是可序列化的。但是本地碎片可能反映已提交事务的不同子集!</p><h2 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h2><div class="table-container"><table><thead><tr><th><strong>Method</strong></th><th><strong>return</strong></th></tr></thead><tbody><tr><td>TT.now()</td><td>TTinterval: [earliest, latest]</td></tr><tr><td>TT.after(t)</td><td>true if t has definitely passed</td></tr><tr><td>TT.before(t)</td><td>true if t has definitely not arrived</td></tr></tbody></table></div><p>TrueTime API 是一个非常有创意的东西，可以同步全球的时间。</p><ul><li><p>TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。</p></li><li><p>TT.after(t)和TT.before(t)是基于TT.now()实现的。</p></li></ul><p>那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。实际部署的时候。每个数据中心需要部署一些Master机器，其他机器上需要有一个slave进程来从Master同步。有的Master用GPS，有的Master用原子钟。</p><blockquote><p>Denote the absolute time of an event e by the function t<sub>abs</sub>(e). In more formal terms, TrueTime guarantees that for an invocation tt = TT.now(), tt.earliest ≤ t<sub>abs</sub>(e<sub>now</sub>) ≤ tt.latest, where enow is the invocation event.</p></blockquote><h2 id="Concurrent-control"><a href="#Concurrent-control" class="headerlink" title="Concurrent control"></a>Concurrent control</h2><h3 id="Timestamp-Management"><a href="#Timestamp-Management" class="headerlink" title="Timestamp Management"></a>Timestamp Management</h3><p>Spanner使用TrueTime来控制并发，实现外部一致性。支持以下几种事务。</p><ul><li>读写事务：读写操作的集合</li><li>只读事务：只有读操作，并且提供的<strong>snapshot isolation</strong>的功能，保证强一致性</li><li>快照读,只读事务由客户端提供时间戳：可以读取stale data</li><li>快照读,客户端提供时间范围<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerTransaction.png" alt=""></li></ul><p>上表是Spanner现在支持的事务。单独的写操作都被实现为读写事务 ； 单独的非快照被实现为只读事务。事务总有失败的时候，如果失败，对于这两种操作会自己重试，无需应用自己实现重试循环。</p><p>时间戳的设计大大提高了只读事务的性能。事务开始的时候，要声明这个事务里没有写操作，只读事务可不是一个简单的没有写操作的读写事务。它会用一个系统时间戳去读，所以对于同时的其他的写操作是没有Block的(只读事务是lock free的)。而且只读事务可以在任意一台已经更新过的replica上面读。</p><p>对于快照读操作，可以读取以前的数据，需要客户端指定一个时间戳或者一个时间范围。Spanner会找到一个已经充分更新好的replica上读取。</p><p>还有一个<strong>有趣的特性</strong>的是，对于只读事务，如果执行到一半，该replica出现了错误。客户端没有必要在本地缓存刚刚读过的时间，因为是根据时间戳读取的。只要再用刚刚的时间戳读取，就可以获得一样的结果。</p><h3 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h3><h4 id="RW-Transaction-without-TS"><a href="#RW-Transaction-without-TS" class="headerlink" title="RW Transaction without TS"></a>RW Transaction without TS</h4><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerRW.png" alt=""></p><p>A、B是两个不同的数据中心，客户端最开始的请求的读操作并不是事务操作，目的是为了找到Paxos Group的leader，并且Leader在锁表中分配该数据的锁，当client获得返回值时进行提交(commit)，该实现与Lab3中的读操作服务本质相同。后续执行二段提交部分，提交完成后并释放锁。</p><p>这种实现与[[Distribute Transaction 笔记]]中实现的2PC+2PL的实现方法相同，只不过加入了Paxos的容错设计</p><h4 id="Assigning-Timestamp-to-RW-Transaction"><a href="#Assigning-Timestamp-to-RW-Transaction" class="headerlink" title="Assigning Timestamp to RW Transaction"></a>Assigning Timestamp to RW Transaction</h4><p>事务的读写将会用到二段锁，当所有的锁都已经获得以后，在任何锁被释放之前(也就是持有所有锁期间)，就可以给事务分配时间戳。对于一个给定的事务，Spanner 会为事务分配时间戳，这个时间戳是 Paxos 分配给 Paxos 写操作的，它代表了<font color="#00b0f0">事务提交的时间</font>。</p><p>Spanner 依赖下面这些单调性:在每个 Paxos 组内，Spanner 会以单调增加的顺序给每个 Paxos 写操作分配时间戳，即使在跨越多个领导者时也是如此。一个单个的领导者副本，可以很容易地以单调增加的方式分配时间戳。在多个领导者之间就会强制实现彼此隔离的不连 贯:一个领导者必须只能分配属于它自己租约时间区间内的时间戳。要注意到，一旦一个时间戳 S 被分配，S<sub>max</sub> 就会被增加到 s，从而保证彼此隔离性(不连贯性)。</p><ul><li>S<sub>i</sub>：一个读写事务的时间戳，当S<sub>i</sub>被分配，S<sub>max</sub>就会增长到S</li><li>T<sub>i</sub>：表示一个事务</li><li>e<sub>i</sub>：代表一个事务的一些事件如开始或结束</li><li>e<sub>i</sub><sup>server</sup> ：表示写事务T<sub>i</sub>的Commit请求到达Coordinator的时间</li><li>t<sub>abs</sub>：一个时间的绝对时间</li></ul><p><strong>External consistency</strong> -&gt; 不变性(invariant)：如果事务T2开始发生在T1提交事务之前，T2的时间戳就必须大于T1的提交事务的时间戳———-tabs(e<sub>1</sub><sup>commit</sup>)<tabs(e<sub>2&lt;/sub&gt;<sup>start</sup>)=&gt;S<sub>1</sub> &lt; S<sub>2 </sub></p><p><strong>Start</strong>：为一个事务 T<sub>i </sub>担任协调者的领导者分配一个提交时间戳 s<sub>i</sub>，不会小于 TT.now().latest 的值，TT.now().latest的值是在e<sub>i</sub><sup>server</sup>事件之后计算得到的。要注意，担任参与者的领导者， 在这里不起作用。第 4.2.1 节描述了这些担任参与者的领导者是如何参与下一条规则的实现的。</p><p><strong>Commit Wait</strong>：担任协调者的领导者，必须确保客户端不能看到任何被 T<sub>i</sub> 提交的数据，直到 TT.after(s<sub>i</sub>)为真。提交等待，就是要确保 s<sub>i</sub> 会比 T<sub>i</sub> 的绝对提交时间小。Commit Wait 的证明如下图所示(只针对于R/W 事物)</p><ul><li>commit wait：T1的时间戳小于其commit提交开始的绝对时间</li><li>assumption：T2的开始时间大于T1 commit的事件的事件</li><li>causality： T2开始的时间小于或等于其commit消息到coordinator的时间</li><li>start：commit消息到达coordinator的时间小于等于T2的时间戳则事物开始</li><li>transitivity：可以得到s1发生在s2之前</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerProof.png" alt=""></p><h4 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h4><p>Spanner在2PC开始之前读操作将会发生在transaction中被Client缓存，这样的话读操作就不会看见同一事务中写入的影响了</p><p><strong>读写操作的实现细节</strong><br>读操作在读写事务中使用wound-wait方法去避免死锁。Client发起读操作到合适Paxos Group的leader副本，获取读锁并且读取最近的数据，在客户端事务存活的时候会不断的向leader发心跳，防止超时。当客户端完成了所有的读操作，并且缓存了所有的写操作，就开始了两阶段提交。客户端选择一个coordinator group，并给每一个leader发送coordinator的id和缓存的写数据。(由客户端驱动二段提交避免两次广域的链接)</p><p><strong>写操作开始</strong><br>non-coordinator-leader首先会获取一个写锁，选择一个prepare时间戳大于之前事务已经分配时间戳的，通过Paxos记录prepare日志。每一个Participant的都要给coordinator发送他自己prepare的那个时间戳。</p><p>coordinator leader首先获得写锁但是需要<font color="#00b0f0">跳过Prepare阶段</font>，在收到(hearing,应该是类似与心跳的机制)所有Participant的Prepare消息后，它需要准备一个时间戳给整个事务，并且commit timestamp S必须大于或等于所有的prepare的时间戳(满足4.1.3中的限制)，大于TT.now().lastest，同一时间coordinator收到commit消息(Participant回复Prepare消息是commit/abort形式)并且大于leader分配给之前事务的时间戳</p><p>在coordinator的副本apply commit的日志记录之前，为了遵循commit-wait规则coordinator leader需要等待TT.after(S)。因为coordinator leader需拿着S基于TT.now().lastest,并且。在commit-wait之后coordinator leader会commit的时间戳发送给client和所有Participant leader</p><h3 id="只读事务-高性能读"><a href="#只读事务-高性能读" class="headerlink" title="只读事务:高性能读"></a>只读事务:高性能读</h3><ul><li>快速的读从本地的(邻近的)分片中``</li><li>不需要<strong>二段锁</strong></li><li>不需要<strong>二段提交</strong></li></ul><h4 id="Corretness"><a href="#Corretness" class="headerlink" title="Corretness"></a>Corretness</h4><p><strong>Serializeble:</strong> R/W<sub>1</sub>（T1）  R/O   R/W<sub>2 </sub>（T2） R/W</p><p><strong>External consistency(外部一致性)</strong><br>Serializable+Real time，与线性一致性相似只不过Extenal consisitency是<font color="#00b0f0">事务级别的属性</font></p><p><strong>示例</strong>：下一个事务必须看见上一个事务的写入</p><ol><li>如果事务T1再另一个事务T2开始之前提交, 则T1提交的时间戳会小于T2提交的时间戳</li><li>如果T1&lt; T2  ，则T2 必须看见T1的写入</li></ol><h4 id="Bad-Plan-只读操作读取最新提交的值"><a href="#Bad-Plan-只读操作读取最新提交的值" class="headerlink" title="Bad Plan 只读操作读取最新提交的值"></a>Bad Plan 只读操作读取最新提交的值</h4><p>由于R/O操作是不加锁的，T3在只读操作时Ry会读取到T2提交的值，因此违背了事务的隔离性也不是串行化。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Bad_Read.png" alt=""></p><h4 id="R-O-with-Snapshot-isolation"><a href="#R-O-with-Snapshot-isolation" class="headerlink" title="R/O with Snapshot isolation"></a>R/O with Snapshot isolation</h4><ol><li>分配时间戳给事务:<ul><li><strong>R/W:</strong> commit 提交开始(coordinator leader分配)</li><li><strong>R/O:</strong> Start 事务开始(paxos leader分配)</li></ul></li><li>执行事务按照时间戳的顺序</li><li>每个副本的数据存储都需要有时间戳作为版本号(MVCC,multiple version concurrent control)</li></ol><blockquote><p>In both Bigtable and Spanner, we designed for long-lived transactions (for example, for report generation, which might take on the order of minutes), which perform poorly under optimistic concurrency control in the presence of conflicts</p></blockquote><p>论文中所讲到Spanner在事务(<strong>实际上是只读事务，读写事务还是需要加锁</strong>)上使用了乐观并发控制，对于只读事务我们是不加锁的，因此对于只读事务我们使用乐观并发控制。</p><p>PS: 在FaRM论文中实现了对与读写事务的OCC，对于读操作是不加锁的</p><p>DDIA中说到：Serilaizability + Snapshot isolation = Optimistic concurrent control </p><p>如下图：T1提交的时间戳为@10，T2提交的时间戳为@20，T3只读事务开始的时间戳为@15，读取y值，会按照时间戳的顺序，因此读取y值会现读@15以前的数据，满足了快照隔离性与可串行性</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Snapshot_isolation.png" alt=""></p><h4 id="R-O-from-Local-Replica-non-Leader-of-Paxos"><a href="#R-O-from-Local-Replica-non-Leader-of-Paxos" class="headerlink" title="R/O from Local Replica(non-Leader of Paxos)"></a>R/O from Local Replica(non-Leader of Paxos)</h4><p>从当地副本进行只读事务，有可能只读事务之前写入还没有同步复制到该副本。例如：副本中没有W@10的操作</p><p><strong>解决方案</strong></p><ul><li>Saft Time ：所有副本中会跟踪这个t<sub>safe</sub>值是所有副本中最大的时间戳，以此来保证副本是最新的。若读操作时间戳为@t,一个副本需要满足t&lt;=t<sub>saft</sub> ,才能进行读写。</li><li>Paxos按照时间戳的顺序发送写操作给副本</li><li>在Rx@15执行前，需要等待大于@15的时间戳写入(与no-op操作道理是一样的)</li><li>等待prepared但是未commit的事务执行</li></ul><h4 id="Clock-must-be-perfect"><a href="#Clock-must-be-perfect" class="headerlink" title="Clock must be perfect"></a>Clock must be perfect</h4><ul><li><p>对只读事务很重要</p></li><li><p>只读事务的时间戳过大 =&gt; 等待时间过长</p></li><li><p>只读事务的时间戳过小 =&gt; 分配给T3更小的时间戳例如为5</p></li></ul><p>Example of problem if r/o xaction’s TS is too small:<br>  r/w T1 @  0: Wx1 C<br>  r/w T2 @ 10:         Wx2 C<br>  r/o T3 @  5:                   Rx?<br>(C for commit)</p><p>根据上述情形我们只会看见T1@0写入的x=1的值，但是实际上T3开始在T2提交过后，根据external consistency：T3必须看见T2的写入x=2。该问题就是不正确时钟导致的分配时间戳错误的问题,</p><p>下述方案中将会解决不正确时钟导致时间戳过小的问题</p><h4 id="Timestamp-are-interval"><a href="#Timestamp-are-interval" class="headerlink" title="Timestamp are interval"></a>Timestamp are interval</h4><p>  Time service yields a TTinterval = [ earliest, latest ].<br>  The correct time is guaranteed to be somewhere in the interval.<br>  Interval width computed from measured network delays,<br>    clock drift assumptions, GPS specs.<br>  Figure 6: intervals are usually microseconds, but sometimes 10+ milliseconds.<br>  So: server clocks aren’t exactly synchronized, but TrueTime<br>    bounds how wrong a server’s clock can be.</p><p>如何保证R/O Txn不会的时间戳不会太小导致读写错误<br>4.12节两个规则[[#Assigning Timestamp to RW Transaction]]</p><ul><li><strong>Start rule</strong>:<br>  事务的时间戳<font color="#00b0f0"> TS = TT.now().latest</font><br>  对于只读事务来说时间戳TS就是开始时间<br>  对于读写事务来说时间戳TS就是事务提交开始(commit begin)的时间，也就是prepared完成时间。</li><li><strong>Commit wait</strong>, for r/w xaction:<br> 在完成提交前, 延迟直到TS &lt; TS.now().earliest，保证该时间戳已经过去，因此只读操作永远不会选择在commit事务开始之前的时间戳。</li></ul><h4 id="update-example-with-interval"><a href="#update-example-with-interval" class="headerlink" title="update example with interval"></a>update example with interval</h4><p>该方案是T1提交然后T2开始，T2必须看见T1的写入，需要TS1 &lt; TS2<br>  r/w T0 @  1: Wx1 C<br>                   |1—————-10| |11———————20|<br>  r/w T1 @ 10:         Wx2 P          C<br>                                 |10————12|<br>  r/o T2 @ 12:                           Rx?<br>(P for T1’s Prepare, C for T1 finishing Commit)</p><p>在P中T2选择了TS2 = TT.now().lastest = 10，Commit-Wait确保C发生在TS2之后(@10过去)，C开始读取时钟获得间隔为11-20 (CommitWait TS.now().earliest =11 &gt;10)。</p><p>T3开始在C之后通过Commit-wait规则我们已经直到@10这个真实时间已经过去(assumption条件)，因此T3在@10之后，T2选择TS3=TT.now().latest=12,这个值是在当前时间之后所以是在@10之后,我们将会读到T2写入的值。</p><blockquote><p>为什么当T2在提交时，T3并发执行能够获得会得到T2的值? 因为根据lab3中只有committed的log才会应用(applied)到状态机，从而修改数据库的值。如果在处理只读事务T3时，并状态机没有应用T2@10写入的数据，会导致T3读取不到T2的值。</p></blockquote><p>我的猜想是<strong>saft time</strong>的机制解决该问题，等待大于@12的值写入数据库之后才能处理只读。因为我们已经分配了为@12的时间戳给了只读事务T3，执行顺序也不会出错，现在就是保证replica中一定由@10的写入。</p><blockquote><p>Commit-Wait的规则是保证序列化与时间戳的正确性。</p></blockquote><p>该例子只是解释了commit-wait+True Time的机制可以防止时钟的错误导致违背外部一致性，因此是否能够读写的T2的写入我想是必然的(因为读取不到T1的写入也违背外部一致性)，但是如何解决T2事务commit与T3并发处理的机制，还是取决于设计者。</p><p>最后可得TS3&gt;TS2,因此T3的可以读到T2写入的X的值</p><blockquote><p>Why this provides external consistency for r/o transactions:<br>  Given that T1 finishes before T2 starts.Commit wait means TS1 is <strong>guaranteed to be in the past.</strong> TS2 = TT.now().latest is guaranteed to be &gt;= correct time thus &gt;= TS of any previous committed transaction (due to its commit wait)</p></blockquote><h4 id="detail-1"><a href="#detail-1" class="headerlink" title="detail"></a>detail</h4><p>分配时间戳需要参与到读事务的Paxos groups的协商，这样的话，Spanner需要一个Scope的表示每一个只读操作，可以描述整个读事务的键(PS：应该不需要coordinator的参加)</p><p><strong>single Paxos</strong>：scop的值只被一个Paxos Group提供，client提交只读事务到leader。leader分配一个S<sub>read</sub>的时间戳并执行读操作。LastTS()是Paxos Group最后一次comitted的读操作，如果没有任何的已经准备的事务，S<sub>read</sub>=LastTS()满足了external-consistency:事务将会看见最后一次写入的结果，因此只读事务将会安排到之后一次提交写事务完成之后</p><p><strong>multiple Paxos</strong>：拥有多个的选项，最复杂的选项是所有groups的leader协商完基于LastTS()的S<sub>read</sub>，一个更简单的选着是clent避免协商的回合，当满足Sread = TT.now().lastest。所有的读操作将会发送到up-to-date的副本</p><h3 id="discussion"><a href="#discussion" class="headerlink" title="discussion"></a>discussion</h3><ul><li>R/W Txn =&gt; 2PC + 2PL</li><li>R/O Txn =&gt; Snapshot isolation + serializablity</li><li>extenal consistency  =&gt; timestamp order + time interval</li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt">https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt</a></p><h4 id="Q-原子时钟是什么"><a href="#Q-原子时钟是什么" class="headerlink" title="Q: 原子时钟是什么?"></a>Q: 原子时钟是什么?</h4><p>A: 一个非常稳定的振荡器。有两种主要的技术被称为“原子钟”:铷钟和铯钟。两者都利用了外层电子状态的变化，这涉及到特定的能量量子和波长。人们可以通过观察电子的兴奋程度来精确地将信号发生器调节到那个波长。原子钟只是时钟的振荡器部分:它产生一个频率，使时钟以正确的频率滴答作响，但它自己不知道它是什么时间。为了提供时间，原子钟最初必须与时间同步，通常是通过GPS(它本身是由一堆原子钟提供时间的)。</p><h4 id="Q-Spanner使用什么种类的原子时钟"><a href="#Q-Spanner使用什么种类的原子时钟" class="headerlink" title="Q: Spanner使用什么种类的原子时钟?"></a>Q: Spanner使用什么种类的原子时钟?</h4><p>A: 遗憾的是，论文没有说明。铷时钟通常是几千美元(e.g. <a href="https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP">https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP</a> 5071A就是一个很好的例子。铯钟不会漂移。当然，任何一个时钟都可能发生故障或电源故障，所以即使有完美的铯时钟，你仍然需要多个铯时钟，并能够同步到UTC。我猜，基于价格，Spanner使用的是与GPS接收器同步的铷时钟。</p><h4 id="Q-TrueTime如何以一种保证包含正确时间的方式选择间隔"><a href="#Q-TrueTime如何以一种保证包含正确时间的方式选择间隔" class="headerlink" title="Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?"></a>Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?</h4><p>A: 这里有一个简单的例子来说明它所使用的推理方法。</p><p>假设主时间服务器S1拥有正确的时间(来自GPS或原子钟)。S2向S1发送请求，询问时间，并得到响应。响应显示“10:00:00 AM”，它在S2发送请求后两秒到达(可以合理地假设S2可以计算事情所花费的时间，即使它不知道绝对时间)。由于整个请求/响应花费了两秒，S2可以推断网络可能将请求延迟了两秒;或者将响应延迟两秒;但仅此而已。因此S2可以得出结论，在它接收到响应的那一刻，正确的时间必须在09:59:58和10:00:02之间。</p><h4 id="Q-外部一致性与线性一致性和序列化有什么关系"><a href="#Q-外部一致性与线性一致性和序列化有什么关系" class="headerlink" title="Q: 外部一致性与线性一致性和序列化有什么关系?"></a>Q: 外部一致性与线性一致性和序列化有什么关系?</h4><p>A: 外部一致性似乎等同于线性化，但应用于整个事务，而不是单个的读写。外部一致性似乎也等同于严格的串行性，这是添加了等效串行顺序必须服从实时顺序的约束的串行性。关键属性是，如果事务T1完成，然后(随后实时)事务T2开始，T2必须看到T1的写入。</p><h4 id="Q-为什么外部一致性是可取的"><a href="#Q-为什么外部一致性是可取的" class="headerlink" title="Q: 为什么外部一致性是可取的?"></a>Q: 为什么外部一致性是可取的?</h4><p>A: 假设哈特谢普苏特通过圣何塞数据中心的网络服务器修改了她的工作组共享的一个帐户的密码。她低声说把新密码隔着隔间告诉了她的同事卡桑德拉。卡桑德拉通过位于圣马特奥的另一个数据中心的网络服务器登录了这个账户。外部一致性保证Cassandra将观察到密码的更改，而不是，例如，看到一个陈旧的副本。</p><h4 id="Q-云Spanner使用Raft而不是Paxos"><a href="#Q-云Spanner使用Raft而不是Paxos" class="headerlink" title="Q: 云Spanner使用Raft而不是Paxos?"></a>Q: 云Spanner使用Raft而不是Paxos?</h4><p>A: 是的。在这篇论文的层面上没有区别。在Spanner构建的时候，Raft还不存在，谷歌已经有了一个调优的可靠的Paxos实现。看看Chandra等人的论文Paxos Made Live。</p><h4 id="Q-Spanner的Commit-Wait有什么目的"><a href="#Q-Spanner的Commit-Wait有什么目的" class="headerlink" title="Q: Spanner的Commit Wait有什么目的?"></a>Q: Spanner的Commit Wait有什么目的?</h4><p>A: 提交等待确保读/写事务在其时间戳中保证已经过时才完成。这意味着在读/写事务完成后启动的只读事务保证具有更高的时间戳，从而可以看到读/写事务的写操作。这有助于实现外部一致性的保证:如果T1在T2开始之前完成，T2将以相同的串行顺序在T1之后完成(即T2将看到T1的写入)。</p><h4 id="Q-什么地方使用Spanner"><a href="#Q-什么地方使用Spanner" class="headerlink" title="Q: 什么地方使用Spanner?"></a>Q: 什么地方使用Spanner?</h4><p>A: 据说有数百个谷歌服务依赖于Spanner。本文介绍了谷歌广告系统对其的使用。谷歌的Zanzibar授权系统使用Spanner。它以云Spanner的形式提供给谷歌的云客户。CockroachDB开源数据库是基于Spanner设计的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://int64.me/2017/Spanner%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.html">Spanner 论文笔记 | Life is magic. Coding is art.</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">spanner论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">MIT6.824 Spanner讲义</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Spanner </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
