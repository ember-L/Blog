<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xv6：文件系统</title>
      <link href="/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%208%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote><p><strong>写在前面</strong>：本文是基于xv6以及MIT6.S081课程内容所写的笔记，在阅读时配合xv6源码理解效果更佳。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    设计文件系统的主要目的是为了<strong>组织</strong>与<strong>存储</strong>数据。文件系统中提供了<strong>共享</strong>用户与程序的数据的方式。同时也提供了<strong>持久化</strong>(persistence)，也就是在设备丢失并重启后，数据仍然能够保存，众所周知内存(RAM)设备的数据断电后是会丢失的。</p><p>​    xv6的文件系统提供了UNIX风格的文件、目录、路径名和在磁盘存储数据(persistence)的方式。同时这样的文件系统也会给设计带来一些挑战：</p><ul><li><strong>保存在硬盘上(on-disk)的数据结构</strong>：文件系统需要表示目录和文件名称的树(tree)，记录每个文件内容块的标识，并记录磁盘中那些块是空闲的。</li><li><strong>crash恢复(crash recovery)</strong>：如果电脑crash发生，文件系统需要在重启后正常工作。问题在于在crash会中断更新的顺序，并且导致on-disk数据结构与文件数据不一致。</li><li><strong>维持不变量(maintian in variant)</strong>：不同的进程同时操作一个文件的时候，需要协调数据的更新，预防并发读写的数据竞争。</li><li><strong>内存缓存常用块(in-memory cache of popular blocks)</strong>：磁盘的访问通常会比内存访问慢几个数量级，所以文件系统需要维持<strong>常用数据块</strong>在内存中的缓存。</li></ul><p>xv6中文件系统的设计是比较简单的，但是用于学习是十分不错的。    </p><h2 id="xv6文件系统"><a href="#xv6文件系统" class="headerlink" title="xv6文件系统"></a>xv6文件系统</h2><p>xv6文件系统的实现被组织为7个层，如下图所述：</p><ol><li><strong>disk layer</strong>，进程在磁盘设备上读写块(blocks);</li><li><strong>buffer cache layer</strong>，将磁盘的块缓存在<strong>内存</strong>中并同步访问，并且在只有一个内核进程才能在一个时间段内修改缓存，将该块存入对应磁盘的块中</li><li><strong>logging layer</strong>，将更高的层中对于几个或是多个的数据块的更新保存在一个<strong>事务</strong>中(transaction)，并且却表这些块能够在面临crash时能够<strong>原子的更新</strong>(要么全部更新，要么都不更新)。</li><li><strong>inode layer</strong>，提供单独的文件的信息(metadata)，每一个文件都有唯一编号(i-number)的<code>inode</code>，一个文件只有一个<code>inode</code>的，在磁盘中有固定的块会保存<code>inode</code>数据。</li><li><strong>directory layer</strong>，将目录设置为了一种特殊的<strong>inode</strong>种类，也就是说目录是文件，目录会保存目录或文件的条目的序列，每一个条目都会包含文件名与i-number。</li><li><strong>pathname layer</strong>，提供分层级的路径命名方式，如/usr/rt,/xv6/fs.c，解析路径明时使用递归的方式查询(find实验中就有所涉及)。</li><li><strong>descriptor layer</strong>，将Unix资源(pipes，devices、file…)抽象化，使用文件系统的接口，简化操作磁盘文件的方式。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/layers.png" alt="layers"></p><p>​    以上便是文件系统与xv6文件系统大致设计，接下来将会由底层的disk layer逐渐讲解到顶层的descriptor layer。</p><h1 id="Disk-Layer"><a href="#Disk-Layer" class="headerlink" title="Disk Layer"></a>Disk Layer</h1><h2 id="磁盘硬件交互"><a href="#磁盘硬件交互" class="headerlink" title="磁盘硬件交互"></a>磁盘硬件交互</h2><p>​    从最低层<strong>Disk layer</strong>讲起，在实际中risc-v主板上会连接许多的存储设备，有SSD与HDD两种常用的磁盘类型，两者的区别在于性能与成本方面。</p><p>​    这些存储设备连接到了电脑总线(bus)之上，总线也连接了<strong>CPU和内存</strong>。一个文件系统运行在CPU上，将内部的数据存储在内存，同时也会以读写block的形式存储在SSD或HDD。读写文件的接口比较简单有read/write，然后以block编号作为参数。</p><p>​    在下图中是CSAPP中硬件的组织，通常情况CPU读取磁盘的文件或是程序，都会将其加载到内存中。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/hw_org.png" alt="hw_org"></p><blockquote><p><strong>术语</strong>：sector与block</p></blockquote><ul><li><strong>sector</strong>，通常是磁盘驱动可以读写的最小单元，它过去通常是512字节。</li><li><strong>block</strong>，通常是操作系统或者文件系统视角的数据。它由<strong>文件系统定义</strong>，在xv6中定义为1024字节。所以xv6中<code>block = 2 * sector</code>。通常来说一个block对应了一个或者多个sector。</li></ul><p>但是这两个术语没有明确的界限，所以容易导致混淆。</p><h2 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h2><p>​    从文件系统的角度来看磁盘还是很直观的。因为对于磁盘就是读写block或者sector，我们可以将磁盘看作是一个巨大的block的数组，数组从0开始，一直增长到磁盘的最后。</p><blockquote><p>磁盘块与类型</p></blockquote><ul><li><strong>boot block</strong>，block0，被用作boot sector来启动操作系统。操作系统也是一个程序保存在数据块中，点击开机后，boot loader会将该操作系统加载内存中。xv6中没有使用boot block。</li><li><strong>super block</strong>，block1通常被称为super block，它描述了文件系统的线管信息。包含磁盘上有多少个block共同构成了文件系统这样的信息。通过block1构造出大部分的文件系统信息。</li><li><strong>log block</strong>，block2-block31。实际上log的大小可能不同，这里在super block中会定义log就是30个block。</li><li><strong>inode block</strong>，在block32到block45之间。一个inode是64字节，描述的了文件的一些相关信息。</li><li><strong>bitmap block</strong>，构建文件系统的默认方法，它只占据一个block。它记录了data block是否空闲。一个字节有8个位，那么一个字节可以表示8个数据块(通过指定位0和1表示数据块是否被使用)，例如<code>0000 0110</code>就可以表示第2和第3个数据块被使用了，一个bitmap就可以表示8*1024个数据块。</li><li><strong>data block</strong>，block46以后的块都属data block，data block存储了文件的内容和目录的内容。</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>通常来说，bitmap block，inode blocks和log blocks被统称为<strong>metadata block</strong>。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据。</p><blockquote><p><strong>代码</strong>：超级块结构体</p></blockquote><p>这个结构体描述了文件系统中一些基本信息，如文件系统block、inode、log的数量等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码</strong>：超级块初始化</p></blockquote><p>​    文件和目录内容都保存在磁盘块中，这就需要一个<strong>空闲池</strong>(free pool)用于分配空闲块。xv6块分配器(block allocator)维持了一个<strong>bitmap块</strong>，一个位(bit)代表一个块，0代表块空闲、1代表块正在使用。<code>mkfs</code>(mkfs/mkfs.c，用C语言编写的程序，本质上时制作一个镜像也就是一个文件)程序设置了这些位对应了各个块的编号，有<code>boot block</code>、<code>superblock</code>等。</p><p>​    输入<code>make clean</code>后再输入<code>make qemu</code>，可以从<code>makefile</code>输出信息看到如下消息所示，第一条是<code>makefile</code>的编译信息，大概就是将 <code>REAMDE</code>、<code>user/_cat</code>，这些程序加载到磁盘，实际是将这些程序写入到了<code>fs.img</code>文件中，最后将这个镜像文件加载到qemu的虚拟磁盘上。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkfs/mkfs fs.img README  user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie  user/_bigfile</span><br><span class="line">----makefile</span><br><span class="line"><span class="comment">#使用gcc编译mkfs文件</span></span><br><span class="line"><span class="section">mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h</span></span><br><span class="line">gcc <span class="variable">$(XCFLAGS)</span> -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c</span><br><span class="line"><span class="comment">#制作fs.img镜像，看/mkfs/mkfs.c代码可知这个镜像实际就是一个文件</span></span><br><span class="line"><span class="comment">#fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);</span></span><br><span class="line"><span class="section">fs.img: mkfs/mkfs README <span class="variable">$(UEXTRA)</span> <span class="variable">$(UPROGS)</span></span></span><br><span class="line">mkfs/mkfs fs.img README <span class="variable">$(UEXTRA)</span> <span class="variable">$(UPROGS)</span></span><br></pre></td></tr></table></figure><p>​    接下来的<code>makefile</code>的输出信息便是mkfs文件系统的<code>printf</code>语句的输出信息，大致就是告诉你文件系统中<strong>块的布局及分配情况</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmeta 70 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000</span><br><span class="line">balloc: first 799 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br></pre></td></tr></table></figure><p>​    在后面有一个<code>balloc</code>开头的输出语句，这实际上是块分配器的函数，接着了解一下块分配的相关操作。</p><p>在<code>mkfs/mkfs.c</code>中就就编写了超级块的初始化数据，主要是定义了文件系统的大小、磁盘块的数量、日志块的数量、日志块的开始编号、inode块的开始编号、bmap块的开始编号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat xv6_stat  <span class="comment">// avoid clash with host struct stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  sb.magic = FSMAGIC;</span><br><span class="line">  sb.size = xint(FSSIZE);</span><br><span class="line">  sb.nblocks = xint(nblocks);</span><br><span class="line">  sb.ninodes = xint(NINODES);</span><br><span class="line">  sb.nlog = xint(nlog);</span><br><span class="line">  sb.logstart = xint(<span class="number">2</span>);</span><br><span class="line">  sb.inodestart = xint(<span class="number">2</span>+nlog);</span><br><span class="line">  sb.bmapstart = xint(<span class="number">2</span>+nlog+ninodeblocks);</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Buffer-cache-layer"><a href="#Buffer-cache-layer" class="headerlink" title="Buffer cache layer"></a>Buffer cache layer</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>buffer cache层</strong>主要完成以下两个任务：</p><ol><li><strong>同步</strong>对磁盘块的访问：只有一个磁盘块的一个副本保存在内存中，并且只有一个内核线程能够在同一时间内操作这个内存副本。</li><li>缓存<strong>常用的块</strong>以提升性能：访问磁盘是特别慢的操作，缓存经常使用的块在内存中，可以加快数据访问的速度。</li></ol><p>在bio.c文件中声明了buffer cache层提供的三个接口：buffer cache层对每一个buffer包含一个<code>sleeplock</code>，保证buffer的同步性。</p><ul><li><strong>bread</strong>：获取一个buf，其中包含指定磁盘块的副本，这个副本能够在后续在磁盘中被读取与修改。返回一个已锁定的buf。</li><li><strong>bwrite</strong>：将已修改的buffer写回对应的磁盘块中。</li><li><strong>brelse</strong>：内核线程完成buffer相关修改后，调用该接口释放这个buf。释放锁定的buf。</li></ul><p>​    buffer cache是内存中保存的固定长度的<strong>双向buf(结构体)链表</strong>，那么也就是说内存中不可能缓存所有的磁盘块，那么当buffer cache满了之后，读取一个新的磁盘块，就需要回收<code>buf</code>节点。在xv6中使用了LRU(least recently used)算法，也就是将最少使用的块写回磁盘回收<code>buf</code>节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p> buf结构体</p></blockquote><ul><li><strong>valid</strong>：buf中是否含有块的副本。</li><li><strong>disk</strong>：buffer块的内容是否已经写回了磁盘，这将会改变块的内容。</li><li><strong>dev</strong>：设备id。</li><li><strong>blockno</strong>：磁盘块的编号。</li><li><strong>refcnt</strong>：引用计数，持有buf节点<code>sleeplock</code>的数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><blockquote><p><strong>buffer cache初始化</strong>：</p></blockquote><p>创建双向链表bcache，bcache中有30个buf节点。如下图</p><ul><li>由<strong>右到左</strong>是使用<code>next</code>指针，这个是<strong>MRU</strong>(most recently used)链表。右边的第一个就是最常(popular)用的buffer节点，依次使用<code>next</code>指向读取下一个块，这些块的<strong>常用程度</strong>依次下降。</li><li>从<strong>左到右</strong>是使用<code>prev</code>指针，这则是<strong>LRU</strong>链表，与<strong>MRU</strong>链表刚好相反。在xv6中会将LRU链表的节点的buffer写回磁盘。</li></ul><p>下图中<code>bcache.head</code>作用是使用<code>prev</code>与<code>next</code>指针指向<strong>MRU</strong>与<strong>LRU</strong>两个方向的链表的头节点。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/linklist-5.png" alt="linklist-5"></p><p>下述代码中，将每一个buffer节点都设置了一个<code>sleeplock</code>，遍历bcache.buf的所有节点创建了双向链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bread</strong>：获得指定块的buf，返回以锁定的buf</p></blockquote><p>​    在bread接口中会调用bget函数，返回指定磁盘块号的buf。如果该buf是新分配的节点里面没有数据，则调用<code>virtio_disk_rw</code>接口读取磁盘块的内容到buf中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bwrite</strong>：将buffer写入磁盘块</p></blockquote><p>一旦<code>bread</code>读取了磁盘并将buffer返回了调用者，调用者将独占使用这个buffer。只有在调用了<code>bwrite</code>之后将修改的数据写入磁盘才能释放buffer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>bget</strong>：获取指定块的buffer</p></blockquote><p><code>bget</code>中会做两件事：</p><ol><li><strong>查找已缓存的buf</strong>：使用next指针扫描<strong>MRU</strong>链表，通过判断<code>dev</code>与<code>blockno</code>参数，如果已经缓存了这个块，获取<code>sleeplock</code>后返回已锁定的buf节点。反之说明没有缓存指定的磁盘块，则进入下一步。</li><li><strong>查找空buf</strong>：使用prev指针扫描<strong>LRU</strong>链表，查找没有使用过的buf节点(<code>b-&gt;refcnt = 0</code>)，将该buf节点的相应字段填入，获取<code>sleeplock</code>后返回已锁定的buf节点。</li></ol><p>​    为了确保<strong>同步性</strong>，文件系统使用锁控制同步，因此每一个磁盘块只能缓存在一个buffer中，确定readers能够看见写入。<code>bget</code>函数中对链表扫描，检查buf节点是否缓存，这个过程持有<code>bcache.lock</code>直到返回，以确保不会多个buf节点缓存一个磁盘块或是一个buf节点缓存多个磁盘节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>bget</code>中在<code>bcache.lock</code><strong>关键区</strong>(critical section)之外，使用<code>sleeplock</code>保护buf节点数据安全，保护对磁盘块的buf节点的读写。在关键区之内，主要是保护了<code>b-&gt;refcnt</code>变量保证buf节点不被重新用于其他磁盘节点，保护已缓存块的信息。</p><blockquote><p><strong>brelse</strong>：调用者释放buffer，减少引用计数</p></blockquote><p>​    当调用者完成了buffer的操作，必须调用<code>brelse</code>(b-release)释放块。<code>brelse</code>释放<code>sleeplock</code>并减少引用计数。当引用计数为零(<code>b-&gt;refcnt=0</code>)的buf节点移动到链表的最右方(如下图所示)，这个buffer节点就变成了<strong>最经常使用</strong>的节点了，在<code>bget</code>中查找已缓存的节点便可以最先找到该节点。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/release_buffer.png" alt="release_buffer"></p><p>​    移动buf节点会引起buffer cache链表以<strong>最近使用频率</strong>进行排序：(从右往左)在链表的第一个buffer是最近最多使用的，最后一个则是最近最少使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p><strong>crash safty</strong></p></blockquote><p>​    在实际中：当使用<code>make</code>命令编译文件时候，会频繁的与文件系统交互，创建读写文件，但是在<code>make</code>命令执行的期间，你的笔记本断电了。那么到你重启笔记本后，使用<code>ls</code>命令显示文件会呈现你期望的状态。</p><p>​    <strong>crash恢复</strong>(crash recovery)是文件系统中最有趣的问题之一。这个问题主要是因为许多文件系统的操作会伴随着写磁盘操作，要写入磁盘的数据是保存在内存中的(已经在内存中修改数据)，但是当数据写入磁盘到一半或是没有将内存的数据写入完，就会出现一个问题——重启系统后导致数据不一致。</p><blockquote><p><strong>crash情景</strong></p></blockquote><p>​    以创建和写入x文件为例，主要调用了<code>open</code>与<code>write</code>这两个系统调用。那么echo期间打印一些写入磁盘的关键操作，忽略了读取操作，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hi&quot;</span> &gt; x</span></span><br><span class="line">write:33 allocate inode for x</span><br><span class="line">write:33 init inode x </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt;-crash1</span></span><br><span class="line">write:46 record x in directory&#x27;s data block</span><br><span class="line">write:32 update root inode</span><br><span class="line">write:33 update inode x</span><br></pre></td></tr></table></figure><p>​    第一二句得知，分配inode块33，就是为x文件分配一个inode，并且初始化inode的数据，(将磁盘块读取到buffer cache，并内存中初始化后，写回磁盘)。接着是更新根目录的数据块，就是添加x文件的描述，如下图所示写到了46这个磁盘块上。最后再是更新系统<strong>根目录的inode</strong>，再是将x文件的inode写回磁盘(将buffer cache中的inode写回磁盘)。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>​    那么此时在上图中crash1点出现系统crash，那么保存在buffer cache的内容将会被全部清空。那么系统就会丢失x文件的inode，但是这个inode已经被<strong>标记为已使用</strong>(可以查看<code>ialloc</code>的实现逻辑)。在根目录下也找不到x文件的inode，也就<strong>无法删除这个inode</strong>。这个问题也是可以恢复的，就是在重启时检查所有的inode块，如果inode没有数据块就直接删除这个inode就可以了，显然这是十分麻烦的方案。</p><p>​    一个还有风险情景是，<strong>同一个数据块属于两个文件</strong>，例如：在文件截断(将文件大小修改为0，释放文件内容)时发生crash，由于这些写磁盘操作是序列化的，那么就会导致inode中引用了一个<strong>数据块</strong>，但是在<strong>bitmap块</strong>中却标记了这个块为空闲。</p><p>​    inode引用了空闲块会造成的问题是，在重启后，内核可能分配这个数据块给其他文件，这就会造成两个不同的文件的内容指向了同一个数据块。如果xv6支持多用户，这就会造成<strong>安全问题</strong>，因为旧文件的用户能够读写新文件用户的数据。</p><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>日志简介</strong></p></blockquote><p>​    为了恰当的应对文件系统的crash问题，因此在xv6中提供的解决方案的方案是<strong>日志(logging)</strong>，这是来自与数据库的解决方案，提供了如下属性：</p><ul><li><strong>原子性(atomic)</strong>，确保文件系统的系统调用是原子性的。这个属性和数据库事务的原子性是完全一样的，比如你调用<code>write</code>系统调用，所有写入磁盘块的操作，要么全部成功，要么全部失败，不会出现写入部分的问题。</li><li><strong>快速恢复(Fast Recovery)</strong>，在重启之后，不需要做大量的工作来修复文件系统，只需要非常小的工作量。在另一个解决方案中，可能需要读取文件系统的所有block，并检查文件系统是否还处于正确的状态，再来修复。所以日志有<strong>快速恢复</strong>的属性。</li><li><strong>高性能(high performance)</strong>，原则上来说，它可以非常的高效，但是在xv6并不高效。</li></ul><p>​    log块保存在固定的磁盘块中，已经在superblock中标识。在superblock中记录了<strong>log块的开始索引</strong>以及<strong>log块的数量</strong>，log块总共有30块(2-31)。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><p>​    通过crash safty部分得知，文件系统调用对所有磁盘块的修改是不能在写入的中途发生系统crash。因此在日志设计中，将一系列磁盘的写入操作，<strong>包装成了一个事务</strong>，将所有磁盘块的写入，转换成了对log块的写入。接着了解一下日志事务的过程。</p><blockquote><p><strong>日志事务</strong></p></blockquote><p>将写入操作的分装成事务以及将日志事务产生效果的过程如下，主要有四个步骤：</p><ol><li><strong>日志写入(log write)</strong>，将直接写入磁盘块，改为写到log块。假设我们在内存中缓存了bitmap块，也就是块45。当需要更新bitmap时，不是直接写block 45，而是将数据写入到log块中，并记录这个更新应该写入到block 45。对于所有的写 block都会有相同的操作。</li><li><strong>操作提交(commit op)</strong>，在某个时间，文件系统的<strong>写操作结束</strong>了，比如说4-5个写磁盘块操作都结束，并且都保存在log块中，我们会提交这些写操作，也就是<strong>提交事务</strong>。这意味着需要在log的某个位置记录属于同一个文件系统的操作的个数，例如5。</li><li><strong>安装日志(install log)</strong>，安装日志就是将log块区域保存的所有要修改的磁盘块，转移到对应的磁盘块，比如说log5块保存的是595块的写入数据，那么就是将log5块复制到595块，依次安装所有日志。</li><li><strong>清理日志(clean log)</strong>，完成安装日志后，就可以清除log块。清除log块实际上就是将属于同一个文件系统调用的操作的个数设置为0。</li></ol><p>以上便是日志事务的所有工作流程，接着讨论一下可能发生的crash点。</p><blockquote><p><strong>日志与crash</strong></p></blockquote><ol><li>在1和2之间发生crash，重启之后什么都不会发生，就像是在执行文件系统调用之前的状态一样。</li><li>在2和3之间发生crash，这时所有的写操作都保存在log块中，已经有<code>committed</code>的标记，重启之后就再次执行<strong>install log</strong>操作就可以了。但是在2过程中crash，就没有<code>committed</code>标记，重启之后，就像是没有写入一样。</li><li>在3执行的过程和4发生之前发生crash，下次重启的时候，我们会<strong>redo log</strong>，我们或许会再次将log块中的数据再次拷贝到文件系统。log中的数据是固定的，我们就算重复写了文件系统，每次写入的数据也是不变的。这就说明<code>install log</code>操作是幂等的(<strong>idempotence</strong>，表示执行多次和执行一次效果一样)。</li></ol><p>以上便是日志在xv6实现的方式，也是最简单的日志实现方式。</p><blockquote><p><strong>数据交互过程</strong></p></blockquote><p>如下图所示是<strong>log write</strong>与<strong>log install</strong>的过程，例如，通过write系统调用，要写入数据到文件中，主要过程如下：只以读写bitmap块为例</p><ol><li>读取块2(磁盘中日志块编号是2-32)与块45到<code>bcache</code>，分别为日志头与bitmap块。</li><li>在内存中bcache修改两个块后，触发<strong>log commit</strong>，这时就将bcache中的块45与块2写入到log块中(写入磁盘)。</li><li>之后的某个时间点触发<strong>log install</strong>，将log块中的$D_{b1}$，其中b1指的是逻辑块，就是一个文件的数据块序列号，比如文件的数据保存在块400，450，460，那么b1=400，b2 = 450，b3 = 460。那么此时b1保存的数据就是块45的数据，直接写入到磁盘块45就可以了</li></ol><p>如下图所示<strong>H</strong>代表<strong>log header</strong>，其保存block数组内容是箭头<strong>H</strong>指向的左上角的矩形框中的数据，图中的流程如上面三步骤。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/log.png" alt="log"></p><h2 id="代码：logging"><a href="#代码：logging" class="headerlink" title="代码：logging"></a>代码：logging</h2><blockquote><p><strong>日志结构</strong></p></blockquote><p>在xv6中设计的log结构：</p><ul><li><strong>logheader结构</strong>：其中n表示本次log要操作的block数量，block数组代表要写入磁盘block的编号。在<code>param.h</code>中定义了一次事务中log最大的block数量。</li><li><strong>log结构</strong>：主要定义了关于log磁盘块相关的元数据，比较特别的是xv6将日志头嵌入了log结构中，第一个log磁盘块保存的就是logheader。</li><li><strong>log对象</strong>：对于日志这个数据对象在xv6中只有一个，一次在并发的事务执行时，需要使用sleep-lock用来解决竞争。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// max # of blocks any FS op writes</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE      (MAXOPBLOCKS*3)  <span class="comment">// max data blocks in on-disk log</span></span></span><br><span class="line">----<span class="built_in">log</span>.c</span><br><span class="line"><span class="comment">//4 + 4*30 = 124字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//124 + 24 + 5 * 4 = 168字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 24字节</span></span><br><span class="line">  <span class="type">int</span> start; <span class="comment">//磁盘上日志块的编号，在xv6中是block2</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//日志块总数量</span></span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// 统计正在执行的文件系统调用数量，例如：read、write</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// 当前事务正在提交</span></span><br><span class="line">  <span class="type">int</span> dev;        <span class="comment">//磁盘设备编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>日志封装</strong></p></blockquote><p>​    如前面的日志介绍，xv6将对于磁盘的多次交互操作封装为<strong>日志事务</strong>，保存读写的原子性，在xv6中就使用了两个接口实现事务的封装：</p><p><strong>begin_op</strong>：在进行磁盘读写前调用，与并发操作中为保护关键区的加锁一样。调用<code>begin_op</code>会进入死循环，这时进程会处于两种状态：</p><ol><li><strong>sleep等待</strong>：(1).当另一个事务正在提交时需要将当前事务进程休眠、(2).当日志块的空间满的时候需要休眠，避免日志块的空间被覆写。只有当另一个进程调用<code>wakeup</code>执行的时候，该事务才可能会被唤醒，并往下执行操作。</li><li><strong>执行事务</strong>：增加outstanding的数量释放log锁，跳出死循环，正常执行磁盘读写操作。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;<span class="comment">//有日志事务正在提交，后来的事务等待</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">//日志块的空间已满，等待日志提交。</span></span><br><span class="line">      <span class="comment">//在这里就表示，log系统只满足两个进程同时并发</span></span><br><span class="line">      <span class="comment">//后来的第三个以及后来的执行的事务需要休眠等待</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//增加outstading</span></span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>end_op</strong>：当磁盘读写操作执行完毕后，调用end_op相当于释放锁的操作，此时将<code>outstanding-1</code>，那么就可以开始提交事务。end_op调用时同样有两种状态：</p><ol><li><p><code>outstading==0</code>：说明日志结束时，log系统当前进程在进行事务操作并结束，那么此时就可以进行<strong>事务提交</strong>操作。</p></li><li><p><code>outstading!=0</code>：说明在日志系统中，同时有两个进程在进行log事务操作，一个事务结束的时候，<code>outstading!=0</code>就说明另一个事务正在执行，那么当前事务就不能提交(主要原因是为了提高log块的利用率)。接着便唤醒(wakeup)休眠进程，因为如果还有进程在<code>begin_op</code>等待，并且<code>log.lh.n</code>的值小于10，那么在begin_op休眠的进程便会被唤醒。如果<code>log.lh.n</code>大于10，那么休眠的进程仍然会休眠，指导当前log事务提交。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//准备提交</span></span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//唤醒begin_op休眠的进程</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    commit();<span class="comment">//将内存中的内容写入到日志块</span></span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q1</strong>：为什么<code>log.lh.n&lt;10</code>的时候，在begin_op休眠的进程就会被唤醒呢？</p><p><strong>A1</strong>：在<code>begin_op</code>有这样的判断<code>log.lh.n + (log.outstanding+1) * MAXOPBLOCKS &gt; LOGSIZE</code>，可以由此计算得出，虽然是一个判断条件，却有两个束缚，只有当日志块少于10的时候，才能够支持两个进程并发执行log事务。</p><p><strong>Q2</strong>：两个log并发执行事务，难道不会耗尽log块的空间吗，例如两个进程同时修改磁盘的15以上的块？</p><p><strong>A2</strong>：在write系统调用函数(kernel/file.c:filewrite)中，一次事务修改磁盘块的大小有所限制，这样就不会导致空间被耗尽。</p><blockquote><ol><li><strong>日志写入</strong></li></ol></blockquote><p>​    由于日志事务存在，xv6就不能够直接使用<code>bwrite</code>将<code>bcache</code>的修改数据直接写回磁盘块。取而代之的是使用<code>log_write()</code>函数：简单来说就是在log结构中记录下修改的磁盘块的编号。</p><p>​    这样做的是方便在后续的<strong>提交操作</strong>中文件系统将bcache中已修改块先保存到磁盘log中，保证事务操作的原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is:</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">//异常检查</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line">  <span class="comment">//简单的操作操作</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorption</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);<span class="comment">//增加buf引用</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>提交操作</strong></li></ol></blockquote><p><code>commit</code>：在end_op中，会调用commit函数进行事务提交，主要的流程如下</p><ul><li><code>write_log</code>：将bcache修改的块写入到磁盘log块上。</li><li><code>1-write_head</code>：将log数据对象写回磁盘块，是真正的<strong>日志提交点</strong>！！！</li><li><code>install_trans</code>：将磁盘log块的数据写回目标的磁盘块上。</li><li><code>2-write_head</code>：清空当前log事务</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_log</code>：这个函数并不难，理清<code>from</code>与<code>to</code>两个buf的含义。</p><ul><li><strong>from</strong>：是在bcache中保存的事务操作中，对目标磁盘块已修改的数据。</li><li><strong>to</strong>：是磁盘log块，编号是2-31。</li></ul><p>那么这里的意思也就是将内存保存的已修改的磁盘块，写到磁盘log块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line">  <span class="comment">//将bcache内存中保存的对数据修改的数据先写入磁盘log块</span></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_head</code>：这个函数有两个作用，先介绍第一个作用。</p><ol><li>作为<strong>提交点</strong>：就是将内存中log数据对象的写回磁盘块2，也就是磁盘log块的开始编号，主要是<code>logheader</code>保存的目标磁盘块的编号。在下述代码块中<strong>bwrite</strong>将log数据对象写入log块，也就代表的是日志事务的<strong>提交点</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//读取磁盘上的logheader</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="comment">//修改磁盘的logheader块保存的内容</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf); <span class="comment">// -&gt;commit point，这里才是真正的事务提交点</span></span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    在<code>bwrite</code>发生前出现crash，那么整个事务就视为报废，重启后也不能事务还原。在其之后发生，那么这个事务也就代表成功执行了。这里也就很好的体现了事务的<strong>原子性</strong>。</p><blockquote><ol><li><strong>安装事务</strong></li></ol></blockquote><p>​    <strong>install_trans</strong>：这个函数发生在日志提交点之后。在事务成功提交后，xv6就可以放心的将log块中保存的数据写回目标磁盘块了。下述代码也就是将磁盘log块的数据写回目标磁盘块，理解起来也十分的简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>清理日志</strong></li></ol></blockquote><p><code>write_head</code>：这里介绍其第二个作用</p><ol><li><strong>清理日志</strong>：在调用write_head前，我们首先将<code>log.lh.n</code>重置为0，那么就代表磁盘块2中保存的logheadr的n字段也被置为0，那么这里<code>write_header</code>作用就是，防止在此后发生crash后，xv6重启后又重新安装日志。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  ....</span><br><span class="line">  install_trans(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>crash恢复</strong></p></blockquote><p>​    当xv6遭遇crash时，那么在重启xv6时就会重新读取磁盘log块，重新安装日志并将清除日志头保存的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();<span class="comment">//重新读取磁盘log块的所有数据</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">//如果在crash前已经正在提交那么就安装日志</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// 清空log块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>inode布局</strong></p></blockquote><p>inode是文件系统的<strong>术语</strong>，主要有两个相关的意思：</p><ul><li>指包含文件大小和数据块的编号，在磁盘上(on-disk)的<strong>数据结构</strong>。</li><li>指包含磁盘inode和额外的内核信息，在内存(in-memory)上的<strong>数据结构</strong>。</li></ul><p>​    在xv6磁盘的布局图中，inode是32-45在磁盘上的14个连续的块。每个inode有固定的大小64字节，一个磁盘块有16个inode(<code>1024/64</code> )。那么给定一个inode号(i-number或inode-number)，系统就可以计算得到inode所在的磁盘块的编号。在xv6中公式为：$32+x/16$，例如，i-number=17，那么所在的block就为$32+17/16= 33$。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fs.png" alt="fs"></p><blockquote><p><strong>on-disk inode</strong></p></blockquote><p>​    <strong>on-disk inode数据结构</strong>包含的内容如：文件大小、文件类型(目录、文件、特殊文件)、<strong>链接数量</strong>(指向inode的目录数量)、指向磁盘数据块的地址的指针(有直接、间接地址，实际就是磁盘块编号)等元数据。以下便是磁盘中保存的inode结构，xv6的实现省去了文件创建、修改时间等等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    xv6的inode有12个直接地址指向12个数据块，1个间接地址指向1个块(数据块)，这个数据块包含了256个块号(<code>1024/4 = 256</code>，除4是因为块号的数据类型为uint32，block number)。由此可以计算得到xv6中可以存储文件的大小最大为$(12  + 256) * 1024 = 268KB$，由此可见xv6中可以容纳的文件大小特别的小。现在inode的地址字段布局如下所示。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/figure8.3.png" alt="figure8.3"></p><p>​    在fs实验中会要求能够存储大文件，超过268KB。具体的实现思路为使用<strong>两级间接指针</strong>，类似于三级页表一样，就是<strong>一级间接地址</strong>(inode保存的一个间接地址指针)指向保存的是256个<strong>二级间接地址</strong>的块，每个二级间接地址指向一个保存256个块号(uint32无符号整数指向数据块，block number)的数据块，具体的指向如下图。在该实验中就会实现前11个指针为直接地址，第12个为一级间接指针，第13个位二级间接指针，那么此时可以容纳最大的文件大小为$(11 + 256 + 256 <em> 256) </em> 1024 = 64MB + 12KB $。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2level_inode.png" alt="2level_inode"></p><p>那么现代操作系统下可以保存几十个GB的文件，那么inode的地址字段又该如何设置呢？没错就要使用<strong>三级指针</strong>，这样也和三级页表更相似了。   </p><blockquote><p><strong>inode锁设计</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p></blockquote><p>在xv6中实现了两种inode锁和两个锁风格的机制用于保护inode结构。</p><ul><li><strong>itable.lock</strong>，是自旋锁，保护inode内存表中最多出现一次inode的不变量(内存inode的<strong>ref</strong>字段，记录内存中有多少个指针指向该inode)</li><li><strong>inode.lock</strong>，是睡眠锁，每一个inode都有一个这样的锁，确保独占的访问inode的字段(如长度)和inode指向的文件或目录内容。睡眠锁可以很好了解放CPU占用问题。</li><li><strong>ref字段</strong>，记录引用该文件的进程数，如果<code>ref&gt;0</code>，<code>inode</code>会继续保存在<code>itable</code>中，并且不会将该<code>itable</code>的条目用于其他<code>inode</code>。</li><li><strong>nlink字段</strong>，用于计算目录的文件(如不同目录路径下引用的这个文件)指向该文件的<strong>条目数</strong>，同样的<code>nlink&gt;0</code>，<code>inode</code>会接续保存在<code>itable</code>中。</li></ul><p>​    以下便是itable的结构，还是比较简单的，就是一个inode数组和自旋锁而已，由于itable保存于内存中，其保存的inode数量只有50个，是少于磁盘保存的inode数的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br></pre></td></tr></table></figure><h2 id="代码：Block-allocator"><a href="#代码：Block-allocator" class="headerlink" title="代码：Block allocator"></a>代码：Block allocator</h2><blockquote><p><strong>块分配器</strong>的相关操作：</p></blockquote><p>​    块分配器提供了两个函数用于操作空闲池：</p><p><strong>bfree</strong>：释放磁盘块，设置bitmap，标记指定磁盘块位空闲：</p><ol><li>使用<code>bread</code>通过inode读取文件的磁盘上<strong>bitmap块</strong>，并缓存了buffer cache的节点</li><li>更改<strong>bmap块</strong>的指定文件数据块号的位的值，将指定位设置为9。例如要删除<code>block number = 60</code>的块，只需要将第一个<code>bitmap</code>块(<code>60/(1024*80) = 0</code>，使用<strong>BBLOCK</strong>计算)上，第8个字节(<code>60/8 = 7</code>，使用<strong>BPB</strong>计算，字符数组从0开始计数)，将第8个字节上的第5个位(<code>60%8 = 4</code>，同样是从0开始)，设置为0就可以了。</li><li>调用<code>log_write</code>，将该inode块的写入操作添加到log header。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE   1024</span></span><br><span class="line"><span class="comment">//计算得出bitmap磁盘的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span></span><br><span class="line"><span class="comment">//一个字节8位，可以标识1024 * 8 个数据块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB           (BSIZE*8)</span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line">  </span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  <span class="comment">//获取数据块号的处于的位数</span></span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  <span class="comment">//标记到一个字节中</span></span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;<span class="comment">//将指定bitmap字节上的数据块位设置为0</span></span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>balloc</strong>：分配磁盘块，设置bitmap，标记指定磁盘块已分配：</p><p>这个函数于<code>bfree</code>函数的实现思路相同，都是操作<strong>bitmap块</strong>，只不过效果是相反的，这里就不过多阐述了。</p><h2 id="代码：Inode分配"><a href="#代码：Inode分配" class="headerlink" title="代码：Inode分配"></a>代码：Inode分配</h2><blockquote><p><strong>in-memory inode</strong></p></blockquote><p>在buffer cache中保存的inode块是直接拷贝的磁盘上的inode块，但是在为了方便<strong>并发控制</strong>以及inode数据操作，xv6中设计inode层上使用的inode结构，如下所示，添加了一些字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// 磁盘设备编号</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode编号</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// 引用计数，有多少进程使用该inode</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">//包含inode的不变量</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode是否已经从磁盘上读取</span></span><br><span class="line">  <span class="comment">//以下字段是完全拷贝于磁盘inode块</span></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分配新的indoe</strong></p></blockquote><p>​    首先xv6调用<code>ialloc</code>，这个函数与<code>balloc</code>相同：如下图所示，遍历磁盘上的所有inode节点，寻找到空闲的inode后，写入inode类型到磁盘，然后通过调用<code>iget</code>从inode表中返回一个条目。<code>ialloc</code>必须确定只有一个进程持有对<code>bp</code>的引用，并且要确定这个过程的<strong>原子性</strong>，不能同时的被其他进程看见这个inode是可获取的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="comment">// Inodes per block.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"><span class="comment">// Block containing inode i</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="comment">//buffer cache保存的inode块的结构是磁盘上的结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    <span class="comment">//bp-&gt;data字段保存的是一个inode磁盘块</span></span><br><span class="line">    <span class="comment">//加inum%IPB就能找到指定的磁盘块上的inode</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ialloc: no inodes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接着看看如何通过<code>iget</code>将空闲的inode加入inode表(内存的保存的结构)。首先遍历整个inode表，如果这个inode以及存在(<code>ip-&gt;ref&gt;0</code>)于inode表中则添加引用计数，并将其inode返回，反之将记录一个空闲inode，退出循环后，分配inode表中这个inode槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already in the table?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;itable.inode[<span class="number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;itable.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//write info to itable&#x27;s inode entry</span></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上过程便是<code>ialloc</code>分配ialloc过程，，将磁盘的inode块读取到<code>buffer cache</code>中，并从<code>buffer cache</code>获取一个空闲inode，将其记录到inode表中，并返回这个inode地址。</p><p>​    如果你看过创建文件的代码后，就可以知道在用户使用<code>open</code>系统调用时，进入内核便会调用<code>create</code>创建文件，接着会调用<code>ialloc</code>为该文件分配inode。</p><blockquote><p><strong>inode锁</strong></p></blockquote><p>在读取或写入inode的元数据或内容之前，必须使用锁来预防数据竞争。inode锁的使用方式是<code>ilock</code>与<code>unilock</code>。</p><ul><li><p><code>ilock</code>使用睡眠锁(sleep-lock)保护inode。一旦ilock独占的访问inode，如果需要就可以<strong>向磁盘读取</strong>(更多的是向buffer cache读取)inode。</p></li><li><p><code>iunlock</code>释放睡眠锁，可以让唤醒一个因等待该inode资源的进程。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">....<span class="comment">//读取buffer cache，并更新inode表中的inode数据</span></span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码：Inode释放"><a href="#代码：Inode释放" class="headerlink" title="代码：Inode释放"></a>代码：Inode释放</h2><blockquote><p><strong>iput</strong>：释放inode</p></blockquote><ul><li><code>iput</code>：如果inode没有其他指针引用(<code>ip-&gt;ref == 1)</code>并且没有目录链接(<code>ip-&gt;nlink == 0</code>)，这个块将会被释放。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 代表没有其他进程将该inode锁定</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;itable.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>itruc</strong>：释放inode指向的文件数据</p></blockquote><p><code>itrunc</code>：在iput中会调用该函数，将文件<strong>截断</strong>为0字节，<strong>释放数据块</strong>，将inode的<code>type</code>字段设置为0(代表该inode未分配)，最后将inode写回磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line">  <span class="comment">//查找直接引用的数据块进行释放</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找间接引用的数据块进行释放</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>iput</strong>：锁与类似于锁的机制</p></blockquote><p>接着研究<code>iput</code>是如何释放inode锁定协议的，主要运用了两个锁和两个类似于锁的机制机制解决。</p><p>​    首先第一个问题是，并发线程为了使用inode可能会在<code>ilock</code>等待，并且没有发现这个inode不会再被分配，就是没有在并发线程知道的情况下释放了inode，但是这不会发生，主要是因为如果inode没有目录链接(<code>ip-&gt;link == 0</code>)并且<code>ip-&gt;ref == 1</code>，系统调用没有方法获取内存inode的指针。而且唯一的引用还是调用<code>iput</code>的线程的引用数，所以调用iput之后检查<strong>inode的引用计数</strong>是否在<code>itable.lock</code>的关键区之外，但是此时链接数量为0，所以说明没有其他线程尝试获取这个inode。</p><p>​    另一个点是，并发调用<code>ialloc</code>可能会选择<strong>相同</strong>的并且<strong>正在</strong>被<code>iput</code>释放的inode，这个只可能发生在<code>iupdate</code>写入inode到磁盘之后，这时inode的type字段为0。但是这个数据竞争是良性的，分配inode的线程在读取或写入inode之前，会等待以获取inode的睡眠锁，直到<code>iput</code>释放。</p><p>​    <code>iput</code>可以写入磁盘，这也就意味这任何系统调用会使用文件系统写入磁盘，因为系统调用可能是最后一个文件引用的调用。<code>read</code>系统调用以只读的方式读取文件都会在结束之前调用<code>iput</code>，这就意味则所有的文件系统调用将会封装到事务中。</p><blockquote><p><strong>挑战</strong>：crash与iput</p></blockquote><p>​    <strong>问题</strong>：crash与iput的交互是一个挑战，因为一些进程可能持有内存inode的引用，所以iput当文件的链接数为0时也不会立即的截断一个文件。但是如果<strong>crash</strong>发生在最后一个进程关闭文件文件描述符之前，然后文件才被标记，但该文件已经分配到磁盘但是没有目录条目指向这个文件，在内存inode写回磁盘时crash，就会有磁盘中有残留的文件数据。</p><p>文件系统解决上述问题，主要有两种方式：</p><ol><li>从<strong>恢复</strong>(recovery)方式上解决：在重启之后，文件系统扫描整个已经标记分配的文件，但是没有目录条目指向，此时只重新为文件添加目录条目就可以了。</li><li>从<strong>锁机制</strong>上解决：文件inode的inumber的链接计数下降到零，但是引用计数却不是零。如果当文件的引用计数到达文件系统删除文件，然后通过从列表删除inode更新磁盘列表。在恢复上，文件系统将会释放所有在list中文件。</li></ol><p>xv6没有实现上述两种方案，这也意味这上述的错误情况可能会发生在xv6中。</p><h2 id="代码：数据块分配"><a href="#代码：数据块分配" class="headerlink" title="代码：数据块分配"></a>代码：数据块分配</h2><p>​    在为文件添加数据时，通常会创建新的数据块。查看<code>write</code>系统调用，就可以知道创建数据块是调用了<code>bmap</code>函数，在<code>bmap</code>中调用了<code>balloc</code>函数就是用于创建数据块的。</p><blockquote><p><strong>bmap</strong>：查找数据块编号</p></blockquote><p>​    <code>bmap</code>函数中会分别使用<strong>直接地址指针</strong>与<strong>间接地址指针</strong>记录数据块号，这些指针记录于inode中。在xv6的文件系统中，<code>ip.addr[0:11]</code>是直接指针地址，<code>ip.addr[12]</code>是间接地址指针地址。<code>bn</code>是用于标记现在要写入数据的块，是该文件的第几个数据块。</p><ol><li><strong>查找直接地址</strong>：如果<code>bn&lt;NDIRECT</code>，说明所写的数据偏移是小于<code>1024*12</code> (12个块)的。查找该索引的地址是否存在，不存在使用<code>balloc</code>分配数据块，并将这个数据块的编号记录到<code>addr</code>数组中，反之返回addr保存的地址值。</li><li><strong>查找间接地址</strong>：如果<code>ip.addr[12]</code>存在，那么就可以直接读取这个保存数据块地址的<strong>地址块</strong>(address block，这个块也是一个数据块)，使用<code>balloc</code>分配数据块，并将其记录到地址块的指定索引中。反之不存在就使用<code>balloc</code>分配地址块。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint)) <span class="comment">// 地址块中256个数据块地址</span></span></span><br><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[bn] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;<span class="comment">//强转1024字符数组为包含256个整数的数据</span></span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>bmap</code>函数便<code>readi</code>与<code>writei</code>可以很方便的操作数据块了。</p><h1 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>​    在linux中目录(dircetory)被设计得像<strong>文件</strong>一样，本质上就是文件加上一些文件系统能够理解的<strong>数据结构</strong>。在inode中的<code>type</code>字段为<code>T_DTR</code>则说明是一个目录，并且这个inode会保存<strong>目录条目</strong>，可以是文件或子目录，这些目录条目则保存在目录inode的<strong>地址指针指向的数据块</strong>中。</p><p>每一个目录都会包含多个目录条目，如下结构体便是目录条目(directory entry)。长度为16字节，分为如下两个字段：</p><ul><li><code>inum</code>(2B)：子目录的inode编号；</li><li><code>name</code>(14B)：文件或者子目录的名称。</li></ul><p>由此可知一个数据块能够保存<code>1024/16 = 64</code>个目录条目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来介绍以下与目录相关的代码。</p><h2 id="代码：directory-layer"><a href="#代码：directory-layer" class="headerlink" title="代码：directory layer"></a>代码：directory layer</h2><blockquote><p><strong>dirlookup</strong>：查找指定文件</p></blockquote><p>​    通过指定的名字在<strong>目录inode</strong>中查找对应的目录条目，如果找到指定的目录条目就将返回对应的<strong>文件inode指针</strong>，将<code>*poff</code>设置为当前的目录条目偏移量，以便调用函数可以修改这个条目，最后通过<code>iget</code>返回一个未锁定的inode指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>dirlink</strong>：添加文件inode到目录inode中</p></blockquote><p>​    在使用<code>open</code>创建文件时会使用到该函数，通过传递给定的名称和i-number作为一个<strong>目录条目</strong>到目录inode(<code>dp</code>)中。主要步骤如下：</p><ol><li><code>dirlookup</code>判断要添加的目录条目inode是否已经存在于当前目录inode中，存在的话则返回一个错误。</li><li>遍历<code>dp</code>指向的保存目录条目的数据块，寻找一个数据块中是否有空闲的目录条目节点，若找到则跳出循环。</li><li>将传递的参数写入空闲目录条目中，再将目录条目写回数据块。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h1><h2 id="代码：Path-names"><a href="#代码：Path-names" class="headerlink" title="代码：Path names"></a>代码：Path names</h2><p>​    在操作文件的时会涉及一系列的路径名，如相对路径、绝对路径、当前路径等。只有指定了正确的路径名我们才能打开正确的文件，因此通过路径查询文件也是十分重要的功能，在xv6也提供了路径名解析的函数：</p><blockquote><p><strong>namei</strong>：解析路径名并返回指定的inode</p></blockquote><p>​    <code>namei</code>是输入一个路径名参数，以此解析路径获得文件inode。如：输入<code>/a/b/c</code>，那么获得的就是文件c的inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>nameiparent</strong>：返回文件父目录的inode</p></blockquote><p>​    <code>nameiparent</code>是<code>namei</code>函数的变种，与其不同的是需要输入两个参数，会返回<strong>父目录的inode</strong>并将路径名的最后一个元素保存到name中。例如输入<code>/a/b/c</code>，name就是c这个文件，而inode则是<code>/a/b</code>这个目录inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>namex</strong>：解析路径函数</p></blockquote><p>​    <code>namex</code>是<code>namei</code>与<code>nameiparent</code>函数的广义的函数，实际上所有的解析操作由<code>namex</code>完成。接着按照流程解释一下namex构成：</p><ol><li>判断路径名开始字符，确定路径名，如果是以<code>&#39;/&#39;</code>开始就是<strong>绝对路径</strong>，为开始读取根inode)，反之是<strong>当前路径</strong>，读取当前进程的inode。以此获得目录inode。</li><li>循环执行<code>skipelem</code>函数，解析路径名称跳过一些目录或者重复的元素(如<code>&#39;/&#39;</code>字符)。</li><li>如果<code>path=/a/b/c</code>，经过<code>skipelem</code>调用后<code>path=b/c</code>。显然path并不为0则进入循环，在循环内部首先检查ip这个inode是否为目录，如果不是则调用<code>iunlockput</code>函数释放inode。再判断调用者是否为<code>nameiparent</code>函数并且<code>path</code>是否为0，是的话则返回这个目录inode。</li><li>判断文件名(<code>name = /b/c</code>)是否在目录inode(根目录<code>/</code>)中存在，如果存在获取<code>/a/b/</code>目录的inode，并将ip设置为当前inode。</li></ol><p>以<code>/a/b/c</code>为例，那么第一次循环<code>path = b/c,name = a ip = a/</code>，第二次循环<code>path = c，name = c ip = b/</code>，第三次循环<code>path = 0,name = c</code>，退出循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line">  <span class="comment">//如///a//b/c，那么第一次调用skipelem函数 path = b/c，name= a。</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>​    Unix设计中比较意思的方面就是在Unix中的大部分资源都可以表示成为<strong>文件</strong>，包括设备(console)，管道，文件。File descriptor layer则是将所有资源统一为文件的层，体现了<strong>一致性</strong>(uniformity).</p><p>​    <strong>文件描述符</strong>从数据类型的视角来看就是一个整型<strong>int</strong>，通过文件描述符我们就可以调用<code>write</code>或<code>read</code>方法去操作文件资源。但是文件描述符的背后的数据结构并不是一个整型所能表述的，文件描述符是通过<strong>层层抽象</strong>得到一个简易的可以操作文件资源的<strong>句柄</strong>，实际原理是将文件的inode与文件描述符通过内核制作成了一个映射。</p><p>​    那么在xv6是如何通过文件inode一步步生成文件描述符，又是如何通过文件描述符操作文件的，接着学习一下有关File descriptor layer的代码。</p><h2 id="代码：文件结构"><a href="#代码：文件结构" class="headerlink" title="代码：文件结构"></a>代码：文件结构</h2><blockquote><p>1.<strong>进程结构</strong></p></blockquote><p>进程的结构体代码，我们会发现proc结构体有两个关于文件的字段：</p><ul><li><strong>ofile</strong>：表示进程<strong>已打开</strong>的文件或文件描述符表，每一个file结构对应一个文件描述符。那么NOFILE==16，也就代表xv6中能够一个进程最多能够打开16个文件。</li><li><strong>cmd</strong>：cmd代表当前进程的<strong>文件目录</strong>的inode。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ....<span class="comment">//有关文件系统的字段</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFILE       16  <span class="comment">// open files per process</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.<strong>文件结构</strong>：保持Unix资源一致性</p></blockquote><p>​    在xv6内核中，为了方便<strong>管理</strong>文件、设备、管道等资源、将这些资源抽象<strong>一致化为文件</strong>，设计成为了file结构体。</p><p>​    每个打开的文件都由一个<code>struct file</code> 表示，对 <strong>inode</strong>或<strong>管道</strong>以及 I/O 偏移量等元数据的封装，不同类型的资源可以使用type字段进行标识。在用户进程每次调用open系统调用创建新文件的过程，就是创建一个新的<code>struct file</code>。file结构在多进程同样也可以很好的协调：</p><ul><li><p>如果多进程独立打开同一个文件，不同的实例的I/O偏移量也不同</p></li><li><p>另一方面，一个打开的文件可以多次出现在一个或多个进程的文件表中，如果一个进程使用 open 打开文件，然后使用 <code>dup</code> 创建别名(单进程文件表)，或使用 <code>fork</code> (多进程文件表)与子进程共享，就会出现这种情况。</p></li></ul><p>文件结构体代码，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="comment">//枚举文件类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// 记录打开文件的引用数量。</span></span><br><span class="line">  <span class="type">char</span> readable; <span class="comment">//表示文件是否可读</span></span><br><span class="line">  <span class="type">char</span> writable; <span class="comment">//表示文件是否可写</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// 记录当前文件管道</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// IO的偏移量</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>3.<strong>全局文件表</strong>：</p></blockquote><p>​    所有以打开的文件，都会保存在系统的全局文件表中(<code>ftable</code>)，在<code>ftable</code>中提供多个函数接口给内核，用于操作全局文件表：</p><ul><li><code>filealloc</code>：分配文件。</li><li><code>filedup</code>：创建重复的文件引用，增加文件引用数。</li><li><code>fileclose</code>：释放文件引用，当引用数为0，释放文件。</li><li><code>fileread、filewrite</code>：对文件进行读写。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----file.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br><span class="line">----param.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILE       100 </span></span><br></pre></td></tr></table></figure><p>全局文件表的主要作用：用于<strong>多进程</strong>之间文件实例的<strong>通信</strong>、内核可以更加方便的使用文件资源。</p><h2 id="代码：创建文件描述符fd"><a href="#代码：创建文件描述符fd" class="headerlink" title="代码：创建文件描述符fd"></a>代码：创建文件描述符fd</h2><blockquote><p>1.<strong>用户级</strong>文件操作示例</p></blockquote><p>​    如下所示，在用户程序中，可以使用<code>open</code>进行创建文件，并且获取文件描述符fd。那么fd就代表这个test1文件。之后我们便可以通过这个fd访问文件，使用<code>write</code>向test1文件写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----user/test1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test1&quot;</span>,O_CREATE|O_RDWR);</span><br><span class="line">    write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着以系统调用操作的顺序进行了解。为了不混淆文件之间的概念，在此先声明下文所提每一个词汇的所指向的实体：</p><ul><li><strong>文件实例</strong>：数据类型为<code>struct file</code>，已打开的文件在全局文件表中保存，其保存的inode字段指向了文件资源。</li><li><strong>文件资源</strong>：主要用于表示磁盘块上的文件数据，内核就是通过文件实例中的inode字段，访问到文件资源的。</li><li><strong>文件描述符</strong>：用户级的文件实例，数据类型为<code>int</code>，是简化过后了文件实例，作为进程文件表的索引。</li></ul><p>以上是笔者自己的表述(不包含设备和管道的描述)，可能有所毛病，如有错请指出。</p><blockquote><p>2.<strong>open</strong>：获取文件描述符</p></blockquote><ol><li>用户通过open系统调用输入的路径(<code>./test1</code>)，在sys_open创调用create函数，创建了当前目录下的文件(<strong>test1</strong>)的inode。</li><li>调用<code>filealloc</code>分配全局文件表，分配一个文件实例。</li><li>调用<code>fdalloc</code>将上述获取的文件实例转化成为<strong>文件描述符</strong>，这可以理解建立了映射。</li><li>设置文件实例的相关字段，这里主要是将<strong>test1</strong>文件的<code>inode</code>绑定到了文件实例上。</li><li>将文件描述符返回给用户。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  argint(<span class="number">1</span>, &amp;omode);</span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  ....<span class="comment">//创建(调用create)或查找目标文件路径的inode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">....<span class="comment">//错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....<span class="comment">//修改文件结构体对应的元数据</span></span><br><span class="line">  f-&gt;ip = ip;<span class="comment">//将文件结构的inode字段设置为目标文件inode</span></span><br><span class="line">  ....<span class="comment">//修改文件结构体对应的元数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.<strong>分配文件描述符</strong>：建立文件实例映射</p></blockquote><p>​    <code>fdalloc</code>函数：观察下述代码，主要是将全局的文件实例，分配给了当前进程，fd则是代表的是进程<strong>打开文件表(open file table)的索引</strong>。那么在此之后只要是该进程的用户进程就能够通过这个文件描述符，访问到对应的文件实例。原理就是简单的hash表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----sysfile</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程粗略的可以描述为下图：</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/fd_open.png" alt="fd_open"></p><h2 id="代码：通过fd修改文件资源"><a href="#代码：通过fd修改文件资源" class="headerlink" title="代码：通过fd修改文件资源"></a>代码：通过fd修改文件资源</h2><blockquote><p>4.<strong>write</strong>：通过文件描述符操作文件</p></blockquote><p>​    在通过<code>open</code>获得<strong>test1</strong>的文件描述符fd后，那么wrtie就可以通过fd去修改文件数据了。具体的过程就是通过<code>argfd</code>函数将fd转换为文件实例，在通过文件实例中保存的<strong>test1的inode</strong>字段，就可以对文件数据进行修改。</p><p>​    之后在调用<code>filewrite</code>就能够将write系统调用传入的字符或字符串，写入到test1文件中了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p;</span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">  argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.<strong>获取文件实例</strong>：根据文件描述符获取对应文件实例</p></blockquote><p>​    在前文也提到了，通过<code>argint</code>获取用户传递的fd，将fd作为当前进程结构的<code>ofile</code>字段的索引便能够得到<strong>文件实例</strong>，这样sys_write函数就能够获得<strong>文件实例</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">argfd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *pfd, <span class="keyword">struct</span> file **pf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  argint(n, &amp;fd);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  <span class="keyword">if</span>(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.<strong>修改文件资源</strong>：通过文件实例的inode字段，访问并修改文件资源。</p></blockquote><p>​    如下述代码所示，这里我们忽略掉设备和管道等文件类型，只关注inode文件操作。在代码中，<code>filewrite</code>函数调用了<code>writei</code>函数，注意到writei中将文件实例的inode字段作为参数进行传递，也就说明<code>writei</code>函数是根据<code>inode</code>对文件资源的描述，对文件资源进行修改的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....<span class="comment">//other file type</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">        <span class="comment">// error from writei</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    文件系统算是操作系统中代码量比较大的一个部分，在学习上也需要配合代码来理解。由于文件系统的体量比较庞大，在学习上也比较困难。在xv6中将文件系统抽象成了7个层面，通过每一层执行不同的功能，在通过操作系统的协调，由繁至简便能够更好的去理解文件系统。</p><p>​    在本章的学习过程中，比较难以理解的就是Buffer cache、Logging、Inode三个层面。其他的代码量也相对比较少，在此总结一下每一个层面的内容：</p><ol><li><strong>Disk layer</strong>：对磁盘数据资源按功能进行范围划分，有boot、super、log、inode、bitmap、data等类型的磁盘块，磁盘的两个扇区算作一个块。</li><li><strong>Buffer layer</strong>：将内存的一部分作为磁盘块的缓存区，加速CPU对磁盘数据的修改。在该层涉及到了双链表与LRU的操作，虽然简单，但还是比较值得学习的。</li><li><strong>Logging layer</strong>：提供数据库中的事务与日志概念，在xv6中实现log，主要是为了防止crash问题，以实现修改磁盘数据的原子性(数据库的概念)。</li><li><strong>Inode layer</strong>：Inode是描述<strong>文件</strong>的一个数据结构，通过inode可以获得文件的基本信息，在Inode层比较需要理解的就是文件指针(用于定位文件磁盘的数据块)、内存inode与磁盘inode的区别、以及内存inode的操作。</li><li><strong>Directory layer</strong>：通过目录的概念，将文件的存储设计成了分级树状的结构。</li><li><strong>Pathname layer</strong>：将一个文件路径名(如a/b/c)通过解析找到对应的文件(c)inode，对文件进行操作。</li><li><strong>File descriptor layer</strong>：将Unix大部分资源一致化，抽象化为<strong>文件</strong>形式(<code>struct file</code>)。提供给用户进程的一个文件实例，通过文件路径名并能够获得文件资源句柄，用户进程可以通过该句柄访问指定的文件进行操作。</li></ol><p>以上便是xv6文件系统的所有知识点了，建议在学习过程中配合源码进行理解。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab mmap</title>
      <link href="/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/"/>
      <url>/2023/07/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab10%EF%BC%9Ammap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/mmap.html">Lab: mmap</a></p></blockquote><p>实验开始之前需要将git分支切换到fs分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout mmap</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="Lab-mmap-hard"><a href="#Lab-mmap-hard" class="headerlink" title="Lab: mmap (hard)"></a>Lab: mmap (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">hard</a>)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    本次实验是实现<code>mmap</code>与<code>munmap</code>这两个系统调用，它们可用于在进程之间共享内存，将文件映射到进程地址空间，并作为<strong>用户级缺页</strong>方案。在本实验中，我们将向xv6添加<code>mmap</code>和<code>munmap</code>，重点关注<strong>内存映射文件</strong>。如果忘记了缺页是如何实现的可以回顾<a href="https://zhuanlan.zhihu.com/p/629442061">COW实验</a>。</p><p>​    如果你不知道<code>mmap</code>系统调用的相关作用以及标识的意义，那么可以在linux下使用<code>man</code>命令查看mmap文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash">man 2 mmap</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">MMAP(2)                                        Linux Programmer&#x27;s Manual                                       MMAP(2)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       mmap, munmap - map or unmap files or devices into memory</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">       void *mmap(void *addr, size_t length, int prot, int flags,</span><br><span class="line">                  int fd, off_t offset);</span><br><span class="line">       int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure><p>如果觉得阅读man的英文手册困难的话可以，查看中文版的手册<a href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/mmap.2.html">MMAP - Linux手册页-之路教程 (onitroad.com)</a>。觉得麻烦的话可以直接看<a href="##mmap解析">mmap解析</a>部分</p><blockquote><p><strong>任务</strong>：实现<code>mmap</code>与<code>munmap</code>的基本功能，以至于能够通过<code>mmaptest</code>的测试，多余的功能并不需要我们去实现</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mmaptest</span></span><br><span class="line">mmap_test starting</span><br><span class="line">test mmap f</span><br><span class="line">test mmap f: OK</span><br><span class="line">test mmap private</span><br><span class="line">test mmap private: OK</span><br><span class="line">test mmap read-only</span><br><span class="line">test mmap read-only: OK</span><br><span class="line">test mmap read/write</span><br><span class="line">test mmap read/write: OK</span><br><span class="line">test mmap dirty</span><br><span class="line">test mmap dirty: OK</span><br><span class="line">test not-mapped unmap</span><br><span class="line">test not-mapped unmap: OK</span><br><span class="line">test mmap two files</span><br><span class="line">test mmap two files: OK</span><br><span class="line">mmap_test: ALL OK</span><br><span class="line">fork_test starting</span><br><span class="line">fork_test OK</span><br><span class="line">mmaptest: all tests succeeded</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertests -q</span></span><br><span class="line">usertests starting</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>HINS</strong>：参照实验文档自行阅读，一定要阅读！！！</p></blockquote><h2 id="mmap解析"><a href="#mmap解析" class="headerlink" title="mmap解析"></a>mmap解析</h2><blockquote><p>mmap系统调用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p><code>mmap</code>可以通过多种方式调用，但本实验只需要其与内存映射文件相关的功能的子集。依次介绍以下每个参数的意思。<code>mmap</code>返回该地址，如果失败，则返回0xffffffffffffffffffff，也就是-1。以下是每个参数的涵义：</p><ul><li><code>addr</code>：如果<code>addr</code>始终为零，这意味着<strong>内核</strong>应该决定映射文件的虚拟地址。</li><li><code>length</code>：要映射的字节数；它可能与文件的长度不同。</li><li><code>prot</code>：内存是否应该映射为可读、可写和/或可执行的，在fcntl.h中有所定义。</li><li><code>flags</code>：在实验中有两个参数<code>MAP_SHARED</code>与<code>MAP_PRIVATE</code>。</li><li><code>fd</code>：文件描述符</li><li><code>offset</code>：文件中要映射的起点。</li></ul><p>接着详细讲解以下<strong>flags</strong>参数的两个宏：</p><p>​    <code>MAP_PRIVATE</code>,对映射区域的修改只对当前进程可见，不会影响磁盘上的原始文件，也就是释放内存后，<strong>不会将修改的数据写回磁盘文件</strong>中。如果要将自己在内存上对文件的修改写入文件，就需要在取消映射前，显式的调用write将数据写回。</p><p>​    <code>MAP_SHARED</code>代表共享同一段物理内存，并且对内存区域修改后，munmap释放内存后，会写回磁盘文件中。可以实现<strong>多进程之间的数据共享和通信</strong>。</p><p>​    如下图所示，分别创建了两个进程，pid=5是pid=4的子进程。在pid=4中调用了两次相同参数的<code>MAP_SHARED</code>的mmap系统调用，返回的用户内存地址分别为p1与p2，可以发现这两个VMA(virtual memory area)是用户内存区域，不同的两个区域映射在了同一个物理内存上。那么使用fork创建子进程，也会映射在与父进程一样的物理内存区域。</p><p>​    <img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/mmap2.png" alt="mmap2"></p><p>但是实验文档中提醒到，It’s OK if processes that map the same <code>MAP_SHARED</code> file do <strong>not</strong> share physical pages，也就是在测试程序中并不要求我们共享物理内存。那么我们在实验中实验的内存映射就如下图所示。包括使用fork创建后，我们也不需要共享物理页。(共享物理页在challenge中会要求实现)</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230726141038789.png" alt="image-20230726141038789"></p><blockquote><p>munmap系统调用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><code>munmap</code>(addr，length)应删除指定地址范围中的<code>mmap</code>映射。如果进程修改了内存并将其映射为<code>MAP_SHARED</code>，则应首先将<strong>修改写入文件</strong>。</p><p>​    <code>munmap</code>调用可能只覆盖mmap-ed区域的一部分，但您可以假设它将在开始或结束时取消映射，或取消整个区域。但是不能只取消中间的一部分(挖一个洞)，如下图所示，这样会导致内存释放(exit函数)的困难，有可能造成内存泄漏。所以通常是从<strong>映射的开头</strong>，开始取消映射到指定位置；或者是从指定位置，取消到映射的结束位置，这种情况也就需要代码控制。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/mmap3.png" alt="mmap3"></p><blockquote><p>mmap内存映射机制</p></blockquote><p>对于用户进程空间，我们该在哪里开始分配虚拟页？目前有两种方案：</p><ol><li>从proc结构体的sz字段开始分配，<a href="https://zhuanlan.zhihu.com/p/632790156">XV6：陷阱 - 知乎 (zhihu.com)</a>的lazy alloation中又所解释，也就是从<strong>堆空间往上</strong>开始分配。但是这种实现方式会有缺陷，sz字段是与堆空间分配有关的字段，会导致内存分配出现冲突。</li><li>从顶部往下分配，也就是在<code>TRAPFRAM</code>页往下分配，用户进程空间是很大的空间(2^64^字节)，所以从顶部往下开始分配也不会造成什么冲突。</li></ol><p>在本次实验中，使用的方案也是从顶部往下开始分配。</p><blockquote><p>VMA结构</p></blockquote><p>​    再来讨论一下VMA结构，在实验文档中提到lecture15有所提及VMA，但是我并没有看到。于是我去搜索了linux下的<strong>VMA</strong>结构，于是定义了<strong>HINS</strong>中所提到的VMA结构。</p><p>​    如下面代码所示，实际上还是比较简单的，就是在<code>proc</code>结构体中定义一个VMA数组用于mmap，这样的好处是，在调用munmap与触发缺页时，我们都能够找到mmap的相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----proc.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> vaild;</span><br><span class="line">  <span class="comment">//mmap参数</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint64 len;</span><br><span class="line">  <span class="type">int</span> perm;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mapped;  <span class="comment">//是否触发缺页</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> <span class="title">mmap</span>[<span class="title">NMMAPVMA</span>];</span> <span class="comment">// 记录mmap信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现：mmap"><a href="#实现：mmap" class="headerlink" title="实现：mmap"></a>实现：mmap</h2><blockquote><p>添加系统调用接口</p></blockquote><p>老生常谈的在实验前添加系统调用接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----syscall.c</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">....</span><br><span class="line">    [SYS_mmap]    sys_mmap,</span><br><span class="line">[SYS_munmap]  sys_munmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----syscall.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mmap   22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_munmap 23</span></span><br><span class="line">    </span><br><span class="line">----user.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">size_t</span>; <span class="comment">// unsigned long int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 <span class="type">off_t</span>;  <span class="comment">// long int</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>,<span class="type">int</span>, <span class="type">off_t</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span>;</span><br><span class="line"></span><br><span class="line">----usys.pl</span><br><span class="line"><span class="title function_">entry</span><span class="params">(<span class="string">&quot;mmap&quot;</span>)</span>;</span><br><span class="line">entry(<span class="string">&quot;munmap&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>初始化VMA字段</p></blockquote><p>​    在分配进程时需要初始化VMA的一些字段，特别是vaild与mapped字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  .... </span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NMMAPVMA; i++)&#123;</span><br><span class="line">    p-&gt;mmap[i].vaild = <span class="number">0</span>;</span><br><span class="line">    p-&gt;mmap[i].mapped = <span class="number">0</span>;</span><br><span class="line">    p-&gt;mmap[i].va = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mmap函数</p></blockquote><p>​    接着实现<code>mmap</code>系统调用，主要流程如下：</p><ol><li>使用arg相关函数获得系统调用的6个参数；</li><li>在建立映射前，处理一些参数错误的状态；</li><li>在实验中我们只处理addr参数为0的映射，也就是内核来分配用户虚拟内存。需要在进程结构体中获得mmap字段(VMA数组)，从中找到一个空的VMA结构用于记录mmap的信息。</li><li>使用<code>find_freespace</code>函数查找空闲的虚拟内存地址值</li><li>初始化VMA结构，并且将VMA结构中的<code>struct file*</code>的<code>ref</code>字段增加(使用filedup函数)，防止文件提前释放。初始化时要注意perm字段的标识是<code>perm&lt;&lt;1 | PTE_U</code>，添加PTE_U是让用户进程能够访问，而<code>perm&lt;&lt;1</code>是PTE的权限位与mmap权限位之间的逻辑关系，就是往左移一位即可。</li><li>返回VMA的<code>addr</code>字段的值，这个值就是我们建立映射的虚拟内存的底部值，<code>addr + len</code>字段就是虚拟内存整个映射区域。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr,len;</span><br><span class="line">  <span class="type">int</span> prot,flags,fd,off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">4</span>,&amp;fd,&amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;addr);argaddr(<span class="number">1</span>,&amp;len);argint(<span class="number">2</span>,&amp;prot);</span><br><span class="line">  argint(<span class="number">3</span>,&amp;flags);argint(<span class="number">5</span>,&amp;off);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//open是以只读形式打开文件的时候，</span></span><br><span class="line">  <span class="comment">//mmap以MAP_SHARED和PROT_WRITE方式进行映射是会出现错误的，在</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == O_RDONLY &amp;&amp; </span><br><span class="line">    (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 va;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(addr == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> *<span class="title">empty</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NMMAPVMA ; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;mmap[i].vaild == <span class="number">0</span>)&#123;</span><br><span class="line">        empty = &amp;p-&gt;mmap[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((va = find_freespace(p-&gt;mmap,len))==<span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;mmap 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化VMA</span></span><br><span class="line">    empty-&gt;vaild = <span class="number">1</span>;</span><br><span class="line">    empty-&gt;f = f;</span><br><span class="line">    empty-&gt;flags = flags;</span><br><span class="line">    empty-&gt;len = len;</span><br><span class="line">    empty-&gt;off = off;</span><br><span class="line">    empty-&gt;perm = prot &lt;&lt; <span class="number">1</span> | PTE_U;</span><br><span class="line">    empty-&gt;addr = va;</span><br><span class="line"></span><br><span class="line">    filedup(empty-&gt;f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> empty-&gt;addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>find_freespace</code>函数，用于查找空闲的符合条件的虚拟地址空间区域，这里我的实现是比较简单的。主要是使用了线性查找，由于VMA数组的<code>addr</code>字段是没有经过排序的，当出现VMA数组中保存的内存区域范围不匹配，更换地址范围，直到遍历完整个<code>VMA</code>数组。</p><p>​    其实这样的实现仍会有问题，就是VMA地址字段没有排序的问题，这样会导致地址是乱序的导致范围覆盖，由于mmap_test的测试简单也就没啥问题，如果严谨的话还是排序一下。</p><p>​    如下所示我们虚拟空间的范围是从TRAPFRAME页底部开始作为<code>top</code>的，<code>bottom</code>则是<code>TRAPFRAM-len</code>，通过下面循环便可以实现虚拟空闲地址分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">find_freespace</span><span class="params">(<span class="keyword">struct</span> vm_area m[],uint64 len)</span>&#123;</span><br><span class="line">  uint64 top = TRAPFRAME,bottom = TRAPFRAME-len;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NMMAPVMA ; i++)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(m[i].vaild == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(top &lt;= (m[i].addr+m[i].len) || bottom &lt;= m[i].addr)&#123;</span><br><span class="line">      top = m[i].addr;</span><br><span class="line">      bottom = top - len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现：mmap缺页handler"><a href="#实现：mmap缺页handler" class="headerlink" title="实现：mmap缺页handler"></a>实现：mmap缺页handler</h2><p>​    通过mmap返回一个虚拟地址后，如果在用户空间使用这个地址就会出现这样的问题，通过scause寄存器可以直到是一个加载页错误(load page fault)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usertrap(): unexpected scause 0x000000000000000d pid=3</span><br><span class="line">            sepc=0x0000000000000076 stval=0x0000003fffffc000</span><br></pre></td></tr></table></figure><p>​    </p><p>​    按照COW实验的做法，我们就需要修改<code>usertrap</code>函数，在其中添加<code>scause=13</code>的判断，如下所示处理mmap缺页，首先是通过stval的地址(缺页异常的虚拟地址值)找到对应的VMA，并调用<code>mmap_fault</code>函数处理mmap缺页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----def.h</span><br><span class="line"><span class="type">int</span>             <span class="title function_">mmap_fault</span><span class="params">(<span class="type">pagetable_t</span>,uint64)</span>;</span><br><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(va &gt; MAXVA)</span><br><span class="line">        panic(<span class="string">&quot;mmap:out of mem&quot;</span>);</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap fault va = %p\n&quot;</span>,va);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NMMAPVMA; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;mmap[i].vaild == <span class="number">1</span> &amp;&amp; p-&gt;mmap[i].addr &lt;= va &amp;&amp; </span><br><span class="line">          va &lt; (p-&gt;mmap[i].addr + p-&gt;mmap[i].len))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;mmap[i].vaild == <span class="number">0</span> &amp;&amp; p-&gt;mmap[i].addr == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;mmap_fault&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmap_fault(p-&gt;pagetable,(uint64)&amp;p-&gt;mmap[i],va)&lt;<span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mmap_fault</code>函数的实现并不是很难，主要又几个容易造成困惑的地方：</p><ul><li>使用readi读取数据时，以<code>m-&gt;f-&gt;off</code>为偏移，开始读取文件数据，这时候的问题时，在使用writei写入数据时会修改<code>m-&gt;f-&gt;off</code>的值，导致文件指针一直处于尾部，导致我们读取不到数据，所以应该采用应该临时的<code>off</code>从<code>m-&gt;off</code>开始读取文件数据。</li><li>使用<code>mappages</code>的时候不能够一下将所有物理页进行映射，原因就是使用<code>kalloc</code>分配物理页可能并不是连续的，在并发的时候会导致不连续的问题，所有需要采取<code>kalloc</code>分配一个物理页就映射一个页。</li></ul><p><code>mmap_fault</code>的实现如下所示，并且需要标记这个VMA的<code>mapped</code>字段，是否触发缺页，这样就可以方便我们释放物理页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">mmap_fault</span><span class="params">(<span class="type">pagetable_t</span> pt,uint64 mmap)</span>&#123;</span><br><span class="line">  <span class="type">int</span> r,i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> *<span class="title">m</span> =</span> (<span class="keyword">struct</span> vm_area*)mmap;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> m-&gt;f;</span><br><span class="line"></span><br><span class="line">  uint64 pa,tva = m-&gt;addr + m-&gt;off;</span><br><span class="line">  </span><br><span class="line">  uint roff = m-&gt;off; <span class="comment">//m-&gt;off开始读取inode数据</span></span><br><span class="line">  </span><br><span class="line">  m-&gt;mapped = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m-&gt;len &amp;&amp; tva &lt; (m-&gt;addr + m-&gt;len);i += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">//分配内存地址，可能不是连续的，因此可以一页一页的分配，并建立映射</span></span><br><span class="line">    <span class="keyword">if</span>((pa = (uint64)kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)pa,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件内容拷贝到内核区</span></span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">0</span>, pa, roff, PGSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        roff += r; <span class="comment">//write已经修改了文件的off字段，</span></span><br><span class="line">        <span class="comment">//再使用off读取会导致读取不到数据</span></span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立映射</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pt, tva, PGSIZE, pa, m-&gt;perm) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tva += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现：munmap"><a href="#实现：munmap" class="headerlink" title="实现：munmap"></a>实现：munmap</h2><p>​    <code>munmap</code>的实现如下所示，释放过程主要分为两个部分：刚好能够释放完或释放一部分，但是不能在用户映射区域”挖一个洞”。</p><p>​    通过<code>munmap</code>的addr参数，找到指定的VMA结构，通过判断参数len与VMA的len确定是否能够完全释放。</p><ol><li>能够完全释放，这就比较简单，直接使用<code>uvmunmap</code>函数将所有页面释放，并清除物理页，将<code>struct file*</code>字段的<code>ref</code>引用数减一，并清空VMA结构体。</li><li>不能够完全释放，判断<code>addr</code>是否从VMA映射的起始位置开始释放。如果<code>addr = m-&gt;addr</code>，就需要对应的修改<code>len</code>与<code>addr</code>字段；反之，将<code>addr</code>以后的映射区域全部取消。</li></ol><p>如果VMA的<code>flags</code>标记为<code>MAP_SHARED</code>，那么在释放前就需要调用writei将物理内存页的修改值写回磁盘文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 va,len;</span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;va);</span><br><span class="line">  argaddr(<span class="number">1</span>,&amp;len);</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area</span> *<span class="title">m</span> =</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NMMAPVMA ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mmap[i].vaild == <span class="number">1</span> &amp;&amp; p-&gt;mmap[i].addr &lt;= va &amp;&amp; </span><br><span class="line">         va &lt; p-&gt;mmap[i].addr+p-&gt;mmap[i].len)&#123;</span><br><span class="line">      m = &amp;p-&gt;mmap[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((m-&gt;len - len) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m-&gt;flags&amp;MAP_SHARED)&#123;</span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(m-&gt;f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span>(writei(m-&gt;f-&gt;ip,<span class="number">1</span>,va,<span class="number">0</span>,m-&gt;len) != m-&gt;len)</span><br><span class="line">        panic(<span class="string">&quot;writei&quot;</span>);</span><br><span class="line">      iunlock(m-&gt;f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m-&gt;f-&gt;ref--;</span><br><span class="line">    m-&gt;f-&gt;off = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//off以上是已经分配的虚拟页</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable,va,len/PGSIZE,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)m,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vm_area));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m-&gt;flags&amp;MAP_SHARED)&#123;</span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(m-&gt;f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span>(writei(m-&gt;f-&gt;ip,<span class="number">1</span>,va,<span class="number">0</span>,len) != len)</span><br><span class="line">        panic(<span class="string">&quot;writei&quot;</span>);</span><br><span class="line">      iunlock(m-&gt;f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(va != m-&gt;addr)&#123;</span><br><span class="line">      <span class="comment">//防止虚拟内存区域出现漏洞</span></span><br><span class="line">      len = m-&gt;len - (va - m-&gt;addr);</span><br><span class="line">      uvmunmap(p-&gt;pagetable, va, len/PGSIZE, <span class="number">1</span>);</span><br><span class="line">      m-&gt;len = m-&gt;len - len;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">      uvmunmap(p-&gt;pagetable, va, len/PGSIZE, <span class="number">1</span>);</span><br><span class="line">      m-&gt;len -= PGROUNDUP(len);</span><br><span class="line">      m-&gt;addr += PGROUNDUP(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现：fork与exit"><a href="#实现：fork与exit" class="headerlink" title="实现：fork与exit"></a>实现：fork与exit</h2><p>​    根据<strong>HINS</strong>提示，我们需要在<code>exit</code>中释放未释放的mmap的映射区域，这时候mapped字段就会起到作用了，只有在触发缺页分配了物理空间后，<code>exit</code>才会将其mmap区域释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----proc.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NMMAPVMA;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mmap[i].vaild &amp;&amp; p-&gt;mmap[i].mapped)</span><br><span class="line">      uvmunmap(p-&gt;pagetable,p-&gt;mmap[i].addr,p-&gt;mmap[i].len/PGSIZE,<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    再根据提示，我们对<code>fork</code>进行修改，只需要增加父进程的VMA结构的文件的引用数，并将其拷贝到子进程就可以了，此时再次运行<code>mmap_test</code>，我们的<code>fork_test</code>就可以通过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----proc.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NMMAPVMA ;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mmap[i].vaild)&#123;</span><br><span class="line">      filedup(p-&gt;mmap[i].f);</span><br><span class="line">      np-&gt;mmap[i] = p-&gt;mmap[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    完成以上的修改便能够通过<code>mmaptest</code>的测试了，实现结果如下所示。本次实验总体来说并不是很难，但是很全面，包括了内存分配、页表映射、陷阱、缺页、文件读写等等内容。在做这个实验之前再复习一下cow实验，解决起来是没太大问题的。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/mmap_result.png" alt="mmap_result"></p><p>​    这个实验本身只是一个综合性的实验，对于mmap大部分细节都没有设计到，如果想要更加的深入实现的话可以尝试解决<strong>challenges</strong>部分。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ul><li>If two processes have the same file mmap-ed (as in <code>fork_test</code>), share their physical pages. You will need reference counts on physical pages.</li><li>Your solution probably allocates a new physical page for each page read from the mmap-ed file, even though the data is also in kernel memory in the buffer cache. Modify your implementation to use that physical memory, instead of allocating a new page. This requires that file blocks be the same size as pages (set <code>BSIZE</code> to 4096). You will need to pin mmap-ed blocks into the buffer cache. You will need worry about reference counts.</li><li>Remove redundancy between your implementation for lazy allocation and your implementation of mmap-ed files. (Hint: create a VMA for the lazy allocation area.)</li><li>Modify <code>exec</code> to use a VMA for different sections of the binary so that you get on-demand-paged executables. This will make starting programs faster, because <code>exec</code> will not have to read any data from the file system.</li><li>Implement page-out and page-in: have the kernel move some parts of processes to disk when physical memory is low. Then, page in the paged-out memory when the process references it.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab fs</title>
      <link href="/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/"/>
      <url>/2023/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab9%EF%BC%9Afs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/fs.html">Lab: fs</a></p></blockquote><p>实验开始之前需要将git分支切换到fs分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout fs</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (moderate)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    在xv6中支持的最大文件大小是268KB，是因为在inode中保存磁盘块的地址指针只有13个(12直接指针，1个间接指针)。本次实验中我们需要扩大这个限制，主要的实现思路是使用二级间接指针，其具体思路请参考inode章节讲解。</p><blockquote><p><strong>任务</strong>：本次实验主要是将inode的地址字段修改为<strong>11直接指针+1间接指针+1间接指针</strong>，并修改fs.c中bmap函数与<code>itruc</code>函数，，实现二级指针的检测与删除，通过bigfile与usertests -q测试便可以完成本次实验。如果有疑问还请阅读实验文档。</p></blockquote><p>​    本次实验的测试程序为<code>bigfile</code>，它会在一个文件中创建65803个块大小的数据，如果不修改源码就会出现下述的问题。并且通过bigfile测试大概会花费2分半左右的时间完成，期间会打印<code>.</code>告诉你程序在运行，如果没有持续的打印，那么说明你的程序出现死锁了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bigfile</span></span><br><span class="line">..</span><br><span class="line">wrote 268 blocks</span><br><span class="line">bigfile: file is too small</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：</p></blockquote><ol><li>首先要熟悉bmap的内容，建议画一下二级间接指针的指向图，大致如下所示，并且你要保证间接指针指向的块能有256*256个。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2level_inode.png" alt="2level_inode"></p><ol><li>理清逻辑块号(logical block number)与addr保存的指针的关系。ps：逻辑块号就是<strong>一个文件</strong>内的数据块的序列，通过逻辑块号配合<code>bmap</code>就能够找到对应的磁盘块号了。</li><li>需要修改<code>NDIRECT</code>宏定义，与dinode(fs.h)和inode(file.h)这两个数据结构的定义，主要要保持一致</li><li>在我们修改NIDRECT宏或是在文件系统出现故障后，我们需要删除fs.img并且重建系统，建议使用make clean与make qemu。</li><li>在使用bread函数后，记得使用brelse释放磁盘块。</li><li>在<code>itruc</code>函数中添加删除二重指针指向的数据块的代码，在原有代码的基础上添加即可，和bmap一样。</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><blockquote><p><strong>修改</strong>：相关宏与inode结构体</p></blockquote><p>​    我的实现是将inode的地址字段(13个无符号整型)进行修改：前11的地址指针作为直接指针，第12个作为单级间接指针，第13个作为二级间接指针。</p><p>​    因此需要修改NDIRECT、MAXFILE宏，并且添加一个NDINDIRECT(N Double-indirect)的宏指定了二级间接指针保存的逻辑块的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">----fs.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDINDIRECT (NINDIRECT * BSIZE / sizeof(uint)) <span class="comment">//the number of double  addr point to blocks</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  ....</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加</strong>：bmap二级间接指针地址块设置</p></blockquote><p>​    首先了解一下<code>bmap</code>的作用：在使用<code>writei</code>与<code>readi</code>时，通过使用逻辑块号配合<code>bmap</code>，找到对应的磁盘块号。地址字段的作用就是保存磁盘块号，那么11个直接指针逻辑块号就是b~0~到b~10~，分别对应一个磁盘块号，那么一级指针逻辑块号的就是b~11~到b~267~，二级间接指针就是b~268~到b~65802~。</p><p>​    需要注意的是逻辑块号是将这三种指针的范围拼接了起来在逻辑上是连续的，在不同的指针中是<strong>隔离的</strong>，因此我们需要从直接-&gt;一级-&gt;二级，这样来查找。因此在操作bn参数时就需要考虑这个问题，对于二级间接指针而言逻辑块号是从0开始的，也就是需要b~n~ -= NINDIRECT。接着寻找磁盘块过程如下：</p><ol><li>b~n~肯定是在二级间接指针(0-256*256-1)范围内的，在此需要进行判断。</li><li>通过<code>addr[12]</code>读取第13个地址整数，是二级间接指针。如果该值不存在，我们就需要使用<code>balloc</code>创建一个磁盘块(indirect block)，用于保存256个一级间接指针，并将其地址保存到<code>add[12]</code>中并返回。</li><li>通过<code>bn/NINDIRECT</code>(范围是在0-255之间)，作为indirect block的索引，找到保存直接间接指针块(direct block)的地址，和步骤2一样这个块不存在的话就创建一个保存地址并返回。</li><li>最后使用<code>bn%NINDIRECT</code>(也可以是<code>bn/NINDIRECT%NINDIRECT</code>)，作为direct block的索引，找到最终数据块的地址，不存在的话就创建保存后返回。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDINDIRECT)&#123;</span><br><span class="line">    <span class="comment">//read the data block,which contains indirect pointer;</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//read d-indirect block to buffer cache</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn/NINDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn/NINDIRECT] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read indirect block to buffer cache</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    bn %= NINDIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn%NINDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// printf(&quot;alloc file block %d\n&quot;,bn);</span></span><br><span class="line">      addr = balloc(ip-&gt;dev);</span><br><span class="line">      <span class="keyword">if</span>(addr)&#123;</span><br><span class="line">        a[bn%NINDIRECT] = addr;</span><br><span class="line">        log_write(bp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加</strong>：itrunc二级间接指针释放</p></blockquote><p>​    itrunc函数就是依葫芦画瓢就可以了，使用两层循环清理完间接块(indirect block,1个)、直接块(direct block，256个) 、数据块(256*256个)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="title function_">if</span><span class="params">(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])</span>&#123;</span><br><span class="line">    <span class="comment">//read d-indirect pointer block , which contains indirect pointer </span></span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      i_addr = a[j];</span><br><span class="line">      <span class="keyword">if</span>(i_addr)&#123;</span><br><span class="line">        i_bp = bread(ip-&gt;dev, i_addr);</span><br><span class="line">        b = (uint*)i_bp-&gt;data;</span><br><span class="line">        <span class="comment">//free data block,to which indirect pointer </span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(b[k])</span><br><span class="line">            bfree(ip-&gt;dev,b[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(i_bp);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    bigfile实验相对来说还是比较简单的，照着原有的代码添加就可以了，就是在一级间接指针遍历的基础上，再添加一层循环就是二级间接指针了。</p><h1 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (moderate)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>以下内容为机翻，如有疑惑请观看实验文档。</p><p>在本实验中，我们将向xv6添加符号链接。符号链接(或软链接)指的是通过路径名链接的文件;当一个符号链接被打开时，内核沿着这个链接指向被引用的文件。符号链接类似于硬链接，但硬链接仅限于指向同一磁盘上的文件，而符号链接可以<strong>跨磁盘设备</strong>。</p><blockquote><p><strong>任务</strong>：实现<code>symlink(char *target, char *path)</code>系统调用，它将在path上创建一个新的符号链接，该链接指向以target命名的文件。有关更多信息，请参阅手册页符号链接。要进行测试，请将symlinktest添加到Makefile并运行它。当测试产生以下输出(包括用户测试成功)时，您的解决方案就完成了。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">symlinktest</span></span><br><span class="line">Start: test symlinks</span><br><span class="line">test symlinks: ok</span><br><span class="line">Start: test concurrent symlinks</span><br><span class="line">test concurrent symlinks: ok</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertests -q</span></span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure><p>如果不了解软连接与硬链接之间的关系，以及实现的可以参考<strong>“区别：软硬链接”</strong>，如果知道其原理可以直接看<strong>实现</strong>部分。</p><blockquote><p>提示：</p></blockquote><ul><li>为symlink创建一个新的系统调用号，在<code>user/usys.pl</code>、<code>user/user.h</code>中添加一个条目，并在<code>kernel/sysfile.c</code>中实现一个空的<code>sys_symlink</code>。</li><li>在<code>kernel/stat.h</code>中添加一个新的文件类型(T_SYMLINK)来表示符号链接。</li><li>在<code>kernel/fcntl.h</code>中添加一个新的标志(O_NOFOLLOW)，如果使用该标识则说明open系统调用打开的是symlink的inode。请注意，传递给open的标志是使用按位或(or，<code>|</code>)操作符组合的，因此新标志不应与任何现有标志重叠。这允许我们在<code>user/symlinktest.c</code>添加到<code>Makefile</code>后编译它。</li><li>实现symlink(target, path)系统调用，在path上创建一个指向target的新符号链接。注意，系统调用成功并不需要目标存在。您需要选择一个位置来存储符号链接的目标路径，例如，在索引节点的数据块中</li><li><code>symlink</code>应该返回一个表示成功(0)或失败(-1)的整数，类似于link和unlink。</li><li>修改打开系统调用以处理路径引用符号链接的情况。如果文件不存在，打开必须失败。当进程在标志中定<code>O_NOFOLLOW</code>要打开时，open应该打开符号链接(而不是跟随符号链接)。</li><li>如果链接的文件也是一个符号链接，则必须递归地跟踪它，直到到达非链接文件。如果链接形成一个循环，则必须返回一个错误代码。如果链接深度达到某个阈值(例如，10)，您可以通过返回错误代码来近似地实现这一点。</li><li>其他系统调用(例如，link和unlink)不能跟随符号链接;这些系统调用对符号链接本身进行操作。</li><li>在本实验中，我们不需要处理指向<strong>目录</strong>的符号链接。</li></ul><h2 id="区别：软硬链接"><a href="#区别：软硬链接" class="headerlink" title="区别：软硬链接"></a>区别：软硬链接</h2><blockquote><p><strong>硬链接：link与unlink</strong></p></blockquote><p>​    如下图所示，对于根目录inode(inum=1)，指向块46保存的是目录条目，其中一个条目保存了x文件的名称(先忽略y文件名称)。此时使用<code>ls</code>命令便会打印根目录下的文件名称，包括x文件。对于x文件有一个inode(inum=17)，这个inode指向块70，是一个数据块，保存的是x文件的数据。根据x文件名称，找到x文件的inode，通过inode我们便可以写入数据到x了。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/indoe_type.png" alt="indoe_type"></p><p>​    那么此时，使用<code>ln</code>命令(xv6中默认是硬链接)，我们将y做一个硬链接指向x文件。如下图所示，我们只是在根目录的<strong>目录条目块</strong>添加一个y文件名称与x文件的inum(17)，并且这个y文件名是指向x文件的inode，这便实现<strong>硬链接</strong>。我们下次就可以通过y文件名称，去访问修改x文件了。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/hard_link.png" alt="hard_link"></p><p>​    上述便是<strong>硬链接</strong>的实现方式，硬链接主要是在<strong>父目录下添加目录条目实现的</strong>，所有可以用多个文件名指向通过文件，只有当硬链接的数量为0(ip-&gt;nlink=0)，我们才能够删除文件。</p><blockquote><p><strong>软链接</strong></p></blockquote><p>​    在linux中使用<code>ln</code>命令加上<code>-s</code>标识，就是用于创建软链接。如图所示，我们创建一个a文件的软链接文件b，这两个文件都是在根目录下，在根目录inode指向的目录条目块中保存了这两个文件名。</p><p>​    那么我们如何通过b文件访问到a文件的呢？步骤如下：</p><ol><li>输入b路径调用open系统调用，打开y文件的inode；</li><li>y文件的inode指向的数据块保存的是<strong>目标文件的路径</strong>，在这里就是x文件的路径名(/a)；</li><li>通过x路径名打开x文件的inode</li><li>通过x文件的inode就可以访问到其数据块，访问a文件的数据了。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/soft_link.png" alt="soft_link"></p><p>以上便是软链接的实现思路了，与硬链接最大的不同是软链接路径有自己的inode，而硬链接共享同一个inode。</p><blockquote><p><strong>不同点</strong>：软硬链接</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">软连接</th><th style="text-align:center">硬链接</th></tr></thead><tbody><tr><td style="text-align:left">实现</td><td style="text-align:center">特殊文件，保存对目标文件路径引用</td><td style="text-align:center">目录条目，直接指向inode</td></tr><tr><td style="text-align:left">磁盘</td><td style="text-align:center">可跨磁盘使用</td><td style="text-align:center">不可跨磁盘使用</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:center">不会影响文件本身</td><td style="text-align:center">当硬链接数量为0时删除文件</td></tr><tr><td style="text-align:left">大小</td><td style="text-align:center">一个inode+一个磁盘块的大小</td><td style="text-align:center">目录条目大小</td></tr></tbody></table></div><h2 id="示例：ln命令"><a href="#示例：ln命令" class="headerlink" title="示例：ln命令"></a>示例：ln命令</h2><p>接着我们在linux下熟悉以下链接命令(<code>ln</code>)，以便我们能够规范一些细节。</p><blockquote><p>case1：ln命令</p></blockquote><p>​    在linux下ln命令用于制作链接，默认情况下是创建硬链接，加上-s标识是创建软链接。如下所示，目标文件为a，使用<code>ln</code>将b文件名链接到a文件，使用<code>ln -s</code> 将c文件作为软链接指向a。</p><p>​    当使用<code>ls -li</code>，可以查看文件的inode信息，文件inode信息的第一个整数如1179775，这个就是inode-number，此时可以发现软链接的文件的inode中权限标识为<code>lrwxrwxrwx</code>，其中<code>l</code>说明这个文件就是一个软链接文件，并且文件名为<code>c-&gt;a</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="built_in">test</span> &amp;&amp; <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">touch</span> a</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> a b</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> -s a c</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ls</span> -li</span></span><br><span class="line">total 0</span><br><span class="line">1179775 -rw-rw-r-- 2 lyj lyj 0 7月  15 23:26 a</span><br><span class="line">1179775 -rw-rw-r-- 2 lyj lyj 0 7月  15 23:26 b</span><br><span class="line">1185341 lrwxrwxrwx 1 lyj lyj 1 7月  15 23:26 c -&gt; a</span><br></pre></td></tr></table></figure><blockquote><p>case2：数据访问</p></blockquote><p>​    向a文件写入数据hello，使用<code>cat</code>命令可以发现，b和c两种链接都可以访问到a的数据。但是在删除a后，软链接c就不能访问到a文件的数据了，而硬链接b却能够访问到a文件的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; a</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> b</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> c</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">rm</span> a</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> b</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> c</span></span><br><span class="line">cat: c: No such file or directory</span><br></pre></td></tr></table></figure><blockquote><p>case3：创建空目标文件与软链接文件</p></blockquote><p>​    在linux中，我们在没有目标文件的情况下是可以创建软链接的(硬链接是不可以的)，并且可以通过软链接路径直接向<strong>空目标文件</strong>写入数据。</p><p>​    如下所示，我们创建1、2文件，可以发现我们可以通过使用2文件路径直接写入数据到1文件中，此时可以说明在创建软链接的时候可能已经创造了1文件(目标文件)的inode了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> -s 1 2</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello 2</span></span><br><span class="line">hello 2</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; 2</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ls</span> -li</span></span><br><span class="line">total 4</span><br><span class="line">1185341 -rw-rw-r-- 1 lyj lyj 6 7月  15 23:33 1</span><br><span class="line">1179775 lrwxrwxrwx 1 lyj lyj 1 7月  15 23:33 2 -&gt; 1</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> 1</span> </span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> 2</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><blockquote><p>case4：链接文件已存在</p></blockquote><p>​    如下所示，如果我们将已经存在的文件(有数据)，作为软连接的时候会出现报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> -s 2 1</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; 2</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> -s 3 2</span></span><br><span class="line">ln: failed to create symbolic link &#x27;2&#x27;: File exists</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>按照提示，添加相关定义</p></blockquote><p>​    如下面代码所示，在指定文件中添加软链接系统调用的相关定义，此时我们可以启动xv6，并运行<code>symlinktest</code>程序测试symlink系统调用是否合理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----usys.pl</span><br><span class="line"><span class="title function_">entry</span><span class="params">(<span class="string">&quot;symlink&quot;</span>)</span>;</span><br><span class="line">----</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_symlink 22</span></span><br><span class="line">----syscall.c</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">....</span><br><span class="line">[SYS_symlink] sys_symlink,</span><br><span class="line">&#125;</span><br><span class="line">----user.h</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">char</span> *target, <span class="type">char</span> *path)</span>;</span><br><span class="line">----stat.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4</span></span><br><span class="line">----fctl.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x800</span></span><br><span class="line">----makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">    ....</span><br><span class="line">$U/_symlinktest\</span><br></pre></td></tr></table></figure><blockquote><p><strong>sys_symlink</strong>：软链接系统调用</p></blockquote><p>​    在sysfile.c中创建 <code>sys_symlink</code>函数，这个函数我们可以复制<code>sys_link</code>函数并进行相应的调整，在<code>dirlink</code>处我们修改为<code>sym_dirlink(struct inode*,char*,char*)</code>，这个函数就是用于创建软链接，实际上就是将目标文件的路径名进行保存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Create the path new as a soft link to the same inode as old.</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], target[MAXPATH], linkpath[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>,*<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, linkpath, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到软连接路径的父目录inode</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(linkpath, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">//创建软连接</span></span><br><span class="line">  <span class="keyword">if</span>(sym_dirlink(dp, name, target) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>sym_dirlink</strong>：创建软链接</p></blockquote><p>模仿以下<code>dirlink</code>的设计方式，新建一个<code>sym_dirlink</code>函数，主要的执行流程如下：</p><ol><li>通过<code>dirlookup</code>查找软链接文件名是否存储在父目录的目录条目中，如果<strong>软连接inode存在</strong>就需要进行相应修改，并且这个文件是已经存储了数据，那么就说明这个不能作为软链接文件(case4)。如果没有存储数据，我们就需要将文件修改为软链接文件，修改文件类型，并通过<code>writei</code>记录目标文件的路径名到磁盘块中。</li><li>如果<strong>软连接inode不存在</strong>，那么就需要创建一个inode，指定类型为T_SYMLINK，并通过<code>writei</code>记录目标文件的路径名到磁盘块中。</li><li>最后，在软链接文件的父目录inode中，记录下链接文件的名称，就是一个目录条目。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">----fs.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sym_dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, <span class="type">char</span>* target)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如ln -s a b &amp;&amp; ln -s c b</span></span><br><span class="line">    <span class="comment">//其中b未被指定为T_SMYLINK，因此需要修改</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;size &gt; <span class="number">0</span> || ip-&gt;type != T_SYMLINK)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;symlink:failed to create symbolic link \&#x27;%s\&#x27;: File exists\n&quot;</span>,name);</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新软连接目标文件为 软连接文件</span></span><br><span class="line">    ip-&gt;type = T_SYMLINK;</span><br><span class="line">    ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将inode地址字段设置为，连接文件的路径名称</span></span><br><span class="line">    <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, T_SYMLINK)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = <span class="number">0</span>;</span><br><span class="line">  ip-&gt;minor = <span class="number">0</span>;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//将目标路径，写入软连接文件的数据块</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在软连接父目录下，添加软连接的目录条目</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;soft_dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = ip-&gt;inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改</strong>：更改open添加软链接</p></blockquote><p>​    在实验提示中要求我们实现<code>O_NOFOLLOW</code>模式位，这个模式位的主要作用就是找到软链接文件的inode。</p><ul><li>在调用open函数时设置了<code>O_NOFOLLOW</code>位，我们打开的不是软链接文件这时候就会返回一个错误。</li><li>在调用open函数时没有设置<code>O_NOFOLLOW</code>位，如果我们输入路径的文件类型是<code>T_SYMLINK</code>的话，我们就需要找到目标文件，如下所示，我们调用一个<code>find_refinode(struct* inode)</code>函数，这个函数就是通过递归找到最终的目标文件。</li><li>在调用open函数时没有设置<code>O_NOFOLLOW</code>位，如果我们输入路径的文件类型不是<code>T_SYMLINK</code>，那么就和正常情况一样，后续的代码也不需要修改。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">1</span>, &amp;omode);</span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//operating symlink inode</span></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_NOFOLLOW &amp;&amp; ip-&gt;type != T_SYMLINK)&#123;</span><br><span class="line">    <span class="comment">//想获取软连接的inode，但路径不是软件链接的路径</span></span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!(omode &amp; O_NOFOLLOW)&amp;&amp; ip-&gt;type == T_SYMLINK)&#123; </span><br><span class="line">    <span class="comment">//获取软连接的目标文件inode</span></span><br><span class="line">    <span class="keyword">struct</span> inode* sl = ip;</span><br><span class="line">    iunlock(sl);</span><br><span class="line">    <span class="keyword">if</span>((ip = find_refinode(sl)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);  </span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>find_refinode</strong>：递归查找目标路径的inode并返回</p></blockquote><p><code>find_refinode</code>函数中设计有几个细节值得注意：</p><ul><li>两个软链接文件<strong>相互连接</strong>，那么会导致<strong>无限递归</strong>，此时需要设置一个递归阈值<code>threshold</code>(设置上限为10)，当我们递归寻找十次后就会返回错误。</li><li>可以通过<code>readi</code>函数，读取软链接文件保存的目标文件路径，使用<code>namei</code>找到指定的目标文件的inode。</li><li>注意加锁和释放锁之间的搭配，避免死锁。</li><li>当目标文件的inode的类型不是<code>T_SYMLINK</code>的时候，函数就可以结束递归了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> threshold = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find soft link of target</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">find_refinode</span><span class="params">(<span class="keyword">struct</span> inode *si)</span>&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>,*<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">  threshold++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(threshold &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">    iput(si);</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> inode*)<span class="number">0</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  ilock(si);</span><br><span class="line">  <span class="keyword">if</span>(readi(si, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH)&#123;</span><br><span class="line">    iunlockput(si);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> inode*)<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(si);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((ip = namei(target)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> inode*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span> || ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> inode*)<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type != T_SYMLINK)&#123;</span><br><span class="line">    iunlock(ip);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  result = find_refinode(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加函数声明到defs.h</p></blockquote><p>​    在fs.c中添加了两个函数，需要在defs.h头文件中添加声明，才能在sysfile.c文件中调用这两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----defs.h</span><br><span class="line"><span class="keyword">struct</span> inode*   <span class="title function_">find_refinode</span><span class="params">(<span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">soft_dirlink</span><span class="params">(<span class="keyword">struct</span> inode*, <span class="type">char</span>*, uint)</span>;</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>​    本次实验难度也是比较适中的，bigfile相对来说是比较简单的。symlink是比较有难度的，因为symlink中会频繁的使用inode锁，导致死锁的问题也会出现的比较频繁，而且实现较为准确的symlink还是要大刀阔斧的修改xv6的源码。后续有在自己的理解上实现了symlink的一个bug，这个bug不耽误我们理解软链接，但是是比较符合linux下的软链接的标准的，如果有兴趣的可以接着阅读。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/result.png" alt="result"></p><h1 id="实验之外：通过软连接路径直接修改文件"><a href="#实验之外：通过软连接路径直接修改文件" class="headerlink" title="实验之外：通过软连接路径直接修改文件"></a>实验之外：通过软连接路径直接修改文件</h1><p>在完成实验后，使用以下命，会出现打开b文件错误的问题，也就是在未创建a文件时候使用<code>echo</code>命令添加数据到b-&gt;a。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s a b</span><br><span class="line">$ <span class="built_in">echo</span> hello &gt; b</span><br><span class="line">open b fail</span><br></pre></td></tr></table></figure><p>这里我们看向open函数中，已知b-&gt;a那么，我们通过b是可以找到a的inode，但是在未创建a文件是，<code>find_refinode</code>函数是无法找到a文件的inode的。因此在这里我们有两种<strong>解决办法</strong>：</p><ol><li>在<code>sys_symlink</code>系统调用结束前，创建连接目标文件的inode。将文件做一个新的标识T_HIDDEN，设定为隐藏，也就是说明这个文件不使用的时候是查找不到的(<code>ls</code>命令无法发现)。</li><li>在<code>find_refinode</code>函数中，当<code>namei</code>，找到不到对于inode的时候创建一个目标文件的inode。这种情况需要修改inode结构，需要使用一个标识，标识文件是被首次创建的，因此在删除目标文件时候，会导致软连接无法找到目标文件。</li></ol><p>两个文件是有一个先后关系，1是在创建软连接时候创建，2是在使用软连接文件时候创建。</p><blockquote><p>新增：ln软连接命令</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: ln old new\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(argc)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">if</span>(link(argv[<span class="number">1</span>], argv[<span class="number">2</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;link %s %s: failed\n&quot;</span>, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;-s&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;symlink: failed error arg %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(symlink(argv[<span class="number">2</span>],argv[<span class="number">3</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;link %s %s: failed\n&quot;</span>, argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现：在创建软连接时候创建目标文件inode</p></blockquote><p>1.添加新的文件类型设定为隐藏，目的是使用ls时通过这个类型实现不打印这个inode</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----stat.h</span></span><br><span class="line"><span class="addition">+#define T_HIDDEN 5</span></span><br></pre></td></tr></table></figure><p>2.在建立完软链接后，使用<code>create</code>函数创建目标文件的inode。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_symlink(void)&#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="addition">+  if((ip = create(target,T_HIDDEN,0,0)) == 0)&#123;</span></span><br><span class="line"><span class="addition">+    printf(&quot;create hidden error\n&quot;);</span></span><br><span class="line"><span class="addition">+    goto bad;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  iunlock(ip);</span></span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  end_op();</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在create函数中，添加<code>T_HIDDEN</code>的相关定义，避免并发调用时的问题。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static struct inode*</span><br><span class="line">create(char *path, short type, short major, short minor)</span><br><span class="line">&#123;</span><br><span class="line">  struct inode *ip, *dp;</span><br><span class="line">  char name[DIRSIZ];</span><br><span class="line"></span><br><span class="line">  if((dp = nameiparent(path, name)) == 0)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  if((ip = dirlookup(dp, name, 0)) != 0)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line"><span class="deletion">-    if((type == T_FILE) &amp;&amp;</span></span><br><span class="line"><span class="deletion">-        (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE ))</span></span><br><span class="line"><span class="addition">+    if((type == T_FILE || type == T_HIDDEN) &amp;&amp;</span></span><br><span class="line"><span class="addition">+    (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE  || type == T_HIDDEN))</span></span><br><span class="line">      return ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if((ip = ialloc(dp-&gt;dev, type)) == 0)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.修改open函数，通过<code>namei</code>提前查找路径的inode，这种方式有避免反复调用create造成错误，如果存在的并且为<code>T_HIDDEN</code>的话我们就将其修改为<code>T_FILE</code>类型。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_open(void)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line"><span class="addition">+  ip = namei(path);</span></span><br><span class="line"><span class="deletion">-   if(omode &amp; O_CREATE == 0)</span></span><br><span class="line"><span class="addition">+  if(omode &amp; O_CREATE &amp;&amp; ip == 0)&#123;</span></span><br><span class="line"><span class="addition">+    ip = create(path, T_FILE, 0, 0);</span></span><br><span class="line"><span class="addition">+    if(ip == 0)&#123;</span></span><br><span class="line"><span class="addition">+      end_op();</span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;else if(ip != 0)&#123;</span></span><br><span class="line"><span class="addition">+    ilock(ip);</span></span><br><span class="line"><span class="addition">+    if(ip-&gt;type == T_HIDDEN)</span></span><br><span class="line"><span class="addition">+      ip-&gt;type = T_FILE;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>缺陷</strong></p></blockquote><p>​    这种情况下是有所缺陷的，那就是会使用多余inode，这些inode只有在<strong>使用后</strong>才能被删除，导致inode table容量不够，这时我们也通过不了<code>usertests -q</code>的<code>iref</code>测试点(大量创建inode，测试inode table容量)了。</p><blockquote><p><strong>结果</strong>：</p></blockquote><p>完成上述修改后就可以达到预设的情况了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">ln</span> -s a b</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; b</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> b</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">rm</span> a</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> b</span></span><br><span class="line">cat: b: No such file or directory</span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; a</span></span><br><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash"><span class="built_in">cat</span> b</span> </span><br><span class="line">hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab locks</title>
      <link href="/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/"/>
      <url>/2023/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab8%EF%BC%9Alocks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/locks.html">Lab: locks</a></p></blockquote><p>实验开始之前需要将git分支切换到locks分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout lock</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator(moderate)"></a>Memory allocator(moderate)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    在<code>kalloctest</code>程序会对内存分配器进行压力测试：三个进程测试点会增长和压缩内存空间，该过程中多次调用在kalloc.c文件中的<code>kalloc()</code>与<code>kfree()</code>，这两个函数又会多次调用锁(kmem.lock)。这时会造成<strong>锁的竞争</strong>(lock contention)，也就是多个CPU一起竞争想要获取同一把锁，这样会导致CPU资源占用从而影响性能。</p><blockquote><p>注意<strong>锁竞争</strong>(lock contention)与<strong>数据竞争</strong>(data race)是不同的：虽然两者都是并发中的概念，但是<strong>锁竞争</strong>只会影响并发的性能，而<strong>数据竞争</strong>会造成数据的完整性与正确性，通常使用锁来保证数据不被竞争。</p></blockquote><p>​    在<code>kalloctest</code>运行时，会打印acquire调用(获得kmem.lock)次数与锁竞争(尝试获得kmem.lock)的次数，如下面打印结果所示：#test-and-set后的整数是锁竞争的次数，#acquire()后是调用acquire函数的次数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: <span class="comment">#test-and-set 83375 #acquire() 433015</span></span><br></pre></td></tr></table></figure><p>在<strong>kalloctest</strong>的test1中，要求锁竞争的次数不超过10次，这也是本次实验设计的重点。</p><p>​    那么该如何减少锁的竞争？实验中给出的提示是让<strong>每个CPU有一个freelist与锁</strong>。锁的作用暂时不说，讲解一下kmem.freelist：从kalloc.c中的定义以及freerange可以得知，freelist就是一个没有数据域的<strong>管理空闲的物理页</strong>链表，每个节点指针域是指向物理页的开头的，因此也可以知晓一个节点的大小是一个物理页长度(4096)。</p><blockquote><p><strong>共享freelist</strong></p></blockquote><p>从下图中可以得知每个CPU都在共享一个freelist，使用锁避免数据竞争。但是每个CPU申请物理页都在操作一个freelist，这时就会造成锁竞争。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230617134152494.png" alt="share"></p><blockquote><p><strong>独立freelist</strong></p></blockquote><p>如下图所示，以两个CPU为例，我们让每个CPU拥有一个freelist，简单来说就是将一整个freelist按可用地址空间大小(<code>kernelbase-phystop</code>)划分为两个部分：</p><ul><li>0x8000000-0x83fff000：第一个CPU的freelist</li><li>0x8400000-0x8800000：第二个CPU的freelist</li></ul><p>这样的话就将一个freelist独立开来了，后续还可以根据CPU数量来划分多个独立的freelist。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/per-cpu.png" alt="per-cpu"></p><blockquote><p>为什么要每个CPU有一个锁？</p></blockquote><p>​    因为每个CPU的freelist是<strong>独立的</strong>，所以当一个CPU的freelist为空后，该CPU又调用<code>kalloc</code>函数会返回0也就是分配失败，这种情况显然造成的性能损失更大。</p><p>​    当前CPU的freelist为空后，kalloc需要提供一种功能，能够获取其他CPU的freelist的一个物理页节点，在实验中这种功能称为<strong>steal</strong>窃取，那么我们的锁也是在此时会起到作用。</p><p>​    例如两个CPU共同竞争同一个CPU的freelist资源时就会有数据竞争，那么锁也在此时起到了作用。</p><p>具体的实验要求与实验提示，不过多赘述，没有看文档的同学，阅读一下locks实验文档。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个实验主要是在kalloc.c文件中完善相应的实现，需要实现每个CPU有独立一个链表有一个独立的锁。</p><blockquote><p>1.<strong>修改</strong>kmem为数组：每个CPU有一个独立的锁与freelist</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure><blockquote><p>2.<strong>初始化</strong>每个CPU的freelist</p></blockquote><p>在kinit中需要将freelist的节点指向每个物理页的起始地址，这时也需要修改freerange的范围。</p><ul><li>将整个内存空间切割为NCPU个块(chunk)，每个CPU管理一个块的内存</li><li>初始化每个CPU的锁(<code>kmem[id].lock</code>)</li><li>确定每个CPU管理内存的起始于结束地址</li><li>传递值给<code>freerange</code>，在其中调用<code>kfree</code>将对应范围的物理页添加到给freelist</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//init locks for per-CPU</span></span><br><span class="line">  uint64 start_offset,end_offset;</span><br><span class="line">  uint64 chunk = (((<span class="type">char</span>*)PHYSTOP - (<span class="type">char</span>*)end)/NCPU);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> id = <span class="number">0</span>; id&lt;NCPU ; id++)&#123;</span><br><span class="line">    initlock(&amp;kmem[id].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    start_offset =  id * chunk;</span><br><span class="line">    end_offset = (NCPU-id<span class="number">-1</span>) * chunk;</span><br><span class="line">    freerange((end + start_offset), (<span class="type">void</span>*)(PHYSTOP - end_offset));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.<strong>修改</strong>：释放物理页kfree</p></blockquote><p>​    在之前也提到了，steal阶段会产生竞争。那么steal阶段与kfree阶段同时进行时也会产生竞争。这时要使用到对应CPU的freelist的锁了，由于其他CPU就算steal了物理页其物理地址也是不变的，那么steal该物理页的进程释放steal的物理页也是调用<code>kfree</code>。</p><ul><li>在kfree中我们需要保证这个物理页准确的归还到<strong>被steal的CPU的freelist</strong>中，所以我们需要根据传入的物理地址判断所处的范围，进而判断CPU的id，最后通过加锁并将物理页归还到原来的CPU的freelist中，再释放锁就可以了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="type">int</span> tid = pa2cpuid(pa); <span class="comment">//target CPU-id</span></span><br><span class="line">  <span class="keyword">if</span>(tid &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;runout mem&quot;</span>);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem[tid].lock);</span><br><span class="line">  r-&gt;next = kmem[tid].freelist;</span><br><span class="line">  kmem[tid].freelist = r;</span><br><span class="line">  release(&amp;kmem[tid].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>pa2cpuid</strong>：该函数是用于判断物理地址范围，这个返回根据kinit的freerange的范围各有所不同，最后返回管理该范围的CPU的id号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">pa2cpuid</span><span class="params">(<span class="type">void</span>* pa)</span>&#123;</span><br><span class="line">  uint64 chunk = (((<span class="type">char</span>*)PHYSTOP - (<span class="type">char</span>*)end)/NCPU);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *p_start = end;</span><br><span class="line">  <span class="type">char</span> *p_end = end + chunk;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;p_end &lt;= (<span class="type">char</span>*)PHYSTOP &amp;&amp; id &lt; NCPU ; id++ , p_start += chunk, p_end += chunk)&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">char</span>*)pa &lt;= p_end &amp;&amp; (<span class="type">char</span>*)pa &gt;= p_start)</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改</strong>：分配物理页kalloc</p></blockquote><ul><li>分配物理页过程不需要过多的修改，只是新增一个判断，当当前CPU的freelist为空后，就需要向其他CPU进行steal了，steal得到的物理地址直接返回即可。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"> </span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> cid = cpuid(); <span class="comment">// current CPU-id</span></span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[cid].lock);</span><br><span class="line">  r = kmem[cid].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem[cid].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem[cid].lock);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    release(&amp;kmem[cid].lock);</span><br><span class="line">    r = steal_mem(cid);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>新增</strong>：窃取(steal)物理页</p></blockquote><ul><li>steal过程原理上是比较简单的，就是遍历所有CPU当有空闲节点时就返回物理页的地址，但是需要注意的是，修改其他CPU的freelist过程是需要加锁的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">find_freepage</span><span class="params">(<span class="type">int</span> sid)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> id = <span class="number">0</span> ; id &lt; NCPU ; id++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(id == sid)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//avoid multi-stealing</span></span><br><span class="line">    acquire(&amp;kmem[id].lock);</span><br><span class="line">    r = kmem[id].freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;steal from CPU-%d&quot;,id);</span></span><br><span class="line">      kmem[id].freelist = r-&gt;next;</span><br><span class="line">      release(&amp;kmem[id].lock);</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem[id].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> run*</span><br><span class="line"><span class="title function_">steal_mem</span><span class="params">(<span class="type">int</span> sid)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)find_freepage(sid);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    完成以上实现就可以通过kalloctest测试了，但是极少情况下test1也会FAIL(超过十次锁竞争)。主要原有是并发测试是多次steal也会导致锁竞争，还有就是在测试之后发现qemu开始的CPU数量是3个而NCPU=8可能会引起多次steal。但是实验的大致意思也就是这样，如果大家有改进思路也可以提出。</p><h1 id="buffer-cache"><a href="#buffer-cache" class="headerlink" title="buffer cache"></a>buffer cache</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>NOTE</strong>：在做该实验时，如果没有阅读xv6的8.1-8.3章节和bio.c代码的读者请阅读完后再做该实验。</p><p>buffer cache介绍</p></blockquote><p>​    <strong>buffer cache</strong>是文件系统组织中的一层，主要功能是缓存磁盘数据到内存中加速访问。在<code>bio.c</code>的bcache结构体中使用一个<code>bcache.lock</code>保护了30个buffer节点，也实现了LRU链表，如下图所示。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/bcache.png" alt="bcache"></p><blockquote><p>实验问题：</p></blockquote><p>​    有了上个实现提供给我们的思路，也就发现了本次实验的问题所在，那就是对单个资源使用一个锁是会导致锁竞争的。也就是xv6对buffer cache(内存资源)只使用一个锁，保护了30个节点的资源竞争，从而造成了锁竞争。</p><p>​    在kalloc的实验中确定了只有固定的CPU线程会使用kmem资源，因此很容易拆分资源。但是buffer cache却不同，多个用户进程会共享同一个buffer资源(给每个CPU设置一个buffer分配器，同样会导致锁竞争)。这样的也导致buffer cache是难于kalloc实验的。</p><blockquote><p>实验解决思路：</p></blockquote><p>​    解决思路同样是将资源进行拆分，这次需要使用<strong>哈希表</strong>(hash table)。哈希表中设置素数(实验提示使用13这个素数)个桶(bucket)，每一个桶内设置放置一些buffer，并且每一个桶都有一个独立的锁。那么当使用<code>bget</code>获取buffer时，只需要将磁盘块的编号进行hash，返回一个整数作为哈希表内桶的编号，并在桶中找到指定的buffer。</p><blockquote><p><strong>HINS</strong>:</p></blockquote><ul><li>在实验中不需要实现LRU链表或是LRU算法了(在以前的实验中要求使用时间戳实现该功能)，因此在<code>brelse</code>中不需要处理<code>refcnt==0</code>的情况了。</li><li>在<code>bget</code>中当指定桶没有空闲的buffer时，需要向其他桶<strong>偷取(steal)</strong>空闲的buffer，像kalloc一样。</li><li>在查找、修改每一个桶的buffer时都需要保证这个操作是原子性的。</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><blockquote><p><strong>新增</strong>：bucket结构</p></blockquote><ul><li><code>bucket</code>结构体中只有两个成员，锁和buf链表的头部。</li><li>将<code>bcache</code>中原有的head与lock删除，新增buckets成员，也就是13个bucket结构体数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET_BUF (int)(NBUF/NBUCKET)<span class="comment">//初始化时用于将buffer均分到bucket中</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><blockquote><p><strong>新增</strong>：hash</p></blockquote><p>该函数采用模运算的方式，将指定的设备号和磁盘块号通过运算转换为桶的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">hash</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> blockno)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(blockno &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> blockno % NBUCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>新增</strong>：插入buf到bucket</p></blockquote><p>采用头插的方式将buf插入到指定的bucket中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head insert</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucket_push</span><span class="params">(<span class="keyword">struct</span> buf *b,<span class="keyword">struct</span> bucket* dbucket)</span>&#123;</span><br><span class="line">  b-&gt;next = dbucket-&gt;head;</span><br><span class="line">  dbucket-&gt;head = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改</strong>：binit初始化bcache中的bucket</p></blockquote><ul><li>初始化每个bucket的锁</li><li>将30个buffer放入都放入第一个桶(<code>bcache.buckets[0]</code>)中制作为一个链表，但是此时我们只需要next执行遍历就可以了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(bucket = bcache.buckets;bucket &lt; bcache.buckets + NBUCKET;bucket++)</span><br><span class="line">    initlock(&amp;bucket-&gt;lock,<span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">cbuf</span>;</span>   <span class="comment">// current buf pointer</span></span><br><span class="line">  bucket = bcache.buckets;</span><br><span class="line">  bucket-&gt;head = bcache.buf; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(cbuf = bcache.buf + <span class="number">1</span> ;cbuf &lt; bcache.buf + NBUF ; cbuf++)&#123;   </span><br><span class="line">    <span class="comment">//push the cache buf into first bucket</span></span><br><span class="line">    initsleeplock(&amp;cbuf-&gt;lock,<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bucket_push(cbuf,bucket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改</strong>：bget获取buf节点</p></blockquote><p><code>bget</code>是本实验最难的一个环节了，并发冲突主要也出现在该函数中，实现流程如下：</p><ol><li>通过输入dev和blockno获取一个hash值，也就是bcache桶的编号。</li><li>获取指定的buffer桶的锁，遍历桶中的buffer节点，如果以及buf已缓存就函数返回，在此过程中需要使用<code>idle_buf</code>记录桶中未缓存的空闲节点，当遍历结束之后如果有空间节点就返回。</li><li>如果指定编号的桶没有缓存的buf节点，并且没有空闲buf节点，此时需要向其他桶偷取空闲buf节点。</li><li>将偷取回来的节点添加到这个桶中，并调用<code>buf_update</code>更新该buf节点的相关元数据，将最后返回锁定的buf。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span>,*<span class="title">idle_buf</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> target_bucket = hash(dev,blockno);</span><br><span class="line">  bucket = bcache.buckets + target_bucket;</span><br><span class="line"> </span><br><span class="line">  acquire(&amp;bucket-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(buf = bucket-&gt;head;buf != <span class="number">0</span>;buf = buf-&gt;next)&#123;</span><br><span class="line">      <span class="comment">// Is the block already cached?</span></span><br><span class="line">    <span class="keyword">if</span>(buf-&gt;dev == dev &amp;&amp; buf-&gt;blockno == blockno)&#123;</span><br><span class="line">      buf-&gt;refcnt++;</span><br><span class="line">      release(&amp;bucket-&gt;lock);</span><br><span class="line">      acquiresleep(&amp;buf-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Not cached.</span></span><br><span class="line">    <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">    <span class="keyword">if</span>(buf-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">      idle_buf = buf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(idle_buf)&#123;</span><br><span class="line">    buf_update(idle_buf,dev,blockno);</span><br><span class="line">    release(&amp;bucket-&gt;lock);</span><br><span class="line">    acquiresleep(&amp;idle_buf-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> idle_buf;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bucket-&gt;lock);</span><br><span class="line">  <span class="comment">//steal other bucket&#x27;s buf to this bucket</span></span><br><span class="line">  idle_buf = steal_buf(target_bucket);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bucket-&gt;lock);</span><br><span class="line">  buf_update(idle_buf,dev,blockno);</span><br><span class="line">  bucket_push(idle_buf,bucket);</span><br><span class="line">  release(&amp;bucket-&gt;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> idle_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述的代码其实就能够通过实验了，但实际上上述代码会有一个问题：并发读取一个块的时候，两个buffer会同时缓存一个磁盘块。</p><p>只不过在实验指导文档说明了，<code>bcachetest</code>程序不会区检查这个冲突的</p><p>When two processes concurrently use the same block number. <code>bcachetest</code> <code>test0</code> doesn’t ever do this.</p><p><strong>Q</strong>：为什么会并发读取一个磁盘块的时候，会导致多个buf节点缓存同一个磁盘块呢？</p><p><strong>A</strong>：首先有两个进程(P1、P2)同时读取<strong>同一个磁盘块</strong>，按照序列化，P1通过上述的步骤2，随后P2也通过了步骤2，两个进程都没有在同一个桶内找到buf节点。之后P1、P2要<strong>并发地偷取</strong>其他桶的空闲buf节点，但是根据偷取过程的原子性，那么返回的节点也就是两个不同的空闲buf节点。返回过后便是要写入节点到桶内了，此时按照上述的代码也就是要写入两次空闲的buf节点，且元数据都指向同一个磁盘块。</p><blockquote><p><strong>再修改</strong>：bget获取buf节点</p></blockquote><p>为了放置上述情况的出现也就是说，需要在偷取完成后增加一个检测过程。这个检测过程也比较简单，还是以两个进程(P1、P2)为例。</p><p>P1、P2通过偷取过程获得了两个空闲块，此时如果P1先将磁盘块数据写入P1的空闲buf块内，并将偷取buf块加入了桶中。P2后续也准备写入，此时就有一个检测过程，判断是否有进程已经读取了同一个磁盘块(已缓存)，如果有就将P2偷取的buf节点(作为一个未缓存buf)放入到桶中，并将查找到的已缓存节点返回。</p><p>代码如下所示，通过这样便可以很好的解决了，并发读取同一个块的问题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span>,*<span class="title">idle_buf</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> target_bucket = hash(dev,blockno);</span><br><span class="line">  bucket = bcache.buckets + target_bucket;</span><br><span class="line"> </span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">//steal other bucket&#x27;s buf to this bucket</span></span><br><span class="line">  idle_buf = steal_buf(target_bucket);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bucket-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(buf = bucket-&gt;head;buf != <span class="number">0</span>;buf = buf-&gt;next)&#123;</span><br><span class="line">    <span class="comment">//same block</span></span><br><span class="line">    <span class="keyword">if</span>(buf-&gt;dev == dev &amp;&amp; buf-&gt;blockno == blockno)&#123;</span><br><span class="line">      buf-&gt;refcnt++;</span><br><span class="line">      bucket_push(idle_buf,bucket);</span><br><span class="line">      release(&amp;bucket-&gt;lock);</span><br><span class="line">      acquiresleep(&amp;buf-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  buf_update(idle_buf,dev,blockno);</span><br><span class="line">  bucket_push(idle_buf,bucket);</span><br><span class="line">  release(&amp;bucket-&gt;lock);</span><br><span class="line">  acquiresleep(&amp;idle_buf-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> idle_buf;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p><strong>steal_buf</strong>: 转移空闲buf</p></blockquote><p>该函数主要有两个流程：</p><ul><li>遍历每一个桶的buffer节点，并查找空闲的buffer(<code>refcnt==0</code>)，这个过程是原子性的，所有需要在查找每个桶时加上对应的锁。</li><li>找到空闲的buffer后，修改桶的buffer链表结构，也就是将该buffer节点从链表中删除，删除时需要注意修改头指针的指向，并将空闲buffer指针地址返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buf* </span><br><span class="line"><span class="title function_">steal_buf</span><span class="params">(<span class="type">int</span> s_bucketno)</span>&#123;</span><br><span class="line">  <span class="type">int</span> bucketno = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span>;</span></span><br><span class="line">  <span class="comment">//trave every bucket</span></span><br><span class="line">  <span class="keyword">for</span>(;bucketno &lt; NBUCKET;bucketno++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(bucketno == s_bucketno)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    bucket = bcache.buckets + bucketno;</span><br><span class="line">    <span class="comment">//find unused block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">pbuf</span>;</span></span><br><span class="line">    <span class="comment">//ensure to find bucket&#x27;s free buf node atomically</span></span><br><span class="line">    acquire(&amp;bucket-&gt;lock);</span><br><span class="line">    <span class="comment">//trave bucket to find free buf node</span></span><br><span class="line">    <span class="keyword">for</span>(pbuf = buf = bucket-&gt;head;buf != <span class="number">0</span>;buf = buf-&gt;next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(buf-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//pop stealed buf node</span></span><br><span class="line">        <span class="keyword">if</span>(pbuf == buf)</span><br><span class="line">          bucket-&gt;head = buf-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pbuf != bucket-&gt;head)</span><br><span class="line">          pbuf-&gt;next =  buf-&gt;next;</span><br><span class="line"></span><br><span class="line">        release(&amp;bucket-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">      &#125;</span><br><span class="line">      pbuf = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;bucket-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;steal_buf:no buffer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改</strong>：brelse释放buf节点</p></blockquote><p><code>brelse</code>、<code>bpin</code>、<code>bunpin</code>的实现十分的简单就是更换锁为指定的桶的锁就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bucketno = hash(b-&gt;dev,b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bucketno = hash(b-&gt;dev,b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bucketno = hash(b-&gt;dev,b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[bucketno].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/lock-result.png" alt="lock-result"></p><p>​    本次实验难度比较适中，用时比较多的也是在buffer cache部分，主要原因是链表的使用以及使用hash函数的时候输入了dev这个参数，花费了一定的功夫才找到bug。</p><p>​    本次两个实验都是解决<strong>锁竞争</strong>(lock contention)，做完本次实验后也可以发现解决锁竞争的方式就是——拆分单个资源为多个资源，并使用独立的锁进行保护，当然sleeplock也是解决锁竞争的好方法。</p><p>​    在实现过程中重叠使用不同的锁很容易导致<strong>死锁</strong>，做过mit6.824的实验后也是比较清楚这些问题，比较好的解决方式就是使用同一个锁保护一个<strong>关键区</strong>(crucial section)，不要重叠使用锁。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab net</title>
      <link href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/"/>
      <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab7%EF%BC%9Anet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/net.html">Lab: networking</a></p></blockquote><p>实验开始之前需要将git分支切换到net分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout net</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><blockquote><p><strong>写在前面</strong>：本节内容分为实验部分与源码部分，内容可能会有多。如果想要多了解一下源码的读者可以观察源码分析部分。</p></blockquote><h1 id="networking-hard"><a href="#networking-hard" class="headerlink" title="networking(hard)"></a>networking(hard)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>qemu模拟设备硬件</p></blockquote><p>本次实验是通过使用qemu在risc-v主板上模拟一个网卡设备称为<strong>E1000</strong>。这个网卡设备可以连接到真实的局域网中(LAN)。但是在实验中，局域网与网卡设备都是通过qemu模拟出来的。xv6(客户端)的IP地址是<code>10.0.2.15</code>，连接到IP地址为<code>10.0.2.2</code>的局域网上。当xv6使用E1000向<code>10.0.2.2</code>发送数据包时，qemu会将包发送给局域网中目的主机(服务端)中。</p><p>要了解e1000网卡的相关内容，可以根据实验中给出的<a href="https://pdos.csail.mit.edu/6.828/2022/readings/8254x_GBe_SDM.pdf">硬件手册</a>的相应章节进行阅读。</p><blockquote><p>网络协议栈</p></blockquote><p>在该实验中提供了较为简单的网络协议栈的代码实现，在后续的源码分析中会又所介绍。陈列一下相关的文件：</p><ul><li><code>sysnet.c</code>：定义了套接字结构，实现了操作套接字链表的方法</li><li><code>net.c/net.h</code>：定义了mbuf(packet buffer management)结构体与网络协议栈，并实现了网络包的发送与接受的相应操作方法。</li><li><code>e1000.c/e1000.h</code>：定义了e1000网卡的寄存器与e1000的DMA缓冲，实现了网卡驱动对网络包的发送与接受的方法。</li></ul><blockquote><p><strong>DMA</strong>：Direct Memory Access</p></blockquote><p>DMA是一种计算机数据传输技术，能够在不干扰CPU的情况下，将数据从存储器（通常是RAM）传输到另一个设备的内存（例如硬盘驱动器或网络适配器）。那么在该实验中时如何实现DMA的呢？</p><ol><li>E1000接受<strong>链路层</strong>传输过来的数据，硬件内部有building blocks，解析后放入内部缓冲队列，然后以DMA的方式与CPU通信。</li></ol><ul><li><p>网卡内部的缓冲队列，发送和接受都有，分别是TX和RX。DMA机制作用如下：在接收时，DMA引擎将队列中的数据拷贝到内存(RAM)，然后中断通知CPU，而不是显式让CPU负责这一块的工作。</p></li><li><p>在DMA机制前主流是<strong>PIO</strong>的方式，分为port-mapped IO &amp;&amp; memory-mapped IO,都是通过CPU指令对设备寄存器进行读写。在CPU和外部设备<strong>速度差异变得非常大</strong>时，这样效率就变得很低。</p></li></ul><p>DMA机制是靠网卡设备的DMA Engine实现的，操作系统只起到配合的作用，例如在内存中划分一块DMA缓冲区用于读写。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/img2.4.png" alt="img2.4"></p><p>上文引用自<a href="https://zhuanlan.zhihu.com/p/368851473">《MIT6.S081》 Lab net - 知乎 (zhihu.com)</a></p><p>在实验中就是将RX与TX这两个缓冲队列的地址字段链接到内存：</p><ul><li><strong>发送</strong>：将要发送的包(mbuf)的内存地址值，填写到TX的addr字段，DMA会将该包的运输到e1000网卡进行发送。</li><li><strong>接收</strong>：当e1000接收到包的时候，DMA会将包运输到内存，RX的addr字段会记录包的内存地址值。注意：在<code>e1000_init</code>时，xv6已经分配了缓冲包的内存区域并与RX链接起来了。</li></ul><p>以上便是DMA的机制内容。</p><blockquote><p>实验要求</p></blockquote><p>完成两个函数<code>e1000_transmit()</code>和<code>e1000_recv()</code>，之后e1000便可以接受和发送网络包了，使用<code>make grade</code>命令进行测试。</p><blockquote><p><strong>HINS</strong>：</p></blockquote><p>跟着实验文档中的HINS部分完成对应的流程，一步步的编写代码差不多就可以完成实验，而且本次实验不需要使用gdb来调试。</p><p>在运行测试点时，需要先在另一个终端中运行<code>make server</code>。</p><p>特别的是，在e1000_trasmit()中要使用mbuf的指针，发送完包后就需要清空包的数据了。在e1000_recv()中需要使用<strong>循环结构</strong>，一次性读取所有的包。这样可以提高速率，不然会产生多个中断，驱动程序也会出现相应的问题，也就是又遗留的包未被处理。</p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><blockquote><p>发送网络包：e1000_trasmit</p></blockquote><p>发送包的环节主要使用了E1000_TDT(记录TX ring的尾索引)、E1000_TDBAL(记录TX ring的基址)这两个寄存器。</p><p>首先，在TX ring初始化时，将TDH(head) = TDT(tail) = 0。xv6要发送一个包就要使<code>TDT+1</code>，e1000就需要将<code>TDH+1</code>就可以发送包了。那么对于DMA引擎的创建的缓冲区来说，xv6是生产者(producer)进行<code>TDT++</code>，e1000是消费者(consumer)进行<code>TDH++</code>。</p><p>通过HINS内容一步步实现代码即可：</p><ol><li>加锁，防止多个CPU竞争资源；</li><li>读取TDT寄存器获得下一个TX ring的索引，判断status字段的<code>E1000_TXD_STAT_DD</code>位是否可以发送下一个包，不可以则退出函数；</li><li>可以发送下一个包的话，需要清除该缓冲区的数据清空；</li><li>将要发送的包的数据填入TX ring；</li><li>使用指针记录当前包的缓冲包的内存地址值，方便步骤3删除包数据；</li><li>更新TDT寄存器，更新之后便能e1000便会自动发送网络包。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  uint32 idx = regs[E1000_TDT];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!(tx_ring[idx].status &amp; E1000_TXD_STAT_DD))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer overflow&quot;</span>);</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tx_mbufs[idx] != <span class="number">0</span>)&#123;</span><br><span class="line">    mbuffree(tx_mbufs[idx]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tx_ring[idx].addr = (uint64)m-&gt;head;</span><br><span class="line">  tx_ring[idx].length = (uint16)m-&gt;len;</span><br><span class="line">  tx_ring[idx].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  tx_mbufs[idx] = m;</span><br><span class="line">  <span class="comment">//增加缓冲队列字段，网卡发送包</span></span><br><span class="line">  regs[E1000_TDT] = (idx+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完代码后，在一个终端T1中运行<code>make server</code>，就会开启python所写的一个简单的服务器。然后在另一个终端T2运行make qemu，开启xv6后运行<code>nettests</code>命令，这时候在T1就会显示<code>a message from xv6</code>的消息，说明xv6发送包成功。</p><blockquote><p>接收网络包：e1000_recv</p></blockquote><p>接收包的环节主要使用了E1000_RDT(记录RX ring的尾索引)、E1000_RDBAL(记录RX ring的基址)这两个寄存器。</p><p>首先，在RX ring初始化时，将RDH(head) = 0，RDT(tail) =  <code>RX_RING_SIZE</code>-1。接收一个包后，e1000将当前RDH作为这个包的索引并且使<code>RDH+1</code>，那么xv6要取出这个包就需要将<code>RDT+1</code>，当RDH = RDT时说明队列已满，而且这个节点是无法使用的，所以这个队列实际上只能接收15个包。</p><ol><li>加锁，防止并发操作DMA的缓冲区；</li><li>得到RT ring的尾索引，并将其+1后模<code>RX_RING_SIZE</code>的值保存为<strong>idx</strong>；</li><li>通过循环判断，指定索引的RX ring队列的节点的status字段的<code>E1000_RXD_STAT_DD</code>位是否标记。如果标记说明该节点是可读的，则可以进入循环读取数据；</li><li>新分配一个mbuf，拷贝DMA缓冲区的内容，也就是拷贝RX ring的addr地址字段指向的内存，实际上不使用深拷贝也没啥问题，但是在<code>net_rx</code>函数内会释放缓冲区的内存，可能会造成问题；</li><li>在调用<code>net_rx</code>前释放锁，避免死锁。<code>net_rx</code>会解析接收网络的包并将数据填入套接字节点的mbufq队列中；</li><li>更新RDT寄存器，说明xv6已经读取完毕。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  uint32 idx = (regs[E1000_RDT]+<span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(rx_ring[idx].status&amp;E1000_RXD_STAT_DD)&#123;</span><br><span class="line">  </span><br><span class="line">    acquire(&amp;e1000_lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">    m = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    m-&gt;len = rx_ring[idx].length;</span><br><span class="line">    memmove(m-&gt;head,(<span class="type">char</span>*)rx_ring[idx].addr,m-&gt;len);</span><br><span class="line"></span><br><span class="line">    rx_ring[idx].status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    net_rx(m);</span><br><span class="line"></span><br><span class="line">    regs[E1000_RDT] = idx;</span><br><span class="line">    idx = (regs[E1000_RDT]+<span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断执行流程：接受网络包"><a href="#中断执行流程：接受网络包" class="headerlink" title="中断执行流程：接受网络包"></a>中断执行流程：接受网络包</h2><p>在chapter5中，以top与bottom两个部分分析了驱动的组成，由于发送网络包没有中断的产生(因为DMA存在)，所有我们以接收包的流程讲解一下驱动组成。如下图所示</p><blockquote><p>TOP部分</p></blockquote><ul><li>在nettest.c代码中使用<code>connet</code>系统调用获取套接字描述符后，调用了read系统调用，等待从套接字链表中读取数据。</li><li>进入内核，通过判断文件描述符类型，调用<code>sockread</code>，因为该sock节点的mbufq队列为空，所以调用<code>sleep</code>函数休眠该进程(shell)。</li><li>该进程被唤醒后，执行mbufq_pophead()函数从sock节点中读取包的数据。并通过copyout函数将数据内容写回到用户空间。</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/dervier_recv.png" alt="dervier_recv"></p><blockquote><p>BOTTOM部分</p></blockquote><ul><li>当E1000网卡接收到网络包后，产生中断调用interrupt handler(<code>e1000_intr</code>)，其调用了<code>e1000_recv</code>函数.</li><li>在<code>e1000_recv</code>函数中，从DMA引擎的mbuf(<code>e1000_init</code>中初始化该部分内存)中读取到对应网络包。</li><li>通过<code>net_rx、sockrecvudp</code>函数，解析网络包，并将网络包的数据添加到sock节点的mbufq队列的尾部。</li><li>唤醒TOP部分的休眠进程。</li></ul><p>通过TOP与BOTTOM两个部分便可以将驱动代码解耦开来了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验原则上想通过实验是比较简单的(HINS部分都说明白了)，但是这次实验的量级十分的大，包含了网络协议栈、网络硬件驱动设计、DMA等等内容，要想理清整个实验的设计源码，对于自己来说挑战还是十分大的。</p><p>主要的难点就是DMA的缓冲设计、intel硬件手册的阅读(全英文，内容晦涩难懂)、网络协议设计。</p><p>写完本次实验，实际上对网络硬件的代码也没啥深入的了解，还是需要对其余源码有一些了解。要有更好的提升，还是得对实验中网络文件有一个大致的了解，如果学有余力可以看看下述的源码分析。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/net_result.png" alt="net_result"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="中断设置"><a href="#中断设置" class="headerlink" title="中断设置"></a>中断设置</h2><p>以kernel/main.c文件中的函数调用顺序介绍pci与e1000的初始化设置。</p><blockquote><p>memory map I/O</p></blockquote><p>e1000在RISC-V主板上的位置，和左上角的Rj45的Ethernet一样。CPU对其进行读写数据与读取内存(RAM)是一样的使用的是<code>memory map I/O</code>，对指定的地址段对设备的寄存器进行读写，便能实现对硬件设备的控制。<img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Sifive.png" alt="Sifive"></p><p>下述虚拟内存代码中，内核映射建立时可以发现新增了两个地址映射PCI-E ECAM总线与e1000的网卡设备，分别映射在0x30000000L与0x40000000L地址上。可以回顾页表章节就会就可以知晓这些地址段是xv6内核地址中预留的地址段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----vm.c</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line">  <span class="comment">// PCI-E ECAM (configuration space), for pci.c</span></span><br><span class="line">  kvmmap(kpgtbl, <span class="number">0x30000000</span>L, <span class="number">0x30000000</span>L, <span class="number">0x10000000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pci.c maps the e1000&#x27;s registers here.</span></span><br><span class="line">  kvmmap(kpgtbl, <span class="number">0x40000000</span>L, <span class="number">0x40000000</span>L, <span class="number">0x20000</span>, PTE_R | PTE_W);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PLIC传递e1000网卡中断</p></blockquote><p><strong>NOTE</strong>：plicinit代码中的设置是有误的，<code>for(int irq = 1; irq &lt; 0x35; irq++)</code>在注释中说明了PCIE设备的IRQs的范围在<code>32-35</code>之间，但是源码中是<code>1-0x35</code>显然是有问题的，在修改位32-35后仍然是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----plic.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line">  <span class="comment">// PCIE IRQs are 32 to 35</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> irq = <span class="number">32</span>; irq &lt; <span class="number">35</span>; irq++)&#123;</span><br><span class="line">    *(uint32*)(PLIC + irq*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个CPU核调用该函数，让中断能够被S-mode感知并处理。Q：为什么要先加4以及后面赋值<code>0xffffffff</code>，A：加4代表在上述地址的基础上后移4字节也是32位，<code>0xffffffff</code>刚好对于pci总线上的32个设备，一个设备对应一个位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----plic.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line"></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line">   <span class="comment">// hack to get at next 32 IRQs for e1000</span></span><br><span class="line">  *(uint32*)(PLIC_SENABLE(hart)+<span class="number">4</span>) = <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置pci总线上的e1000设备</p></blockquote><p>pci设置实际上不是很复杂，主要就是识别e1000网卡的设备id，并配置pci中e1000的地址，让pci总线能够传输e1000的数据。之后便调用e1000_init初始化e1000网卡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">----pci.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pci_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//e1000的物理地址</span></span><br><span class="line">  uint64 e1000_regs = <span class="number">0x40000000</span>L;</span><br><span class="line">  <span class="comment">//pci总线的物理地址</span></span><br><span class="line">  uint32  *ecam = (uint32 *) <span class="number">0x30000000</span>L;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//PCI有32个设备接口，找到e1000设备接口，并进行配置</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> dev = <span class="number">0</span>; dev &lt; <span class="number">32</span>; dev++)&#123;</span><br><span class="line"><span class="type">int</span> bus = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> func = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    uint32 off = (bus &lt;&lt; <span class="number">16</span>) | (dev &lt;&lt; <span class="number">11</span>) | (func &lt;&lt; <span class="number">8</span>) | (offset);</span><br><span class="line">    <span class="keyword">volatile</span> uint32 *base = ecam + off;</span><br><span class="line">    uint32 id = base[<span class="number">0</span>];<span class="comment">//设备id</span></span><br><span class="line">    <span class="comment">// 100e:8086 is an e1000</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0x100e8086</span>)&#123;</span><br><span class="line">      <span class="comment">// base[1]=7代表允许IO访问、内存访问、开启控制</span></span><br><span class="line">      base[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">      __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">      <span class="comment">// tell the e1000 to reveal its registers at</span></span><br><span class="line">      <span class="comment">// physical address 0x40000000.</span></span><br><span class="line">      base[<span class="number">4</span>+<span class="number">0</span>] = e1000_regs;</span><br><span class="line"></span><br><span class="line">      e1000_init((uint32*)e1000_regs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__sync_synchronize()</code> 是一种同步原语，用于确保在多线程环境中对共享变量的访问是原子的和有序的。它可以用来防止编译器和处理器对指令进行<strong>重排</strong>，从而保证代码的正确性。这个函数没有参数，它只是一个内存屏障，用于强制处理器刷新所有存储器和缓存，以确保所有先前的存储操作已经完成(在《锁》章节会继续讲解)。</p><blockquote><p>初始化e1000设备</p></blockquote><p>对e1000网卡进行初始化主要是一下步骤，对于一些控制寄存器，要想深入了解可以继续观看intel硬件手册。</p><ol><li><strong>重置控制寄存器</strong></li><li><strong>配置传输寄存器</strong>：将TX ring队列的每一个节点都设置<code>E1000_TXD_STAT_DD</code>位，让其可以传输包；将TX ring的地址写入TDBAL寄存器，这一步就是将e1000寄存器编写使用C语言代替，可以方便的使用C语言编写传输包的控制；配置TDLEN、TDH、TDT寄存器，分别代表了e1000设备中TX ring队列长度、头索引、尾索引。</li><li><strong>配置接收寄存器</strong>：创建DMA引擎的内存缓冲区mbuf，将RX ring节点的<code>addr</code>字段指向内存区域，这样当包到达e1000后便能够传输到内存区域；将RX ring的地址写入RDBAL寄存器，作用与传输部分一样；配置RDLEN、RDH、RDT寄存器，分别代表了e1000设备中RX ring队列长度、头索引、尾索引。</li><li><strong>配置MAC地址</strong>：将e1000的MAC地址写入RA寄存器。</li><li>设置多播表，在本实验中并未设置。</li><li>设置传输、接收控制寄存器的相应的位。</li><li><strong>中断设置</strong>，当e1000接收到网络包后，便能够产生中断。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">----e1000.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_init</span><span class="params">(uint32 *xregs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;e1000_lock, <span class="string">&quot;e1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">  regs = xregs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the device</span></span><br><span class="line">  regs[E1000_IMS] = <span class="number">0</span>; <span class="comment">// disable interrupts</span></span><br><span class="line">  regs[E1000_CTL] |= E1000_CTL_RST;</span><br><span class="line">  regs[E1000_IMS] = <span class="number">0</span>; <span class="comment">// redisable interrupts</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(tx_ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(tx_ring));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TX_RING_SIZE; i++) &#123;</span><br><span class="line">    tx_ring[i].status = E1000_TXD_STAT_DD;</span><br><span class="line">    tx_mbufs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  regs[E1000_TDBAL] = (uint64) tx_ring;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">sizeof</span>(tx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">  regs[E1000_TDLEN] = <span class="keyword">sizeof</span>(tx_ring);</span><br><span class="line">  regs[E1000_TDH] = regs[E1000_TDT] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(rx_ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_ring));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RX_RING_SIZE; i++) &#123;</span><br><span class="line">    rx_mbufs[i] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rx_mbufs[i])</span><br><span class="line">      panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">    rx_ring[i].addr = (uint64) rx_mbufs[i]-&gt;head;</span><br><span class="line">  &#125;</span><br><span class="line">  regs[E1000_RDBAL] = (uint64) rx_ring;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">sizeof</span>(rx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">  regs[E1000_RDH] = <span class="number">0</span>;</span><br><span class="line">  regs[E1000_RDT] = RX_RING_SIZE - <span class="number">1</span>;</span><br><span class="line">  regs[E1000_RDLEN] = <span class="keyword">sizeof</span>(rx_ring);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter by qemu&#x27;s MAC address, 52:54:00:12:34:56</span></span><br><span class="line">  regs[E1000_RA] = <span class="number">0x12005452</span>;</span><br><span class="line">  regs[E1000_RA+<span class="number">1</span>] = <span class="number">0x5634</span> | (<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// multicast table</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>/<span class="number">32</span>; i++)</span><br><span class="line">    regs[E1000_MTA + i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transmitter control bits.</span></span><br><span class="line">  regs[E1000_TCTL] = E1000_TCTL_EN |  <span class="comment">// enable</span></span><br><span class="line">    E1000_TCTL_PSP |                  <span class="comment">// pad short packets</span></span><br><span class="line">    (<span class="number">0x10</span> &lt;&lt; E1000_TCTL_CT_SHIFT) |   <span class="comment">// collision stuff</span></span><br><span class="line">    (<span class="number">0x40</span> &lt;&lt; E1000_TCTL_COLD_SHIFT);</span><br><span class="line">  regs[E1000_TIPG] = <span class="number">10</span> | (<span class="number">8</span>&lt;&lt;<span class="number">10</span>) | (<span class="number">6</span>&lt;&lt;<span class="number">20</span>); <span class="comment">// inter-pkt gap</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// receiver control bits.</span></span><br><span class="line">  regs[E1000_RCTL] = E1000_RCTL_EN | <span class="comment">// enable receiver</span></span><br><span class="line">    E1000_RCTL_BAM |                 <span class="comment">// enable broadcast</span></span><br><span class="line">    E1000_RCTL_SZ_2048 |             <span class="comment">// 2048-byte rx buffers</span></span><br><span class="line">    E1000_RCTL_SECRC;                <span class="comment">// strip CRC</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ask e1000 for receive interrupts.</span></span><br><span class="line">  regs[E1000_RDTR] = <span class="number">0</span>; <span class="comment">// interrupt after every received packet (no timer)</span></span><br><span class="line">  regs[E1000_RADV] = <span class="number">0</span>; <span class="comment">// interrupt after every packet (no timer)</span></span><br><span class="line">  regs[E1000_IMS] = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>); <span class="comment">// RXDW -- Receiver Descriptor Write Back</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DMA缓冲区"><a href="#DMA缓冲区" class="headerlink" title="DMA缓冲区"></a>DMA缓冲区</h2><p>DMA = 通过DMA引擎，网卡可以直接读取的RAM地址，而不需要内核作为中间商去调配数据的转移。那么在xv6中就设计一种缓冲结构体，这个结构体用于存放网络包字节序列。</p><blockquote><p>mbuf结构体</p></blockquote><p>这个结构体十分的简单，mbuf实际上是一个链表。主要介绍的是<code>char *head</code>字段，这个字段永远指向的都是网络包的头部，如下图所示。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230615215318420.png" alt="image-20230615215318420"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>  *<span class="title">next</span>;</span> <span class="comment">// the next mbuf in the chain</span></span><br><span class="line">  <span class="type">char</span>         *head; <span class="comment">// the current start position of the buffer</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len;   <span class="comment">// the length of the buffer</span></span><br><span class="line">  <span class="type">char</span>         buf[MBUF_SIZE]; <span class="comment">// the backing store</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>mbuf变式(队列)以及相关函数方法</p></blockquote><ul><li>在实验中sock保存便是这个mbufq队列，用于读取mbuf实体的数据，在前文知道了mbuf是一个链表，那么这个mbufq的head、tail则是用于指向mbuf实体的头节点与尾节点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbufq</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">head</span>;</span>  <span class="comment">// the first element in the queue</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">tail</span>;</span>  <span class="comment">// the last element in the queue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>下述宏定义值得注意的是——<code>typeof</code>关键字，是GUN C提供的一种特性。类似于C++的decltype关键字，在此处主要是用于推断函数值的返回类型与判断结构类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mbufpullhdr(mbuf, hdr) (typeof(hdr)*)mbufpull(mbuf, sizeof(hdr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mbufpushhdr(mbuf, hdr) (typeof(hdr)*)mbufpush(mbuf, sizeof(hdr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mbufputhdr(mbuf, hdr) (typeof(hdr)*)mbufput(mbuf, sizeof(hdr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mbuftrimhdr(mbuf, hdr) (typeof(hdr)*)mbuftrim(mbuf, sizeof(hdr))</span></span><br></pre></td></tr></table></figure><p>在发送包阶段会给数据添加各种协议头部，由于每个协议头部的结构体不同，使用该方法便能够将m-&gt;head强转为对应结构体类型，之后方便的设置协议的字段了。</p><ul><li>下述是一些mbuf通用的操作函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mbuf *<span class="title function_">mbufalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> headroom)</span>;<span class="comment">//分配一个空的mbuf</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mbuffree</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span>;<span class="comment">//释放mbuf</span></span><br><span class="line"><span class="comment">//添加一个mbuf节点到mbuf队列的尾部</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mbufq_pushtail</span><span class="params">(<span class="keyword">struct</span> mbufq *q, <span class="keyword">struct</span> mbuf *m)</span>;</span><br><span class="line"><span class="comment">//取出mbuf队列的头部</span></span><br><span class="line"><span class="keyword">struct</span> mbuf *<span class="title function_">mbufq_pophead</span><span class="params">(<span class="keyword">struct</span> mbufq *q)</span>;</span><br><span class="line"><span class="comment">//判断mbuf队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mbufq_empty</span><span class="params">(<span class="keyword">struct</span> mbufq *q)</span>;</span><br><span class="line"><span class="comment">//初始化mbuf队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mbufq_init</span><span class="params">(<span class="keyword">struct</span> mbufq *q)</span>;</span><br></pre></td></tr></table></figure><h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><blockquote><p>套接字结构体：<strong>链表</strong></p></blockquote><p>套接字是传输层的概念，主要是用于服务端与客户端进程端对端的链接。在net实验中，实现的是sock链表用于记录套接字，套接字中包含mbufq字段包含可以读取的网络包的数据。</p><p>每一个套接字对应的是一个文件描述符，通过这个描述符用户空间便能够读取内存中对应sock链表的节点数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----sysnet.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">next</span>;</span> <span class="comment">// the next socket in the list</span></span><br><span class="line">  uint32 raddr;      <span class="comment">// the remote IPv4 address</span></span><br><span class="line">  uint16 lport;      <span class="comment">// the local UDP port number</span></span><br><span class="line">  uint16 rport;      <span class="comment">// the remote UDP port number</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// protects the rxq</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbufq</span> <span class="title">rxq</span>;</span>  <span class="comment">// a queue of packets waiting to be received</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>套接字分配</p></blockquote><p>在nettest实验中会使用connect系统调用(kernelsysfile.c)用于创建套接字，那么在connect中会调用sockalloc用于创建链表节点。</p><p>在新sock节点记录客户端的端口号与服务端的端口号、IP地址，通过判断该节点是否存在于sock链表中，如果存在通过头插的方式将其加入到链表中，反之则清空套接字并退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">----sysnet.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sockalloc</span><span class="params">(<span class="keyword">struct</span> file **f, uint32 raddr, uint16 lport, uint16 rport)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">si</span>, *<span class="title">pos</span>;</span></span><br><span class="line"></span><br><span class="line">  si = <span class="number">0</span>;</span><br><span class="line">  *f = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*f = filealloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span> ((si = (<span class="keyword">struct</span> sock*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize objects</span></span><br><span class="line">  si-&gt;raddr = raddr;</span><br><span class="line">  si-&gt;lport = lport;</span><br><span class="line">  si-&gt;rport = rport;</span><br><span class="line">  initlock(&amp;si-&gt;lock, <span class="string">&quot;sock&quot;</span>);</span><br><span class="line">  mbufq_init(&amp;si-&gt;rxq);</span><br><span class="line">  (*f)-&gt;type = FD_SOCK;</span><br><span class="line">  (*f)-&gt;readable = <span class="number">1</span>;</span><br><span class="line">  (*f)-&gt;writable = <span class="number">1</span>;</span><br><span class="line">  (*f)-&gt;sock = si;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add to list of sockets</span></span><br><span class="line">  acquire(&amp;lock);</span><br><span class="line">  pos = sockets;</span><br><span class="line">  <span class="comment">//检测套接字是否重复</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">//头插</span></span><br><span class="line">  si-&gt;next = sockets;</span><br><span class="line">  sockets = si;</span><br><span class="line">  release(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  <span class="keyword">if</span> (si)</span><br><span class="line">    kfree((<span class="type">char</span>*)si);</span><br><span class="line">  <span class="keyword">if</span> (*f)</span><br><span class="line">    fileclose(*f);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写入套接字</p></blockquote><p>通过<code>connect</code>获取到套接字描述符fd后，套接字节点与套接字描述符是1对1的关系，使用write(fd,…)后通过识别文件类型便会调用<code>sockwrite</code>，在该函数中主要是创建一个mbuf临时缓冲区并且需要预留网络包的协议头部分。</p><p>使用<code>copyin</code>函数将用户空间的要发送的字符串拷贝到mbuf中，并使用<code>net_tx_udp</code>函数将udp的协议头加入到mbuf中，之后便是加入ip、arp、Ethernet协议头到mbuf中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----sysnet.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sockwrite</span><span class="params">(<span class="keyword">struct</span> sock *si, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">  m = mbufalloc(MBUF_DEFAULT_HEADROOM);</span><br><span class="line">  <span class="keyword">if</span> (!m)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copyin(pr-&gt;pagetable, mbufput(m, n), addr, n) == <span class="number">-1</span>) &#123;</span><br><span class="line">    mbuffree(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  net_tx_udp(m, si-&gt;raddr, si-&gt;lport, si-&gt;rport);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>读取套接字</p></blockquote><p>与write相似，通过read系统调用<code>sockread</code>函数读取对应的套接字链表。判断套接字的mbuf是否为空，为空则休眠该进程等待mbuf的输入。当该节点的mbuf被写入便会唤醒该节点，那么就可以读取接收的网络包的数据并使用<code>copyout</code>拷贝回用户空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----sysnet.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sockread</span><span class="params">(<span class="keyword">struct</span> sock *si, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;si-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span> (mbufq_empty(&amp;si-&gt;rxq) &amp;&amp; !pr-&gt;killed) &#123;</span><br><span class="line">    sleep(&amp;si-&gt;rxq, &amp;si-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pr-&gt;killed) &#123;</span><br><span class="line">    release(&amp;si-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m = mbufq_pophead(&amp;si-&gt;rxq);</span><br><span class="line">  release(&amp;si-&gt;lock);</span><br><span class="line"></span><br><span class="line">  len = m-&gt;len;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; n)</span><br><span class="line">    len = n;</span><br><span class="line">  <span class="keyword">if</span> (copyout(pr-&gt;pagetable, addr, m-&gt;head, len) == <span class="number">-1</span>) &#123;</span><br><span class="line">    mbuffree(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mbuffree(m);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议包的加工就如下图所示，从上至下添加每一层的协议头。不同的是，在xv6的ping测试中没有使用应用层的协议，添加的是原生的字符序列。在传输层使用的是udp协议，在链路层添加arp协议头，在物理层添加了以太网Ethernet的协议头。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/packet.png" alt="packet"></p><h3 id="地址信息"><a href="#地址信息" class="headerlink" title="地址信息"></a>地址信息</h3><p>在net.h中定义了qemu模拟的xv6主机的ip地址与mac地址。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="type">static</span> uint32 local_ip = MAKE_IP_ADDR(<span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">15</span>); <span class="comment">// qemu&#x27;s idea of the guest IP</span></span><br><span class="line"><span class="type">static</span> uint8 local_mac[ETHADDR_LEN] = &#123; <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span> &#125;;</span><br><span class="line"><span class="type">static</span> uint8 broadcast_mac[ETHADDR_LEN] = &#123; <span class="number">0xFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="物理层：Ethernet"><a href="#物理层：Ethernet" class="headerlink" title="物理层：Ethernet"></a>物理层：Ethernet</h3><blockquote><p>Ethernet结构体</p></blockquote><p>该结构体中简单地定义了Ethernet的协议字段，也就是本机mac地址、目的主机的mac地址，还有协议类型type，在本实验中只有ip与udp类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETHADDR_LEN 6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth</span> &#123;</span></span><br><span class="line">  uint8  dhost[ETHADDR_LEN];</span><br><span class="line">  uint8  shost[ETHADDR_LEN];</span><br><span class="line">  uint16 type;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETHTYPE_IP  0x0800 <span class="comment">// Internet protocol</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETHTYPE_ARP 0x0806 <span class="comment">// Address resolution protocol</span></span></span><br></pre></td></tr></table></figure><blockquote><p>发送Ethernet包</p></blockquote><p>发送Ethernet包也就是在ip或udp包添加eth头部并发送。发送时候，由于不知道目标主机的mac地址所以目标mac地址被设置为了<strong>广播mac地址</strong>。之后则是调用<code>e1000_tramit</code>代码是e1000网卡发送eth包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="comment">// sends an ethernet packet</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">net_tx_eth</span><span class="params">(<span class="keyword">struct</span> mbuf *m, uint16 ethtype)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eth</span> *<span class="title">ethhdr</span>;</span></span><br><span class="line"></span><br><span class="line">  ethhdr = mbufpushhdr(m, *ethhdr);</span><br><span class="line">  memmove(ethhdr-&gt;shost, local_mac, ETHADDR_LEN);</span><br><span class="line">  <span class="comment">// In a real networking stack, dhost would be set to the address discovered</span></span><br><span class="line">  <span class="comment">// through ARP. Because we don&#x27;t support enough of the ARP protocol, set it</span></span><br><span class="line">  <span class="comment">// to broadcast instead.</span></span><br><span class="line">  memmove(ethhdr-&gt;dhost, broadcast_mac, ETHADDR_LEN);</span><br><span class="line">  ethhdr-&gt;type = htons(ethtype);</span><br><span class="line">  <span class="keyword">if</span> (e1000_transmit(m)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free packet&quot;</span>);</span><br><span class="line">    mbuffree(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接收Ethernet包</p></blockquote><p>解析Eth协议头，通过<code>mbupullhdr</code>函数取出eth协议头，判断Ethernet协议的类型并进一步的取出后一个的协议头部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----net.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">net_rx</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eth</span> *<span class="title">ethhdr</span>;</span></span><br><span class="line">  uint16 type;</span><br><span class="line"></span><br><span class="line">  ethhdr = mbufpullhdr(m, *ethhdr);</span><br><span class="line">  <span class="keyword">if</span> (!ethhdr) &#123;</span><br><span class="line">    mbuffree(m);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  type = ntohs(ethhdr-&gt;type);</span><br><span class="line">  <span class="keyword">if</span> (type == ETHTYPE_IP)</span><br><span class="line">    net_rx_ip(m);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (type == ETHTYPE_ARP)</span><br><span class="line">    net_rx_arp(m);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    mbuffree(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链路层：ARP"><a href="#链路层：ARP" class="headerlink" title="链路层：ARP"></a>链路层：ARP</h3><p>ARP虽然实验中有源码，但是在测试中并没有使用arp，因为这个实验是点对点的网络联通测试，所以没有涉及ARP的运用，感兴趣的化可以自行了解。</p><h3 id="网络层：IP"><a href="#网络层：IP" class="headerlink" title="网络层：IP"></a>网络层：IP</h3><blockquote><p>IP结构体</p></blockquote><p>在该结构体中定义了一些IP必要的字段，如检验和、包的生存期、本机ip与目的主机的ip等字段，相对来说比较简单，并没有实现IPv6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line">  uint8  ip_vhl; <span class="comment">// version &lt;&lt; 4 | header length &gt;&gt; 2</span></span><br><span class="line">  uint8  ip_tos; <span class="comment">// type of service</span></span><br><span class="line">  uint16 ip_len; <span class="comment">// total length</span></span><br><span class="line">  uint16 ip_id;  <span class="comment">// identification</span></span><br><span class="line">  uint16 ip_off; <span class="comment">// fragment offset field</span></span><br><span class="line">  uint8  ip_ttl; <span class="comment">// time to live</span></span><br><span class="line">  uint8  ip_p;   <span class="comment">// protocol</span></span><br><span class="line">  uint16 ip_sum; <span class="comment">// checksum</span></span><br><span class="line">  uint32 ip_src, ip_dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMP 1  <span class="comment">// Control message protocol</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCP  6  <span class="comment">// Transmission control protocol</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDP  17 <span class="comment">// User datagram protocol</span></span></span><br></pre></td></tr></table></figure><p>添加ip协议头部与解析头部几乎与Ethernet操作一样，在接收ip包时，<code>net_rx_ip</code>函数会多一些检测如检验和的检测等。</p><h3 id="传输层：UDP"><a href="#传输层：UDP" class="headerlink" title="传输层：UDP"></a>传输层：UDP</h3><blockquote><p>结构体</p></blockquote><p>传输层协议有TCP与UDP，在本实验中也涉及不了TCP的设计，UDP的设计也相对比较简单。在挑战中会有TCP设计，感兴趣的话可以尝试一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----net.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp</span> &#123;</span></span><br><span class="line">  uint16 sport; <span class="comment">// source port</span></span><br><span class="line">  uint16 dport; <span class="comment">// destination port</span></span><br><span class="line">  uint16 ulen;  <span class="comment">// length, including udp header, not including IP header</span></span><br><span class="line">  uint16 sum;   <span class="comment">// checksum</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与IP层相同，添加协议头部与解析协议头部的过程都相似，查看net.c源码是可以读懂的，这里就不赘述了。</p><h3 id="应用层：DNS"><a href="#应用层：DNS" class="headerlink" title="应用层：DNS"></a>应用层：DNS</h3><blockquote><p>DNS结构体</p></blockquote><p>看下述结构中有<code>uint8 rd: 1;</code> 这样的对象定义，<code>rd:1</code>是用于声明rd是一个<strong>位域</strong>变量，位域允许在内存中比较小的空间中表示一个小的整数。这对于网络协议结构非常有用，可以将小的标志位压缩到原本会被浪费的字节内存中。在这个例子中，rd 只需要占用一个bit，而不是完整的字节空间，因此可以节省内存并提高效率。</p><p><code>__attribute__((packed))</code>是GCC编译器的一个扩展属性(attribute)，它的作用是取消或减少结构体在编译过程中的对齐优化，使用这个属性主要是让<strong>位域</strong>不被对齐优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// an DNS packet (comes after an UDP header).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns</span> &#123;</span></span><br><span class="line">  uint16 id;  <span class="comment">// request ID</span></span><br><span class="line"></span><br><span class="line">  uint8 rd: <span class="number">1</span>;  <span class="comment">// recursion desired</span></span><br><span class="line">  uint8 tc: <span class="number">1</span>;  <span class="comment">// truncated</span></span><br><span class="line">  uint8 aa: <span class="number">1</span>;  <span class="comment">// authoritive</span></span><br><span class="line">  uint8 opcode: <span class="number">4</span>; </span><br><span class="line">  uint8 qr: <span class="number">1</span>;  <span class="comment">// query/response</span></span><br><span class="line">  uint8 rcode: <span class="number">4</span>; <span class="comment">// response code</span></span><br><span class="line">  uint8 cd: <span class="number">1</span>;  <span class="comment">// checking disabled</span></span><br><span class="line">  uint8 ad: <span class="number">1</span>;  <span class="comment">// authenticated data</span></span><br><span class="line">  uint8 z:  <span class="number">1</span>;  </span><br><span class="line">  uint8 ra: <span class="number">1</span>;  <span class="comment">// recursion available</span></span><br><span class="line">  </span><br><span class="line">  uint16 qdcount; <span class="comment">// number of question entries</span></span><br><span class="line">  uint16 ancount; <span class="comment">// number of resource records in answer section</span></span><br><span class="line">  uint16 nscount; <span class="comment">// number of NS resource records in authority section</span></span><br><span class="line">  uint16 arcount; <span class="comment">// number of resource records in additional records</span></span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns_question</span> &#123;</span></span><br><span class="line">  uint16 qtype;</span><br><span class="line">  uint16 qclass;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARECORD (0x0001)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QCLASS  (0x0001)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns_data</span> &#123;</span></span><br><span class="line">  uint16 type;</span><br><span class="line">  uint16 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">  uint32 ttl;</span><br><span class="line">  uint16 len;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于一些字段的使用可以观察<code>nettests.c</code>的代码会生成dns请求和解析dns请求。</p><blockquote><p>制作DNS请求</p></blockquote><p>传入一个<code>uint8* obuf</code>到函数中，这个地址的数据是DNS请求会在后续的write调用中替代字节序列数据。简短的介绍一下制作DNS请求的步骤：</p><ol><li><strong>制作DNS头部</strong>：将obuf的地址强转为dns结构体对象的基址</li><li>请求的id值保存到dns对象的字段中，rd赋值为1说明需要递归解析出域名地址，qdcount赋值为1说明只有一个请求。<code>htons</code>函数方法将本机字节转换为网络字节顺序，Risc-V使用小端序，而网络顺序是大端序。</li><li>接着是将dns结构体后续的地址强转为需要<strong>解析的域名字符串</strong>(“pdos.csail.mit.edu.”)的地址，这就是dns要传输的数据部分。</li><li><strong>制作DNS尾部</strong>：将数据部分后续地址强转为dns_question结构体地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Make a DNS request</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dns_req</span><span class="params">(uint8 *obuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dns</span> *<span class="title">hdr</span> =</span> (<span class="keyword">struct</span> dns *) obuf;</span><br><span class="line">  hdr-&gt;id = htons(<span class="number">6828</span>);</span><br><span class="line">  hdr-&gt;rd = <span class="number">1</span>;</span><br><span class="line">  hdr-&gt;qdcount = htons(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  len += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dns);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// qname part of question</span></span><br><span class="line">  <span class="type">char</span> *qname = (<span class="type">char</span> *) (obuf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dns));</span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;pdos.csail.mit.edu.&quot;</span>;</span><br><span class="line">  encode_qname(qname, s);</span><br><span class="line">  len += <span class="built_in">strlen</span>(qname) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constants part of question</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dns_question</span> *<span class="title">h</span> =</span> (<span class="keyword">struct</span> dns_question *) (qname+<span class="built_in">strlen</span>(qname)+<span class="number">1</span>);</span><br><span class="line">  h-&gt;qtype = htons(<span class="number">0x1</span>);</span><br><span class="line">  h-&gt;qclass = htons(<span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">  len += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dns_question);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是DNS包的制作，与ping不同的是将字节数据部分替换为DNS头部+数据部分，实际上就是是数据形式变得更加规范。那么这样来说在服务端接收到包之后对其进行对于的解析，可以得到域名的数据。</p><p>到此本文就结束了，对于DNS解析部分可以观察对于的代码相对于制作dns请求来说是比较复杂的，但实际上也不难。</p><h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><ul><li>[ ] In this lab, the networking stack uses interrupts to handle ingress packet processing, but not egress packet processing. A more sophisticated strategy would be to queue egress packets in software and only provide a limited number to the NIC at any one time. You can then rely on TX interrupts to refill the transmit ring. Using this technique, it becomes possible to prioritize different types of egress traffic. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">easy</a>)</li><li>[ ] The provided networking code only partially supports ARP. Implement a full <a href="https://tools.ietf.org/html/rfc826">ARP cache</a> and wire it in to <code>net_tx_eth()</code>. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">moderate</a>)</li><li>[ ] The E1000 supports multiple RX and TX rings. Configure the E1000 to provide a ring pair for each core and modify your networking stack to support multiple rings. Doing so has the potential to increase the throughput that your networking stack can support as well as reduce lock contention. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">moderate</a>), but difficult to test/measure</li><li>[ ] <code>sockrecvudp()</code> uses a singly-linked list to find the destination socket, which is inefficient. Try using a hash table and RCU instead to increase performance. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">easy</a>), but a serious implementation would difficult to test/measure</li><li>[ ] <a href="https://tools.ietf.org/html/rfc792">ICMP</a> can provide notifications of failed networking flows. Detect these notifications and propagate them as errors through the socket system call interface.</li><li>[ ] The E1000 supports several stateless hardware offloads, including checksum calculation, RSC, and GRO. Use one or more of these offloads to increase the throughput of your networking stack. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">moderate</a>), but hard to test/measure</li><li>[ ] The networking stack in this lab is susceptible to receive livelock. Using the material in lecture and the reading assignment, devise and implement a solution to fix it. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">moderate</a>), but hard to test.</li><li>[ ] Implement a UDP server for xv6. (<a href="https://pdos.csail.mit.edu/6.828/2022/labs/guidance.html">moderate</a>)</li><li>[ ] Implement a minimal TCP stack and download a web page.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6：中断与设备驱动</title>
      <link href="/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%205%EF%BC%9A%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%205%EF%BC%9A%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>写在前面</strong>：本文主要是介绍了中断的原理以及驱动的设计，其中介绍了大部分的xv6的驱动代码，建议读者可以提前阅读一下相关源码，在阅读本文是可以使用GDB去调试过一遍中断的流程。对于时钟中断的代码可能有点晦涩，因为在课程中没有介绍，所有这些都是看xv6书和源码得到的结论，本文对此的介绍可能有些许问题，仅供参考。</p></blockquote><h1 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h1><p>中断对应的场景，就是硬件需要得到操作系统的<strong>关注</strong>，例如网卡收到了一个packet，网卡会生成一个中断；用户通过键盘按下了一个按键，键盘会产生一个中断。操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。</p><blockquote><p>中断与系统调用的不同，同时也是驱动设计的难点</p></blockquote><ol><li><p><strong>异步性(asynchronous)</strong>。当硬件生成中断时，interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的上下文(context)下。</p></li><li><p><strong>并行性(concurrency)</strong>。对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。所以我们在CPU和设备之间是真正的并行的，我们必须管理这里的并行。</p></li><li><p><strong>可编程设备(program device)</strong>。例如网卡，UART，而这些设1备需要被编程。每个设备都有一个编程手册，就像RISC-V有一个包含了指令和寄存器的手册一样。设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。不过通常来说，设备的手册不如RISC-V的手册清楚，这会使得对于设备的编程会更加复杂。</p></li></ol><blockquote><p>中断的产生</p></blockquote><p>如下图所示，是一个SiFive主板，这上面连接了大量的设备，如：以太网卡，MicroUSB，MicroSD等，主板上的各种线路将外设和CPU连接在一起。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Sifive.png" alt="Sifive"></p><p>下图是SiFive有关处理器的文档，图中的右侧是各种各样的设备，例如UART0(地址在memlayout.h中定义0x100000000)。其映射的地址为类似于读写内存，通过向相应的设备地址执行load/store指令，我们就可以对例如UART的设备进行编程。</p><blockquote><p><strong>通用异步收发器</strong>(Universal Asynchronous Receiver/Transmitter)，通常称作<strong>UART，是一种串行、异步、全双工的通信协议</strong>，在嵌入式领域应用的非常广泛。在xv6充当的是串口控制台设备驱动程序。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Device.png" alt="Device"></p><p>所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断。PLIC会<strong>管理来自于外设的中断</strong>。进一步查看PLIC的结构图。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/PLIC.png" alt="PLIC"></p><p>从左上角可以看出，我们有53个不同的来自于设备的中断。这些中断到达PLIC之后，PLIC会<strong>路由</strong>这些中断。图的U54是CPU的核，PLIC会将中断路由到某一个CPU的核。如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。所以PLIC需要保存一些内部数据来<strong>跟踪中断的状态</strong>。具体流程是：</p><ul><li>PLIC会通知当前有一个待处理的中断</li><li>其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理</li><li>CPU核处理完中断之后，CPU会通知PLIC</li><li>PLIC将不再保存中断的信息</li></ul><blockquote><p>以上是中断的硬件部分，接着介绍中断的软件部分。</p></blockquote><h1 id="设备驱动简介"><a href="#设备驱动简介" class="headerlink" title="设备驱动简介"></a>设备驱动简介</h1><blockquote><p>在使用windows操作系统时，都会用到驱动精灵或者时官方的驱动更新硬件驱动，那么<strong>驱动</strong>是什么呢？</p></blockquote><p><strong>驱动</strong>：操作系统中用于<strong>管理</strong>硬件设备的代码程序。主要的功能是配置硬件设备，通知设备执行特定操作，处理由此产生的中断，并与可能正在等待设备I/O的进程进行交互。</p><blockquote><p>中断与设备驱动</p></blockquote><p>设备需要得到操作系统的<strong>关注</strong>，设备便能够被操作系统配置生成中断。中断在trap章节我们节有所提及，是三种trap类型的其中之一。</p><p>那么如trap章节所讲，trap处理代码同样也需要检查<strong>设备是否发起中断</strong>并<strong>调用驱动interrupt handler</strong>，在xv6中是由devintr函数进行调度(dispatch)。</p><blockquote><p>驱动代码组成</p></blockquote><p>许多的驱动代码会被分为两段：</p><ul><li><strong>top half</strong>：通常是<strong>用户进程</strong>，或者内核的其他部分调用的接口。在进程的内核线程中运行。例如UART设备的接口(write、read)被调用时，需要设备执行I/O，这段代码需要等待设备操作的完成。如shell进程等待键盘的输入。</li><li><strong>bottom half</strong>：通常是<strong>中断处理程序(interrupt handler)</strong>。在中断期间执行，当设备完成操作时将会发起中断，interrupt handler将会查询那个操作被完成，唤醒等待的进程，并通知设备去执行下一个等待操作。</li></ul><p>通常情况下，驱动中会有一些队列(或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler(bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。</p><p>通常对于Interrupt handler来说存在一些限制，因为它并没有运行在任何进程的context中，所以进程的page table并不知道该从哪个地址读写数据，也就无法直接从Interrupt handler读写数据。驱动的top部分通常与用户的进程交互，并进行数据的读写。</p><blockquote><p>如何对设备进行编程</p></blockquote><p>通常来说，设备编程是通过<strong>memory mapped I/O</strong>完成的。在SiFive的手册中，设备地址出现在物理地址的特定区间内(页表章节有所提及，memlayout.h定义了这些地址)，这个区间由主板制造商决定。</p><p>操作系统需要知道这些设备位于物理地址空间的具体位置，然后再通过普通的load/store指令对这些地址进行编程。load/store指令实际上的工作就是<strong>读写</strong>设备的控制寄存器。</p><p>例如，对网卡执行store指令时，CPU会修改网卡的某个控制寄存器，进而操作网卡发送一个packet。所以这里的load/store指令不会读写内存，而是会操作设备。</p><blockquote><p>以上便是中断的软件部分——设备驱动，接着我们更加深入的去理解这驱动代码，如何使用设备编程。</p></blockquote><h1 id="UART驱动设计"><a href="#UART驱动设计" class="headerlink" title="UART驱动设计"></a>UART驱动设计</h1><p>本节以shell的<code>&quot;$ &quot;</code>命令为示例，以代码的视角观察：<code>&quot;$ &quot;</code>如何通过shell调用接口输出到console文件设备的，来介绍UART驱动设计。</p><h2 id="中断相关的寄存器"><a href="#中断相关的寄存器" class="headerlink" title="中断相关的寄存器"></a>中断相关的寄存器</h2><ul><li><p><strong>sie</strong>(Supervisor Interrupt Enable）：这个寄存器中有一个bit(E）专门针对例如UART的<strong>外部设备的中断</strong>；有一个bit(S）专门针对<strong>软件中断</strong>，软件中断可能由一个CPU核触发给另一个CPU核；还有一个bit(T）专门针对<strong>定时器中断</strong>。</p></li><li><p><strong>sstatus</strong>(Supervisor Status)：这个寄存器中有一个bit来<strong>打开或者关闭中断</strong>。每一个cpu核都有独立的sie和sstatus寄存器，除了通过sie寄存器来单独控制特定的中断，还可以通过sstatus寄存器中的一个bit来控制<strong>所有的中断</strong>。</p></li><li><p><strong>sip</strong>(Supervisor Interrupt Pending）：当发生中断时，处理器可以通过查看这个寄存器知道当前是<strong>什么类型</strong>的中断。</p></li><li><p><strong>scause</strong>：在trap章节有大量使用这个寄存器的案例。它会表明当前状态的原因是中断。</p></li><li><strong>stvec</strong>：记录trampoline(trampoline.S)与kernelvec(kernelvec.S)的入口地址，当在用户空间触发trap(像是ecall)就进入trampoline函数；在内核空间则进入kernelvec函数。</li></ul><p>对于scause、stvec这两个就可以忽略了，接着主要使用到与中断设置相关的寄存器。</p><h2 id="xv6设置中断"><a href="#xv6设置中断" class="headerlink" title="xv6设置中断"></a>xv6设置中断</h2><p>现在我们又回到chapter 2所讲述的xv6启动的代码，在<code>entry.S</code>中设置好每个CPU的栈后，便进入了<code>start</code>函数开始设置中断相关的寄存器，让cpu能够处于接受中断的状态。</p><blockquote><p><strong>start</strong>：设置<code>sie</code>寄存器</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  timerinit();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>start</code>函数中，将所有的<strong>中断</strong>、<strong>异常</strong>处理都<strong>委托</strong>给管理者模式(Supervisor mode，也可以称为内核模式，之后使用S-mode代替)，然后设置<code>sie</code>寄存器来接收外部的(设备)，软件和定时器中断，之后初始化定时器。</p><p>接着进入<code>main</code>函数，设置处理外部中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----kernel/main.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">....</span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">  scheduler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>初始化Console设备</p></blockquote><p>在console.c中的<code>consoleinit</code>函数首先初始化锁，这里并不需要关心锁的问题。并且将console文件设备的读写接口连接到write与read系统调用上。接着调用了<code>uartinit</code>函数(kernel/uart.c)处理UART设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----kernel/console.c</span><br><span class="line"><span class="comment">//初始化控制台，设置读写系统调用连接到控制台</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化UART设备：主要是管理设备的寄存器</p></blockquote><p>这里的流程是先关闭中断，之后设置波特率(串口线的传输速率），设置字符长度为8bit，重置FIFO，最后再重新打开中断。看下述代码注释也可以知晓大部分的含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">----uart.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是uartinit函数，运行完这个函数之后，原则上UART就可以生成中断了。但此时还没有对PLIC编程，所以<strong>外部(设备)中断不能被CPU感知</strong>。最终，在main函数中，需要调用plicinit函数。</p><blockquote><p><strong>设置PLIC</strong>：让CPU能够感知外部中断</p></blockquote><p>PLIC与外设一样，也占用了一个I/O地址(0xC0000000)，主要是设置设备的IRQ(Interupt ReQuest)寄存器的<strong>I/O地址</strong>，从而可以在PLIC中判断中断的设备，并可以路由到CPU。</p><ul><li>第一行设置PLIC接收来自UART的中断，进而将中断<strong>路由</strong>到CPU。</li><li>第二行设置PLIC接收来自<strong>IO磁盘</strong>的中断。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----plic.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">  *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----memlayout.h</span><br><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br></pre></td></tr></table></figure><p><code>main</code>函数中，<code>plicinit</code>函数之后就是<code>plicinithart</code>函数。<code>plicinit</code>是由0号CPU运行，之后，每个CPU的核都需要调用<code>plicinithart</code>函数。</p><ul><li>设置CPU允许S-mode能够感知UART与VIRTIO中断。</li><li>并且将S-mode的特权级设置为0，也就是忽略中断的优先级。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----memlayout.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="comment">//每个核都调用该函数</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们有了生成中断的外部设备(console与UART)，<strong>PLIC可以传递中断到单个的CPU</strong>。</p><p>但是CPU自己还没有设置好接收中断，因为我们还没有设置好<code>sstatus</code>寄存器。在main函数的最后，程序调用了scheduler函数。</p><blockquote><p><strong>scheduler</strong>：设置每个核的sstatus寄存器</p></blockquote><p>scheduler是内核进程，调度CPU资源给RUNNABLE用户进程，在<code>chapter 7 调度</code>章节会重点讲解。在scheduler中调用了<code>intr_on()</code>函数，开启中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">  ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际运行进程之前，会执行<code>intr_on</code>函数通过设置sstatus的<code>SIE</code>位，使得CPU能接收中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----riscv.h</span><br><span class="line"><span class="comment">// enable device interrupts</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">intr_on</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_sstatus(r_sstatus() | SSTATUS_SIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个时间点，中断被完全打开了。如果PLIC正好有待处理(pending)的中断，那么这个CPU核会收到中断。</p><h2 id="UART驱动Top部分"><a href="#UART驱动Top部分" class="headerlink" title="UART驱动Top部分"></a>UART驱动Top部分</h2><p>由sh调用write输出<code>&#39;$&#39;</code>与<code>&#39; &#39;</code>字符到Console，接着我们看看Console是如何得来的。</p><blockquote><p>创建Console<strong>文件设备</strong></p></blockquote><p>首先这个进程的main函数创建了一个代表Console的设备。这里通过<code>mknod</code>操作创建了console设备。</p><p>因为这是第一个打开的文件，所以这里的文件描述符0。之后通过<code>dup</code>创建stdout和stderr。这里实际上通过复制文件描述符0，得到了另外两个文件描述符1，2，最终文件描述符0，1，2都用来代表Console。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----user/init.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//复制文件描述符，设置为标准输出、标准错误</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout = 1</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr = 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>write系统调用，向Console中输出”$ “字符串</p></blockquote><p>在<code>sh.c</code>程序中<code>getcmd</code>函数，通过使用write调用先要求Console中输出<code>&quot;$ &quot;</code>字符，之后再调用<code>gets</code>(实际上是调用read读取命令)函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----sh.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管Console背后是UART设备，但是从应用程序来看，它就像是一个普通的<strong>文件</strong>，也就是向文件输入数据，通过UART串口输出到显示器。Shell程序只是向文件描述符2写了数据，它并不知道文件描述符2对应的是什么。</p><blockquote><p>进入write系统调用</p></blockquote><p>所以由Shell输出的每一个字符都会触发一个write系统调用。之前我们已经看过了write系统调用最终会走到sysfile.c文件的<strong>sys_write</strong>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----sysfile.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br><span class="line">----file.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//在console.c中将其指向了consolewrite</span></span><br><span class="line">    ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; </span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>filewrite</code>函数中首先会判断文件描述符的类型。<code>mknod</code>生成的文件描述符属于<strong>设备(FD_DEVICE）</strong>，而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的write函数。因为我们现在的设备是Console，所以我们知道这里会调用console.c中的<code>consolewrite</code>函数。</p><blockquote><p>write系统调用与Console文件交互</p></blockquote><p>这里先通过<code>either_copyin</code>将字符<code>&quot;$ &quot;</code>拷入，之后调用uartputc函数。uartputc函数将字符写入给UART设备，所以可以认为<strong>consolewrite是一个UART驱动的top部分</strong>。uart.c文件中的<code>uartputc</code>函数会实际的打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----console.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Console文件设备与UART设备交互</p></blockquote><p>uartputc函数会稍微有趣一些。在UART的内部会有一个buffer用来发送数据，buffer的大小是32个字符。同时还有一个为consumer提供的读指针和为producer提供的写指针，来构建一个环形的buffer(环形队列）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----uart.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TX_BUF_SIZE 32</span></span><br><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br><span class="line">uint64 uart_tx_w; <span class="comment">// write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]</span></span><br><span class="line">uint64 uart_tx_r; <span class="comment">// read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UART的内部会有一个buffer用来发送数据，buffer的大小是32个字符。同时还有一个为<strong>consumer</strong>提供的读指针和为<strong>producer</strong>提供的写指针，来构建一个环形的buffer(环形队列)。</p><p>在本例中，Shell程序是生产者(producer，输入字符串)，所以需要调用<code>uartputc</code>函数。</p><p>在uartputc函数中第一件事情是判断环形buffer是否已经满了。如果读写指针相同，那么buffer是空的，如果写指针加1等于读指针，那么buffer满了。当buffer是满的时候，向其写入数据是没有意义的，所以这里会<code>sleep</code>一段时间，将CPU出让给其他进程。</p><p>当然，在本例中，buffer必然不是满的，因为提示符<code>“$”</code>是我们送出的第一个字符。所以代码会走到else，字符会被送到buffer中，更新写指针，之后再调用<code>uartstart</code>函数。</p><blockquote><p><strong>uartstart</strong>：发送数据，引起中断</p></blockquote><p>首先是检查当前设备是否空闲，如果空闲的话，我们会从buffer中读出数据，然后将数据写入到<strong>THR</strong>(Transmission Holding Register）发送寄存器。这里相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中结构一个死循环，只有将buffer中的字符全部读取完毕后才会退出或是读取LSR寄存器(Line State Register)判断UART的THR寄存器已满(也就是没有UART接收的字符没有发出去)。</p><p>到后面则是读取buffer，将值写入到<strong>THR</strong>寄存器，如果你使用GDB进行调试的话这时屏幕就已经显示<code>&#39;$&#39;</code>字符了。简单来说就是将字符写入<strong>THR</strong>寄存器就可以UART可以向显示设备发送数据了，显示设备也可以显示字符了。</p><p>值得注意的是，每当UART设备发送了<strong>一个字节</strong>数据后，将会生成一个中断，从而调用<code>uartintr</code>，这个函数便是interrupt handler，也就是驱动的bottom部分。接着我们看看bottom部分如何设计。</p><h2 id="UART驱动Bottom部分"><a href="#UART驱动Bottom部分" class="headerlink" title="UART驱动Bottom部分"></a>UART驱动Bottom部分</h2><p>在shell通过write完成uart设备字节发送后(bootm)，GDB中使用backtrace命令会发现<code>uartintr</code>是由<code>kerneltrap</code>所调用的，可以得知是在内核也会引起中断。</p><p><code>uartintr</code>会再次调用<code>uartstart</code>函数，这个函数在top部分已经被<code>uartputc</code>函数所调用过，那么为什么又要生成一个中断再调用uartstart函数呢?原因是需要检测设备是否完成了buffer内所有字节的发送，并将UART的buffer清空。</p><p>如果一个进程写入多个字节到console，那么当<code>uartputc</code>调用<code>uartstart</code>发送一个字节后，生成一个中断后<code>uartintr</code>会不断调用<code>uartstart</code>函数，把buffer内的数据全部发送完毕。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Console%EF%BC%9Aoutput.png" alt="Console：output"></p><p>上图所表示的便是驱动的Top与Bottom部分的结合，那么接着以xv6的代码了解一下，内核是如何识别中断，并以此调用对应设备的interrupt handler。</p><blockquote><p><strong>Kerneltrap</strong>识别中断：Console<strong>输出</strong>字符</p></blockquote><p>之前已经在<code>sstatus</code>寄存器中打开了中断，所以处理器会被中断。在上文中shell以及通过write向UART发送了一个中断并且发向了PLIC，PLIC会将中断路由给一个特定的CPU核，并且如果这个CPU核设置了<code>sie</code>寄存器的E bit(外部中断的bit位），那么会发生以下事情，像syscall一样从用户空间进入内核空间：</p><ol><li>首先，会清除<code>sie</code>寄存器相应的bit，这样可以阻止CPU核被其他中断打扰，该CPU核可以专心处理当前中断。处理完成之后，可以再次恢复<code>sie</code>寄存器相应的bit。</li><li>设置SEPC寄存器为当前的程序计数器。</li><li>保存当前的mode。在我们的例子里面，因为当前运行的是Shell程序，所以会记录user mode。</li><li>将mode设置为S-mode。</li><li>将程序计数器的值设置成stvec的值。在我们的例子中，Shell运行在用户空间，所以<code>stvec</code>保存的是uservec函数的地址。</li></ol><blockquote><p><strong>devintr：</strong>中断处理</p></blockquote><p>此时shell程序接收外部中断时(键盘)，像是系统调用一样进入内核，进入usertrap函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    intr_on();</span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>devintr</code>函数中，首先会通过<code>scause</code>寄存器判断当前中断是否是来自于<strong>外设中断</strong>。如果是的话，再调用<code>plic_claim</code>函数来获取中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  <span class="comment">//scause -&gt; 64bit = 16 bit in hex</span></span><br><span class="line">  <span class="comment">//第一个是判断trap是否是中断</span></span><br><span class="line">  <span class="comment">//第二个是判断是否是Supervisor Enternal interrupt</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>plic_claim</strong>：获取中断</p></blockquote><p><code>plic_claim</code>函数位于plic.c文件中。在这个函数中，当前CPU核会告知PLIC，自己要处理中断，<code>PLIC_SCLAIM</code>会将中断号返回，对于UART设备来说，返回的中断号是10。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----plic.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----memlayout.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br></pre></td></tr></table></figure><p>在<code>devintr</code>函数调用完<code>plic_claim</code>函数后，判断中断的设备号，如果是UART中断，那么会调用<code>uartintr</code>函数(uart.c)。会从UART的接受寄存器中读取数据，之后将获取到的数据传递给<code>consoleintr</code>函数。</p><blockquote><p>UART接收数据</p></blockquote><p>首先RHR与THR是同一个寄存器，那么uartgetc通过读取RHR就可以获取键盘的字符数据，如果没有输入的话RHR就是空为-1，再次进入进入uartstart</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">----uart.c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0      <span class="comment">// receive holding register (for input bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0      <span class="comment">// transmit holding register (for output bytes)</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以代码会直接运行到uartstart函数，这个函数会将Shell存储在buffer中的任意字符送出。实际上在提示符<code>“$”</code>之后，Shell还会输出一个空格字符，write系统调用可以在UART发送提示符<code>“$”</code>的同时，并发的将空格字符写入到buffer中。所以UART的发送中断触发时，可以发现在buffer中还有一个空格字符，之后会将这个空格字符送出。</p><h1 id="UART接收键盘中断"><a href="#UART接收键盘中断" class="headerlink" title="UART接收键盘中断"></a>UART接收键盘中断</h1><h2 id="Top部分"><a href="#Top部分" class="headerlink" title="Top部分"></a>Top部分</h2><p>本节主要是介绍console.c这个设备文件为主，介绍一下当我们按下键盘的一个键后，中断设备是如何进行相应处理，或者是说我们按下一个键后sh程序是如何将字符显示出来的。</p><blockquote><p><strong>读取字节</strong>：read系统调用</p></blockquote><p>在sh.c文件的getcmd函数，在shell输出完<code>”$ “</code>字符串后，就会使用<code>gets</code>函数字符串。那么在<code>gets</code>函数中也主要是通过对Console文件设备(fd=0)发起<code>read</code>系统调用，就可以获得完整的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----sh.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">gets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, cc;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i+<span class="number">1</span> &lt; max; )&#123;</span><br><span class="line">    cc = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cc &lt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    buf[i++] = c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上read系统调用是一个阻塞I/O命令，会导致shell进程放弃cpu的资源使用。此时所需要的就是等待Console设备的输入，也就是等待键盘键入字符。</p><p>接着了解一下如何read系统调用过程。</p><blockquote><p>read系统调用与Console文件交互</p></blockquote><p><code>fileread</code>函数与前面所讲的<code>filewrite</code>函数原理相似，这也就是说read系统调用所参数fd=0的情况下，此时read系统调用是与console的consoleread函数所绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----file.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; </span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>consoleread</strong>：从console设备中读取字符</p></blockquote><p>console设备像UART设备一样都有一个环形buffer用于读取数据，在该函数中通过从buffer中读取字节，再通过<code>copyout</code>将字符返回到用户空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此我们知道了如何通过read向console设备中读取文件，但是buffer的数据从何而来？接着我们查看一下Bottom部分代码，了解如何从键盘键入字符发起中断，将字符加入console的buffer中。</p><h2 id="Bottom部分"><a href="#Bottom部分" class="headerlink" title="Bottom部分"></a>Bottom部分</h2><p>需要谨记的一点是，接收键盘中断与shell发送字符不同点在于，shell程序(read调用)是一个消费者(consumer)，而键盘输入(或者是console)是一个生产者(producer)。</p><p>从<code>kerneltrap</code>到<code>uarintr</code>的过程与之前shell的write调用是一样的，因此就不赘述了。</p><blockquote><p><strong>uartintr</strong>：读取键盘中断</p></blockquote><p>在前面的<code>uartintr</code>不同的是，因为有键盘的输入，此时调用<code>uartgetc</code>是可以从<strong>RHR</strong>寄存器中读取到字符的，那么得到的字符发送到<code>consoleintr</code>函数中就进入console文件中断处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>consoleintr</strong>：将键盘输入添加到环形buffer中</p></blockquote><p>当键盘输出的是一个普通的字符时，<code>consoleintr</code>会调用<code>consputc</code>，在该函数中会调用<code>uartputc_sync</code>(与uartputc功能相同，主要区别是这个函数能够防止冲突)。</p><p>那么在之前也讲到调用<code>uartputc</code>函数，会向UART的THR寄存器发送字节，那么相应的也会使屏幕中显示键盘输入的字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">----console.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后我们要需要主要 <code>if(c == &#39;\n&#39; || c == C(&#39;D&#39;) || cons.e-cons.r == INPUT_BUF_SIZE)</code>语句的判断，简单来说就是，只有在我们键盘敲下回车键后该函数才会调用<code>wakeup(&amp;cons.r);</code>将buffer的读指针唤醒，也就是说<code>consoleread</code>在此次之后才能够<strong>移动</strong>console的buffer的读指针，也就是只有敲下回车后，read系统调用才会返回用户空间。</p><p>接着我们下来以GDB的视角去确认一下这个结论。</p><h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><ol><li><p>打开两个终端<strong>T1</strong>与<strong>T2</strong>，在T1中输入<code>make qemu-gdb</code>，然后再T2中输入<code>gdb-multiarch</code>。</p></li><li><p>在T2中先输入<code>b consoleread</code>命令，然后使用<code>continue</code>命令运行xv6.</p></li><li><p>再输入<code>b uartintr</code>命令，再<code>uartintr</code>函数中设置断点</p></li><li>然后到T1中先<strong>按下一个键——a</strong>，此时在T2中会发现我们程序停在了<code>uartintr</code>函数处，也就说明UART设备是接收键盘中断的。也可以在T2窗口中使用<code>backtrace</code>命令查看函数调用栈，可以确认<code>uartintr</code>是由<code>kerneltrap</code>调用。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/image-20230531011640028.png" alt="image-20230531011640028"></p><ol><li>T2窗口中输入<code>layout src</code>命令开启源代码窗口，输入<code>next</code>命令到<code>consoleintr</code>函数处。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/uartintr1.png" alt="uartintr1"></p><ol><li>使用<code>step</code>命令进入该函数，再使用<code>next</code>命令到<code>consoleputc</code>函数。那么在此时我们继续使用<code>next</code>命令，就可以看到T1窗口显示字符了。</li></ol><blockquote><p>如果你想看到如何一步步使，T1窗口中显示我们输入的字符的可以使用<code>step</code>命令进入该函数,但是在前面也讲到了是将字符写入<strong>THR</strong>寄存器导致的</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/output%20.png" alt="output "></p><ol><li>之后使用<code>continue</code>命令，执行完整个键盘输入字符的中断过程，会发现我们之前设置<code>consoleread</code>函数断点没有触发。那么此时敲下回车键，又在<code>uartintr</code>函数产生中断，使用两次<code>continue</code>命令运行整个中断过程，那么会发现此时程序停在了<code>consoleread</code>的断点处。</li></ol><blockquote><p><strong>为什么要continue两次</strong>？因为键盘中断调用一次<code>uartintr</code>函数，此次调用会向THR寄存器发送数据。在之前讲过，每次向THR发送一个字节就会生成一次中断也会调用一次<code>uartintr</code>。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/consoleread.png" alt="consoleread"></p><p>以上便是键盘输入产生中断，并通过read调用获取输入返回用户空间的过程了。</p><h1 id="驱动中的并发"><a href="#驱动中的并发" class="headerlink" title="驱动中的并发"></a>驱动中的并发</h1><blockquote><p>锁：并发控制</p></blockquote><p>在之前我们所讲到的代码中，会发现到在interrupt handler中都有使用<code>acquire</code>与<code>release</code>加锁核释放锁的过程(锁的内容会在chapter 6中讲到)。</p><p>这里简单的说一下锁的作用，以console设备的buffer数据结构为例，使用acquire函数获取锁后，就可以保护这个buffer避免<strong>并发的访问</strong>。</p><blockquote><p>xv6中并行控制</p></blockquote><p>设备与CPU是<strong>并行</strong>运行的。例如当UART向Console发送字符的时候，CPU会返回执行Shell，而Shell可能会再执行一次系统调用，向buffer中写入另一个字符，这些都是在<strong>并行的执行</strong>。这里的并行称为producer-consumer并行。</p><p>中断会<strong>停止</strong>当前运行的程序。例如，Shell正在运行第212个指令，突然来了个中断，Shell的执行会立即停止。对于用户空间代码，当从中断中返回时，我们会恢复用户空间代码，并继续执行执行停止的指令。</p><p>当内核被中断打断时(调用<code>kerneltrap</code>)，这意味着即使是内核代码，也不是直接串行运行的。在两个内核指令之间，取决于中断是否打开，可能会被中断打断执行。对于一些代码来说，如果不能在执行期间被中断，这时内核需要临时关闭中断，来确保这段代码的<strong>原子性</strong>。</p><blockquote><p><strong>驱动的top和bottom部分是并行运行的</strong></p></blockquote><p>例如，Shell会在传输完提示符<code>“$”</code>之后再调用write系统调用传输空格字符，代码会走到UART驱动的top部分（uartputc），将空格写入到buffer中。但是同时在<strong>另一个CPU核</strong>，可能会收到来自于UART的中断，进而执行UART驱动的bottom部分，查看<strong>相同的buffer</strong>。所以一个驱动的top和bottom部分可以<strong>并行的</strong>在不同的CPU上运行。</p><p>这里我们通过锁来管理并行。因为这里有共享的数据，要求buffer在一个时间只被一个CPU核所操作。 </p><blockquote><p>producer/consumser<strong>并发</strong></p></blockquote><p>这是驱动中的非常常见的典型现象。在驱动(如console.c或是uart.c)中会有一个buffer，在我们之前的例子中，buffer是32字节大小。并且有两个指针，分别是读指针和写指针。</p><p>这里是以shell调用write输出<code>“$ ”</code>为例：</p><p><strong>producer</strong>(write调用)可以一直写入数据，直到写指针 + 1等于读指针，此时32字节的buffer就已经<strong>满了</strong>。当buffer满了的时候，producer必须停止运行。在uartputc函数了解到，如果buffer满了，将会调用<code>sleep</code>，暂时搁置Shell并运行其他的进程。</p><p><strong>consumer</strong>(Interrupt handler)，也就是<code>uartintr</code>函数，，每当有一个中断，并且读指针落后于写指针，<code>uartintr</code>函数就会从读指针中读取一个字符再通过UART设备发送，并且将读指针加1。当读指针追上写指针，也就是两个指针相等的时候，buffer为空，这时就不用做任何操作。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/queue.png" alt="queue"></p><p>这两个部分是并发执行的，值得区分的是producer/consumer因为需要加锁的原因，不能够<strong>同时访问</strong>buffer。因为buffer在内存中只有一个副本，为了避免冲突所以加锁。</p><p>在同一个时间片内，只有一者能够访问buffer数据，那为什么说这样是并发的呢？对于共享数据<strong>并发执行会导致冲突</strong>，但是在上述情景下，两个CPU分别扮演producer与consumer，只有两者都运行到<code>uartintr</code>才会造成其中一个独占buffer的情况，另一个则是需要等待持锁CPU释放才能运行。在时间上也就可以视为两个CPU时并发执行的，因为只有在两者都运行到interrupt handler函数内会让其中一者等待，其余的时间都是并行的执行的。</p><h1 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统中会使用时钟中断(timer interrupt)来维护它的时钟(clock)，时钟设备有一个间隔值如0.1s产生一个中断，就会触发内核选择进行调度，使内核能够<strong>切换正在运行</strong>的进程。这个过程我们称为调度，这节的知识会在chatper 7 讲解，想要提前了解调度算法的可以看这一篇文章<a href="https://zhuanlan.zhihu.com/p/633626661">操作系统导论：调度 - 知乎 (zhihu.com)</a>。</p><p><code>usertrap</code> 和 <code>kerneltrap</code> 中的 <code>yield</code> 调用会导致这种切换。每个 RISC-V CPU的时钟硬件都会生成时钟中断。Xv6 对这个时钟硬件进行编程，使其定期中断相应的CPU。</p><h2 id="中断设置"><a href="#中断设置" class="headerlink" title="中断设置"></a>中断设置</h2><p>RISC-V 要求在<strong>机器模式</strong>(M-mode)下处理时钟中断，而不是S-mode。RISC-V机器模式执行时没有分页，并且有一套单独的控制寄存器(以m开头的寄存器)，在机器模式下运行普通的 xv6 内核代码是不实用的。xv6对定时器中断的处理与上面谈到的 trap 机制完全分离了。</p><blockquote><p>时钟初始化代码</p></blockquote><p>在机器模式下执行start.c程序，在<code>start</code>函数中调用<code>timerinit</code>设置了接收时钟中断 。主要是通过设置M-mode的特殊寄存器：作用与S-mode的寄存器相似，不同点在于这些是M-mode的寄存器。</p><ul><li><strong>mstvec</strong>：记录timervec函数的入口</li><li><strong>mscratch</strong>：预留时钟中断的一个临时区域，每个CPU有40字节区域。将后两个8字节区域设置为<code>CLINT_MTIMECMP</code>寄存器地址与时钟中断间隔的interval值。</li><li><strong>mstatus</strong>：设置在M-mode下CPU能够处理外部中断。</li><li><strong>msie</strong>：开启时钟中断。</li></ul><p>一部分工作是对<strong>CLINT</strong>(硬件core-local interruptor)进行编程，使其每隔一定时间产生一次中断，在代码中是0.1s中断一次。因此时钟中断是设备主动发起的中断，而不是像键盘输入一样需要人为的干预。</p><p>另一部分是设置一个类似于trapframe的<code>scratch</code>区域，帮助时钟中断处理程序<strong>保存寄存器</strong>和<strong>CLINT</strong>寄存器的地址。最后，<code>start</code>函数将<code>mtvec</code>设置为<code>timervec</code>，启用定时器中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">----memlayout.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br><span class="line">----start.c</span><br><span class="line"><span class="comment">// a scratch area per CPU for machine-mode timer interrupts.</span></span><br><span class="line">uint64 timer_scratch[NCPU][<span class="number">5</span>];</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  </span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中断生成"><a href="#中断生成" class="headerlink" title="中断生成"></a>中断生成</h2><p>在用户或内核代码执行的任何时候都会产生时钟中断。内核<strong>无法禁用</strong>时钟中断(在M-mode才能够禁用时钟中断)。因此，时钟中断处理程序必须以保证<strong>不干扰被中断的内核代码</strong>的方式进行工作。</p><p>基本策略是处理程序要求RISC-V引发一个<strong>软件中断</strong>并立即返回。RISC-V 用普通的 trap 机制将软件中断传递给内核，并允许内核禁用它们。</p><blockquote><p>生成<strong>软件中断</strong>：内核空间进入机器模式</p></blockquote><p><strong>机器模式</strong>的时钟中断向量是<code>timervec</code>。像是用户空间进入内核空间一样，当触发时钟中断后，将会跳转到<code>timervec</code>函数中(kernelvec.S)，再最后通过<code>mret</code>命令再回到内核空间。</p><p>在<code>start</code>函数中准备<code>scratch</code>区域保存一些寄存器，告诉 <strong>CLINT 何时产生下一个时钟中断</strong>，使RISC-V产生一个<strong>软件中断</strong>，恢复寄存器，然后返回。在定时器中断处理程序中没有 C 代码。</p><blockquote><p>中断生成流程</p></blockquote><ol><li>读取<code>mscratch</code>寄存器地址到a0寄存器，将a1-a3寄存器保存到scratch前24字节中。</li><li>将scratch区域的后16字节(scratch[3]，scratch[4])分别读取到a1、a2寄存器中。a1为、a2为中断间隔。</li><li>增加<code>MTIMECMP</code>寄存器，其实我也不太清楚这个寄存器有何用，上文可以猜测当时钟到达这个寄存器的值的时候会引起中断。</li><li>之后便是生成<strong>软件中断</strong>，主要是通过在M-mode设置S-mode的<code>sip</code>寄存器，开启SSIP位，也就代表有pending的中断，代表着生成了<strong>软件中断</strong>，这个中断也是会触发。</li><li>恢复中断前的a0-a1寄存器。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.globl timervec</span><br><span class="line">.align 4</span><br><span class="line">timervec:</span><br><span class="line">        </span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line"></span><br><span class="line">        ld a1, 24(a0) #address of CLINT_MTIMECMP(hart)</span><br><span class="line">        ld a2, 32(a0) # interval</span><br><span class="line">        ld a3, 0(a1) #cpu=0 a3 = 2,002,681</span><br><span class="line">        add a3, a3, a2 # a3+interval</span><br><span class="line">        sd a3, 0(a1) #cpu=0 a3 = 3,002,681 </span><br><span class="line">#设置软件中断，返回中断处</span><br><span class="line">        li a1, 2</span><br><span class="line">        csrw sip, a1</span><br><span class="line">#恢复中断前寄存器</span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line"></span><br><span class="line">        mret</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>处理时钟中断产生的软件中断的代码可以在<code>devintr</code>（kernel/trap.c:204）中看到。在此之后可以看到<code>w_sip(r_sip() &amp; ~2)</code>代码，这里便是完成了时钟中断后，<code>sip</code>的SSIP位清空，也就代表着pending的中断得到了处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过判断<code>scause</code>寄存器，判断中断类型。可以发现是时钟中断，并调用时钟中断的处理函数<code>clockintr</code>。值得注意的是这个中断是再M-mode内生成的软件中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line">uint ticks;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此便介绍完了时钟中断，之部分内容xv6书对此介绍也少，所有只能给出自己的理解，想要更深入的了解可以去观察硬件驱动的参考文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章节是目前为止，是花费最多时间来介绍代码的内容。学习完本节内容熟悉一下几点：</p><ul><li>中断与设备驱动之间的概念与关系</li><li>驱动程序的设计</li><li>中断的产生与处理</li></ul><p>因为涉及大量代码所有本节知识也需要自己花费时间让自己消化，建议使用GDB在interrupt handler处打上断点进行调试，尝试理解中断生成与处理的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6：trap机制</title>
      <link href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%204%EF%BC%9A%E9%99%B7%E9%98%B1%20trap/"/>
      <url>/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%204%EF%BC%9A%E9%99%B7%E9%98%B1%20trap/</url>
      
        <content type="html"><![CDATA[<h1 id="简述：trap机制"><a href="#简述：trap机制" class="headerlink" title="简述：trap机制"></a>简述：trap机制</h1><p>有三种事件会导致CPU搁置普通命令的执行，强制将控制权转交给处理该事件的特殊代码。</p><ul><li><p><strong>系统调用(system call)</strong>：执行ecall指令，向内核请求并操作特定硬件资源。</p></li><li><p><strong>异常(exception)</strong>：由尝试做非法事件的指令触发，例如除零操作。</p></li><li><p><strong>设备中断(device interrupt)</strong>：当设备发出信号时提示内核需要注意，例如当磁盘完成读写请求时。 </p></li></ul><p>xv6使用trap(陷阱)作为这三种情况的术语。通常，代码在执行时发生 trap，之后都会被<br>恢复，而且不需要意识到发生了什么特殊的事情(trap 是透明的)。</p><p>透明性对于<strong>中断</strong>十分重要，被中断的代码通常<strong>不会意识</strong>到会发生trap。</p><blockquote><p>trap执行的顺序为：</p></blockquote><ol><li><p>控制权转移到内核(在内核中忽略这一步)</p></li><li><p>内核保存寄存器和其他状态(存储到内存中)</p></li><li><p>内核执行特定的处理程序代码</p></li><li><p>内核恢复保存的状态，从trap中返回</p></li><li><p>代码从发起trap的地方恢复</p></li></ol><blockquote><p>xv6中trap处理的四个阶段</p></blockquote><ol><li><p>RISC-V CPU采取硬件行动(特殊指令，如ecall)</p></li><li><p>执行汇编指令(trampoline.S)进入内核的C语言代码(kernel/traps)处理</p></li><li><p>C函数(usertrap)将决定怎样处理trap，如系统调用、中断、xv6没有提供异常处理</p></li><li><p>内核执行系统调用或设备驱动服务</p></li></ol><p>三种类型的trap有所共性表明了，内核可以用单一的代码入口处理所有的trap。为三种不同进入trap的情况：来自用户空间的trap、来自内核空间的trap、时钟中断，设置单一的汇编入口和trap的C语言处理程序还是很方便的。</p><h1 id="RISC-V陷阱机制"><a href="#RISC-V陷阱机制" class="headerlink" title="RISC-V陷阱机制"></a>RISC-V陷阱机制</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>每个RISC-V CPU有一组<strong>控制寄存器</strong>，用于内核写入这些寄存器告诉CPU如何处理陷阱，并且内核可以读取这些寄存器查明以发生的陷阱。</p><p>RISC-V CPU除了32个通用寄存器外，还有一些特殊寄存器</p><blockquote><p>32个通用寄存器</p></blockquote><div class="table-container"><table><thead><tr><th>reg</th><th>name</th><th>saver</th><th>description</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td></td><td>hardwired zero</td></tr><tr><td>x1</td><td>ra</td><td>caller</td><td>return address</td></tr><tr><td>x2</td><td>sp</td><td>callee</td><td>stack pointer</td></tr><tr><td>x3</td><td>gp</td><td></td><td>global pointer</td></tr><tr><td>x4</td><td>tp</td><td></td><td>thread pointer</td></tr><tr><td>x5-7</td><td>t0-2</td><td>caller</td><td>temporary registers</td></tr><tr><td>x8</td><td>s0/fp</td><td>callee</td><td>saved register / frame pointer</td></tr><tr><td>x9</td><td>s1</td><td>callee</td><td>saved register</td></tr><tr><td>x10-11</td><td>a0-1</td><td>caller</td><td></td></tr><tr><td>x12-17</td><td>a2-7</td><td>caller</td><td></td></tr><tr><td>x18-27</td><td>s2-11</td><td>callee</td><td>saved registers</td></tr><tr><td>x28-31</td><td>t3-6</td><td>caller</td><td>temporary registers</td></tr></tbody></table></div><ul><li><strong>callee</strong>：在函数调用的时候<strong>不会保存</strong></li><li><strong>caller</strong>：在函数调用的时候<strong>会保存</strong></li></ul><blockquote><p>特殊控制寄存器(与trap有关)：</p></blockquote><p>riscv.h中有所定义，这些是管理者模式与trap有关的寄存器，用户模式不能对其进行读写。</p><ul><li><p><strong>stvec</strong>：保存陷阱处理代码的地址，当内核转到用户空间，将trampoline页的虚拟地址写入该地址。</p></li><li><p><strong>sepc</strong>: 当trap发生时，RISC-V保存pc的值到这个寄存器中(因为pc会被stvec的值给复写，那么就可以执行trap入口汇编代码)。sret(从trap中返回的指令)指令将会sepc赋值给pc，又返回发起trap指令的，下一条指令继续执行。</p></li><li><p><strong>scause</strong>：RISC-V保存描述陷阱原因的数字(syscall实验中有所使用)</p></li><li><p><strong>sscratch</strong>：内核在这里放置了一个值，这个值会方便 trap 恢复/储存用户上下文(在用户空间的系统调用中会演示其用途)</p></li><li><p><strong>sstatus</strong>：SIE 位控制设备中断是否被启用，如果内核清除 SIE，RISC- V 将推迟设备中断，直到内核设置 SIE。如果内核清除 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。SPP 位表示 trap 是来自什么模式，并控制sret 返回到什么模式。(在syscall实验中也有使用)</p></li></ul><blockquote><p>其余的特殊寄存器：在前面章节有所讲解</p></blockquote><ul><li><strong>pc</strong>（用户空间可以读写）</li><li><strong>s0(fp)</strong></li><li><strong>satp</strong>（用户空间不能读写）</li></ul><p>多核芯片上的每个 CPU 都有自己的一组这些寄存器，而且在任何时候都可能有多个<br>CPU 在处理一个 trap。</p><h2 id="特殊寄存器处理trap"><a href="#特殊寄存器处理trap" class="headerlink" title="特殊寄存器处理trap"></a>特殊寄存器处理trap</h2><p>当需要执行 trap 时，RISC-V 硬件对所有的 trap 类型（除时钟中断外）进行以下操作：</p><ol><li><p>如果该 trap 是设备中断，且 sstatus SIE 位为 0，则不要执行以下任何操作。</p></li><li><p>通过清除 SIE 来禁用中断。</p></li><li><p>复制 pc 到 sepc</p></li><li><p>将当前模式(用户或监督者)保存在 sstatus 的 SPP 位。</p></li><li><p>在 scause 设置该次 trap 的原因。</p></li><li><p>将模式转换为监督者。</p></li><li><p>将 stvec 复制到 pc。</p></li><li><p>执行新的 pc</p></li></ol><blockquote><p><strong>注意</strong>：CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存 pc 以外的任何<br>寄存器。</p></blockquote><p><strong>内核软件</strong>必须执行这些任务。CPU 在 trap 期间做很少的工作的一个原因是为了给软件提供<strong>灵活性</strong>，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。</p><h1 id="用户陷阱-traps-from-user-space"><a href="#用户陷阱-traps-from-user-space" class="headerlink" title="用户陷阱(traps from user space)"></a>用户陷阱(traps from user space)</h1><blockquote><p>来自用户的陷阱：主要有三种系统调用、异常、中断。接着我们以系统调用write为例讲解trap如何进入内核。</p></blockquote><h2 id="系统调用-代码调用流程"><a href="#系统调用-代码调用流程" class="headerlink" title="系统调用(代码调用流程)"></a>系统调用(代码调用流程)</h2><p>从shell程序初始化启动，首先会调用write系统调用打印’$’、’ ‘两个字符。从shell程序角度来说，write就是C函数调用，但是实际上，write通过执行ecall指令来执行系统调用。ecall指令会切换到内核空间中。执行完ecall后会执行一个由汇编语言写的函数uservec( trampoline.S 文件的一部分)。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/trap%20process.png" alt="trap process.png"></p><blockquote><p>执行流程：如上图，黑色方向是进入内核，蓝色方向是退出内核</p></blockquote><p>进入内核</p><ol><li><p>调用write系统调用，执行ecall命令</p></li><li><p>进入trampoline.S的uservec函数：保存用户寄存器</p></li><li><p>进入内核中执行c语言实现的代码usertrap</p></li><li><p>调用syscall函数并调用sys_write函数打印字符</p></li></ol><p>退出内核</p><ol><li><p>在usertrap中调用usertrapret函数</p></li><li><p>最后调用汇编代码实现的userret代码：恢复用户寄存器的值</p></li></ol><p>以上便是系统调用的大致流程，接着通过gdb的视角看看这部分过程。</p><h2 id="系统调用-gdb"><a href="#系统调用-gdb" class="headerlink" title="系统调用(gdb)"></a>系统调用(gdb)</h2><h3 id="ecall指令之前状态"><a href="#ecall指令之前状态" class="headerlink" title="ecall指令之前状态"></a>ecall指令之前状态</h3><blockquote><p>通过系统调用<strong>进入内核</strong></p></blockquote><ol><li>在user/sh.asm中查看write调用ecall的指令地址为<strong>e08</strong>(断点设置处)。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/write.png" alt="write.png"></p><ol><li><p>打开两个终端窗口<strong>T1</strong>、<strong>T2</strong>。在T1中输入<code>make qemu-gdb</code>，在T2中输入<code>gdb-multiarch</code> (ubuntu20.4的实验环境)</p></li><li><p>那么在T2中设置ecall的断点<code>b *0xe08</code>，使用<code>continue</code>命令后，通过<code>print</code>命令打印寄存器的值。</p></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb1.png" alt="gdb1.png"></p><blockquote><p>pc、sp的值都比较小靠近地址0x0，由页表章节也可以得知我们当前处于用户空间中</p></blockquote><ol><li>在gdb并没有提供给我们查看页表的方式，但是在qemu中提供给了查看页表的方法。转到终端T1按下<code>ctrl a + c</code>按键进入qemu的console，输入<code>info mem</code>，那么qemu就会打印完整的页表(如果打印的是内核的页表，建议运行continue命令后等待一会再使用<code>info mem</code> 查看页表)。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/info%20mem.png" alt="info mem.png"></p><p>看qemu的输出可以得知，这是一个非常小的一个页表只包含了7条映射关系。这是用户程序Shell的页表，而Shell是一个非常小的程序，这7条映射关系是有关Shell的指令和数据，以及一个无效的page用来作为guard page，以防止Shell尝试使用过多的stack page。</p><p>而且最后两个条PTE的虚拟地址十分的大，非常接近虚拟地址的顶端，通过查看页表章节可以得知这两个页分别为trapframe(用于保存/恢复用户寄存器)与trampoline(用户进出内核代码)页</p><blockquote><p><strong>注意</strong>：这里的页表没有包含任何内核部分的地址映射，这里既没有对于内核数据段的映射，也没有对内核指令段的映射。因此这个页表几乎是完全为用户代码执行而创建的。</p></blockquote><ol><li>使用info reg命令查看通用寄存的信息。简单看看一些寄存的值a0、a1、a2，这三个寄存器通过判断应该是保存了write系统调用的三个参数。而且在sh.asm代码中可以查看到a7这保存的是write系统调用的编号。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb2.png" alt="gdb2.png"></p><ol><li>通过使用<code>examining</code>命令，查看a1寄存器存储了write系统调用的字符参数的地址，那么用字符(/c)的格式输出可以清晰的看见，存储的就是<code>&#39;$&#39;</code>与<code>&#39; &#39;</code>这两个字符。</li></ol><p>同样的通过指令(/i)的格式化输出，可以看见在0xe06往后数的3条命令。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb3.png" alt="gdb3.png"></p><h3 id="ecall指令之后的状态"><a href="#ecall指令之后的状态" class="headerlink" title="ecall指令之后的状态"></a>ecall指令之后的状态</h3><blockquote><p>在课程中教授使用stepi指令，就直接跳转到了<strong>0x3ffffff004</strong>地址，而我在测试时直接运行到了0xe0c地址(可能是环境或者gdb版本原因)，所以就需要在trampoline地址设置断点。</p></blockquote><ol><li><p>虽然没有明确的指定，但是ecall所做的<strong>第一件事</strong>就是将cpu的用户模式转为管理者模式。</p></li><li><p>可以设置通过<code>b *(stvec)</code>或<code>b 0x3ffffff000</code>设置断点，使用si命令可以发现我们直接跳入了这个地址，再查看sepc寄存器的值0xe08可以进一步的确认就是从ecall指令跳转到这个位置的。ecall的<strong>第二个</strong>作用是将ecall指令的地址写入sepc寄存器中</p></li></ol><p><strong>stvec</strong>中保存的就是0x3ffffff000这个地址，在用户空间从内核退出时由<strong>内核将trampoline.S的地址写入该寄存器</strong>。那么我们获知ecall的<strong>第三个</strong>作用就是将当前stvec寄存器的值写入pc。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb4.png" alt="gdb4.png"></p><blockquote><p><strong>总结</strong>：ecall完成三件事</p></blockquote><ul><li><p>代码从用户模式改到管理者模式(supervisor mode)</p></li><li><p>将<code>ecall</code>的pc值保存到了<code>sepc</code>寄存中</p></li><li><p><code>ecall</code>跳转到<code>stvec</code>寄存器指向的指令，也就是将<code>stvec</code>写入pc </p></li></ul><ol><li>在这个位置我们再去T1终端窗口，输入<code>info mem</code>命令，查看当前页表会发现页表映射并没有改变(<code>satp</code>并没有变)，所以也可以确定我们仍然在用户空间中。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/info%20mem1.png" alt="info mem1.png"></p><p><strong>ecall不会切换页表</strong>，我们需要在用户页表的某个地方来执行最初的内核代码(进入内核)。而trampoline页是<strong>内核映射</strong>到每一个用户页表中的，使得虽然我们在使用用户页表仍能够让内核在某个地方能够执行一些指令。</p><blockquote><p><strong>NOTE</strong>：在trampoline页映射的PTE没有PTE_U位，也就说明这个页不能被用户修改，这也就说明trap机制是安全的。同时我们在执行trampoline的代码(没有PTE_U位用户不能执行这些代码)，也能够进一步的说明我们<strong>处于管理者模式</strong>中。</p></blockquote><p>如果使用<code>info reg</code>命令查看会发现现在寄存器的值仍然是之前的值，这些用户的数据需要保存在内存中的某处，像是栈一样保存数据。否则在trap返回时寄存器的数据无法恢复，用户数据也就被<strong>复写</strong>，导致无法正常的运行用户程序。</p><ol><li>进入内核，执行内核中的C代码还需要做以下的一些事(<code>ecall</code>并不会做这些事)：</li></ol><ul><li><p>保存用户寄存器的值到内存中</p></li><li><p>从用户页切换到内核页：修改<strong>satp</strong>寄存器</p></li><li><p>为C代码提供内核栈，这个栈是每个进程在创建之初就有的，现在需要让<strong>sp</strong>寄存器的指向内核栈的地址</p></li><li><p>跳转到内核处理trap的C代码<strong>usertrap</strong>函数</p></li></ul><p>接着继续运行trampoline.S的代码完成以上的事件。</p><blockquote><p>在其他机器中，或许可以直接将用户寄存器的内容保存于合适的物理内存中。但是RISC-V不允许这样做，因为RISC-V中管理者模式不能直接访问内存，需要通过页表映射去访问。</p></blockquote><p>在xv6中，对于<strong>保存用户寄存器</strong>的实现有两部分。</p><ul><li><strong>每个用户页表都有自己的trapframe页</strong>，这个页包含的是32个用户寄存器的值。（可以在proc.h中查看trapframe结构体）</li></ul><p>接着我们认识一下trapframe页中起始的5个特殊的槽位，这些都是内核事前存放的值，在用户进入内核时被读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----proch</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// 保存内核页表的地址</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// 进程内核栈</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// 内核C函数代码usertrap()入口地址</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// 保存用户PC寄存器</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// 内核硬件线程id号</span></span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>内核将trapframe页映射到了每个用户页表上</strong>，这样就形成了<strong>一对多</strong>的关系，唯一的trapframe虚拟地址，通过页表映射到了不同进程的trapframe物理地址。</li></ul><blockquote><p>在用户页表中由内核<strong>提前设计了一个映射关系</strong>，在虚拟地址trampoline页下面就是trapframe页，所以trapframe页的起始位置总是0x3ffffffe000。这样的话即使在管理者模式中内核同样可以通过这个映射访问到用户内存。</p></blockquote><h3 id="uservec函数"><a href="#uservec函数" class="headerlink" title="uservec函数"></a>uservec函数</h3><p>uservec函数的入口是<strong>trampoline</strong>页的起始地址，在修改a0寄存指向<strong>trapframe</strong>页之后。我们就可以开始保存寄存器的值了。</p><ol><li>看下图中通过examining答应的接下来需要执行的6条指令。第一条命令<code>csrw</code>就是将a0的值保存到<code>sscratch</code>寄存器中。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb4.png" alt="gdb4.png"></p><ol><li>运行到0x3fffffff0c指令后，通过查看a0寄存的值可知，我们将<strong>trapframe</strong>的地址值写入了a0寄存器，对应的汇编代码是<code>li a7 TRAPFRAME</code>等效于第2到第4条指令。</li></ol><p>如下图，我们打印<strong>ssrcatch</strong>与<strong>a0</strong>寄存器的值，可以发现a0的值已经保存到了sscratch中。而且a0的值是write函数的参数为文件描述符，在退出内核模式时将会还原a0的值。</p><p>a0保存了trapframe的虚拟地址0x3fffffe00，这是trapframe结构体的基址，通过<strong>偏移量</strong>便能保存特定寄存器的值了(具体可以查看trampoline.S代码，该过程比较无聊直接跳过)。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb5.png" alt="gdb5.png"></p><ol><li>在寄存器存储结束的位置打上断点<code>b *0x3ffffff07e</code>，观测接下来的存储指令分别为</li></ol><ul><li>取a0+8的地址开始的一个双字加载到sp</li><li>取a0+32的地址开始的一个双字加载到tp</li><li>取a0+16的地址开始的一个双字加载到t0</li><li>取a0+0的地址开始的一个双字加载到t1</li></ul><blockquote><p>寄存器大小为64位(8字节=一个双字)，那么每个寄存器的偏移量的粒度就是8字节</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb6.png" alt="gdb6.png"></p><p>通过打印这些寄存器的值对应到trapframe的描述也可以进一步的了解这些值的意义。</p><ul><li>sp是内核栈的地址，如果你仔细观察查看页表章节的内核虚拟内存布局，可以得知sp地址0x3ffffffc000是内核栈的地址。在这个内核栈页上面的页是guard页地址应该为0x3ffffffd000。</li><li>tp是硬件线程的编号，通过这个值我们可以确定xv运行在那个核上保存的值也就是hartid</li><li>t0是内核C代码trap处理函数usertrap的入口地址，类型上是一个函数指针。</li><li>t1是内核页表的地址</li></ul><ol><li>使用si继续执行代码，执行到<code>csrw satp t1</code>和<code>sfence.vam</code>(刷新TLB)，这也就是将内核页表写入了satp寄存器中。</li></ol><blockquote><p>在切换satp的值后，用户页表应该切换为了内核页表，在此时我们再去T1终端窗口打印页表信息</p></blockquote><p>这时页表就变成了一个十分巨大的页表了，这便是内核页表。我们有了内核页表、内核栈指针，也就可以读取内核数据。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/info%20mem2.png" alt="info mem2.png"></p><blockquote><p><strong>Q</strong>：为什么从用户页表切换到了内核页表之后(<strong>虚拟地址的映射关系改变</strong>)，代码并没有奔溃？此时我们是在内存某个位置执行代码，<code>pc</code>的值也是虚拟地址，为什么代码同一个虚拟地址没有执行了一些无关的代码地址。</p></blockquote><p><strong>A</strong>：因为此时代码仍在trampoline中，内核与用户的虚拟地址都映射到了同一个物理地址(一对一关系)</p><ol><li>执行<code>jr t0</code>指令，将会跳转到内核的C代码trap.c文件的usertrap函数中。接着就要一内核栈、内核页表跳转到usertrap函数了。</li></ol><h3 id="usertrap函数"><a href="#usertrap函数" class="headerlink" title="usertrap函数"></a>usertrap函数</h3><p>之后便是运行C代码，相比于汇编也更加容易理解。下述便是trap.c中的usertrap函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多原因都可以使程序运行到usertrap函数中来，例如系统调用、除0(异常)、设备中断。</p><blockquote><p>usertrap某种程度上存储并恢复硬件的状态，但是需要检查触发trap的原因，确定相应的处理方式</p><p>usertrap函数执行流程</p></blockquote><ol><li>更改stvec寄存器写入内核处理异常与中断的地址。取决于trap来自于用户还是内核，不同的情况处理trap的方式也是不同。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在内核中执行任何操作之前，usertrap中先将stvec指向了kernelvec变量，<strong>这是内核空间trap处理代码的位置</strong>，而不是用户空间trap处理代码的位置。</p></blockquote><ol><li>调用myproc函数获取当前运行的进程。myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid。myproc函数找出当前运行进程的方法。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>保存sepc寄存器的值到trapframe中，它仍然保存在sepc寄存器中。</li></ol><blockquote><p><strong>可能发生的情况</strong>：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致sepc寄存器的内容被<strong>复写</strong>。我们需要保存当前进程的sepc寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过检查scause的值判断引发trap的原因。打印scause的值为8，也可以得知引发trap的原因是系统调用。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb7.png" alt="gdb7.png"></p><ol><li>通过if语句进入代码块后，首先判断进程是否被杀死，shell程序没有被杀掉，所以通过该语句。</li></ol><p>接着将trapframe中的epc的值+4，在回到用户空间时pc寄存器就被设置epc的值(为ecall的下一条语句的地址)，而不是重新执行ecall指令。</p><p>xv6会在处理系统调用的时候<strong>能够使用中断</strong>，这样中断可以更快的服务，有些系统调用需要更多的时间进行处理。中断总是会被risc-v的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> ----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; </span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后便是进入系统调用的流程，在syscall实验中也有所讲解，该部分也直接省略掉。值得注意的是系统调用的参数保存在了a0，a1，a2中，但是在uservec中我们将a0值换为了trapfame的地址，但是在之后我们便将sscratch(保存a0的值)，那么在系统调用中也就可以通过用<strong>读取内存的方式</strong>获取系统调用的值了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----trampoline.S</span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br></pre></td></tr></table></figure><ol><li>在系统调用完之后，再次判断进程是否被杀死。最后便调用usertrapret退出trap代码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="usertrapret函数"><a href="#usertrapret函数" class="headerlink" title="usertrapret函数"></a>usertrapret函数</h3><blockquote><p>查看trap.c中的usertrapret函数</p></blockquote><ol><li><strong>关闭中断</strong>。我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新stvec寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码。</li></ol><p>关闭中断因为当我们将stvec更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>填入trapframe指定字段</strong>，这些内容对于执行trampoline代码非常有用。这里的代码就是：</li></ol><ul><li>存储内核页表的指针</li><li>存储当前用户进程的内核栈地址指针</li><li>存储usertrap函数的指针，这样trampoline代码才能跳转到这个函数</li><li>从tp寄存器中读取当前的cpu核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为<strong>用户代码可能会修改这个数字</strong>。</li></ul><blockquote><p>在usertrapret函数中，设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>设置sstatus寄存器</strong>。这个寄存器的SPP位控制了sret指令的行为，该位为0表示下次执行sret的时候，我们想要返回用户模式。这个寄存器的SPIE位控制了，在执行完sret之后，是否打开中断。因为我们在返回到用户空间之后，我们的确希望打开中断，所以这里将SPIE位设置为1。修改完这些bit位之后，我们会把新的值写回到sstatus寄存器。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>将sepc设置成epc的值</strong>。在执行完sret指令后会将sepc的值写入pc，从而执行ecall的下一条指令。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>生成用户页表地址</strong>，根据用户页表地址生成相应的satp值，这样我们在返回到用户空间的时候才能完成用户页表的切换。</li></ol><p>在汇编代码trampoline中完成页表的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是<strong>同时在用户和内核空间中映射</strong>。所以在之后我们便会调用汇编代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>调用userret函数</strong>。计算得出trampoline.S中userret的函数地址，将trampoline_userrt地址转换为函数指针，并将之前生成的satp的值作为参数且存储在a0寄存器中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><blockquote><p>现在程序又回到了trampoline中，接着梳理userret的执行流程</p></blockquote><ol><li><strong>切换页表</strong>。在执行<code>csrw satp, a1</code>之前，页表应该还是巨大的内核页表。这条指令会将用户页表存储在satp寄存器中，执行完这条指令后就切换后了用户页表。</li></ol><blockquote><p>幸运的是，用户页表也映射了trampoline页，所以程序还能继续执行而不是崩溃。</p></blockquote><p>通过打印a0的值也可以得知，a0的值就是我们传入的satp的参数。</p><p>现在可能对a0的值似乎有点混乱了。先捋一下，我们正在使用的a0寄存器保存的是satp这个参数、trapframe保存的a0值(偏移量为112的地址)是系统调用write的返回值、系统调用的第一个参数值文件描述符保存在sscratch中。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb8.png" alt="gdb8.png"></p><ol><li><strong>恢复用户寄存器的值</strong>。将trapframe地址写入a0(也就将a0保存的satp地址的值覆盖了)，通过以a0为基础将用户保存到trapframe中的用户寄存器的值恢复到寄存器中。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb9.png" alt="gdb9.png"></p><ol><li><strong>执行sret指令返回用户空间</strong>。我们在恢复完a0的值(系统调用的返回值)后，便指令sret指令。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/gdb10.png" alt="gdb10.png"></p><blockquote><p>sret会执行三件事:</p></blockquote><ul><li><p>管理者模式会切换回用户模式</p></li><li><p>sepc寄存器的数值会被拷贝到pc寄存器</p></li><li><p>重新打开中断</p></li></ul><p>执行完这条指令后我们就返回了用户空间。继续执行ecall的下一条指令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用被刻意设计的像函数调用，但是背后的user/kernel转换比函数调用要复杂的多。之所以复杂，很大一部分原因是要保持user/kernel之间的<strong>隔离性</strong>，内核不能信任来自用户空间的任何内容。</p><p>xv6实现trap的方式比较特殊，xv6<strong>并不关心性能</strong>。但是通常来说，操作系统的设计人员和cpu设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当我们在实现的时候，可以从以下几个问题出发：</p><ul><li><p>硬件和软件需要协同工作，你可能需要重新设计xv6，重新设计rics-v使得这里的处理流程更加简单，更加快速。</p></li><li><p>需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</p></li></ul><h1 id="内核陷阱-traps-from-kernel-space"><a href="#内核陷阱-traps-from-kernel-space" class="headerlink" title="内核陷阱(traps from kernel space)"></a>内核陷阱(traps from kernel space)</h1><blockquote><p>xv6根据内核或是用户的代码，以不同的方式配置了CPU的trap寄存器</p></blockquote><ul><li><strong>kernelvec</strong>：在内核栈中保存/恢复通用寄存器的值</li><li><strong>kerneltrap</strong>：内核处理trap的C语言代码</li></ul><p>当内核正在使用CPU，内核使<code>stvec</code>寄存器指向<code>kernelvec</code>汇编代码。由于xv6正处于内核，<code>kernelvec</code>可以依赖于<code>satp</code>寄存设置内核页表，并且栈指针指向一个有效的内核栈。<code>kernelvec</code>压入32个通用寄存器到内核栈，之后将会从中断内核代码除恢复这些寄存器，并且不会收到干扰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">        # make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        # save the registers.</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">        # call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        # return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p><code>kernelvec</code>保存中断线程的寄存到栈中，这些寄存器也只属于这个线程。不同线程中，其中一个线程因为trap导致切换线程，在这种情况下需要能够在内核栈恢复trap(中断/异常)的线程的寄存器。</p><p><code>kernelvec</code>汇编函数保存完寄存器代码后，会跳转到<code>kerneltrap</code>C函数代码中执行。<code>kerneltrap</code>代码处理两种类型的trap(中断/异常)。之后将会调用<code>devintr</code>函数去检查中断。如果不是设备中断，引起trap的就是异常，异常发生在内核是致命的错误，内核将会调用<code>panic</code>并停止执行。</p><p>如果<code>kerneltrap</code>是由于时钟被调用的，一个进程的内核线程正在运行(与不是调度线程)，<code>kerneltrap</code>调用<code>yield</code>函数让其他的线程能够得到机会运行。在某个时刻，其中一个线程将会停止，让线程和它的<code>kerneltrap</code>能够再次运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line">  <span class="comment">//检查是否是中断引起的trap</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>kerneltrap</code>的执行结束，它需要返回中断的代码处。因为<code>yield</code>函数可能会复写<code>sepc</code>与<code>sstatus</code>寄存器，<code>kerneltrap</code>开始时需要保存这些寄存器。之后恢复这些控制寄存器，返回到<code>kernelvec</code>。<code>kernelvec</code>弹出内核栈内保存的32个通用寄存器并执行<code>sret</code>，将<code>sepc</code>拷贝到<code>pc</code>从而重新执行被中断的内核代码。</p><p>当CPU从用户模式转到内核模式，xv6设置CPU的<code>stvec</code>寄存指向<code>kernelvec</code>(在<code>usertrap</code>代码，如果在系统调用期间发生中断，需要进入<code>kernelvec</code>函数中)，在内核开始执行，<code>stvec</code>仍设置为<code>uservec</code>的时间窗口，重要的是在此期间不发生中断。幸运的是RISC-V中总是在进入trap时，会禁用中断。并且在设置<code>stvec</code>寄存器后才会再次启用中断。</p><h1 id="缺页-page-fault"><a href="#缺页-page-fault" class="headerlink" title="缺页(page fault)"></a>缺页(page fault)</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p>缺页可以实现一系列管理虚拟内存功能，如下</p></blockquote><ul><li>lazy allocation：惰性分配</li><li>copy-on-write fork：COW</li><li><p>demand paging：分页请求</p></li><li><p>memory mapped files：内存映射文件</p></li></ul><p>在当今的操作系统都实现了这些功能，但是在xv6中却没有实现这些功能，当出现缺页的问题时，内核会将该进程直接杀死。好在在后续的实验中需要我们自己实现COW与MMAP的功能。</p><blockquote><p>缺页与除零操作一样属于<strong>异常</strong>trap类型(也有中断缺页，只不过在xv6中讲到的都是异常缺页，参考COW实验)</p></blockquote><h3 id="回顾：虚拟内存"><a href="#回顾：虚拟内存" class="headerlink" title="回顾：虚拟内存"></a>回顾：虚拟内存</h3><blockquote><p>虚拟内存的优点</p></blockquote><ul><li><p><strong>Isolation</strong>，隔离性。虚拟内存使得操作系统可以为每个应用程序提供属于它们自己的地址空间。</p></li><li><p><strong>level of indirection</strong>，提供了一层抽象。处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。需要特别注意的虚拟页：</p><ul><li><p><strong>trampoline page</strong>，它使得内核可以将一个物理内存page映射到多个用户地址空间中。</p></li><li><p><strong>guard page</strong>，它同时在内核空间和用户空间用来保护Stack。</p></li></ul></li></ul><p>到目前为止内存地址映射相对来说比较<strong>静态</strong>。不管是用户页表还是内核页表，都是在最开始的时候设置好，之后就不会再做任何变动。</p><h3 id="缺页：地址动态映射"><a href="#缺页：地址动态映射" class="headerlink" title="缺页：地址动态映射"></a>缺页：地址动态映射</h3><p>缺页可以让地址映射关系变得<strong>动态</strong>起来。通过缺页，内核可以更新页表，这是一个非常强大的功能。因为现在可以动态的更新虚拟地址这一层抽象，结合页表和缺页，内核将会有巨大的<strong>灵活性</strong>。</p><p>首先，我们需要思考的是，什么信息会向内核传达发生了缺页。或者说，当发生缺页时，内核需要什么样的信息才能够响应缺页。</p><ul><li><p>第一个信息是<strong>出错的虚拟地址</strong>，或者是触发缺页的源。当出现缺页的时候，xv6内核会打印出错的虚拟地址，并且这个地址会被保存在stval寄存器中。所以，当一个用户应用程序触发了缺页，缺页会使用与syscall相同的trap机制，将程序运行切换到内核，同时也会将出错的地址存放在stval寄存器中。</p></li><li><p>第二个信息是<strong>出错的原因</strong>，对不同场景的缺页有不同的响应。不同的场景是指，比如因为load指令触发的缺页、因为store指令触发的缺页又或者是因为jump指令触发的缺页。在scause寄存器的介绍中(如下图)，有多个与缺页相关的原因。比如，</p><ul><li>13表示是因为load引起的缺页；</li><li>15表示是因为store引起的缺页；</li><li>12表示是因为指令执行引起的缺页。</li></ul><p>所以第二个信息存在scause寄存器中，其中总共有3个类型的原因与缺页相关，分别是读、写和指令。ecall进入到supervisor mode对应的是8。基本上来说，缺页与系统调用使用相同的trap机制来从用户空间切换到内核空间。如果是因为缺页触发的trap机制并且进入到内核空间，stval寄存器和scause寄存器都会有相应的值。</p></li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/scause.png" alt="scause"></p><ul><li>第三个信息是<strong>触发缺页的指令的地址</strong>。这个地址存放在sepc寄存器中，并同时会保存在<code>trapframe-&gt;epc</code>我们或许想要知道的第三个信息是触发缺页的指令的地址。从上节课可以知道，作为trap处理代码的一部分，这个地址存放在sepc寄存器中，并同时会保存在<code>trapframe-&gt;epc</code></li></ul><h3 id="缺页：硬件"><a href="#缺页：硬件" class="headerlink" title="缺页：硬件"></a>缺页：硬件</h3><p>从硬件和xv6的角度来说，当出现了缺页，现在有了3个对我们来说极其有价值的信息，分别是：</p><ul><li>引起缺页的<strong>虚拟内存地址</strong>(stval)</li><li>引起缺页的<strong>原因类型</strong>(scause)</li><li>引起缺页时的<strong>程序计数器值</strong>(epc)，这表明了缺页在用户空间发生的位置</li></ul><p>之所以关心触发缺页时的程序计数器值，是因为在缺页处理程序中我们或许想要修复页表，并<strong>重新执行</strong>对应的指令。理想情况下，修复完page table之后，指令就可以无错误的运行了。所以，能够恢复因为缺页的指令运行是很重要的。</p><h2 id="案例：Lazy-Allocation"><a href="#案例：Lazy-Allocation" class="headerlink" title="案例：Lazy Allocation"></a>案例：Lazy Allocation</h2><h3 id="代码：堆空间分配"><a href="#代码：堆空间分配" class="headerlink" title="代码：堆空间分配"></a>代码：堆空间分配</h3><blockquote><p>动态空间分配主要关注的是<code>sbrk</code>这个系统调用。</p></blockquote><p>分析下述代码，在proc结构体中有一个字段是<code>sz</code>，这个是整个进程虚拟空间的大小。如下图sz字段既是进程空间的大小，也是堆的起始地址。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/vmproc.png" alt="vmproc"></p><p>在<code>sys_brk</code>系统调用中，记录当前sz(堆的初始地址)为<code>addr</code>，并使用<code>growproc</code>新增物理页建立映射，将<code>sz</code>字段增加n。最后返回<code>addr</code>值(堆的虚拟地址)到用户空间，用户进程就能使用堆空间了。</p><blockquote><p><strong>NOTE</strong>：堆空间是向上增长的，而堆空间是向下增长的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">     uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">----sysproc.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理：Lazy-Allocation"><a href="#原理：Lazy-Allocation" class="headerlink" title="原理：Lazy Allocation"></a>原理：Lazy Allocation</h3><blockquote><p>eager allocation</p></blockquote><p>首先先了解，与之相对的<strong>eager allocation</strong>（xv6中默认的实现）。这种分配方式是用户进程调用malloc(sbrk系统调用)时，内核立即反应该请求，新建物理页并于虚拟地址建立映射，返回用户空间后用户便能够使用这部分的内存了。</p><blockquote><p>为什么需要lazy allocation？</p></blockquote><p>实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，进程的内存消耗会增加许多，但是有部分内存永远也不会被应用程序所使用到。</p><blockquote><p>lazy allcotion</p></blockquote><p><strong>lazy allocation</strong>的实现是，用户空间发起<code>sbrk</code>系统调用时不是立即分配物理页建立页表映射，只是做出一点标识(增加sz字段)告诉操作系统地址，用户后续要使用增加的这部分内存。</p><p>之后在用户要使用刚刚<code>sbrk</code>申请的这一段空间时，就会触发<strong>缺页</strong>进入内核空间，根据trap产生原因进行处理，然后就是创建页表与建立页表映射返回用户空间，那么用户就可以使用这部分内存了。</p><h3 id="实现：Lazy-allocation"><a href="#实现：Lazy-allocation" class="headerlink" title="实现：Lazy allocation"></a>实现：Lazy allocation</h3><blockquote><ol><li>sbrk实现改为Lazy allocation</li></ol></blockquote><p>看下述代码，在sbrk中只需要做的是增加了sz的长度，注释<code>growproc</code>语句。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sbrk(void)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  int n;</span><br><span class="line"></span><br><span class="line">  argint(0, &amp;n);</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  myproc()-&gt;sz = myproc()-&gt;sz + n;</span></span><br><span class="line"><span class="deletion">-  // if(growproc(n) &lt; 0)</span></span><br><span class="line"><span class="deletion">-  //   return -1;</span></span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时重新运行xv6，在shell中运行<code>echo hi</code>命令这时候会得到以下的报错。对应到我们之前所讲的。下面几个寄存器的作用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012c8 stval=0x0000000000005008</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><ul><li><strong>scause</strong>：保存触发trap的原因</li><li><strong>sepc</strong>：触发trap时，在用户空间的pc值</li><li><strong>stval</strong>：触发trap的的用户进程的虚拟地址</li></ul><p>根据<strong>scause</strong>寄存器的值(=15)我们可以知道，是store指令错误导致缺页错误(查看scause值表)。之所以会导致这个错误，是因为在shell中执行程序，shell会先<code>fork</code>一个子进程，子进程会通过<code>exec</code>执行<code>echo</code>。在这个过程中，shell会申请一些内存，所以Shell会调用<code>sys_sbrk</code>，所以导致触发缺页错误。</p><blockquote><p>在上述错误中我们可以知道，出问题的进程pid=3。根据xv6的设计可以知道内核进程pid=1，而shell程序的pid=2。那fork得到的子进程pid=3.</p></blockquote><p>而且根据ecp的值，我们可以找到触发trap的指令，在sh.asm中可以发现，<code>sw</code>这是存储字的指令，那么就是说存储nu的值到内存时触发的缺页异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----sh.<span class="keyword">asm</span></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(uint nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">      hp-&gt;s.size = nu;</span><br><span class="line">    <span class="number">12</span>c8:<span class="number">01652423</span>          sws6,<span class="number">8</span>(a0)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><ol><li>缺页处理代码</li></ol></blockquote><p>根据上述错误，我们回到usertrap函数，查看原函数并没有处理<code>store page fault</code>的代码，因此看下述代码中我们加入一个检查scause=15的处理代码。</p><p>具体的逻辑如下：首先我们需要从<code>stval</code>寄存器中读取触发缺页的虚拟地址，然后申请一个物理页，清空物理页并建立内存映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">....</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123; </span><br><span class="line">    uint64 va = r_stval(),pa;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page falut: %p\n&quot;</span>,va);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>((pa = (uint64)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)pa,<span class="number">0</span>,PGSIZE);</span><br><span class="line">      va = PGROUNDDOWN(va);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable,va,PGSIZE,pa,PTE_R|PTE_U|PTE_W) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><ol><li>释放内存uvmunmap函数错误</li></ol></blockquote><p>这时候我们再次运行<code>echo hi</code>命令会出现下述错误。于是在kernel/vm.c文件查看对应的函数，uvmumap函数作用是释放用户内存。在panic处检查错误的虚拟地址，发现为虚拟地址值为0x6000。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hi</span></span><br><span class="line">page falut: 0x0000000000005008</span><br><span class="line">page falut: 0x0000000000014f48</span><br><span class="line">panic: uvmunmap: not mapped</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在uvmunmap中检查错误的虚拟地址</span></span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hi</span></span><br><span class="line">page falut: 0x0000000000005008</span><br><span class="line">page falut: 0x0000000000014f48</span><br><span class="line">va = 0x0000000000006000</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure><p>那么根据前两个page fault的地址可以知道，我们只创建了两个物理页地址分别为(0x5000和0x14000)并建立映射。但是uvmumap是按照顺序进行的释放物理页的。那么0x6000是实际上还没有触发缺页的地址(sbrk已经分配但是没有使用)，因此页表内没有PTE记录，所以会panic。</p><blockquote><p>这个错误理解起来就是，sbrk实际上分配很多内存，但是触发缺页的地址只有0x5000与0x14000因此只分配这两个物理页，页表里面也只添加了这些PTE。那么0x6000到<code>p-&gt;sz</code>这个区间(除去0x14000)在lazy allocation逻辑上已经分配，但是呢，并没有触发缺页因此没有实际分配对应的物理页。</p></blockquote><p>根据下述GDB调试可以得知是调用exec覆盖之前页表内存</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/lazy%20allocation.png" alt="lazy allocation"></p><blockquote><p>4.问题解决：</p></blockquote><p>解决的方式十分的简单就是直接跳过这个检测就行了，也就是删除panic，添加一个<code>continue</code>，因为在逻辑上我们已经增加了堆空间，但是在exec执行时我们需要跳过这个检测，到后续才能在使用内存时通过缺页创建。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  pte_t *pte;</span><br><span class="line"></span><br><span class="line">  if((va % PGSIZE) != 0)</span><br><span class="line">    panic(&quot;uvmunmap: not aligned&quot;);</span><br><span class="line"></span><br><span class="line">  for(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    if((pte = walk(pagetable, a, 0)) == 0)</span><br><span class="line">      panic(&quot;uvmunmap: walk&quot;);</span><br><span class="line">    if((*pte &amp; PTE_V) == 0)</span><br><span class="line"><span class="addition">+     continue;</span></span><br><span class="line"><span class="deletion">-     //panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    if(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(&quot;uvmunmap: not a leaf&quot;);</span><br><span class="line">    if(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((void*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以上便是一个基于<strong>缺页</strong>实现的lazy allocation策略。其核心思想主要是<strong>等一会儿</strong>，也就是到我们要使用这部分内存时再分配，避免造成内存的浪费。</p><p>缺点就是开销有点大，因为缺页导致每次都需要通过trap进出内核。</p><h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>Copy-on-Write fork的具体实现也就是缺页异常的一种。在实验中会有所涉及，在本文就不过多赘述了，具体的实现可以查看<a href="https://zhuanlan.zhihu.com/p/629442061">Xv6 Lab5：COW </a>。</p><h2 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h2><p>其余的实现有Zero Fill On Demand、mmap、Demand Paging，其思想与前两者一致，想要了解可以观看课程视频，或是中文翻译文档。</p><p>参考：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec08-page-faults-frans/8.3-zero-fill-on-demand">8.3 Zero Fill On Demand - MIT6.S081 (gitbook.io)</a></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>这一章花费了大量的文笔去描述了xv6中，如何通过trap实现进出内核空间。单纯的只是看xv6的指导书的话是很难理解的，建议还是观看课程视频。</p><p>本章主要是讲解了两种trap方式：</p><ul><li><strong>系统调用</strong>：以系统调用的视角讲解了用户空间是如何进出内核的。</li><li><strong>异常</strong>：以缺页的方式，讲解了内核该如何优雅的处理异常代码，而不是简单的杀死进程。</li></ul><p>本文主要以系统调用的trap类型，使用GDB的方式演示了用户空间是如果通过一行行指令进入内核空间的。通过学习完本节，不但可以了解GDB的调试方式、寄存器在其中的作用、汇编代码，更重要的是对xv6的trap设计更加了解了。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab COW</title>
      <link href="/2023/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab5%EF%BC%9ACOW/"/>
      <url>/2023/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab5%EF%BC%9ACOW/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/cow.html">Lab: COW</a></p></blockquote><p>实验开始之前需要将git分支切换到cow分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout cow</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="普通fork的问题"><a href="#普通fork的问题" class="headerlink" title="普通fork的问题"></a>普通fork的问题</h3><p>一个进程调用fork后会创建和父进程一样大的物理内存空间，并拷贝父进程的物理内存的内容。这样会造成物理空间的浪费，以shell程序为例运行一个命令首先会调用fork拷贝父进程，然后使用exec将程序重新写入子进程的空间。</p><p>在这种情况下，首先创建和父进程一样大的空间会造成<strong>空间的浪费</strong>，其次将父进程的内容拷贝到子进程有使用exec覆盖内存会<strong>浪费时间</strong>。</p><h3 id="copy-on-write-fork"><a href="#copy-on-write-fork" class="headerlink" title="copy-on-write fork"></a>copy-on-write fork</h3><blockquote><p>copy-on-write fork是缺页(异常操作)的一种应用场景，几乎在所有操作系统中都实现了这个功能。</p></blockquote><p>==COW==怎样解决上述普通fork的问题？</p><p>像是惰性分配(lazy allocation)的方式，先不创建物理页表而是进程，当进程需要使用这部分内存时再分配。</p><p>所以COW fork的具体实现就是，在使用fork创建子进程时，只是给子进程<strong>创建一个页表</strong>,将子进程的虚拟页<strong>映射</strong>到父进程的物理页，并且将子进程的PTE与父进程的PTE设置为<strong>不可读</strong>(清空PTE_W位)。那么当运行子进程时，需要写入对应的物理页时就会<strong>触发缺页异常</strong>。trap处理程序会识别缺页异常，在cow处理程序中新建物理页，并重新设置页表的PTE映射到该物理页并设置标志位。</p><blockquote><p><strong>Q：</strong>为什么要将父进程也设置为<strong>不可读</strong>？</p><p><strong>A：</strong>我们要保持父进程与子进程的<strong>隔离性</strong>，那么父进程如果可以直接写这个物理页，那么子进程就可以看见了父进程的数据了。</p></blockquote><h2 id="COW实验"><a href="#COW实验" class="headerlink" title="COW实验"></a>COW实验</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>本次实验是在xv6中完成cow fork功能。需要通过cowtest的测试与usertests -q测试。</p><blockquote><p>实验的输出结果如下：使用<code>make grade</code>便可以</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">file: ok</span><br><span class="line">ALL COW TESTS PASSED</span><br><span class="line">$ usertests -q</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>建议观看<a href="https://www.bilibili.com/video/BV19k4y1C7kA?p=7&amp;vd_source=e58c5653c6883cfb538c73385a0fba63">lecture8</a>，这节课介绍了缺页错误的基本处理方式与COW的实现原理。</p><p>当usertrap发现错误时，可以通过<code>scause</code>的参数看如下的表中关于引起trap类型。在实验中我们主要是处理写入物理页错误(主要是因为PTE_W没有设置会被mmu检测出来)，那么相应的scause数值是<code>0xf=15</code>，代表载入缺页(store page fault)，通过scause参数我们也可以发现出现了这条命令不是中断触发的，因此这里的缺页是属于一种异常操作(读取了非法的物理地址，由mmu检查得出)。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/scause.png" alt="scause"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>本次实验主要是修改fork的拷贝方式，那么首先我们要看看fork是如何拷贝的，看下述代码我们可以知道fork主要是使用了uvmcopy实现了内存的拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 为子进程创建页表并建立trapframe与trampoline的映射</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是修改uvmcopy函数的拷贝逻辑了。</p><h3 id="修改fork拷贝方式"><a href="#修改fork拷贝方式" class="headerlink" title="修改fork拷贝方式"></a>修改fork拷贝方式</h3><p>在下述注释的代码中，xv6为子进程新建了物理页，拷贝父进程的内存内容，并将子进程的的虚拟地址映射到新的物理页上。</p><p>根据cow fork的原理则是将子进程的虚拟地址映射到父进程的物理页上。需要注意以下几点</p><ul><li>设置父进程与子进程的pte标志位，清空PTE_W，添加cow fork识别位(PTE_F=1L &lt;&lt; 8)</li><li>增加对于物理页的引用计数</li><li>mappages将子进程的虚拟地址映射到父进程的物理地址</li></ul><blockquote><p><strong>Q：</strong>为什么要添加PTE_F位?</p><p><strong>A：</strong>cow fork是一种特殊的缺页处理方式，将pte的写位清空后会触发缺页异常，那么当其他物理页也是只读也触发了缺页异常，显然不能够与cow fork的处理方式一样所以，需要标记这个位。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----vm.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">      <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">      pa = PTE2PA(*pte);    <span class="comment">//parent&#x27;s physical page address</span></span><br><span class="line"></span><br><span class="line">      *pte &amp;= ~PTE_W;       <span class="comment">//clear the write flag</span></span><br><span class="line">      *pte |= PTE_F;</span><br><span class="line">      flags = PTE_FLAGS(*pte);   </span><br><span class="line">      <span class="comment">// if((mem = kalloc()) == 0)</span></span><br><span class="line">      <span class="comment">//   goto err;</span></span><br><span class="line">      <span class="comment">// memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line">      <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree((<span class="type">void</span>*)pa);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      increRC((<span class="type">void</span>*)pa); <span class="comment">// increase physical page&#x27;s ref count, encapsulation data RC , increRC is method for it</span></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>改完uvmcopy函数后会出现了没有处理scause=15的缺页异常的处理函数的问题。</p><h3 id="处理COW缺页错误-trap-c"><a href="#处理COW缺页错误-trap-c" class="headerlink" title="处理COW缺页错误(trap.c)"></a>处理COW缺页错误(trap.c)</h3><p>当uvmcopy建立好映射后，当子进程或者父进程写入物理页时就会触发缺页异常，那么根据scause的值xv6需要对15这个值进行对应的处理。</p><p>编写一个函数称为cowfault通过输入进程的页表与错误的虚拟地址便可以处理cow fork的缺页异常了。如果cowfault返回值为-1说明有非法参数，或是pte的设置错误，那么xv6会杀死对应的进程。返回值为0则是成功。</p><blockquote><p>cowfault的执行流程</p></blockquote><ol><li>检测虚拟地址是否合法</li><li>通过walk获得缺页错误的虚拟地址pte，并检测pte的权限位。</li><li>生成物理地址(子进程与父进程共同使用的物理页地址)</li><li>获得这个物理页的引用计数，如果引用计数为1说明此时只有一个进程在使用这个物理页，我们只需要修改权限位即可(添加PTE_W与清空PTE_F)。</li><li>反之我们有多个进程在使用一个物理页，因此我们需要重新分配新的物理页，拷贝原理的物理页的内容。</li><li>调用kfree：这个函数会在kalloc被重新调整，通过引用计数判断是否能够释放内存。</li><li>判断虚拟地址的数据，如果<code>va == 0</code>的话说明这个页是代码段页，那么我们是不能修改这个页面的，也就是不能添加写位。修改pte的值将虚拟内存的地址指向新建的物理。</li></ol><blockquote><p><strong>Q：</strong>我们为什么不用在cowfault处理函数修改父进程或子进程的pte权限位</p><p><strong>A：</strong>首先两个进程是隔离的，我们不能获取另一个进程的页表数据。其次，如果是父进程或子进程的pte中没有写权限，那么我们仍然会触发cow fault，这样的话在cowfault函数中新建物理页并拷贝，或是新增pte的权限(上述第4点)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowfault</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 va)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(pagetable,va,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>|| (*pte &amp; PTE_F) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    uint64 pa = PTE2PA(*pte); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rc = getRC((<span class="type">void</span>*)pa);</span><br><span class="line">    <span class="keyword">if</span>(rc == <span class="number">1</span>)&#123;<span class="comment">//rc == 1 means don’t copy src physical page</span></span><br><span class="line">      *pte |= PTE_W;</span><br><span class="line">      *pte &amp;= ~PTE_F;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint64 new = (uint64)kalloc();</span><br><span class="line">    <span class="keyword">if</span>(!new)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memmove((<span class="type">void</span>*)new , (<span class="type">void</span>*)pa ,PGSIZE);<span class="comment">//copy parent&#x27;s physical memory</span></span><br><span class="line"></span><br><span class="line">    kfree((<span class="type">void</span>*)pa); <span class="comment">// just reduce old pg&#x27;s ref count , not free the physical page</span></span><br><span class="line">    <span class="keyword">if</span>(PGROUNDDOWN(va) == <span class="number">0</span>)&#123;</span><br><span class="line">      *pte  = PA2PTE(new) | PTE_V | PTE_R | PTE_U | PTE_X; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      *pte  = PA2PTE(new) | PTE_V | PTE_R | PTE_W | PTE_U | PTE_X; <span class="comment">// remap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;&#123;</span><br><span class="line">      ....</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>(cowfault(p-&gt;pagetable,r_stval())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用计数-kalloc-c"><a href="#引用计数-kalloc-c" class="headerlink" title="引用计数(kalloc.c)"></a>引用计数(kalloc.c)</h3><p>kalloc是关于物理页的分配。那么对cow的功能实现后我们需要添加物理页引用计数，不能让kfree随意的释放物理页(像是c++的share_ptr)。</p><blockquote><p>实现流程</p></blockquote><ol><li>添加一个物理页编号的数组，作为物理页的引用计数。所以物理页都需要编号包括硬件设备的物理页，不然kfree释放或是kalloc分配时会因为引用计数的问题出现错误。</li><li>kalloc函数：初始化物理页的引用计数，当有函数调用kalloc时说明对应的物理页已经被应用了并且将引用计数设置为1。</li></ol><blockquote><p>为什么需要加锁，因为在多核cpu下对于物理页的分配或是引用计数的操作会产生竞争</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----kalloc.c</span><br><span class="line"><span class="type">int</span> RC[PHYSTOP/PGSIZE];</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    <span class="type">int</span> pn = (uint64)r/PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(RC[pn] != <span class="number">0</span>)&#123;</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RC[pn] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>kfree函数：减少物理页的引用计数，当引用计数降为1时释放这个物理页。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="type">int</span> pn = (uint64)pa / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span>(RC[pn]&lt;<span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;kfree rf&quot;</span>);</span><br><span class="line">  <span class="type">int</span> tmp = --RC[pn];</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>添加引用计数变量的接口(封装RC变量)：</p><ul><li><p>getRC：便于在cowfault中判断是否只有一个进程使用该物理页。</p></li><li><p>increRC：便于在uvmcopy函数中调用并增加该物理页的引用计数。</p></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得物理页的引用计数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getRC</span><span class="params">(<span class="type">void</span> *pa)</span>&#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="type">int</span> pn = (uint64)pa/PGSIZE;</span><br><span class="line">  <span class="type">int</span> tmp = RC[pn];</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加物理页的引用计数</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">increRC</span><span class="params">(<span class="type">void</span> *pa)</span>&#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="type">int</span> pn = (uint64)pa/PGSIZE;</span><br><span class="line">  <span class="keyword">if</span>((uint64)pa &gt;= PHYSTOP || RC[pn] &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;incre&quot;</span>);</span><br><span class="line">  RC[pn]++;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在xv6最开始时，初始化都会调用kfree清空物理内存，最开始RC数组内的变量都为0，调用kfree就会出现panic，这时只需要将RC初始为1即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">//初始化所有物理页的引用计数</span></span><br><span class="line">    RC[(uint64)p / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cow遗漏之处"><a href="#cow遗漏之处" class="headerlink" title="cow遗漏之处"></a>cow遗漏之处</h3><blockquote><p><strong>Fault:</strong> 在cowtest测试中对于file测试点会出现问题：</p><p>因为pipe调用copyout将内核内存(文件描述符)拷贝到用户空间会出现了问题。</p><p>内核进程也不能够使用用户进程的虚拟地址去修改用户数据，xv6绕过<strong>mmu</strong>直接使用<strong>物理地址</strong>修改了物理页的数据，因此缺乏硬件的支持(检测虚拟地址的PTE)导致在不能写入物理页的情况下通过物理地址写入了数据，从而打破了子进程与父进程的<strong>隔离性</strong>。</p></blockquote><p><strong>处理方法</strong>：检测用户进程虚拟地址与页表对应的PTE的标志位，如果没有PTE_W并且有PTE_F位，那么说明用户进程(cow fork)与其他进程共享物理内存，就应该触发cowfault的处理函数，这样的话就实现了完善的cow fork。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">----vm.c</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(pagetable,va0,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>  || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_F) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(cowfault(pagetable , va0) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pa0 = walkaddr(pagetable, va0);</span></span><br><span class="line">    <span class="comment">// if(pa0 == 0)</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line"></span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE</strong>: 上述代码中需要在def.h中补上一些函数的接口</p><ol><li><p>在vm.c中要调用trap.c的cowfault函数，在def.h中声明</p><p><code>int cowfault(pagetable_t,uint64)</code></p><p>如果需要更强的封装性就需要使用void指针，进一步的进行类型强转。</p><p><code>int cowfault(void*,void*)</code></p></li><li><p>在trap.c与vm.c中调用了kalloc.c中的RC变量的接口也需要声明</p><p><code>int getRC(void*)</code></p><p><code>void increRC(void*)</code></p><p>上述void*对应的是物理地址这个uint64变量。</p></li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验相对于前面的实验算是比较困难的实验，前期在做的时候实在识别不了报出的错误(没有做引用计数的管理)，于是照着看了一遍<a href="https://www.bilibili.com/video/BV19k4y1C7kA?p=11&amp;vd_source=e58c5653c6883cfb538c73385a0fba63">lecture12</a>，知道了为什么有这些问题出现，并进一步的优化了代码(父进程不需要重新分配物理并将之前的页释放)。</p><p>看着教授做完，自己没有怎么过脑子。但是自己在做的过程中也遇到了一些问题，例如textwrite测试中，不能在代码段写入数据的问题。以及引用计数中，擅自释放了物理页的问题。</p><p>做完这个实验熟悉了：</p><ul><li>c语言中面对对象的<strong>封装</strong>思想：<ul><li>在kalloc.c中对于RC(引用计数)变量，在def.h文件不能<strong>暴露</strong>RC变量，而是提供接口如increRC(增加引用计数)、getRC(获得引用计数)。</li><li>使用void指针进行类型强转实现更加健硕的封装性，如在def.h中定义这个接口getRC(void *)，实际上我们传入的参数是物理地址(uint64)。</li></ul></li><li>提高安全代码书写的意识，检测非法变量。</li><li>操作系统如何管理内存：通过页表这一个抽象实现了<strong>隔离</strong>与<strong>高性能的内存运用</strong>。</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/cow%20result.png" alt="cow result"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab Multithread</title>
      <link href="/2023/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab6%EF%BC%9AMultithreading/"/>
      <url>/2023/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab6%EF%BC%9AMultithreading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/thread.html">Lab: Multitrheading</a></p></blockquote><p>实验开始之前需要将git分支切换到thread分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout thread</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="Uthread-switching-between-threads-moderate）"><a href="#Uthread-switching-between-threads-moderate）" class="headerlink" title="Uthread: switching between threads (moderate）"></a>Uthread: switching between threads (moderate）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    本次实验是要实现用户级的线程上下文切换机制。在实验中提供了两个文件<code>user/uthread.c</code>和<code>user/uthread_switch.S</code>，在<code>uthread.c</code>文件中提供了一些用户级线程要使用的包，还有三个线程的代码，在这个文件中缺少了创建线程与切换上下文的代码。</p><blockquote><p><strong>任务</strong>：创建线程和保存/恢复寄存器以在线程之间切换的计划，并实现该计划。当你完成后，评分应该表明你的解决方案通过了线程测试。</p></blockquote><p>当完成之后可以运行uthread，输出的结果如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">$ uthread</span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_a: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_b: <span class="built_in">exit</span> after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>​    但是如果没有实现线程切换代码，程序是不会有任何的输出。因此我们需要在实验中添加，代码到<code>thread_create()</code> 、 <code>thread_schedule()</code>两个函数的指定区域，再添加汇编代码到<code>thread_switch.S</code>。</p><ul><li><code>thread_switch.S</code>保存的是切换上下文的汇编代码，在<code>kernel/switch.S</code>中便有所实现，就是保存/恢复callee寄存器的值，因为callee寄存器在函数调用中不会被保存。</li><li><code>thread_schedule()</code>函数与内核文件<code>proc.c/scheduler()</code>函数的实现原理是相同的，就是找到一个RUNNALBE线程并调用<code>thread_switch</code>切换上下文，但是uthread中并没有实现上下文切换。</li><li><code>thread_create()</code>函数就是创建一个线程，在内核代码<code>proc.c/allocproc</code>函数中就有创建当前线程的上下文的代码。</li></ul><p>​    如下面代码所示，我们将上下文的ra寄存器保存为了<code>forkret</code>的地址，那么当scheduler切换到该线程后就会转到<code>forkret</code>函数，并且返回用户空间。后面讲栈指针设置为了栈的地址设置为了内核栈的上一页，值得注意的是栈是从<strong>上往下增长的</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>HINTS</strong>：一些关于调试的用户文件的技巧，如果感兴趣的话可以自行查看</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​    用户级线程切换与内核级线程切换并没有什么区别，所以大部分的代码都可以cv内核的代码。</p><blockquote><p><strong>context</strong>：上下文结构</p></blockquote><p>​    <code>context</code>直接cv内核文件中的contex结构体(<code>kernel/pro.h</code>)就可以了，然后添加<code>context</code>字段到<code>thread</code>结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----uthread.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>     <span class="title">context</span> <span class="title">ucontext</span>;</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>上下文切换</strong></p></blockquote><p>​    上下文切换代码也可以直接cv内核上下文切换的汇编代码(<code>kernel/switch.S</code>)，如下所示我们将代码粘贴到<code>uthread_switch</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl thread_switch</span><br><span class="line"></span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line">sd ra, 0(a0)</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    sd s0, 16(a0)</span><br><span class="line">    sd s1, 24(a0)</span><br><span class="line">    sd s2, 32(a0)</span><br><span class="line">    sd s3, 40(a0)</span><br><span class="line">    sd s4, 48(a0)</span><br><span class="line">    sd s5, 56(a0)</span><br><span class="line">    sd s6, 64(a0)</span><br><span class="line">    sd s7, 72(a0)</span><br><span class="line">    sd s8, 80(a0)</span><br><span class="line">    sd s9, 88(a0)</span><br><span class="line">    sd s10, 96(a0)</span><br><span class="line">    sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ld s0, 16(a1)</span><br><span class="line">    ld s1, 24(a1)</span><br><span class="line">    ld s2, 32(a1)</span><br><span class="line">    ld s3, 40(a1)</span><br><span class="line">    ld s4, 48(a1)</span><br><span class="line">    ld s5, 56(a1)</span><br><span class="line">    ld s6, 64(a1)</span><br><span class="line">    ld s7, 72(a1)</span><br><span class="line">    ld s8, 80(a1)</span><br><span class="line">    ld s9, 88(a1)</span><br><span class="line">    ld s10, 96(a1)</span><br><span class="line">    ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">ret    /* return to ra */</span><br></pre></td></tr></table></figure><blockquote><p>创建线程：</p></blockquote><p>​    与<code>allocproc</code>一样，在创建线程时候需要分配线程上下文的<code>sp</code>与<code>ra</code>寄存器，<code>func</code>就是每个线程的要执行的函数，在上下文切换后就是返回到<code>func</code>函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;ucontext.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">  t-&gt;ucontext.ra = (uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在thread结构体中有一个<code>char stack[STACK_SIZE]</code>字段，那么也就是说线程的栈空间是两个页，8192字节。那么<code>t-&gt;stack</code>就是栈的底部，由于<code>risc-v</code>的栈是从上往下增长的，所以我们要将栈指针设置为stack数组的最后一个值即可，布局如下图所示。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/thread_stack.png" alt="thread_stack"></p><blockquote><p>线程调度</p></blockquote><p>​    线程调度函数没什么特别的，我们需要做的就是调用<code>thread_switch</code>上下文切换的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123; </span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line"></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;ucontext,(uint64)&amp;next_thread-&gt;ucontext);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>写在前面</strong>：这个实验与后一个实验本身都不难，因此实验文档只是通过翻译软件翻译的，建议看官方原文档。</p></blockquote><p>​    在本实验中，您将探索使用哈希表进行线程和锁的并行编程。这个实验的过程使用的是UNIX的pthread线程库，因此不需要在qemu或是xv6上运行，在正常的linux上运行即可。您可以通过man pthreads从手册页找到有关它的信息，也可以在在网络上搜索上查找。</p><p>​    文件<code>notxv6/ph.c</code>包含一个简单的哈希表，如果从单个线程使用它是正确的，但如果从多个线程使用它就不正确了。在xv6目录中，输入如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ph</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ph 1</span></span><br></pre></td></tr></table></figure><p>​    请注意，要构建ph, Makefile使用的是操作系统的gcc，而不是6.S081工具。ph的参数指定在哈希表上执行put和get操作的线程数。运行一段时间后，<code>./ph 1</code>将产生类似于以下的输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100000 puts, 3.991 seconds, 25056 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 3.981 seconds, 25118 gets/second</span><br></pre></td></tr></table></figure><p>您看到的数字可能与这个示例输出相差两倍或更多，这取决于您的计算机有多快，是否有多个核心，以及它是否忙于做其他事情。</p><p>ph运行两个基准。首先，它通过调用<code>put()</code>将许多键添加到哈希表中，并以每秒放置次数为单位打印实现的速率。它使用<code>get()</code>从哈希表中获取键。它打印由于put操作而应该在哈希表中但缺少的数字键(在本例中为零)，并打印每秒实现的get次数。</p><p>通过给ph一个大于1的参数，可以告诉它同时从多个线程使用它的哈希表。试试ph 2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ph 2</span></span><br><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure><p>这个<code>./ph 2</code>输出的第一行表明，当两个线程<strong>并发</strong>地向哈希表中添加条目时，它们达到了每秒53,044次插入的总速率。这大约是运行ph 1时单线程速率的两倍。这是一个出色的“并行加速”，大约是2倍，这是人们可能希望的(即两倍的内核产生两倍的单位时间的工作)。</p><p>但是，缺少16579个键的两行表明，大量本应在哈希表中的键不在哈希表中。也就是说，put应该将这些键添加到哈希表中，但是出了问题。看看<code>notxv6/ph.c</code>，特别是<code>put()</code>和<code>insert()</code>。</p><blockquote><p>为什么有2个线程，而不是1个线程丢失的键?用两个线程确定可能导致丢失密钥的事件序列。</p><p>为了避免这种事件序列，请在<code>notxv6/ph.c</code>中的<code>put</code>和<code>get</code>中插入lock和unlock语句，以便在两个线程中丢失的键数始终为0。相关的pthread调用是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure><p>当<code>make grade</code>说你的代码通过了<code>ph_safe</code>测试时，你就完成了，这需要两个线程的零丢失键。此时，<code>ph_fast</code>测试失败也没关系。</p></blockquote><p>不要忘记调用<code>pthread_mutex_init()</code>。先用一个线程测试你的代码，然后用两个线程测试。它是否正确(即你是否消除了丢失的键?)?相对于单线程版本，双线程版本是否实现了并行加速(即每单位时间内完成的总工作量更多)?</p><p>在某些情况下，并发put()操作在哈希表中读取或写入的内存没有重叠，因此不需要锁来相互保护。您可以更改ph.c以利用这种情况来获得一些put()s的并行加速吗?提示:每个哈希桶加一个锁怎么样?</p><blockquote><p>不要忘记调用pthread_mutex_init()。先用一个线程测试你的代码，然后用两个线程测试。它是否正确(即你是否消除了丢失的键?)?相对于单线程版本，双线程版本是否实现了并行加速(即每单位时间内完成的总工作量更多)?</p><p>在某些情况下，并发put()操作在哈希表中读取或写入的内存没有重叠，因此不需要锁来相互保护。您可以更改ph.c以利用这种情况来获得一些put()s的并行加速吗?提示:每个哈希桶加一个锁怎么样?</p></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>首先声明了一个全局变量lock，在main函数中对这个锁变量进行初始化。</li><li>这里我使用了两个宏定义了加锁与解锁的两个函数(图的方便而已)</li></ul><p>​    对于ph程序并不需要增加多少代码，问题处是在使用<code>put</code>函数时<strong>并发</strong>修改哈希表的键值时候，会出现<strong>更新丢失</strong>(如：当两个线程同时找到同一个空闲的entry，并同时调用insert，那么第一个完成insert调用的，会被第二个覆盖)等等问题，因此我们需要在put过程增加锁，将put操作视为原子操作就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lock(x) pthread_mutex_lock(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unlock(x) pthread_mutex_unlock(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line">  Lock(&amp;lock);</span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.  </span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);  </span><br><span class="line">  &#125;</span><br><span class="line">  Unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_init(&amp;lock,<span class="literal">NULL</span>);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>为什么get过程不需要加锁呢？</p></blockquote><p>​    首先get是幂等操作(这个操作不会对共享数据产生影响，简单来说就是读操作)，其次在实验中没有<strong>序列化与一致性</strong>的要求，简单来说就是实验中没有读操作与写操作交错，并检测读取数据的值是否正确，这些都是分布式系统的内容，也就不过多延申了。</p><p>​    省去了锁的开销，也可以满足文档中对ph程序并发速率的提升要求。</p><blockquote><p>减少锁竞争</p></blockquote><p>​    在实验文档最后，有一提问是否可以给<strong>每一个哈希桶添加一个锁</strong>提高并发速率，这个显然是可以的，但是只针对的是哈希桶比较多的情况下.在并发写入要求高并且哈希桶少时反而速率更慢，主要是锁使用的开销。在实验8 locks中的两个实验会涉及到锁竞争问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line">  Lock(&amp;lock[i]);</span><br><span class="line">  ....</span><br><span class="line">  Unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) </span><br><span class="line">      pthread_mutex_init(&amp;lock[i],<span class="literal">NULL</span>);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>​    在本实验中，您将实现一个barrier:应用程序中的一个点，所有参与的线程必须等待，直到所有其他参与的线程也到达该点。您将使用pthread条件变量，这是一种序列协调技术，类似于xv6的睡眠和唤醒。</p><p>文件<code>notxv6/barrier.c</code>包含一个错误的barrier。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make barrier</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./barrier 2</span></span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion `i == t&#x27; failed.</span><br></pre></td></tr></table></figure><p>​    <code>./barrer 2</code>，其中2这个参数是指定在barrier上同步的线程数(barrier.c.nthread)。每个线程执行一个循环。在每个循环迭代中，线程调用<code>barrier()</code>，然后休眠一个随机的微秒数。assert触发，因为一个线程在另一个线程到达barrier之前离开了barrier。期望的行为是，每个线程都阻塞在<code>barrier()</code>中，直到它们的所有n个线程都调用了<code>barrier()</code>。</p><blockquote><p>本实验的任务：是实现期望的barrier原理。除了在ph赋值中看到的锁原语之外，还需要以下新的pthread原语;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br></pre></td></tr></table></figure><p>确保你的解决方案可以通过barrier测试</p></blockquote><p>​    <code>pthread_cond_wait</code>在被调用时释放互斥锁，并在返回之前重新获取互斥锁。我们已经给出了<code>barrier_init()</code>。你的工作是实现barrier()，这样恐慌就不会发生。我们已经为你们定义了结构barrier;它的字段供您使用。</p><p>有两个问题会使你的任务复杂化:</p><ul><li>你必须处理一连串的barrier调用，每次调用barrier称为一轮。bstate.round记录当前轮。每轮所有线程都到达barrier，我们应该增加bstate。。</li><li>你必须处理这样一种情况:在其他线程退出barrier之前，一个线程在循环中竞争。特别是，从一轮到下一轮重用bstate.nthread变量，当上一轮仍在使用bstate.nthread变量时，确保离开barrier并在循环中竞争的线程不会增加这个变量。</li></ul><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>​    这个实验就是完成barrier函数，在主函数中就是创建多个线程并发调用barrier。多个线程全部调用完一次barrier后，就增加bstate.round变量。</p><p>​    那么该如何控制当全部线程都完成一次调用后，再递增round变量呢？这时候就需要使用到线程的<strong>条件变量</strong>了(go语言的channel与条件变量与其相似)，其原理就是xv6中的睡眠锁。</p><p>​    这时候实现就是，当一个线程以及运行完一次barrier后就将<strong>休眠</strong>，只有当最后一个调用完barrier的线程将<code>round+1</code>再将其他线程<strong>唤醒</strong>，继续往下运行即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;<span class="comment">//完成调用barrier线程的数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread)&#123;<span class="comment">//满足条件后唤醒所有线程</span></span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread != nthread)&#123;<span class="comment">//休眠线程</span></span><br><span class="line">    <span class="comment">//调用这个函数后是先解锁，调用完成再加锁与xv6的sleep函数相同</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这时候我们再运行barrier程序，会出现一个问题就是nthread没有被重置，如下我们再barrier最后增加一行代码编译代码再运行，仍然还是会有问题，这样的更新在并发时会有所问题，多次重置bstate.nthread变量。</p><p>​    例如：当两个线程a、b，a满足条件唤醒b，这时候<strong>b还没有被唤醒</strong>(没有加锁)，这时候a直接将bstate.nthread赋值为0，进入下一轮并且进入下一轮的休眠状态。这时候b被唤醒，又将bstate.nthread赋值为0，这时候进入下一轮也会休眠，这就是死锁了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  if(bstate.nthread != nthread)&#123;//休眠线程</span><br><span class="line">    //调用这个函数后是先解锁，调用完成再加锁与xv6的sleep函数相同</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line"><span class="addition">+ bstate.nthread = 0;</span></span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    正确的修改方法是，就是只重置一次bstate.nthread的变量，那么就是在下一轮通过判断bstate变量进行修改即可。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;//完成调用barrier线程的数量</span><br><span class="line"><span class="addition">+ if(bstate.nthread == nthread+1 )</span></span><br><span class="line"><span class="addition">+    bstate.nthread = 1;</span></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    由于我在此之前已经做过了mit6.824的实验对于并发编程又所了解所有解决这个实验也比较简单，这个实验比较有意思的部分就是实现用户级的线程切换程序，大致也对于pthread的调度方式有了深刻的了解。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/thread_result.png" alt="thread_result"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab syscall</title>
      <link href="/2023/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab2%EF%BC%9Asyscall/"/>
      <url>/2023/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab2%EF%BC%9Asyscall/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/syscall.html">Lab: System calls</a></p></blockquote><p>实验开始之前需要将git分支切换到syscall分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="1-GDB"><a href="#1-GDB" class="headerlink" title="1.GDB:"></a>1.GDB:</h1><p><a href="https://blog.csdn.net/u011675745/article/details/122656997#:~:text=Undefined%20item%3A%20%22riscv%3Arv64%22%20%E4%BD%BF%E7%94%A8%20gdb-multiarch%20%E6%97%B6%E4%BC%9A%E5%9C%A8%E5%BC%80%E5%A4%B4%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%20set%20architecture,riscv64%20%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%8C%E6%80%AA%E4%B8%8D%E5%BE%97%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E3%80%82%20%E5%9C%A8%20Stack%20Overflow%20%E4%B8%8A%E6%89%BE%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E8%AF%B4%E9%9C%80%E8%A6%81%E5%B0%86%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%88%B0%208.3%20%E4%BB%A5%E4%B8%8A%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82">参考链接</a></p><blockquote><p>我的实验环境为<strong>ubuntu20.04</strong>，只有gdb-multiarch这个gdb调试工具，建议不要安装riscv64-linux-gdb因为特别难以下载且不好安装。</p></blockquote><h2 id="连接GDB-Server"><a href="#连接GDB-Server" class="headerlink" title="连接GDB Server"></a>连接GDB Server</h2><ol><li><p>打开一个terminal，在xv6的文件夹中键入make qemu-gdb打开gdbserver。在课程演示中我们使用了CPUs=1这个选项以一个cpu运行xv6<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091040.png" alt="image.png"></p></li><li><p>再打开一terminal，同样在xv6文件夹中，键入gdb-multiarch这个命令就可以链接到gdb-server了，链接成功后如图所示<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091420.png" alt="image.png"></p></li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ol><li><p>如上述所说将gdb-server连接完毕</p></li><li><p>在syscall.c文件的syscall函数处添加断点，b=break<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.1.png" alt="2.1"></p></li><li><p>让程序运行，使用c=continue，当运行到syscall函数处就会发生中断。<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.2.png" alt="2.2"></p></li><li><p>使用backtrace查看栈信息，栈顶为syscall(),那么调用syscall的函数就是usertrap函数，问题1<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.3.png" alt="2.3"></p></li><li><p>使用layout src，更改gdb布局可以查看源代码位置<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.8.png" alt="2.8"></p></li><li><p>使用<code>p /x *p</code>打印proc结构体的指针变量，其中<code>/x</code>是以十六进制打印<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.4.png" alt="2.4"></p></li></ol><blockquote><p>打印<code>p-&gt;trapframe-&gt;a7</code>的值是多少？参考initcode.S文件</p></blockquote><p>p-&gt;trapframe-&gt;a7 = 7，在后续的实验中也会知道这个值实际上是<strong>系统调用的编号</strong>，等于7说明我们调用了exec系统调用</p><p><img src="../img/lab/2.9.png" alt=""></p><ol><li>同样我们可以打印$+寄存器名称打印寄存器值。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.5.png" alt="2.5"></p><blockquote><p>CPU在此之前是从什么模式进入管理者模式的？<a href="https://pdos.csail.mit.edu/6.828/2022/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">riscv-privileged</a></p></blockquote><p><strong>sstatus</strong>：是supervisor mode的状态寄存器，特权寄存器，功能主要是跟踪当前的处理器的操作状态。32位的sstatus寄存器的spp位(第8位)：指示硬件线程的在进入supervisor mode之前的特权级。0表示从用户模式陷入(trap)，1反之是从机械模式陷入。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/sstatus.png" alt="sstatus"><br>如上图中得到sstatus中的值为0x22，说明第8位是为0的，则是从<strong>用户模式陷入管理者模式</strong>。</p><ol><li>当我们将 <code>num = p-&gt;trapframe-&gt;a7;</code> 替换为 <code>num = * (int *) 0;</code>，那么xv6的内核崩溃，如下图所示是kernel.asm打印的sepc(Supervisor Exception Program Counter)寄存器的值可以帮助我们找到<strong>内核页错误</strong>。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.7.png" alt="2.7"></p><blockquote><p>写下内核正在执行的汇编指令。哪个寄存器对应变量num?</p></blockquote><p><strong>stval</strong>(Supervisor Trap Value)寄存器保存num变量为0，让内核崩溃汇编指令的地址是sepc保存的。</p><p>通过上图得知<strong>sepc</strong>所报错的地址为<code>0x000000008000207c</code>，那么要跟踪这个错误，就可以使用地址作为断点，并使用c运行程序，再使用layout asm查看断点所对应的汇编代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb-multiarch</span><br><span class="line">(gdb) b *0x000000008000207c</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.10.png" alt="2.10"></p><p>通过打印汇编指令可以得知(lw-loading word是risv-v加载物理内存的字到寄存器的指令),CPU将s2寄存器的值加载到了物理地址=0处，由于0x0-0x80000000(xv6 图3.3)处是IO设备的地址因此会导致内核崩溃。</p><p><strong>scause</strong>(Supervisor Cause Register)寄存器，当从一个陷阱进入管理者模式，scause被写入并指示是哪一个事件导致了陷阱。</p><p>查看riscv-privileged的图4.1、4.2，其低31位是异常代码，由于在报错中scause=0xd<br>转为十进制等于13，且没有发生中断，找到对应的描述可知，错误是加载了错误的页表</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/scause1.png" alt="scause1"></p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/scause.png" alt="scause"></p><p>请注意，scause是由上面的内核崩溃打印的，但您通常需要查看其他信息来跟踪导致崩溃的问题。例如，为了找出内核崩溃时正在运行的用户进程，可以打印出进程的名称：</p><blockquote><p>内核奔溃时正在运行的二进制文件的名称是什么？它的进程ID(ID)是多少？</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.12.png" alt="2.12"></p><h1 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h1><h2 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h2><ol><li>查看kernel/syscall.h代码，其中定义了每一个系统调用的宏</li><li>查看user/usys.pl的perl代码，这是一个脚本文件主要是生成usys.S这个汇编文件，这个汇编文件中包含了每一个系统调用的接口，因此需要在usys.pl文件中加入<code>entry(&quot;trace&quot;)</code>用于生成trace系统调用接口,在usys.S会生成如下4行代码。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><ol><li>查看kernel/syscall.c代码，在<code>syscall(void)</code>函数中，通过<code>p-&gt;trapframe-&gt;a7</code>获取系统调用号，接着进行系统调用<code>syscalls[num]()</code>，其中syscalls是一个系统调用<strong>函数指针数组</strong>，系统调用的返回值保存于<code>p-&gt;trapframe-&gt;a0</code>中。</li></ol><p>以上便是系统调用的大致过程了。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>本次实验我们需要再用户空间中实现一个trace应用，这个应用可以<strong>跟踪打印</strong>程序中系统调用。trace函数的参数是系统调用syscall_id的掩码(mask)，在掩码中将对应的位设为1则trace函数就会打印相应的系统调用。</p><p>例如我们调用<code>trace(6)</code>,其中<code>6 = 0110</code>，那么就会打印syscall_id=2，3的系统调用，相当于<code>1&lt;&lt;SYS_exit</code>,<code>1&lt;&lt;SYS_wait</code>。</p><blockquote><p>trace程序示例</p></blockquote><p>调用用户空间的trace程序，接着是掩码，最后则是跟踪的程序与跟踪调用程序的参数（通过exec系统调用运行的程序），打印的格式为：<code>进程的pid：syscall 系统调用名称  -&gt; 系统调用返回值</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们可以调用预先设定好的程序usertests，进行测试，值得注意的是fork创建的子进程也是需要复制掩码的，具体代码可以看proc.c中的fork函数实现</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p><strong>HINS</strong>：</p></blockquote><ol><li><p>修改makefile在用户空间添加trace程序</p></li><li><p>修改<code>usys.pl</code>，添加trace系统调用入口</p></li><li><p>修改user.h，添加trace系统调用函数接口</p></li><li><p>修改<code>syscall.h</code>、<code>syscall.c</code>文件，添加trace系统调用函数接口定义，系统调用的名称。</p></li><li><p>修改proc.h，在proc结构体中添加<code>trace_mask</code>字段</p></li><li><p>修改sysproc.c，添加trace系统调用的处理函数sys_trace，其中要获得系统调用的参数可以参考sleep函数以及exit函数。</p></li><li><p>修改proc.c，在fork函数中添加子进程继承父进程掩码字段</p></li></ol><blockquote><p>主要文件修改</p></blockquote><ol><li><p><code>sysproc.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  </span><br><span class="line">  argint(<span class="number">0</span>,&amp;mask);</span><br><span class="line">  <span class="comment">//swtich on the trace_syscall</span></span><br><span class="line">  myproc()-&gt;trace_mask |= mask; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>syscall.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* syscall_names[] = &#123;</span><br><span class="line">  <span class="string">&quot; &quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">  <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>,</span><br><span class="line">  <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;num) &amp; p-&gt;trace_mask)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,myproc()-&gt;pid,syscall_names[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>proc.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h1><h2 id="系统调用实现-1"><a href="#系统调用实现-1" class="headerlink" title="系统调用实现"></a>系统调用实现</h2><p>在该实现中我们需要实现一个叫做<strong>sysinfo</strong>的的系统调用，这个系统调用主要是返回一个<strong>sysinfo</strong>结构体，其中包含两个字段：1.nproc:不是UNUSED的进程数量,2.freemem :空闲物理空间的字节。用户程序通过调用<code>sysinfo(struct sysinfo *info)</code>，那么info参数中就会返回对应的字段。</p><p>实验中提供一个用户程序sysinfotest进行测试，最后打印OK则实验成功</p><blockquote><p><strong>HINS</strong>：</p></blockquote><ol><li><p>添加 <code>$U/_sysinfotest</code>到 Makefile的UPROGS中。</p></li><li><p>在user.h中添加以下声明<br> <code>struct sysinfo</code>;<br> <code>int sysinfo(struct sysinfo *)</code>;</p></li><li><p>参考sys_fstat() (kernel/sysfile.c)和filestat() (kernel/file.c)这两个函数学习如何使用copyout函数将sysinfo结构体内容传回用户空间。</p></li><li><p>在kalloc.c中添加函数，统计空闲物理内存字节</p></li><li><p>在proc.c中添加函数，统计不是UNUSED进程的数量</p></li></ol><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol><li><strong>sysproc.c</strong>：需要注意的是获取到用户的参数地址后需要判断是是否超出物理内存的最大值，超出了说明其是错误参数，返回0xffffffffffffffff</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">n_proc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64 <span class="title function_">free_memory</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">....</span><br><span class="line">uint64 </span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">kinfo</span>;</span></span><br><span class="line">  uint64 uinfo;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;uinfo);<span class="comment">//user pointer to struct  sysinfo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(uinfo &gt; PHYSTOP)&#123;<span class="comment">//error arugement</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  kinfo.nproc = n_proc();</span><br><span class="line">  kinfo.freemem = free_memory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//copy info to u_info</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, uinfo, (<span class="type">char</span> *)&amp;kinfo, <span class="keyword">sizeof</span>(kinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>proc.c</strong>：文件开始定义了一个proc数组，说明xv6中最大进程量为NPROC，再到allocpid中查看，我们便可以得知nextpid是定义了下一个进程的id，因此只需遍历这个proc数组并判断进程状态，就可以得到满足条件的进程数了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line"><span class="title function_">unused_proc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nextpid &amp;&amp; i &lt; NPROC;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(proc[i].state != UNUSED )&#123;</span><br><span class="line">      nproc++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>kalloc.c</strong>：物理内存分配器，给用户进程、内核栈、页表、管道分配内存</li></ol><blockquote><p><strong>kmem</strong>结构体中包含了两个结构体</p><ul><li>run：一个没有数据域的链表，主要作用是记录未分配的物理页表的节点</li><li>spinlock：内存分配与删除时的锁</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>由于freelist指向空页表的个数，我们只需要遍历freelist统计其有多少个节点即可，最后乘以页表的字节数，就可以得到空闲内存的字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">free_memory</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 freemem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">free</span> =</span> kmem.freelist;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">free</span>)&#123;</span><br><span class="line">    <span class="built_in">free</span> = <span class="built_in">free</span>-&gt;next;</span><br><span class="line">    freemem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freemem *= PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> freemem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2.11.png" alt="2.11"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab traps(详解)</title>
      <link href="/2023/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab4%EF%BC%9Atraps/"/>
      <url>/2023/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab4%EF%BC%9Atraps/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/traps.html">Lab: System traps</a></p></blockquote><p>实验开始之前需要将git分支切换到traps分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout traps</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h1><p>这个实验主要目的是帮助我们能够认识汇编代码，通过gdb调试user/call.c文件，回答相应问题。</p><h2 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h2><p>下述的指令格式表述为：全称/简写，下列展示的是实验中普遍使用的指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.<span class="built_in">break</span>/b (*地址)/函数名 <span class="comment">#设置断点，指令地址可以查看asm文件</span></span><br><span class="line"><span class="comment">#除此之外通常可以使用b *$stvec,在trampoline处设置断点</span></span><br><span class="line"></span><br><span class="line">2.<span class="built_in">continue</span>/c <span class="comment">#运行到断点处然后停下</span></span><br><span class="line"></span><br><span class="line">3.stepi/si <span class="comment">#运行单个汇编指令，进入函数</span></span><br><span class="line"></span><br><span class="line">4.n <span class="comment">#运行一行c语言代码，不进入函数</span></span><br><span class="line"></span><br><span class="line">5.step/s <span class="comment">#运行一行C语言代码，进入函数</span></span><br><span class="line"></span><br><span class="line">6.info/i reg/r <span class="comment">#查看32个同一寄存器和PC寄存器的值</span></span><br><span class="line"></span><br><span class="line">7.info/i <span class="built_in">break</span>/b <span class="comment">#查看断点信息</span></span><br><span class="line"></span><br><span class="line">8.info/i frame <span class="comment">#打印当前栈帧</span></span><br><span class="line"></span><br><span class="line">9.<span class="built_in">print</span>/p (/x) 变量/$寄存器 <span class="comment">#打印C语言变量值或寄存器的值，/x是将值为打印16进制的值</span></span><br><span class="line"></span><br><span class="line">10.examining/x 地址 <span class="comment">#检测内存单元并打印</span></span><br><span class="line">                <span class="comment">#可以使用/x十六进制 /i指令 /c字符格式化打印值</span></span><br><span class="line">                <span class="comment">#而且可以使用/4c打印4个字节单元并输出为字符</span></span><br><span class="line">11.list 地址  <span class="comment">#打印函数的源代码在指定的位置。</span></span><br><span class="line"></span><br><span class="line">12.layout asm/src/split <span class="comment">#分别打开汇编代码窗口、源码窗口、split打开汇编和源码窗口</span></span><br><span class="line">                        <span class="comment">#ctrl x + a 可以关闭layout窗口</span></span><br></pre></td></tr></table></figure><h2 id="调试call程序"><a href="#调试call程序" class="headerlink" title="调试call程序"></a>调试call程序</h2><ol><li><p>打开两个终端窗口T1、T2。现在T1运行<code>make qemu-gdb</code>，然后T2在<code>gdb-multiarch</code>(ubuntu20.4)。</p></li><li><p>在T2中更改调试程序为<code>user/_call</code>(在gdbinit中指定的调试文件为kernel/kenrel)</p></li><li><p>在main函数处设置断点，使用<code>c/continue</code>运行程序</p></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/traps1.png" alt="traps1.png"></p><ol><li>在T1窗口中输入<code>call</code>，运行call程序。在T2窗口中使用c运行程序到断点，然后使用layout split打开源码和汇编代码的窗口。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/traps2.png" alt="traps2.png"></p><ol><li>使用si一条一条地运行汇编指令。然后使用<code>p $a1</code>、<code>p $a2</code>打印寄存器。我们会发现这两个寄存器保存的是printf函数后两个参数的值。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/trap3.png" alt="trap3.png"></p><ol><li><p>那么a0应该就是保存着printf<strong>格式字符串的地址</strong>，于是我们运行过0x30的指令后，使用<code>x /5c $a0</code>(x = examine)这个gdb指令检测内存值。使用该命令后我们也能够看见每个字符的ASCII码值以及对应的字符。拼接起来也就是”%d %d”</p></li><li><p>查看ra寄存器，使用<code>info reg ra</code>(简写为i r ra,ra为寄存器名称保存<strong>函数返回后执行的下一条指令</strong>的地址)，同样可以使用<code>p /x $ra</code>打印。</p></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/traps4.png" alt="traps4.png"></p><blockquote><p>简述auipc、jalr指令</p></blockquote><p>这两个指令主要是用于<strong>函数跳转</strong>，一般是一起使用，用于<strong>较远指令</strong>的地址的跳转。</p><p>这样设计的主要原因是RISC-V指令是32位的，且jal指令跳转的立即数也只有20，那么也就是说我们的函数跳转不能超出$2^{20}$，但是寄存器是64位的我们保存的地址却能够高达$2^{64}$。于是我们要设计长地址的跳转。在计算机组成与设计(RISC-V)中有所介绍。</p><ul><li>指令格式：<code>auipc rd immediate</code>，将pc的值+立即数左移12位后的值赋给rd(目标寄存器)</li></ul><p>例如：auipc ra 0x00，也就是将pc的值赋给ra。</p><ul><li>指令格式：<code>jalr immediate(rs</code>)，将pc+4后复制给ra寄存器，再将immediate(12位)+rs寄存器的值并赋值给pc，这样就跳转到了指定地址。这里的立即数就是12位，那么也刚好对应了auipc将立即数左移12位留下的空缺了。</li></ul><p>例如：jalr 1562(ra)，也就是将ra的值+1562(这是十进制数)跳转到指定函数，此时ra的值为该当前pc+4，也就是jalr指令的下一条指令的地址。</p><h2 id="实验提问"><a href="#实验提问" class="headerlink" title="实验提问"></a>实验提问</h2><blockquote><ol><li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?</li></ol></blockquote><p>那几个寄存器保存了函数的参数？ a0：格式字符串 、a1：12 、a2：13。</p><blockquote><ol><li>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</li></ol></blockquote><p>在该函数中我们并没有调用f、g这两个函数，因为这两个被编译器优化为了内联函数，在编译期就计算得出了值。</p><blockquote><ol><li>At what address is the function printf located?</li></ol></blockquote><p>可以查看call.asm中printf函数的入口地址，也可以通过我们上述jalr指令的计算：0x30(ra原有的值)+0x61a(1562的16进制值) = 0x64a，这就是printf函数的入口了。</p><blockquote><ol><li>What value is in the register ra just after the jalr to printf in main?</li></ol></blockquote><p>在上述的分析后和gdb调试过后也可以得知，在运行jalr指令进入printf函数后，ra寄存器的值被设置为了jalr后一条指令的地址了。</p><blockquote><p>Run the following code.</p><p>   <code>unsigned int i = 0x00646c72;</code><br>   <code>printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</code></p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p></blockquote><p>添加代码到call中并运行，可以得到下述结果。E110是57616转换获得的值，大端还是小端读取并不会影响这个值的顺序。</p><p>ASCII是两个字节也就是占8位，刚好两个16进制数表示。</p><p>由于RISC-V中使用小段序读取，因此我们是先读取72这个ASCII码值为r，然后则是6c：l，最后就是64：d。如果改为大端序读取就是反过来先读取d然后是l、r，输出为Wodlr。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/trap5.png" alt="trap5.png"></p><blockquote><p>In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?</p><p>   <code>printf(&quot;x=%d y=%d&quot;, 3);</code></p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/trap6.png" alt="trap6.png"></p><p>看上图我们可以得知，$a2寄存器的值为1(在最开始的调试中，理解到了printf的第三个参数是a0的值)并未被清空，于是在输出中就有了y=1的结果。</p><h1 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>看过实验指导可以跳过简介部分。</p><blockquote><p>目的</p></blockquote><p>简单来说就是实现一个类似于gdb中的backtrace命令的函数，对于调试来说，反向跟踪通常是有用的:在错误发生点上方的栈上的函数调用列表。为了帮助进行回溯，编译器生成机器码，这些机器码在与当前调用链中的每个函数对应的栈上维护一个栈帧。每个栈帧由返回地址和一个指向调用方栈帧的“帧指针”组成。寄存器0包含一个指向当前栈帧的指针(它实际上指向栈上保存的返回地址的地址加上8)。你的回溯应该使用帧指针来遍历栈，并在每个栈帧中打印保存的返回地址。</p><blockquote><p>任务</p></blockquote><p>在kernel/printf.c中实现一个backtrace()函数。在sys_sleep中对该函数进行调用，然后运行bttest该程序调用了sys_sleep。您的输出应该是以下形式的返回地址列表(但数字可能会有所不同):</p><pre><code>backtrace:0x0000000080002cda0x0000000080002bb60x0000000080002898</code></pre><p>在bbtest完成后退出qemu。在终端窗口中:运行addr2line -e kernel/kernel(或riscv64-unknown-elf-addr2line -e kernel/kernel)并从你的反向跟踪中剪切和粘贴地址，如下所示:</p><pre><code>$ addr2line -e kernel/kernel0x0000000080002de20x0000000080002f4a0x0000000080002bfcCtrl-D</code></pre><p>addr2line的输出为：(简单来说就是将ra寄存器的返回的地址值转换为c语言文件中的行，输出的格式我们就可以知道函数调用的顺序：trap-&gt;syscall-&gt;sysproc)</p><pre><code>kernel/sysproc.c:74kernel/syscall.c:224kernel/trap.c:85</code></pre><blockquote><p><strong>HINS:</strong></p></blockquote><ul><li><p>在kernel/def.h文件中添加backtrace的定义，让sys_sleep函数可以调用该函数</p></li><li><p>GCC编译器将当前执行函数的帧指针存储在寄存器s0中。在kernel/riscv.h中增加如下函数:<br>static inline uint64<br>r_fp()<br>{<br>uint64 x;<br>asm volatile(“mv %0, s0” : “=r” (x) );<br>return x;<br>}</p></li></ul><p>并在backtrce()中调用此函数以读取当前帧指针<code>。r_fp()</code>使用内联汇编来读取s0。</p><ul><li><p>这堂课的<a href="https://pdos.csail.mit.edu/6.1810/2022/lec/l-riscv.txt">讲义</a>中有栈框架布局的图片。注意，返回地址位于堆栈帧的帧指针的固定偏移量(-8)处，保存的帧指针位于帧指针的固定偏移量(-16)处。</p></li><li><p>backtrace()将需要一种方法来识别它已经看到了最后一个堆栈帧，并且应该停止。一个有用的方法是，为每个内核栈分配的内存由单个与页面对齐的页面组成，因此给定栈的所有栈帧都在同一页面上。可以使用PGROUNDDOWN(fp)(参见kernel/riscv.h)来标识帧指针所指向的页面。</p></li></ul><p>一旦你的backtrace开始工作，在kernel/printf.c中的panic中调用它，当内核奔溃时，这样你就可以看到内核的回溯。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>添加提示中的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----riscv.h</span><br><span class="line"><span class="comment">//read fp regsiter</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----def.h</span><br><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">----sysproc.h</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RISC-V中的栈内存结构：</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/stack.png" alt="stack.png"></p><p>如上图和之前的简介中我们可以得知，FP寄存器的值是地址值，那么FP-8就是返回地址的值，FP-16就是上一个栈指针的地址值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---<span class="built_in">printf</span>.c---</span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;barcktrace:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint64 ra,fp = r_fp();<span class="comment">//frame pointer -&gt; address</span></span><br><span class="line">  uint64 pre_fp = *((uint64*)(fp - <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(PGROUNDDOWN(fp)==PGROUNDDOWN(pre_fp))&#123;</span><br><span class="line">    ra = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ra);</span><br><span class="line">    fp = pre_fp;</span><br><span class="line">    pre_fp = *((uint64*)(fp - <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ra = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,ra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用r_fp函数获取fp指针的地址值，那么前一个fp指针的地址为<code>*((uint64*)(fp - 16))</code>，这里主要是将整数值转换为指针并解引用也就是取该地址的值。(ra的值也是这样取出)</p></li><li><p>使用PGROUNDDOWN函数判断pre_fp与fp的是否位于同一页中，如果相同则位于同一页，那么就可以取出ra的值并打印，使用%p符号。</p></li><li><p>如果不相同则退出，此时pre_fp是在另一页中，但是fp仍处于该页中，仍需要将该栈帧的ra值取出。</p></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>运行xv6，调用bttest程序，那么就会打印栈帧中ra的值，这都是一些地址值。</p><p>退出qemu，并使用addr2line程序，对地址进行转换就可以获得返回地址<strong>对应文件的行</strong>了。</p><h1 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><blockquote><p>由于实验简介过长，请自行观看官方文档。</p></blockquote><p>本次实验主要是实现两个系统调用<code>sigalram(int,void(*)())</code>、<code>sigreturn()</code>。通过这两个系统实现alarm功能，<strong>监测用户程序使用CPU的时长</strong>，从而对用户程序发出提醒。</p><ul><li><strong>sigalarm</strong>：第一个参数是设置时钟中断个数当达到个数时调用指定函数，第二个参数时设置alarm的处理函数。</li><li><strong>sigreturn</strong>：在alarm处理函数中执行完所以代码后调用，主要功能是<strong>恢复中断前的状态</strong>。</li></ul><p>监测时间主要是以<strong>时钟中断为单位</strong>(进程调度的基础)，如果时钟中断为50ms，那么每50ms进行一次中断，那么通过统计用户进程进行了几次中断，就可以获知用户进程到达了警报的CPU使用时长，从而给出提醒。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>1.makeflie添加alarmtest用户程序</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">...</span><br><span class="line">$U/_alarmtest\</span><br></pre></td></tr></table></figure><p>2.kernel:添加系统调用声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----syscall.c</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----syscall.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br></pre></td></tr></table></figure><p>3.user：添加系统调用入口与函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----user.h</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> (*)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----usys.pl</span><br><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="test0"><a href="#test0" class="headerlink" title="test0"></a>test0</h3><blockquote><p><strong>过程</strong></p></blockquote><ol><li><p>调用sigalarm系统调用，该系统调用用于设置proc的alarm字段</p></li><li><p>进入test0的循环结构，不断调用write系统调用。</p></li><li><p>在调用write的间隙，内核产生时钟中断。</p></li><li><p>用户程序中断：从trap进入内核，时钟中断数量到达触发alarm的数量，设置frame中的epc寄存器值为alarm处理函数的入口地址。</p></li></ol><blockquote><p>因为此时epc是发生中断时用户程序的指令地址(像是系统调用一样被赋值)，将其修改为处理函数的入口便能够在从trap返回时，直接执行alarm处理函数</p></blockquote><ol><li><p>中断返回：从trap中返回后，执行alarm处理函数，调用sigreturn系统调用(这里并没什么用)。</p></li><li><p>调用sigalarm(0,0)，关闭alarm。</p></li></ol><blockquote><p><strong>Q</strong>：有一个问题则是，在触发alarm条件后将epc设置为alarm处理函数入口，但是执行完alarm处理函数后，为什么会返回到用户程序发生中断的地址(<strong>ra寄存器</strong>)</p><p><strong>代码</strong></p></blockquote><ol><li>在proc.h进程结构体中添加结构体字段<ul><li>interval：触发alarm的时钟中断数量</li><li>ticks：需要统计的时钟中断的数量</li><li>handler：记录处理alarm的函数的地址</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在sysproc中添加系统调用函数的实现</p><ul><li><p>sys_sigaram：初始化proc有关alarm字段</p></li><li><p>sys_sigreturn：这时只返回0</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    uint64</span><br><span class="line">    <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> interval;</span><br><span class="line">    uint64 f_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  argint(<span class="number">0</span>,&amp;interval);</span><br><span class="line">  argaddr(<span class="number">1</span>,&amp;f_addr);</span><br><span class="line">  </span><br><span class="line">  p-&gt;interval = interval;</span><br><span class="line">  p-&gt;handler = f_addr;</span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在usertrap函数中的时间中断处处理alarm，判断设备中断为时钟中断则增加ticks字段，当时钟中断次数到达<strong>指定数量</strong>时，就将内存中epc的寄存器值改变为<strong>alarm处理函数的地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks == p-&gt;interval &amp;&amp; <span class="number">0</span> &lt; p-&gt;interval)&#123;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>A</strong>：完成test0，回答一下前面的问题，为什么我们能够返回用户发生中断的地址。</p></blockquote><p>看下图中，达到alarm条件时，这时是由于中断从trap进入内核处理，于是查看栈帧中ra寄存器的值，将ra的值对比alarmtest的文件中，发现这个地址刚好对应了if(count&gt;0)的地址，也就是中断发生的地址。</p><p>那么这样的话在中断产生时，就将<strong>返回地址的值写入了ra=0x14a</strong>，epc=0x154。这样就算从trap返回到alarm处理函数中，<strong>ret指令也会将ra写入pc</strong>，使得alarm处理函数能够返回test0。</p><blockquote><p><strong>NOTE</strong>：<strong>中断位置的pc</strong>与<strong>ra地址</strong>不同也会导致中断前的状态被复写。因此需要在<strong>sigreturn</strong>调用中<strong>恢复中断前的epc的</strong>，让alarm处理函数不需要正常返回。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/trap7.png" alt="trap7.png"></p><h3 id="test1-2-3"><a href="#test1-2-3" class="headerlink" title="test1/2/3"></a>test1/2/3</h3><blockquote><p>alarm处理函数完成后，控制权返回到用户被时间中断的指令处</p></blockquote><p>在之前的实现中可以完成了基本的alarm程序，但是现在会有一个问题：中断前的状态怎样恢复？</p><p>在test0后面也说到了ra与epc地址值不同，会导致一些寄存器被复写。(如果函数调用栈没有保存中断前使用的寄存器也会导致这种情况)</p><p>这个问题也困惑了我很久，为什么需要恢复中断前的状态？我们再在脑海中构建一下<strong>中断后返回到alarm处理程序</strong>的过程。接着以test1为例简述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">500000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    foo(i, &amp;j);</span><br><span class="line">  &#125;</span><br><span class="line">  sigalarm(<span class="number">0</span>, periodic);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((noinline)) foo(<span class="type">int</span> i, <span class="type">int</span> *j) &#123;</span><br><span class="line">  <span class="keyword">if</span>((i % <span class="number">2500000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用sigalarm系统调用，通过trap进入内核并设置proc结构体有关alarm字段，同时时钟中断也在进行。</p></li><li><p>在test1循环中调用foo函数，只有调用10次<strong>alarm处理程序</strong>后才能退出循环，并再次调用sigalarm关闭alarm。（foo程序只是将j值加一）</p></li><li><p>发生时钟中断：当发生中断时，用户程序执行periodic程序，并返回中断处。</p></li><li><p>返回中断处执行foo函数，之后判断i与j的值是否相同，按照直觉来说肯定是相同的，但实际上会发生错误，因为<strong>寄存器会被复写</strong>。</p></li></ol><blockquote><p>什么时候会中断？</p></blockquote><ol><li><p>在for循环执行时被中断</p></li><li><p>在调用foo程序时候中断</p></li><li><p>在调用periodic时中断(几乎不可能，两次时钟中断肯定会执行完这部分代码)</p></li></ol><blockquote><p>以foo函数调用时中断为例分析：为什么需要恢复中断前的状态</p></blockquote><p>如果仅仅以test0的代码运行test1会导致，内核直接杀死进程，给出的错误是<strong>缺页错误</strong>，也就是访问了错误地址。</p><p>在test0最后也说到在触发中断alarm时，需要将epc修改为handler的地址，同时也要记录当前的epc，以便能够在调用periodic函数之后调用sigreturn恢复中断处的epc并返回。</p><p>那么在foo函数的汇编代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((noinline)) foo(<span class="type">int</span> i, <span class="type">int</span> *j) &#123;</span><br><span class="line"> <span class="number">1</span>ae:    <span class="number">1101</span>                    addi    sp,sp,<span class="number">-32</span></span><br><span class="line"> <span class="number">1b</span>0:    ec06                    sd    ra,<span class="number">24</span>(sp)</span><br><span class="line"> <span class="number">1b</span>2:    e822                    sd    s0,<span class="number">16</span>(sp)</span><br><span class="line"> <span class="number">1b</span>4:    e426                    sd    s1,<span class="number">8</span>(sp)</span><br><span class="line"> <span class="number">1b</span>6:    <span class="number">1000</span>                    addi    s0,sp,<span class="number">32</span></span><br><span class="line"> <span class="number">1b</span>8:    <span class="number">84</span>ae                    mv    s1,a1</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>在上述代码中我们修改的sp、s0(fp)、s1寄存器，在此之后中断调用periodic函数(设置sp、s0、ra寄存器)，在调用sigreturn函数后并没有恢复sp寄存器，而是直接返回foo函数，那么此时sp、s0的寄存器的值肯定是不同的，也就会导致缺页错误了。</p><blockquote><p><strong>修复缺页错误</strong></p></blockquote><p>在文档的提示中告诉我们需要恢复很多寄存器的值，那么我们就直接在proc结构体中添加pre_trapframe字段保存中断前的寄存器的值。</p><p>注意我们还需要分配物理页给这个中断帧(因为这个pre_trapframe内存占用十分大，proc中剩余的物理页内存不足以放下这个结构体)、也需要在进程结束时释放这个物理页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----proc.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">pre_trapframe</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">----proc.c</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">  <span class="keyword">if</span>((p-&gt;pre_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pre_trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;pre_trapframe);</span><br><span class="line">  p-&gt;pre_trapframe = <span class="number">0</span>;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在触发alarm的中断条件时，那么将ra、sp、s0、epc寄存器的值保存。并在完成alarm处理函数后，进入sigreturn系统调用恢复保存的寄存器。如下所示，我们再次运行代码那么就不会出现缺页错误了(这时的问题就是有i与j不同的错误了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks == p-&gt;interval &amp;&amp; <span class="number">0</span> &lt; p-&gt;interval)&#123;</span><br><span class="line">      p-&gt;pre_trapframe-&gt;ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">      p-&gt;pre_trapframe-&gt;sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">      p-&gt;pre_trapframe-&gt;s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">      p-&gt;pre_trapframe-&gt;epc = p-&gt;trapframe-&gt;epc; </span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">----sysproc.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">    p-&gt;trapframe-&gt;ra =p-&gt;pre_trapframe-&gt;ra;</span><br><span class="line">  p-&gt;trapframe-&gt;sp =p-&gt;pre_trapframe-&gt;sp;</span><br><span class="line">  p-&gt;trapframe-&gt;epc =p-&gt;pre_trapframe-&gt;epc;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;pre_trapframe-&gt;s0 ;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查看alarmtest汇编代码，修复i、j值不同的问题</p></blockquote><ol><li><p>在test1函数查看得知j的值保存于s0-52的地址处(使用gdb的examine命令：x /u $s0-52可以查看内存的值)，i的值则保存于s1寄存器中。a0、a1的寄存器会保存调用foo函数的i、j参数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00000000000001ee &lt;test1&gt;:</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">j = 0;</span><br><span class="line">#在s0寄存器-52的地址写入j的值：s0-52 = 0x3f8c</span><br><span class="line">216:    fc042623              sw    zero,-52(s0)</span><br><span class="line">for(i = 0; i &lt; 500000000; i++)&#123;</span><br><span class="line">#s1保存i的值</span><br><span class="line">22c:    4481                    li    s1,0</span><br><span class="line">....</span><br><span class="line">  foo(i, &amp;j);</span><br><span class="line">#a0保存了第一个参数i(s1)、a1保存第二个参数j(s0-52)的地址</span><br><span class="line">24a:    fcc40593              addi    a1,s0,-52</span><br><span class="line">24e:    8526                    mv    a0,s1</span><br><span class="line">250:    00000097              auipc    ra,0x0</span><br><span class="line">254:    f5e080e7              jalr    -162(ra) # 1ae &lt;foo&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看foo函数，在该代码中可以发现a5、a0、s1，参与了i、j的运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00000000000001ae &lt;foo&gt;:</span><br><span class="line">void __attribute__ ((noinline)) foo(int i, int *j) &#123;</span><br><span class="line">....</span><br><span class="line">if((i % 2500000) == 0) &#123;</span><br><span class="line">1ba:    002627b7              lui    a5,0x262</span><br><span class="line">1be:    5a07879b              addiw    a5,a5,1440</span><br><span class="line">1c2:    02f5653b              remw    a0,a0,a5</span><br><span class="line">1c6:    c909                    beqz    a0,1d8 &lt;foo+0x2a&gt;</span><br><span class="line">*j += 1;</span><br><span class="line">1c8:    409c                    lw    a5,0(s1)</span><br><span class="line">1ca:    2785                    addiw    a5,a5,1</span><br><span class="line">1cc:    c09c                    sw    a5,0(s1)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>通过上述分析便可以得知，我们需要恢复a0、a1、a5、s1的值。这时再像之前一样保存和恢复这些寄存器的值即可。</p></li></ol><blockquote><p>完善中断恢复机制</p></blockquote><p>在之前中我们使用了太多的C代码去保存/恢复寄存器的值。有两个弊端：</p><ol><li>代码并不简介</li><li>当用户程序中使用更多的寄存器时仍然会出现恢复中断现场失败的问题</li></ol><p>于是我们直接选择保存，恢复整个陷阱帧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">----trap.c</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks == p-&gt;interval &amp;&amp; <span class="number">0</span> &lt; p-&gt;interval)&#123;</span><br><span class="line">      *p-&gt;pre_trapframe = *p-&gt;trapframe;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">----sysproc.c</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  *p-&gt;trapframe = *p-&gt;pre_trapframe;</span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;pre_trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在test0中说到简单的讲sigreturn的值设置为0即可，但这个0值是无用的，在test3中需要让我们也恢复a0寄存器的值，因为函数调用的值会保存在a0寄存器中，所以sigreturn的返回值设置为了p-&gt;pre_trapframe-&gt;a0。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验算是做这课以来算是我分析时长最长的实验了，特别是alarm实验对其中中断恢复的理解以及gdb的调试也花了十分多的时间，但是理解之后也确实对trap的知识点有了更加深厚的理解了。</p><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/traps%20result.png" alt="traps result.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab pgtbl</title>
      <link href="/2023/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab3%EF%BC%9Apgtbl/"/>
      <url>/2023/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab3%EF%BC%9Apgtbl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验：<a href="https://pdos.csail.mit.edu/6.828/2022/labs/pgtbl.html">Lab: System calls</a></p></blockquote><p>实验开始之前需要将git分支切换到syscall分支不然有些文件你是没有的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git checkout pgtbl</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h1 id="Speed-up-system-calls-easy"><a href="#Speed-up-system-calls-easy" class="headerlink" title="Speed up system calls (easy)"></a>Speed up system calls (easy)</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>一些操作系统(例如Linux)通过在用户空间和内核之间<strong>共享只读</strong>区域中的数据来加快某些系统调用。这消除了执行这些系统调用时内核交叉的需要。为了帮助您了解如何将映射插入到页表中，第一个任务是为xv6中的getpid()系统调用实现此优化。</p><blockquote><p>创建每个进程时，将一个只读页面映射到<strong>USYSCALL</strong>(在memlayout.h中定义的虚拟地址)。在该页的开始，存储一个usyscall结构(也在memlayout.h中定义)，并初始化它以存储当前进程的PID。对于本实验，用户空间端提供了ugetpid()，它将自动使用usycall映射。如果<strong>ugetpid</strong>测试用例在运行pgtbltest时通过，您将获得这部分实验的全部学分。</p><p><strong>HINS</strong>：</p></blockquote><ul><li><p>在kernel/proc.c中的proc_pagetable()中执行映射。</p></li><li><p>选择允许用户空间只读取页面的权限位。</p></li><li><p>您可能会发现mappages()是一个有用的实用程序。</p></li><li><p>不要忘记在allocproc()中分配和初始化页。</p></li><li><p>确保在freeproc()中释放页。(同时也需要在proc_freepagetable()中释放PTE)</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个实验主要是在用户进程中提供一个共享页(page)，加快访问的速度，主要思想是<strong>不直接系统调用的执行</strong>，而是通过USYSCALL这个<strong>固定的虚拟地址</strong>，通过虚拟地址翻译找到指定页。</p><p>如下图所示，不同进程的同一虚拟地址通过页表映射到了不同的物理页。</p><blockquote><ol><li><strong>Trampoline页</strong>：物理页中只有一页，保存的是进出内核的代码。内核与用户共享且虚拟地址与物理地址一对一映射</li><li><strong>Trapframe页</strong>：一个进程一页，保存寄存器数据。每一个进程一个，相同的虚拟地址映射不同的物理页。(USYSCALL页的实现方式也可以参照于该页的实现)</li></ol></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/lab3.2.png" alt="lab3.2.png"></p><ol><li>在proc.h中添加一个usyscall结构体指针，像trapframe一样<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---proc.h---</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">sc</span>;</span><span class="comment">//usyscall page</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>在allocproc()为进程分配一个物理页，然后将usyscall结构体放入刚创建的页(page)字节数组中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---proc.c---</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span>((p-&gt;sc = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> <span class="title">u</span>;</span></span><br><span class="line">  u.pid = p-&gt;pid;</span><br><span class="line">  *p-&gt;sc = u;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在proc_pagetable中，在进程页表中建立USYSCALL页的PTE，创建映射。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---proc.c---</span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">...</span><br><span class="line">  <span class="title function_">if</span><span class="params">(mappages(pagetable, USYSCALL, PGSIZE,</span></span><br><span class="line"><span class="params">            (uint64)(p-&gt;sc), PTE_R | PTE_U ) &lt; <span class="number">0</span>)</span>&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>分别在proc_freepagetable()、freeproc()中清除USYSCALL页的PTE、清除物理页。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">---proc.c---</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;sc)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;sc);</span><br><span class="line"></span><br><span class="line">  p-&gt;sc = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>为了帮助我们可视化RISC-V页表，也许还可以帮助将来的调试，第二个任务是编写一个打印页表内容的函数。</p><blockquote><p>定义一个名为vmprint()的函数。它应该接受一个pagetable_t参数，并以下面描述的格式打印该pagetable。在execute .c中，在返回argc之前插入<code>if(p-&gt;pid==1)</code> <code>vmprint(p-&gt;pagetable)</code>，打印第一个进程的页表。如果你通过了这部分实验的打印测试，你就可以得到全部的学分。</p></blockquote><p>当我们启动xv6时，它应该像这样打印输出，描述第一个进程刚刚完成exec()ing init时的页表:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6b000</span><br><span class="line"> ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000</span><br><span class="line"> .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000</span><br><span class="line"> .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000</span><br><span class="line"> ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure><p>第一行显示vmprint的参数。在此之后，每个PTE都有一行，包括引用树中较深的页表页的PTE。每个PTE行由一些“..”缩进，表示其在树中的深度。每个PTE行显示其页表页中的PTE索引、PTE位以及从PTE中提取的物理地址。不要打印无效(PTE_A)的PTE。在上面的示例中，顶级页-表页具有条目0和255的映射。条目0的下一层仅映射了索引0，而该索引0的底层映射了条目0、1和2。</p><blockquote><p><strong>HINS</strong>：</p></blockquote><ul><li><p>可以将vmprint()放在kernel/vm.c中。</p></li><li><p>使用kernel/riscv.h文件末尾的宏。</p></li><li><p>freewalk的是递归遍历页表的，因此vmprint可以按照其代码来实现。</p></li><li><p>在kernel/def .h中定义vmprint的原型，以便可以从exec调用它。</p></li><li><p>在printf调用中使用%p来打印完整的64位十六进制pte和地址，如示例所示。</p></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>大致的过程就是通过，在vm.c 文件中实现一个函数名为vmprint，输入的参数为，一级(根)页表的<strong>物理地址</strong>。在vmprint函数中通过遍历一级页表，获得二级页表的PTE，判断PTE的PTE_A位然后输出进行个格式输出。同理再遍历二级页表、再遍历三级页表。</p><p>由于三级页表的结构是树(512叉树)，因此我们可以使用循环或是递归的方式，可以参照freewalk一样使用递归去从根节点遍历到叶子节点。</p><blockquote><p>在exec中加入指定的代码，让用户进程初始化后就可以调用vmprint</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---exec.c---</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>)&#123;</span><br><span class="line">    vmprint(p-&gt;pagetable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现：循环"><a href="#实现：循环" class="headerlink" title="实现：循环"></a>实现：循环</h3><p>由于是三级页表的PTE打印，比较简单的实现就是通过三层嵌套循环将每一级的页表PTE打印出来。代码相对于递归的实现也是要多很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line"><span class="comment">//pagetable实际上就是一个存放pte的数组，类型为uint64</span></span><br><span class="line">   <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">   <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">     uint64 pa2 = PTE2PA(pte);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,pa2);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)&#123;</span><br><span class="line">       <span class="type">pagetable_t</span> pagetable1 = (<span class="type">pagetable_t</span>)pa2; </span><br><span class="line">       <span class="type">pte_t</span> pte = pagetable1[j];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">         uint64 pa1 = PTE2PA(pte);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,j,pte,pa1);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">512</span>; k++)&#123;</span><br><span class="line">         </span><br><span class="line">           <span class="type">pagetable_t</span> pagetable0 = (<span class="type">pagetable_t</span>)pa1;</span><br><span class="line">           <span class="type">pte_t</span> pte = pagetable0[k];</span><br><span class="line">         </span><br><span class="line">           <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">             uint64 pa0 = PTE2PA(pte);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,k,pte,pa0);</span><br><span class="line">         </span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>因为三级页表的数据结构与树结构十分相似，因此逻辑上也十分好实现。当遍历到叶子结点(第三级页表)时就结束递归即可。</p><p>递归的方式实现，由于vmprint的参数只设置了一个，因此需要添加一个称为fmtprint的函数通过添加level参数来控制格式输出。每次递归调用传递的就是pte转换后的下一级物理地址了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fmtprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line"><span class="comment">//pagetable实际上就是一个存放pte的数组，类型为uint64</span></span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">switch</span> (level)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,pa);</span><br><span class="line">        fmtprint((<span class="type">pagetable_t</span>)pa,level<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,i,pte,pa);</span><br><span class="line">        fmtprint((<span class="type">pagetable_t</span>)pa,level<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,i,pte,pa);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line"></span><br><span class="line">  fmtprint(pagetable,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Detect-which-pages-have-been-accessed-hard"><a href="#Detect-which-pages-have-been-accessed-hard" class="headerlink" title="Detect which pages have been accessed(hard)"></a>Detect which pages have been accessed(hard)</h1><h2 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h2><p>一些垃圾收集器(自动内存管理的一种形式)可以从哪些页面被访问(读或写)的信息中获益。在本部分实验中，您将向xv6添加一个新特性，该特性通过检查RISC-V页表中的访问位来检测该信息并将其报告给用户空间。当RISC-V硬件分页行走器解决TLB错误时，它会在PTE中标记这些位。</p><blockquote><p>主要任务是实现pgaccess()，这是一个系统调用，用于报告哪些页面已被访问。系统调用有三个参数。首先，它使用第一个用户页的起始虚拟地址进行检查。其次，需要检查页数。最后，它将用户地址存入缓冲区，以将结果存储为位掩码(一种每页使用一位且第一页对应最低有效位的数据结构)。如果运行pgtbltest时pgaccess测试用例通过，将获得这部分实验的全部学分。</p><p><strong>HINS</strong>:</p></blockquote><ul><li><p>阅读user/pgtlbtest.c中的pgaccess_test()以查看如何使用pgaccess。</p></li><li><p>在kernel/sysproc.c中实现sys_pgaccess()。</p></li><li><p>使用argaddr()和argt()来解析参数，lab2对这两种方法有所使用。</p></li><li><p>对于输出位掩码，在内核中存储一个临时缓冲区，并在填充正确的位后将其复制给用户(通过copyout())更容易。</p></li><li><p>kernel/vm.c中的walk()对于查找正确的pte非常有用。</p></li><li><p>在kernel/riscv.h中定义PTE_A，即访问位。请参考<a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V特权架构手册</a>来确定其值。</p></li><li><p>检查PTE_A是否设置后，请<strong>务必清除</strong>PTE_A。否则，将无法确定自pgaccess()最后一次调用以来是否访问了该页(即，将永远设置该位)。</p></li><li><p>vmprint()在调试页表时可能会派上用场。</p></li></ul><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>首先查看pgtbltest.c中的代码。pgaccess系统调用的参数分别为</p><ul><li><p>需要检查页的起始地址：这是一个虚拟地址，通过使用起始的虚拟地址配合walk函数(实现的是物理页的翻译过程)，找到最后一级页表的PTE(物理页的PTE)。</p></li><li><p>需要检查页的页数：从起始虚拟地址开始，以一个页的4096字节为单位作为一个索引(<strong>页数组</strong>)，一段连续的虚拟页。</p></li><li><p>位掩码：一个无符号整数(4字节，32位)每个位代表的就是该页表是否被访问过。</p></li></ul><p>例如，在测试中有32个页。有1、2、30个页表被访问，那么abits对应的就是第2、3、31位设置为1，再通过判断我们就可以知晓这几个页被访问过了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abits: 0100 0000 0000 0000 0000 0000 0000 0110</span><br></pre></td></tr></table></figure></p><p>如下述测试案例中，使用了malloc申请了32个页的<strong>连续的</strong>虚拟页，因为页(page)是一个4096字节的数组。那么我们刚好可以使用<code>4096*32</code>长度的char(一个字节)的字符数组来表示32个页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pgaccess_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);</span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  buf[PGSIZE * <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">  buf[PGSIZE * <span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">  buf[PGSIZE * <span class="number">30</span>] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (abits != ((<span class="number">1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)))</span><br><span class="line">    err(<span class="string">&quot;incorrect access bits set&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test: OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用整数数组的话就是<code>int buf[32*(PGSIZE/4)]</code>，每一页的起始位置就是<code>buf[n * PGSIZE/4]</code></p></blockquote><p>接着调用一次pgaccess()，但这时我们申请的几个页并没有使用(物理页已经存在，malloc调用了sbrk系统调用，创建了物理页)。</p><p>之后对创建的第1、2、30页进行读取并修改，此时这三个页就已经被访问了，那么相应的三个页的PTE_A的位也被设置为1了。</p><p>那么再调用一次pgaccess，通过abits为就可以知道那些页被访问过了。最后再判断abits的位，释放内存就结束测试了。</p><p>按照图3.3中的PTE的flag设置，将PTE_A设置为第6位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---riscv.h---</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A 1L&lt;&lt;6</span></span><br></pre></td></tr></table></figure><blockquote><p>实现sys_pgaccess系统调用</p></blockquote><ol><li><p>通过argaddr、argint，获得系统调用的前两个参数：第一个虚拟页的起始地址、页数目。</p></li><li><p>遍历页数目，通过walk将va+进程页表，获得最后一级页表的PTE。</p></li><li><p>判断获取的PTE，如果PTE_A位被设置，将abits变量对应的位设置为1，并将PTE_A清空。</p></li><li><p>由于这些页是连续的，需要获取下一个的虚拟页的起始地址为va+=PGSIZE</p></li><li><p>使用copyout将abits变量传回用户空间，注意copyout这个参数设置。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">---sysproc.c---</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 base,mask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;base);</span><br><span class="line">  argint(<span class="number">1</span>,&amp;len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//base is virtual adddress,next page address = va + 4096</span></span><br><span class="line">  uint64 va = base;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable,va,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A)&#123;</span><br><span class="line">      abits |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">      <span class="comment">//clear the PTE_A flag</span></span><br><span class="line">      *pte &amp;= (~PTE_A);</span><br><span class="line">    &#125;</span><br><span class="line">    va += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  argaddr(<span class="number">2</span>,&amp;mask);</span><br><span class="line">  <span class="comment">//copy abits to mask</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, mask, (<span class="type">char</span> *)&amp;abits, <span class="keyword">sizeof</span>(abits)) &lt; <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>遗留</strong>:现在有一个尚存的问题是通过buf对每一个页进行读取修改，翻看源码也没有看到是何时在通过虚拟地址(buf)访问访问到物理地址并且修改PTE的。</p><p>因为在实验的时候，是自己添加PTE_A这个位，所以我想的是在通过虚拟地址访问到物理地址并修改后，要自己去修改pte的PTE_A位。但是在我们完成sys_pgaccess函数之后运行就通过实验了。通过翻找vm.c以及sbrk调用我都没有找到在哪修改了pte，所以我将这个问题留到了最后。</p><p>猜测：可能是硬件更改的pte</p></blockquote><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230411154637.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVim配置</title>
      <link href="/2023/03/14/Nvim/"/>
      <url>/2023/03/14/Nvim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>实验环境：</strong> VMware+Ubuntu20.4，配置参考</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu下安装neovim</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install neovim</span><br></pre></td></tr></table></figure><p>Python依赖安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-neovim</span><br></pre></td></tr></table></figure><h1 id="安装终端字体"><a href="#安装终端字体" class="headerlink" title="安装终端字体"></a>安装终端字体</h1><ol><li><p>进入<a href="www.nerdfonts.com">nerdfonts</a>,选择自己想要的字体，我选择的字体是Hack Nerd Font</p></li><li><p>解压字体，到用户字体文件夹中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip Hack -d /usr/share/fonts/Hack</span><br></pre></td></tr></table></figure></li><li><p>使用命令安装字体</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/fonts/Hack</span><br><span class="line">sudo mkfontscale <span class="comment"># 生成核心字体信息</span></span><br><span class="line">sudo mkfontdir <span class="comment"># 生成字体文件夹</span></span><br><span class="line">sudo fc-cache -fv <span class="comment"># 刷新系统字体缓存</span></span><br></pre></td></tr></table></figure></li><li><p>在terminal中修改字体<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/p2.png" alt=""></p></li></ol><h1 id="配置nvim"><a href="#配置nvim" class="headerlink" title="配置nvim"></a>配置nvim</h1><blockquote><p><strong>文件目录树</strong></p></blockquote><ul><li>core目录：放置一些常用键的映射(options.lua)文件，nvim一些选项的修改(缩进长度等)</li><li>plugins目录：一些插件的lua文件配置</li><li>plugin目录：插件包</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/p1.png" alt=""></p><h2 id="初始化nvim文件"><a href="#初始化nvim文件" class="headerlink" title="初始化nvim文件"></a>初始化nvim文件</h2><p>在<code>~/.config/nvim</code>文件目录下新建一个文件<code>init.lua</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> init.lua</span><br><span class="line">nvim init.lua</span><br></pre></td></tr></table></figure><p>文件的内容如下：core.options指向的是./lua/core/options.lua文件内容</p><blockquote><p>lua语法还是相对vim配置语法是比较简单的，<code>--</code>表示注释</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--核心配置</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core.options&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core.keymaps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.plugins-setup&quot;</span>)<span class="comment">--插件安装管理插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.nvim-tree&quot;</span>)<span class="comment">--目录树插件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.lualine&quot;</span>)<span class="comment">--状态栏</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.treesitter&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.lsp&quot;</span>)<span class="comment">--代码</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.cmp&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.autopairs&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.Comment&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.gitsigns&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.bufferline&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;plugins.telescope&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="核心文件"><a href="#核心文件" class="headerlink" title="核心文件"></a>核心文件</h2><h3 id="option-lua"><a href="#option-lua" class="headerlink" title="option.lua"></a>option.lua</h3><p>新建文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lua</span><br><span class="line"><span class="built_in">mkdir</span> lua/core</span><br><span class="line"><span class="built_in">touch</span> lua/core/options.lua</span><br></pre></td></tr></table></figure><ul><li>local opt声明局部变量</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行号</span></span><br><span class="line">opt.relativenumber = <span class="literal">true</span></span><br><span class="line">opt.number = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 缩进</span></span><br><span class="line">opt.tabstop = <span class="number">2</span></span><br><span class="line">opt.shiftwidth = <span class="number">2</span></span><br><span class="line">opt.expandtab = <span class="literal">true</span></span><br><span class="line">opt.autoindent = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 防止包裹</span></span><br><span class="line">opt.<span class="built_in">wrap</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 光标行</span></span><br><span class="line">opt.cursorline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用鼠标</span></span><br><span class="line">opt.mouse:append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统剪贴板</span></span><br><span class="line"><span class="comment">--opt.clipboard:append(&quot;unnamedplus&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 默认新窗口右和下</span></span><br><span class="line">opt.splitright = <span class="literal">true</span></span><br><span class="line">opt.splitbelow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索</span></span><br><span class="line">opt.ignorecase = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外观</span></span><br><span class="line">opt.termguicolors = <span class="literal">true</span></span><br><span class="line">opt.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line">vim.cmd<span class="string">[[colorscheme tokyonight]]</span><span class="comment">--选择对应的主题</span></span><br></pre></td></tr></table></figure><h3 id="keymaps-lua"><a href="#keymaps-lua" class="headerlink" title="keymaps.lua~~~~"></a>keymaps.lua~~~~</h3><p>新建文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> lua/core/keymap.lua</span><br></pre></td></tr></table></figure><p>文件内容：</p><p>像配置vim的按键配置一样，我们先要设置一个主键，将主键设置为空格。</p><p>键映射的设置：keymap.set(“模式”,”修改后的键”,”修改前的键”)</p><blockquote><p>建议是不要设置太多的键，否则会导致键位冲突以及难以记住，</p></blockquote><p>键位介绍</p><ul><li><p><code>&lt;CR&gt;</code>表示换行</p></li><li><p><code>&lt;leader&gt;</code>表示主键</p></li><li><p><code>&lt;C+w&gt;</code>表示ctrl+一个w键，若w是大写，则是ctrl+shift+w</p></li><li><p>插入模式退出：ESE-&gt;jk(连续点击)</p></li><li><p>可视模式多行移动：选中多行shift+j向上移动，shift+k向下移动</p></li></ul><p>正常模式：</p><ul><li><p>添加窗口：空格(主键)+sv分割右半区窗口，空格+sh分割下半区窗口</p></li><li><p>取消搜索高亮：空格+nh</p></li><li><p>切换标签栏(buffer)：空格+l向左切换，空格+l向右切换</p></li><li><p>打开目录树：空格+e，打开文件目录</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim.g.mapleader = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">local</span> keymap = vim.keymap</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 插入模式 ---------- ---</span></span><br><span class="line">keymap.set(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;jk&quot;</span>, <span class="string">&quot;&lt;ESC&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 视觉模式 ---------- ---</span></span><br><span class="line"><span class="comment">-- 单行或多行移动</span></span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;:m &#x27;&gt;+1&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;:m &#x27;&lt;-2&lt;CR&gt;gv=gv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 正常模式 ---------- ---</span></span><br><span class="line"><span class="comment">-- 窗口</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sv&quot;</span>, <span class="string">&quot;&lt;C-w&gt;v&quot;</span>) <span class="comment">-- 水平新增窗口 </span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;sh&quot;</span>, <span class="string">&quot;&lt;C-w&gt;s&quot;</span>) <span class="comment">-- 垂直新增窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消高亮</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;nh&quot;</span>, <span class="string">&quot;:nohl&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换buffer</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;l&quot;</span>, <span class="string">&quot;:bnext&lt;CR&gt;&quot;</span>)</span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;r&quot;</span>, <span class="string">&quot;:bprevious&lt;CR&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------- 插件 ---------- ---</span></span><br><span class="line"><span class="comment">-- nvim-tree</span></span><br><span class="line">keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;:NvimTreeToggle&lt;CR&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="plugins-setup-lua：自动安装插件管理文件"><a href="#plugins-setup-lua：自动安装插件管理文件" class="headerlink" title="plugins-setup.lua：自动安装插件管理文件"></a>plugins-setup.lua：自动安装插件管理文件</h3><p>新建文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lua/plugins</span><br><span class="line"><span class="built_in">touch</span> lua/plugins/plugin-set.lua</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自动安装packer</span></span><br><span class="line"><span class="keyword">local</span> ensure_packer = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> fn = vim.fn</span><br><span class="line">  <span class="keyword">local</span> install_path = fn.stdpath(<span class="string">&#x27;data&#x27;</span>)..<span class="string">&#x27;/site/pack/packer/start/packer.nvim&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> fn.empty(fn.glob(install_path)) &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    fn.system(&#123;<span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--depth&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;https://github.com/wbthomason/packer.nvim&#x27;</span>, install_path&#125;)</span><br><span class="line">    vim.cmd <span class="string">[[packadd packer.nvim]]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> packer_bootstrap = ensure_packer()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存此文件自动更新安装软件</span></span><br><span class="line"><span class="comment">-- 注意PackerCompile改成了PackerSync</span></span><br><span class="line"><span class="comment">-- plugins.lua改成了plugins-setup.lua，适应本地文件名字</span></span><br><span class="line">vim.cmd(<span class="string">[[</span></span><br><span class="line"><span class="string">  augroup packer_user_config</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd BufWritePost plugins-setup.lua source &lt;afile&gt; | PackerSync</span></span><br><span class="line"><span class="string">  augroup end</span></span><br><span class="line"><span class="string">]]</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;packer&#x27;</span>).startup(<span class="function"><span class="keyword">function</span><span class="params">(use)</span></span></span><br><span class="line">  use <span class="string">&#x27;wbthomason/packer.nvim&#x27;</span></span><br><span class="line">  use <span class="string">&#x27;folke/tokyonight.nvim&#x27;</span> <span class="comment">-- 主题</span></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-lualine/lualine.nvim&#x27;</span>,  <span class="comment">-- 状态栏</span></span><br><span class="line">    requires = &#123; <span class="string">&#x27;kyazdani42/nvim-web-devicons&#x27;</span>, opt = <span class="literal">true</span> &#125;  <span class="comment">-- 状态栏图标</span></span><br><span class="line">  &#125;</span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-tree/nvim-tree.lua&#x27;</span>,  <span class="comment">-- 文档树</span></span><br><span class="line">    requires = &#123;</span><br><span class="line">      <span class="string">&#x27;nvim-tree/nvim-web-devicons&#x27;</span>, <span class="comment">-- 文档树图标</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  use <span class="string">&quot;christoomey/vim-tmux-navigator&quot;</span> <span class="comment">-- 用ctl-hjkl来定位窗口</span></span><br><span class="line">  use <span class="string">&quot;nvim-treesitter/nvim-treesitter&quot;</span> <span class="comment">-- 语法高亮</span></span><br><span class="line">  use <span class="string">&quot;p00f/nvim-ts-rainbow&quot;</span> <span class="comment">-- 配合treesitter，不同括号颜色区分</span></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&quot;williamboman/mason.nvim&quot;</span>,</span><br><span class="line">    <span class="string">&quot;williamboman/mason-lspconfig.nvim&quot;</span>,  <span class="comment">-- 这个相当于mason.nvim和lspconfig的桥梁</span></span><br><span class="line">    <span class="string">&quot;neovim/nvim-lspconfig&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">-- 自动补全</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/nvim-cmp&quot;</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/cmp-nvim-lsp&quot;</span></span><br><span class="line">  use <span class="string">&quot;L3MON4D3/LuaSnip&quot;</span> <span class="comment">-- snippets引擎，不装这个自动补全会出问题</span></span><br><span class="line">  use <span class="string">&quot;saadparwaiz1/cmp_luasnip&quot;</span></span><br><span class="line">  use <span class="string">&quot;rafamadriz/friendly-snippets&quot;</span></span><br><span class="line">  use <span class="string">&quot;hrsh7th/cmp-path&quot;</span> <span class="comment">-- 文件路径</span></span><br><span class="line"></span><br><span class="line">  use <span class="string">&quot;numToStr/Comment.nvim&quot;</span> <span class="comment">-- gcc和gc注释</span></span><br><span class="line">  use <span class="string">&quot;windwp/nvim-autopairs&quot;</span> <span class="comment">-- 自动补全括号</span></span><br><span class="line"></span><br><span class="line">  use <span class="string">&quot;akinsho/bufferline.nvim&quot;</span> <span class="comment">-- buffer分割线</span></span><br><span class="line">  use <span class="string">&quot;lewis6991/gitsigns.nvim&quot;</span> <span class="comment">-- 左则git提示</span></span><br><span class="line"></span><br><span class="line">  use &#123;</span><br><span class="line">    <span class="string">&#x27;nvim-telescope/telescope.nvim&#x27;</span>, tag = <span class="string">&#x27;0.1.1&#x27;</span>,  <span class="comment">-- 文件检索</span></span><br><span class="line">    requires = &#123; &#123;<span class="string">&#x27;nvim-lua/plenary.nvim&#x27;</span>&#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> packer_bootstrap <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;packer&#x27;</span>).sync()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1Td4y1578E/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c265abadb6d61a5e86273ce8c3af5dc6">【全程讲解】Neovim从零配置成属于你的个人编辑器_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> NVim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab4:Shards KV Service(未完善)</title>
      <link href="/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Sharded%20KV%20Service/"/>
      <url>/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Sharded%20KV%20Service/</url>
      
        <content type="html"><![CDATA[<div class="tip warning faa-parent animated-hover"><p><p class="faa-horizontal">这个实验由于时间关系PartB部分只完成了一点，但是我后续还是会更新的，读者可以不介意的话可以观看</p></div>  <div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div> <h1 id="Shards实验简述"><a href="#Shards实验简述" class="headerlink" title="Shards实验简述"></a>Shards实验简述</h1><h2 id="为何需要Shards？"><a href="#为何需要Shards？" class="headerlink" title="为何需要Shards？"></a>为何需要Shards？</h2><blockquote><p>Shard设计的目的简单来说就是为了并行性(parallel)、多个区域能够有Shards的副本能够加快访问就是是locally</p></blockquote><p>在分布式的事务处理中数据通常情况不会放置到一个副本中，一个事务中通常情况下会包含许多的key分布在不同的副本中，为了保证分区的容错性副本也被设计为一个raft组，这样每个副本中的数据(数据库)就是一个Shard，如何操作这样一个事务具体实现也是和[[Spanner 论文笔记]]中的描述相同。</p><h2 id="Sharded-KV-Service的组成"><a href="#Sharded-KV-Service的组成" class="headerlink" title="Sharded KV Service的组成"></a>Sharded KV Service的组成</h2><ul><li><strong>a set of replica groups：</strong> 每一个replica Group作为一个副本是Shards的子集，一个副本由一些服务器组成，这些服务器使用Raft来复制组间的Shards。</li><li><strong>shard controller：</strong> shard controller是知道那个Raft Group含有客户请求的键，这些信息叫做Cofiguration，Cofiguration会随着时间进行改变。Client会向Shard controller询问那个replica Group有这个特定的键,replica Group为了查明那个Shards应该用于服务也会询问Shard Controller。为了实现容错shard Controller任然是一个Raft Group。</li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><blockquote><p>本次实验主要挑战是处理Reconfiguration的问题——组间分片分配的改变</p></blockquote><p>在单一给应该replica Group中，所有的Group members必须同意当一个reconfiguration发生在与Client有关的Put/Append/Get操作。Put可能与reconfigurantion同时到达，reconfigurantion会导致复制组停止对持有Put的key的Shard负责。组中的所有副本必须在Put发生在reconfigurantion之前还是之后达成一致。</p><p>reconfigurantion还需要副本组之间的交互。例如，在configuration10中，组G1可能负责分片S1。在configuration11中，组G2可能负责分片S1。在10到11的reconfigurantion过程中，G1和G2必须使用RPC将分片S1的内容(键/值对)从G1移动到G2。</p><p>本次实验的通用架构(一个配置服务和一组副本组)遵循与Flat Datacenter Storage、BigTable、Spanner、FAWN、Apache HBase、Rosebud、Spinnaker和许多其他相同的通用模式。然而，这些系统在许多细节上与这个lab不同，而且通常也更复杂和更有能力。</p><h1 id="Part-A-The-Shard-controller"><a href="#Part-A-The-Shard-controller" class="headerlink" title="Part A: The Shard controller"></a>Part A: The Shard controller</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>Shardctrler管理着一个序列的cofiguration，每个configuration描述着一个组的replica Group和分配给replica的分片。每当这个分配需要改变时，Shardctrler就会用新的recofiguration一个新的configuration。K/V客户端和服务器在想要知道当前(或过去)配置时联系shardctrler。</p><p>该实验也是一个像[[KVRaft]]一样的设计，需要检测冗余的设置</p><blockquote><p>HINTS: Go maps are references. If you assign one variable of type map to another, both variables refer to the same map. Thus if you want to create a new Config based on a previous one, you need to create a new map object (with make()) and copy the keys and values individually.</p></blockquote><p>本次Part A最重要的是<strong>实现分片的移动</strong>的问题(建议是自己独立实现)，对于新添加group与删除group都应该做出对应的处理，其余的设计与lab3的设计相似，需要在applier中进行判断操作的类型并做出相应的处理。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>Configuration的参数是每个config的id、Shards一个整数数组存放GID、一个map Group ID对应的servers名称列表。我们将会根据Shards中的GID来分配，意思也是这个Shard最多由10replica Group来分配。例如有3个Group为1,2,3我们就需要将10个shards均匀的分配给这三个group可以是 {1,1,1,2,2,2,3,3,3,3}、 {1,1,1,2,2,2,2,3,3,3}、{1,1,1,1,2,2,2,3,3,3}这三种情况来是Shards的服务达到负载均衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NShards = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num    <span class="type">int</span>              <span class="comment">// config number</span></span><br><span class="line">    Shards [NShards]<span class="type">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">    Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RPC完善"><a href="#RPC完善" class="headerlink" title="RPC完善"></a>RPC完善</h2><p>Part A我们需要去完成Join、Leave、Move和Query等RPC，这些RPC都是用于允许管理员(Client)去控制Shard controller：添加replica Group、删除replica Group、在replica Group间移动shards(RPC的参数也是在comm.go中进行添加)</p><h3 id="Join-RPC"><a href="#Join-RPC" class="headerlink" title="Join RPC"></a>Join RPC</h3><p>管理者使用这个RPC去添加新的replica group，实参是mappings从唯一的，非零的replica group的标识符(GID)到服务器的名称列表的集合。当包含了新的replica group的时候shardctrler应该<strong>更新</strong>configuration，新的configuration应该在完整的组集中尽可能均匀地分配碎片，并且应该尽<strong>可能少地move shards</strong>以实现该目标。shardctrler应该允许重用GID，只要GID不是当前configuration的一部分.</p><h4 id="Join分片策略"><a href="#Join分片策略" class="headerlink" title="Join分片策略"></a>Join分片策略</h4><p>在设计上我们需要尽<strong>可能少的去移动</strong>分片以达到分片的服务的负载平衡，如我们在{1,1,1,1,1,2,2,2,2,2} ，G1与G2各有五个分片，此时我们添加有个G3，则我们需要重新分配一下每个组的分片，最大组与最小组的分片个数差不应该大于1，分配应该时G1:4，G2:3，G3:3 这样此时我们需要从G1中分配一个分片给G3，G2中分配两分片给G3，这样便可以到达负载均衡，结果为{1,1,1,1,3,2,2,2,3,3}</p><blockquote><p><strong>NOTE</strong>:在go语言中map的遍历是无序的，因此为了保持整个leader与follower的shards的分配是一致，需要将每个从map遍历中获取的gids进行一次排序</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> MoveShards_Join(new_gids []<span class="type">int</span>, add_gids []<span class="type">int</span>, Shards [NShards]<span class="type">int</span>) [NShards]<span class="type">int</span> &#123;</span><br><span class="line">    Assign_shards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>) <span class="comment">//gid-&gt;  the num of assigning shards</span></span><br><span class="line">    Gshards := <span class="built_in">len</span>(Shards) / <span class="built_in">len</span>(new_gids)</span><br><span class="line">    Remain_shards := <span class="built_in">len</span>(Shards) % <span class="built_in">len</span>(new_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign shards to group</span></span><br><span class="line">    <span class="comment">//均匀分配给现存的groups</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> new_gids &#123;</span><br><span class="line">        <span class="keyword">if</span> Remain_shards != <span class="number">0</span> &#123;</span><br><span class="line">            Remain_shards--</span><br><span class="line">            Assign_shards[g] = Gshards + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Assign_shards[g] = Gshards</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move_gid_i := <span class="number">0</span>                  <span class="comment">//the index of add_gids</span></span><br><span class="line">    move_gid := add_gids[move_gid_i] <span class="comment">//assign the shard to add_id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, gid := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">if</span> Assign_shards[gid] != <span class="number">0</span> &#123;</span><br><span class="line">            Assign_shards[gid]--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当执行多个move操作后导致shard的负载不均衡</span></span><br><span class="line">            <span class="comment">//因此需要使用改方法来调节</span></span><br><span class="line">            <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(add_gids) &lt;= move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> id, shards := <span class="keyword">range</span> Assign_shards &#123;</span><br><span class="line">                    <span class="keyword">if</span> shards &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> is_exist <span class="type">bool</span></span><br><span class="line">                        <span class="keyword">for</span> m_i := i; m_i &lt; <span class="built_in">len</span>(Shards); m_i++ &#123;</span><br><span class="line">                            <span class="keyword">if</span> Shards[m_i] == id &#123;</span><br><span class="line">                                is_exist = <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> !is_exist &#123;</span><br><span class="line">                            move_gid = id</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move shards</span></span><br><span class="line">            Shards[i] = move_gid</span><br><span class="line">            Assign_shards[move_gid]--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更换需要添加分片的组</span></span><br><span class="line">        <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(add_gids) &gt; move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">            move_gid_i++</span><br><span class="line">            move_gid = add_gids[move_gid_i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Shards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个参数的意思</p><ol><li><p><strong>new_gid：</strong> join后的分组，组号数组</p></li><li><p><strong>add_gid：</strong> join加入的分组，可能是多个组，后续用于修改shards对应索引的gid</p></li><li><p><strong>Assign_shards：</strong> 一个map用于组号与分片数量的映射，<code>[Gid]shards</code></p></li><li><p><strong>Gshards：</strong> 每个组应该获得的“商”分片，也就是<code>总分片/组数</code></p></li><li><p><strong>Remain_shards：</strong>  <code>总分片%组数</code> 获得的余数，用于均匀的分配分片</p></li></ol><h3 id="Leave-RPC"><a href="#Leave-RPC" class="headerlink" title="Leave RPC"></a>Leave RPC</h3><p>参数是先前加入组的gid列表。shardctrler创建一个不包括这些组的新configuration，并将这些组的碎片分配给其余组。新的配置应该在组中尽可能均匀地分配碎片，并且应该尽可能少地移动碎片以实现该目标。</p><h4 id="Leave分片策略"><a href="#Leave分片策略" class="headerlink" title="Leave分片策略"></a>Leave分片策略</h4><p>其原理与Join的相关参数相同，都是要尽可能通过少的去移动分片到达平衡。例如{1,1,1,4,2,2,2,3,3,4}分片的策略，此时我们需要移除G1这个组，则我们应该将G1的分片分配给G2,G3,G4。结果为{2,3,4,4,2,2,2,3,3,4}.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> MoveShards_Leave(new_gids []<span class="type">int</span>, leave_gids []<span class="type">int</span>, Shards [NShards]<span class="type">int</span>) [NShards]<span class="type">int</span> &#123;</span><br><span class="line">    Assign_shards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>) <span class="comment">//gid-&gt;  the num of assigning shards</span></span><br><span class="line">    Gshards := <span class="built_in">len</span>(Shards) / <span class="built_in">len</span>(new_gids)</span><br><span class="line">    Remain_shards := <span class="built_in">len</span>(Shards) % <span class="built_in">len</span>(new_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign shards to group</span></span><br><span class="line">    <span class="comment">//均匀分配分片给现存的group</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> new_gids &#123;</span><br><span class="line">        <span class="keyword">if</span> Remain_shards != <span class="number">0</span> &#123;</span><br><span class="line">            Remain_shards--</span><br><span class="line">            Assign_shards[g] = Gshards + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Assign_shards[g] = Gshards</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提取出需要添加分片的Gid</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">if</span> Assign_shards[g] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            Assign_shards[g]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得需要移动分片的gid的数组</span></span><br><span class="line">    <span class="keyword">var</span> move_gids []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> Assign_shards &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            move_gids = <span class="built_in">append</span>(move_gids, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要移动分片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(move_gids) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Shards</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map是无序遍历，对move_gids重新排序</span></span><br><span class="line">    sort.Ints(move_gids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//load re-balance</span></span><br><span class="line">    move_gid_i := <span class="number">0</span>                   <span class="comment">//the index of add_gids</span></span><br><span class="line">    move_gid := move_gids[move_gid_i] <span class="comment">//assign the shard to newGroups(gid)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将leave_group的分片给剩余的groups</span></span><br><span class="line">    <span class="keyword">for</span> i, g := <span class="keyword">range</span> Shards &#123;</span><br><span class="line">        <span class="keyword">for</span> _, lg := <span class="keyword">range</span> leave_gids &#123;</span><br><span class="line">            <span class="keyword">if</span> g == lg &#123;<span class="comment">//shards索引对应的id是需要移除的组号</span></span><br><span class="line">                <span class="keyword">if</span> Assign_shards[move_gid] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    Shards[i] = move_gid</span><br><span class="line">                    Assign_shards[move_gid]--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟换需要添加分片的组号</span></span><br><span class="line">        <span class="keyword">if</span> Assign_shards[move_gid] == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(move_gids) &gt; move_gid_i+<span class="number">1</span> &#123;</span><br><span class="line">            move_gid_i++</span><br><span class="line">            move_gid = move_gids[move_gid_i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Shards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Move-RPC"><a href="#Move-RPC" class="headerlink" title="Move RPC"></a>Move RPC</h4><p>参数是一个shard号和一个GID。shardctrler应该创建一个新的配置，其中将分片分配给组。Move的目的是让我们能够测试我们的软件。Move后的join或leave可能会取消Move，因为join和leave重新平衡。(也就是将相应的Shard位置的Server改为Move的参数)(逻辑十分简单，可以自行完成)</p><h4 id="Query-RPC"><a href="#Query-RPC" class="headerlink" title="Query RPC"></a>Query RPC</h4><p>RPC的参数是一个configuration号。shardctrler回复具有该编号的configuration。如果该编号为-1或大于已知的最大配置编号，则shardctrler应返回最新配置。Query(-1)的结果应该反映shardctrler在接收到Query(-1) RPC之前完成处理的每个Join、Leave或Move RPC。(逻辑十分简单，可以自行完成)</p><h1 id="Part-B：Sharded-Key-Value-Server"><a href="#Part-B：Sharded-Key-Value-Server" class="headerlink" title="Part B：Sharded Key/Value Server"></a>Part B：Sharded Key/Value Server</h1><h2 id="实验概述-1"><a href="#实验概述-1" class="headerlink" title="实验概述"></a>实验概述</h2><p>PartB的实验简单来说就是Shards + KVServer，也就是我们有多台KVServer作为数据库的分片存储，因此我们可以将lab3中的代码迁移到lab4中,值得注意的是shardctrler(PartA)与本环节的搭配。</p><blockquote><p>组成成分：</p></blockquote><ul><li><p><strong>Client：</strong> 提供接口向ctrler与raft group进行通讯，如一个应用一样</p></li><li><p><strong>shardctrler：</strong> 一个Raft Group，拥有指定Shard的对应Replica Group的信息</p></li><li><p><strong>Replica Group：</strong> 一个Raft Group，存储了一个KV数据库表示着一个shard </p></li></ul><p>在Client.go中有个接口叫做Key2shard()，通过该函数判断那个分片有我们请求的数据，实现原理简单来说就是根据输入的key进行hash(%10)，得到的余数(也就是Shards中索引)作为返回值。<code>在PartA中我们也知道一个索引在shards数组中对应的是一个Gid</code>。</p><h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><ul><li><p>通过第一个测试点没有配置改变的情形是静态的分片，将KVServer的基础上+shardctrler边可以通过该测试点</p></li><li><p>处理动态配置的情形，同一个Replica Group中的所有server的需要对数据进行迁移，如join操作后，原来只有一个分组G1的Configuration<code>[1,1,1,1,1,1,1,1,1,1]</code>，加入分组G2变为<code>[1,1,1,1,1,2,2,2,2,2]</code> ，因此G1需要检查配置变化并将shard5-shard9的数据迁移到G2。</p></li></ul><p><strong>实验过程交互图：</strong> 以3个Replica Group为例。开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230126210055.png" alt="interact of ShardKV.png"></p><h2 id="实现-概述"><a href="#实现-概述" class="headerlink" title="实现-概述"></a>实现-概述</h2><blockquote><p>Relica Group应该<strong>周期性</strong>(&lt;=100ms)的去轮询shardctrler配置是否发生改变，如果发生改变需要立即去处理迁移问题</p><p>Replica Group之间应该提供RPC，以便能够在发现配置改变后去转移分片(也就是传送KV表)，shardctrler的Config结构体包含服务器名称，需要一个labrpc.ClientEnd去发送RPC。使用传递给StartServer()的make_end()函数将服务器名转换为客户端。</p></blockquote><h3 id="修改Lab3的内存模型"><a href="#修改Lab3的内存模型" class="headerlink" title="修改Lab3的内存模型"></a>修改Lab3的内存模型</h3><ul><li>将KV表转换为多个(NShards=10)Shard便于移动或删除</li><li>添加深拷贝接口，<code>map是一个引用</code></li><li>在申请内存时需要先建立NShards个Shard分片，之后给每个分片申请内存</li><li>添加Migration的Shard处理接口<ul><li><strong>服务端：</strong> Shard_Migration()对请求的分片进行复制</li><li><strong>客户端：</strong> Shard_Get()将服务端请求回来的数据进行同步复制(WAL)到follower并应用</li></ul></li><li>添加分片状态：<ol><li>Pulling:该分片正处理拉取阶段，需要等待拉取成功，Get与PutAppend都需要等待Pulling状态改变</li><li>Empty:该分片为空，GET进行读取时也需要等待，PutAppend操作进行写入时可以不用等待</li><li>Used:分片已被使用，说明该分片是有数据的，可以进行直接进行读写，不需要任何等待</li></ol></li></ul><blockquote><p><strong>注意：</strong> 在lab3的kvserver中我们的snapshot的设计的快照存储需要进行对应的调整</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Pulling = <span class="number">1</span></span><br><span class="line">    Empty   = <span class="number">2</span></span><br><span class="line">    Used    = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShardStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mShards <span class="keyword">map</span>[<span class="type">int</span>]*Shard<span class="comment">//也可以使用数组替代map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shard <span class="keyword">struct</span> &#123;</span><br><span class="line">    KV    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    State ShardState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewShard</span><span class="params">()</span></span> *Shard &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Shard&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>), Empty&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mShard.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mShard.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mShard.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mShard.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mShard.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> Shard_Migrate() (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, Err) &#123;</span><br><span class="line">    KV := mShard.DeepCopy().KV</span><br><span class="line">    mShard.KV = <span class="literal">nil</span></span><br><span class="line">    mShard.KV = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">return</span> KV, OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> Shard_Get(newKV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> newKV &#123;</span><br><span class="line">        mShard.KV[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mShard *Shard)</span></span> DeepCopy() *Shard &#123;</span><br><span class="line">    newShard := NewShard()</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> mShard.KV &#123;</span><br><span class="line">        newShard.KV[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newShard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(StateMachine *ShardStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    shard := key2shard(op.Key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = StateMachine.mShards[shard].KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[shard].KV_Append(op.Key, op.Value)</span><br><span class="line">        StateMachine.mShards[shard].State = Used</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[shard].KV_Put(op.Key, op.Value)</span><br><span class="line">        StateMachine.mShards[shard].State = Used</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Migrate&quot;</span>:</span><br><span class="line">        cr.KV, cr.Err = StateMachine.mShards[op.Shard].Shard_Migrate()</span><br><span class="line">        StateMachine.mShards[op.Shard].State = Empty</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SetShard&quot;</span>:</span><br><span class="line">        cr.Err = StateMachine.mShards[op.Shard].Shard_Get(op.KV)</span><br><span class="line">        StateMachine.mShards[op.Shard].State = Used</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拉取最新的Configuration"><a href="#拉取最新的Configuration" class="headerlink" title="拉取最新的Configuration"></a>拉取最新的Configuration</h3><p>获取配置(poll)像applier的异步设计一样，我们开启一个协程进行周期性(不大于100ms)的获取最新配置，而且在获得到新配置后，通过判断其分片状态与组号进行修改分片的状态</p><blockquote><p><strong>Pulling State：</strong> 在migration中进行拉取对应的shard的操作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> poll() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> iShard := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">            <span class="comment">//cancel old cfg of the Pulling state</span></span><br><span class="line">            <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) == <span class="number">0</span> &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Empty</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Used</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newCfg := kv.mck.Query(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">//check change cfg</span></span><br><span class="line">        <span class="keyword">if</span> kv.Is_CfgChanged(newCfg.Num) &#123;</span><br><span class="line">            <span class="comment">//kv.LastCfg = kv.CurrentCfg</span></span><br><span class="line">            <span class="keyword">if</span> _, isleader := kv.rf.GetState(); isleader &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;G%v&#123;S%v&#125; poll Config change Cfg.Shards:%v CfgNum %d&quot;</span>,</span><br><span class="line">                    kv.gid, kv.me, newCfg.Shards, newCfg.Num)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.CurrentCfg = newCfg</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//convert shard state to pull</span></span><br><span class="line">        <span class="keyword">for</span> iShard, gid := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Empty &amp;&amp; gid == kv.gid &#123;</span><br><span class="line">                kv.StateMachine.mShards[iShard].State = Pulling</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        time.Sleep(<span class="number">75</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE：</strong> 需要增加WrongGroup的检测</p></blockquote><h3 id="分片迁移"><a href="#分片迁移" class="headerlink" title="分片迁移"></a>分片迁移</h3><blockquote><p>思考：</p><ol><li>配置改变后，以何种方式进行迁移分片(push or pull)？</li><li>在何种情况判断需要进行转移分片</li><li>如何设计RPC？</li><li>如何处理RPC?</li><li>如何处理RPC的回复(WAL)？</li></ol></blockquote><ol><li><p><strong>迁移分片的方式：</strong> 迁移分片有两种策略Pull与Push，两种方案没有具体的难度区别，我的设计采用的是Pull：</p><ul><li><p><strong>Push：</strong> 当G1的Leader发现配置变化(添加G2)，那么G1的Leader向G2的服务器发送RPC(含有Shard的数据),等待RPC的回复。</p><ul><li><strong>Pull：</strong> 当G2的Leader发现配置变化(添加G2)，那么G2的Leader的Leader向G1发送RPC，获得Shard的数据。</li></ul></li></ul></li><li><p><strong>迁移分片(Pull)条件：</strong> 我们开启一个协程叫做<strong>migration</strong>，通过周期性的观察观察新旧配置和判断shard的状态来判断是否需要进行pull。</p></li></ol><p>如<code>lastCfg=[1,1,1,1,1,1,1,1,1,1](Cfg.Num=1)</code>,<code>currentCfg=[1,1,1,1,1,2,2,2,2,2](Cfg.Num=2)</code>,每个Replica Group的migration的协程中进行处理。那么我们新加入的G2需要shard5-shard9这五个分片的数据，那Leader需要<strong>遍历Cfg.Shards中的gid</strong>，若gid = kv.gid并且判断该分片的状态，为Empty说明需要向target group进行pull分片。</p><blockquote><p>发送MigrationRPC：为了提高效率，采用了goroutine与waitgroup的方式进行并发发送RPC。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> migration() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        <span class="keyword">if</span> _, is_leader := kv.rf.GetState(); is_leader &#123;</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">for</span> iShard := <span class="keyword">range</span> kv.CurrentCfg.Shards &#123;</span><br><span class="line">                <span class="comment">//current sending pull request</span></span><br><span class="line">                <span class="keyword">if</span> kv.StateMachine.mShards[iShard].State == Pulling &amp;&amp;</span><br><span class="line">                    <span class="built_in">len</span>(kv.StateMachine.mShards[iShard].KV) == <span class="number">0</span> &#123;</span><br><span class="line">                    wg.Add(<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(iShard <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        kv.mu.Lock()</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        kv.CommandId++</span><br><span class="line">                        KV := kv.StartPull(iShard)</span><br><span class="line">                        <span class="comment">//handle the err KV</span></span><br><span class="line">                        kv.ReplicateShard(KV, iShard)</span><br><span class="line">                        kv.mu.Unlock()</span><br><span class="line">                    &#125;(iShard)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>RPC设计：</strong> 我们采用pull的方式，当主机发现了配置改变后，向拥有分片的分组发送请求迁移分片，此时我们的发送RPC的Replica Group是作为<strong>客户端</strong>进行发送请求(意味着需要像lab3的实验中client一样设计ClientId与CommandId)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MigrateArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"> ClientId  <span class="type">int64</span></span><br><span class="line"> CommandId <span class="type">int64</span></span><br><span class="line"> Shard     <span class="type">int</span></span><br><span class="line"> CfgNum    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>type MigrateReply struct {<br>    KV  map[string]string<br>    Err Err<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">4. **处理RPC：**  接收方作为**服务端**接收RPC并发送了Raft层进行同步(**Migration操作不是幂等操作**)引用，因此这个操作的处理需要进行**冗余判断**。</span><br><span class="line">```go</span><br><span class="line">func (kv *ShardKV) Migrate(args *MigrateArgs, reply *MigrateReply) &#123;</span><br><span class="line">    ...//一些错误判断</span><br><span class="line"></span><br><span class="line">    if kv.CurrentCfg.Num &lt; args.CfgNum &#123;</span><br><span class="line">        DPrintf(&quot;G%d&#123;S%d&#125; outdate Cfg %d Args.Cfg %d&quot;, kv.gid, kv.me, kv.CurrentCfg.Num, args.CfgNum)</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if kv.StateMachine.mShards[args.Shard].State == Empty &#123;</span><br><span class="line">        reply.Err = ErrEmpty</span><br><span class="line">        reply.KV = nil</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(&quot;G%v&#123;S%v&#125; receive Migrate(pull) message&quot;, kv.gid, kv.me)</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        ClientId:    args.ClientId,</span><br><span class="line">        CommandId:   args.CommandId,</span><br><span class="line">        Opt:         &quot;Migrate&quot;,</span><br><span class="line">        CfgNum:      args.CfgNum,</span><br><span class="line">        Shard:       args.Shard,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    if !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //handle the channle reply</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>处理RPC回复(Replicat Shard)：</strong> </li></ol><p>我们为什么需要通过调用Raft接口(Start)预写日志(WAL)来实现同步呢？</p><p>在Lab2、3中我们都深刻的体会到了Raft所提供的容错的作用，主要是在Leader服务器崩溃后实现数据的容错(follower的Shard的数据与leader相同)，也能满足<strong>线性一致性</strong>。</p><blockquote><p><strong>NOTE：</strong> 我们在migration()中是开启了锁，在处理RPC的回复(也就是复制Shard)是我们是调用了Start接口，因此我们在Raft层与Server层都有锁，造成死锁问题，需要在调用Start时解锁，并在收到applych的消息后进行加锁</p></blockquote><p>分片迁移交互过程图如下：<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230127004744.png" alt="image.png"></p><ol><li>新加入的组，根据配置向有指定分片的组发送Migration RPC</li><li>服务分片的组，处理MigrationRPC将指定的分片的数据进行深拷贝并删除的日志同步到follower并应用。</li><li>服务分片的组，返回MigrationRPC作为回复</li><li>新加入分组根据RPC的信息，写入日志同步到follower并应用<br>Lab4B实验添加的流程大致就是如前两幅图所示的情形。接着我们还要继续讨论一些细节，例如并发请求的处理、配置丢失等问题。</li></ol><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><h3 id="1-no-op空日志添加"><a href="#1-no-op空日志添加" class="headerlink" title="1.no-op空日志添加"></a>1.no-op空日志添加</h3><blockquote><p>在lab3中，实现了对于Read only query，在其中就使用了no-op的空日志使状态机重演(replay)以提交日志，使状态机的日志达到最新。</p></blockquote><p>在本次实验中我们仍然需要使用no-op去使状态机达到最新，因为对于shard实验，我们需要考虑到shard的状态以及配置号是否匹配的问题，我们需要使状态机的shard恢复到以前的状态，这样才能使Get操作能够正常运行。</p><h3 id="2-target-gid的寻找："><a href="#2-target-gid的寻找：" class="headerlink" title="2.target_gid的寻找："></a>2.target_gid的寻找：</h3><p>我们每次都需要通过查找旧配置与新配置比较，获知哪个组存储了指定分片，获得到一个target_gid后，但是发送MigrationRPC，回复的分片的数据并没有数据。</p><blockquote><p><strong>原因：</strong></p></blockquote><p>实验中PutAppend的操作<strong>间隔短</strong>，poll、migration<strong>周期尚未到达</strong>，导致我们在获取最新配置后跳过了很多的配置，因此我们需要进行一次重新获取target_gid</p><blockquote><p><strong>优化：</strong> </p></blockquote><p>我们同时可以进行优化，RPC发送到Server回复的时间过长，我们需要记录下已经发送的target_gid避免无效的浪费。</p><h3 id="3-MigrationRPC错误回复的处理"><a href="#3-MigrationRPC错误回复的处理" class="headerlink" title="3.MigrationRPC错误回复的处理"></a>3.MigrationRPC错误回复的处理</h3><p>通过target_gid进行pull分片，如果跳过了许多配置导致target_gid，只能返回一个ErrEmpty，此时就需要寻找新的target_gid，进行重新pull</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send Migration RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> SendMigrationRPC(iShard <span class="type">int</span>, Group []<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, si := <span class="keyword">range</span> Group &#123; <span class="comment">//find the leader of target group</span></span><br><span class="line">            <span class="keyword">var</span> reply MigrateReply</span><br><span class="line">            srv := kv.make_end(si)</span><br><span class="line">            ok := srv.Call(<span class="string">&quot;ShardKV.Migrate&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">            <span class="keyword">if</span> !ok || (ok &amp;&amp; (reply.Err == ErrWrongLeader ||</span><br><span class="line">                reply.Err == ErrTimeout)) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> reply.Err == ErrWrongGroup || reply.Err == ErrOutdate ||</span><br><span class="line">                reply.Err == ErrEmpty &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, reply.Err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reply.KV, OK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find targetid to send RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> StartPull(iShard <span class="type">int</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> target_gid <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> Groups <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> Err Err</span><br><span class="line">    CfgNum := kv.CurrentCfg.Num</span><br><span class="line">    term, _ := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="comment">// find target gid to pull shard</span></span><br><span class="line">        target_gid, CfgNum, Groups = kv.GetTargetId(iShard, kv.gid, CfgNum)</span><br><span class="line">        <span class="keyword">if</span> target_gid != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//crecete gid chage shard state</span></span><br><span class="line">            Group := Groups[target_gid]</span><br><span class="line"></span><br><span class="line">            KV, Err = kv.SendMigrationRPC(iShard, Group)</span><br><span class="line">            <span class="comment">//err targetid</span></span><br><span class="line">            <span class="keyword">if</span> Err == ErrEmpty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> Err == ErrOutdate || Err == ErrWrongGroup &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> KV</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-服务端数据不匹配客户端的请求："><a href="#4-服务端数据不匹配客户端的请求：" class="headerlink" title="4.服务端数据不匹配客户端的请求："></a>4.服务端数据不匹配客户端的请求：</h3><p>配置增长过大时有可能会导致客户端向请求服务端的数据回复了一个空数据(违背了线性一致)，主要原因也是客户端请求的组还未Pull到正确的target_gid。</p><blockquote><p>解决方案</p></blockquote><ol><li>当我们发现Shard状态为Pulling时，不能只<strong>回复一个ErrNoKey</strong>。</li></ol><p>当服务端处理<strong>Get</strong>请求发现Shard状态不为Used时</p><ul><li>我们可以让客户端进行重发Get请求</li><li>或者等待一段时间让Shard的数据得到更新(Get是幂等操作是否Apply并不是很重要)</li></ul><p>我的设计是将主处理线程暂停100毫秒，让poll与migrate线程去处理分片。如果还是错误则返回客户端，更新完配置后，重新发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------server.go-------------------*/</span></span><br><span class="line"><span class="keyword">if</span> ishard := key2shard(args.Key); kv.StateMachine.mShards[ishard].State != Used &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> kv.StateMachine.mShards[ishard].State != Used &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">5</span> &#123;</span><br><span class="line">            reply.Err = ErrOutdate</span><br><span class="line">            DPrintf(<span class="string">&quot;G%d Shard[%d] return ErrOutdate To Client&quot;</span>, kv.gid, ishard)</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">        time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------client.go-------------------*/</span></span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrWrongGroup || reply.Err == ErrOutdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> reply.Err == ErrOutdate &#123;</span><br><span class="line">        ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">        args.CfgNum = ck.config.Num</span><br><span class="line">        DPrintf(<span class="string">&quot;resend&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务端处理<strong>PutAppend</strong>请求发现Shard状态为Pulling时</p><ul><li>在请求Start前进行判断Shard是否为Pulling，来决定是否停止下来等待pull和replicate shard操作完成 </li></ul><ol><li>首先在处理Get与PutAppend时，要判断客户端与服务端的<strong>配置是否相同</strong> :如果客户端是过期或是比服务器高的配置请求都会导致读写操作出现问题。写操作会导致分片与组号不匹配，读操作会导致一直读一个错误的分片导致死锁。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> kv.CurrentCfg.Num != args.CfgNum &#123;</span><br><span class="line">    reply.Err = ErrOutdate</span><br><span class="line">    DPrintf(<span class="string">&quot;G%d Cfg is Outdate&quot;</span>, kv.gid)</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> Shards </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debugging by Pretty Printing</title>
      <link href="/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Debug/"/>
      <url>/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Debug/</url>
      
        <content type="html"><![CDATA[<h1 id="Debugging-In-Detributed-System"><a href="#Debugging-In-Detributed-System" class="headerlink" title="Debugging In Detributed System"></a>Debugging In Detributed System</h1><p>Debug官方博客<a href="[Debugging by Pretty Printing (josejg.com">Debugging by Pretty Printing </a>](<a href="https://blog.josejg.com/debugging-pretty/">https://blog.josejg.com/debugging-pretty/</a>))</p><h2 id="Go-Side"><a href="#Go-Side" class="headerlink" title="Go Side"></a>Go Side</h2><p>在文件util.go中进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> raft</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve the verbosity level from an environment variable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getVerbosity</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    v := os.Getenv(<span class="string">&quot;VERBOSE&quot;</span>)</span><br><span class="line">    level := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> v != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        level, err = strconv.Atoi(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;Invalid verbosity %v&quot;</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> logTopic <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dClient  logTopic = <span class="string">&quot;CLNT&quot;</span></span><br><span class="line">    dCommit  logTopic = <span class="string">&quot;CMIT&quot;</span></span><br><span class="line">    dDrop    logTopic = <span class="string">&quot;DROP&quot;</span></span><br><span class="line">    dError   logTopic = <span class="string">&quot;ERRO&quot;</span></span><br><span class="line">    dInfo    logTopic = <span class="string">&quot;INFO&quot;</span></span><br><span class="line">    dLeader  logTopic = <span class="string">&quot;LEAD&quot;</span></span><br><span class="line">    dLog     logTopic = <span class="string">&quot;LOG1&quot;</span></span><br><span class="line">    dLog2    logTopic = <span class="string">&quot;LOG2&quot;</span></span><br><span class="line">    dPersist logTopic = <span class="string">&quot;PERS&quot;</span></span><br><span class="line">    dSnap    logTopic = <span class="string">&quot;SNAP&quot;</span></span><br><span class="line">    dTerm    logTopic = <span class="string">&quot;TERM&quot;</span></span><br><span class="line">    dTest    logTopic = <span class="string">&quot;TEST&quot;</span></span><br><span class="line">    dTimer   logTopic = <span class="string">&quot;TIMR&quot;</span></span><br><span class="line">    dTrace   logTopic = <span class="string">&quot;TRCE&quot;</span></span><br><span class="line">    dVote    logTopic = <span class="string">&quot;VOTE&quot;</span></span><br><span class="line">    dWarn    logTopic = <span class="string">&quot;WARN&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debugStart time.Time</span><br><span class="line"><span class="keyword">var</span> debugVerbosity <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    debugVerbosity = getVerbosity()</span><br><span class="line">    debugStart = time.Now()</span><br><span class="line"></span><br><span class="line">    log.SetFlags(log.Flags() &amp;^ (log.Ldate | log.Ltime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Debug</span><span class="params">(topic logTopic, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> debugVerbosity &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        time := time.Since(debugStart).Microseconds()</span><br><span class="line">        time /= <span class="number">100</span></span><br><span class="line">        prefix := fmt.Sprintf(<span class="string">&quot;%06d %v &quot;</span>, time, <span class="type">string</span>(topic))</span><br><span class="line">        format = prefix + format</span><br><span class="line">        log.Printf(format, a...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Debug方式</p></blockquote><p>在原有的log.Printf处修改为Debug()；注S%d打印当前server号是有必要的，可以在后续dslog的脚本中进行分栏打印</p><p>示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug(dLog, <span class="string">&quot;S%d T:%d -&gt; S%d Sending PLI: %d PLT: %d LC: %d &quot;</span>,</span><br><span class="line">                        rf.me, rf.currentTerm, server, Args.PrevlogIndex, Args.PrevlogTerm,</span><br><span class="line">                        Args.LeaderCommit)</span><br></pre></td></tr></table></figure><blockquote><p>运行方式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERBOSE=1 go <span class="built_in">test</span> -run 2B</span><br></pre></td></tr></table></figure><h2 id="Python-Script"><a href="#Python-Script" class="headerlink" title="Python Script"></a>Python Script</h2><h3 id="将python脚本转为终端命令"><a href="#将python脚本转为终端命令" class="headerlink" title="将python脚本转为终端命令"></a>将python脚本转为终端命令</h3><blockquote><p>本需要加上python3 <em>.py( </em> 可以不用后缀)，将其转为如ls那样的内部终端命令</p></blockquote><p>1.需要的环境,python3解释器</p><p>2.打开终端,输入which python3 复制解释器地址</p><p>3.在你需要执行的python文件最上方加上 #! python解释器地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin python3</span></span><br></pre></td></tr></table></figure><p>4.修改当前需要执行的文件的权限 chmod +x python文件名</p><p>5.复制当前文件到python解释器的bin/文件目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp dtest ~/bin</span><br></pre></td></tr></table></figure><p>6.终端直接输入你的python文件名就可以看到运行结果了</p><blockquote><p>效果如下</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/python%20command.png" alt="command"></p><h3 id="dslog：Prettifying-the-Logs"><a href="#dslog：Prettifying-the-Logs" class="headerlink" title="dslog：Prettifying the Logs"></a>dslog：Prettifying the Logs</h3><p>经过Go side处理后我们的Log仍旧比较杂乱颜色单一，因此使用python脚本进行优化，首先要去在系统环境中装载python <a href="https://github.com/Textualize/rich">rich</a>的美化包</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERBOSE=1 go <span class="built_in">test</span> -run 2B &gt; output.log</span><br></pre></td></tr></table></figure><p>然后打印处output.log</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">008258 LOG2 S2 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008256 VOTE S3 Granting Vote to S1 at T1</span><br><span class="line">008258 VOTE S1 &lt;- S0 Got vote</span><br><span class="line">008258 VOTE S4 Granting Vote to S1 at T1</span><br><span class="line">008259 PERS S4 Saved State T:1 VF:1</span><br><span class="line">008258 PERS S3 Saved State T:1 VF:1</span><br><span class="line">008259 LOG2 S3 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008259 VOTE S1 &lt;- S2 Got vote</span><br><span class="line">008260 LEAD S1 Achieved Majority for T1 (3), converting to Leader</span><br><span class="line">008260 TIMR S1 Broadcast, reseting HBT</span><br><span class="line">008260 LOG1 S1 -&gt; S0 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008260 LOG1 S1 -&gt; S2 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008259 LOG2 S4 Saved Log (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">008261 LOG1 S1 -&gt; S3 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008262 LOG1 S1 -&gt; S4 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []</span><br><span class="line">008262 TIMR S1 Leader, checking heartbeats</span><br><span class="line">008263 TIMR S0 Resetting ELT, received AppEnt T1</span><br><span class="line">008263 TIMR S3 Resetting ELT, received AppEnt T1</span><br><span class="line">008264 TIMR S2 Resetting ELT, received AppEnt T1</span><br><span class="line">008264 LOG2 S2 LOG: (-1, 0) [&#123;&lt;nil&gt; 0&#125;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后将脚本代码写入dslog</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"><span class="keyword">from</span> rich <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">from</span> rich.columns <span class="keyword">import</span> Columns</span><br><span class="line"><span class="keyword">from</span> rich.console <span class="keyword">import</span> Console</span><br><span class="line"><span class="keyword">from</span> rich.traceback <span class="keyword">import</span> install</span><br><span class="line"></span><br><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line"><span class="comment"># Mapping from topics to colors</span></span><br><span class="line">TOPICS = &#123;</span><br><span class="line">    <span class="string">&quot;TIMR&quot;</span>: <span class="string">&quot;#9a9a99&quot;</span>,</span><br><span class="line">    <span class="string">&quot;VOTE&quot;</span>: <span class="string">&quot;#67a0b2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LEAD&quot;</span>: <span class="string">&quot;#d0b343&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TERM&quot;</span>: <span class="string">&quot;#70c43f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LOG1&quot;</span>: <span class="string">&quot;#4878bc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LOG2&quot;</span>: <span class="string">&quot;#398280&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CMIT&quot;</span>: <span class="string">&quot;#98719f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PERS&quot;</span>: <span class="string">&quot;#d08341&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SNAP&quot;</span>: <span class="string">&quot;#FD971F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DROP&quot;</span>: <span class="string">&quot;#ff615c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CLNT&quot;</span>: <span class="string">&quot;#00813c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TEST&quot;</span>: <span class="string">&quot;#fe2c79&quot;</span>,</span><br><span class="line">    <span class="string">&quot;INFO&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WARN&quot;</span>: <span class="string">&quot;#d08341&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ERRO&quot;</span>: <span class="string">&quot;#fe2626&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TRCE&quot;</span>: <span class="string">&quot;#fe2626&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># fmt: on</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_topics</span>(<span class="params">value: <span class="type">Optional</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    topics = value.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topic <span class="keyword">in</span> topics:</span><br><span class="line">        <span class="keyword">if</span> topic <span class="keyword">not</span> <span class="keyword">in</span> TOPICS:</span><br><span class="line">            <span class="keyword">raise</span> typer.BadParameter(<span class="string">f&quot;topic <span class="subst">&#123;topic&#125;</span> not recognized&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> topics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"></span></span><br><span class="line"><span class="params">    file: typer.FileText = typer.Argument(<span class="params"><span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;File to read, stdin otherwise&quot;</span></span>),</span></span><br><span class="line"><span class="params">    colorize: <span class="built_in">bool</span> = typer.Option(<span class="params"><span class="literal">True</span>, <span class="string">&quot;--no-color&quot;</span></span>),</span></span><br><span class="line"><span class="params">    n_columns: <span class="type">Optional</span>[<span class="built_in">int</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--columns&quot;</span>, <span class="string">&quot;-c&quot;</span></span>),</span></span><br><span class="line"><span class="params">    ignore: <span class="type">Optional</span>[<span class="built_in">str</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--ignore&quot;</span>, <span class="string">&quot;-i&quot;</span>, callback=list_topics</span>),</span></span><br><span class="line"><span class="params">    just: <span class="type">Optional</span>[<span class="built_in">str</span>] = typer.Option(<span class="params"><span class="literal">None</span>, <span class="string">&quot;--just&quot;</span>, <span class="string">&quot;-j&quot;</span>, callback=list_topics</span>),</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    topics = <span class="built_in">list</span>(TOPICS)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We can take input from a stdin (pipes) or from a file</span></span><br><span class="line">    input_ = file <span class="keyword">if</span> file <span class="keyword">else</span> sys.stdin</span><br><span class="line">    <span class="comment"># Print just some topics or exclude some topics (good for avoiding verbose ones)</span></span><br><span class="line">    <span class="keyword">if</span> just:</span><br><span class="line">        topics = just</span><br><span class="line">    <span class="keyword">if</span> ignore:</span><br><span class="line">        topics = [lvl <span class="keyword">for</span> lvl <span class="keyword">in</span> topics <span class="keyword">if</span> lvl <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">set</span>(ignore)]</span><br><span class="line"></span><br><span class="line">    topics = <span class="built_in">set</span>(topics)</span><br><span class="line">    console = Console()</span><br><span class="line">    width = console.size.width</span><br><span class="line"></span><br><span class="line">    panic = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> input_:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time, topic, *msg = line.strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="comment"># To ignore some topics</span></span><br><span class="line">            <span class="keyword">if</span> topic <span class="keyword">not</span> <span class="keyword">in</span> topics:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            msg = <span class="string">&quot; &quot;</span>.join(msg)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Debug calls from the test suite aren&#x27;t associated with</span></span><br><span class="line">            <span class="comment"># any particular peer. Otherwise we can treat second column</span></span><br><span class="line">            <span class="comment"># as peer id</span></span><br><span class="line">            <span class="keyword">if</span> topic != <span class="string">&quot;TEST&quot;</span>:</span><br><span class="line">                i = <span class="built_in">int</span>(msg[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Colorize output by using rich syntax when needed</span></span><br><span class="line">            <span class="keyword">if</span> colorize <span class="keyword">and</span> topic <span class="keyword">in</span> TOPICS:</span><br><span class="line">                color = TOPICS[topic]</span><br><span class="line">                msg = <span class="string">f&quot;[<span class="subst">&#123;color&#125;</span>]<span class="subst">&#123;msg&#125;</span>[/<span class="subst">&#123;color&#125;</span>]&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Single column printing. Always the case for debug stmts in tests</span></span><br><span class="line">            <span class="keyword">if</span> n_columns <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> topic == <span class="string">&quot;TEST&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(time, msg)</span><br><span class="line">            <span class="comment"># Multi column printing, timing is dropped to maximize horizontal</span></span><br><span class="line">            <span class="comment"># space. Heavylifting is done through rich.column.Columns object</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cols = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_columns)]</span><br><span class="line">                msg = <span class="string">&quot;&quot;</span> + msg</span><br><span class="line">                cols[i] = msg</span><br><span class="line">                col_width = <span class="built_in">int</span>(width / n_columns)</span><br><span class="line">                cols = Columns(cols, width=col_width - <span class="number">1</span>, equal=<span class="literal">True</span>, expand=<span class="literal">True</span>)</span><br><span class="line">                <span class="built_in">print</span>(cols)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># Code from tests or panics does not follow format</span></span><br><span class="line">            <span class="comment"># so we print it as is</span></span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;panic&quot;</span>):</span><br><span class="line">                panic = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># Output from tests is usually important so add a</span></span><br><span class="line">            <span class="comment"># horizontal line with hashes to make it more obvious</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> panic:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * console.width)</span><br><span class="line">            <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    typer.run(main)</span><br></pre></td></tr></table></figure><p>当我们将脚本安装好后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dslog --<span class="built_in">help</span> <span class="comment">#查看脚本使用参数</span></span><br><span class="line"></span><br><span class="line">dslog -n 3 -i TIMR output.log </span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://blog.josejg.com/assets/images/debugging-raft/colored.png" alt=""></p><h3 id="dtest：Capturing-Rare-Failures"><a href="#dtest：Capturing-Rare-Failures" class="headerlink" title="dtest：Capturing Rare Failures"></a>dtest：Capturing Rare Failures</h3><p>dtest脚本的作用是多次运行测试，方便检查出稀有的错误</p><p>如dslog将dtest安装完毕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Dict</span>, DefaultDict, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"><span class="keyword">import</span> rich</span><br><span class="line"><span class="keyword">from</span> rich <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">from</span> rich.table <span class="keyword">import</span> Table</span><br><span class="line"><span class="keyword">from</span> rich.progress <span class="keyword">import</span> (</span><br><span class="line">    Progress,</span><br><span class="line">    TimeElapsedColumn,</span><br><span class="line">    TimeRemainingColumn,</span><br><span class="line">    TextColumn,</span><br><span class="line">    BarColumn,</span><br><span class="line">    SpinnerColumn,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> rich.live <span class="keyword">import</span> Live</span><br><span class="line"><span class="keyword">from</span> rich.panel <span class="keyword">import</span> Panel</span><br><span class="line"><span class="keyword">from</span> rich.traceback <span class="keyword">import</span> install</span><br><span class="line"></span><br><span class="line">install(show_locals=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatsMeter</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Auxiliary classs to keep track of online stats including: count, mean, variance</span></span><br><span class="line"><span class="string">    Uses Welford&#x27;s algorithm to compute sample mean and sample variance incrementally.</span></span><br><span class="line"><span class="string">    https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#On-line_algorithm</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    n: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">    mean: <span class="built_in">float</span> = <span class="number">0.0</span></span><br><span class="line">    S: <span class="built_in">float</span> = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, datum</span>):</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line">        delta = datum - self.mean</span><br><span class="line">        <span class="comment"># Mk = Mk-1+ (xk – Mk-1)/k</span></span><br><span class="line">        self.mean += delta / self.n</span><br><span class="line">        <span class="comment"># Sk = Sk-1 + (xk – Mk-1)*(xk – Mk).</span></span><br><span class="line">        self.S += delta * (datum - self.mean)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">variance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.S / self.n</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">std</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(self.variance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_results</span>(<span class="params">results: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Dict</span>[<span class="built_in">str</span>, StatsMeter]], timing=<span class="literal">False</span></span>):</span><br><span class="line">    table = Table(show_header=<span class="literal">True</span>, header_style=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Failed&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    table.add_column(<span class="string">&quot;Total&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> timing:</span><br><span class="line">        table.add_column(<span class="string">&quot;Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.add_column(<span class="string">&quot;Real Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;User Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line">        table.add_column(<span class="string">&quot;System Time&quot;</span>, justify=<span class="string">&quot;right&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> test, stats <span class="keyword">in</span> results.items():</span><br><span class="line">        <span class="keyword">if</span> stats[<span class="string">&quot;completed&quot;</span>].n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        color = <span class="string">&quot;green&quot;</span> <span class="keyword">if</span> stats[<span class="string">&quot;failed&quot;</span>].n == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;red&quot;</span></span><br><span class="line">        row = [</span><br><span class="line">            <span class="string">f&quot;[<span class="subst">&#123;color&#125;</span>]<span class="subst">&#123;test&#125;</span>[/<span class="subst">&#123;color&#125;</span>]&quot;</span>,</span><br><span class="line">            <span class="built_in">str</span>(stats[<span class="string">&quot;failed&quot;</span>].n),</span><br><span class="line">            <span class="built_in">str</span>(stats[<span class="string">&quot;completed&quot;</span>].n),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> timing:</span><br><span class="line">            row.append(<span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row.extend(</span><br><span class="line">                [</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;real_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;real_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;user_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;user_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;stats[<span class="string">&#x27;system_time&#x27;</span>].mean:<span class="number">.2</span>f&#125;</span> ± <span class="subst">&#123;stats[<span class="string">&#x27;system_time&#x27;</span>].std:<span class="number">.2</span>f&#125;</span>&quot;</span>,</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        table.add_row(*row)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_test</span>(<span class="params">test: <span class="built_in">str</span>, race: <span class="built_in">bool</span>, timing: <span class="built_in">bool</span></span>):</span><br><span class="line">    test_cmd = [<span class="string">&quot;go&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">f&quot;-run=<span class="subst">&#123;test&#125;</span>&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> race:</span><br><span class="line">        test_cmd.append(<span class="string">&quot;-race&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> timing:</span><br><span class="line">        test_cmd = [<span class="string">&quot;time&quot;</span>] + cmd</span><br><span class="line">    f, path = tempfile.mkstemp()</span><br><span class="line">    start = time.time()</span><br><span class="line">    proc = subprocess.run(test_cmd, stdout=f, stderr=f)</span><br><span class="line">    runtime = time.time() - start</span><br><span class="line">    os.close(f)</span><br><span class="line">    <span class="keyword">return</span> test, path, proc.returncode, runtime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">last_line</span>(<span class="params">file: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.seek(-<span class="number">2</span>, os.SEEK_END)</span><br><span class="line">        <span class="keyword">while</span> f.read(<span class="number">1</span>) != <span class="string">b&quot;\n&quot;</span>:</span><br><span class="line">            f.seek(-<span class="number">2</span>, os.SEEK_CUR)</span><br><span class="line">        line = f.readline().decode()</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fmt: off</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_tests</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tests: <span class="type">List</span>[<span class="built_in">str</span>],</span></span><br><span class="line"><span class="params">    sequential: <span class="built_in">bool</span>       = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--sequential&#x27;</span>,      <span class="string">&#x27;-s&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Run all test of each group in order&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    workers: <span class="built_in">int</span>           = typer.Option(<span class="params"><span class="number">1</span>,      <span class="string">&#x27;--workers&#x27;</span>,         <span class="string">&#x27;-p&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Number of parallel tasks&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    iterations: <span class="built_in">int</span>        = typer.Option(<span class="params"><span class="number">10</span>,     <span class="string">&#x27;--iter&#x27;</span>,            <span class="string">&#x27;-n&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Number of iterations to run&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    output: <span class="type">Optional</span>[Path] = typer.Option(<span class="params"><span class="literal">None</span>,   <span class="string">&#x27;--output&#x27;</span>,          <span class="string">&#x27;-o&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Output path to use&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    verbose: <span class="built_in">int</span>           = typer.Option(<span class="params"><span class="number">0</span>,      <span class="string">&#x27;--verbose&#x27;</span>,         <span class="string">&#x27;-v&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Verbosity level&#x27;</span>, count=<span class="literal">True</span></span>),</span></span><br><span class="line"><span class="params">    archive: <span class="built_in">bool</span>          = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--archive&#x27;</span>,         <span class="string">&#x27;-a&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Save all logs intead of only failed ones&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    race: <span class="built_in">bool</span>             = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--race/--no-race&#x27;</span>,  <span class="string">&#x27;-r/-R&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Run with race checker&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    loop: <span class="built_in">bool</span>             = typer.Option(<span class="params"><span class="literal">False</span>,  <span class="string">&#x27;--loop&#x27;</span>,            <span class="string">&#x27;-l&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Run continuously&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    growth: <span class="built_in">int</span>            = typer.Option(<span class="params"><span class="number">10</span>,     <span class="string">&#x27;--growth&#x27;</span>,          <span class="string">&#x27;-g&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Growth ratio of iterations when using --loop&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    timing: <span class="built_in">bool</span>           = typer.Option(<span class="params"><span class="literal">False</span>,   <span class="string">&#x27;--timing&#x27;</span>,          <span class="string">&#x27;-t&#x27;</span>,    <span class="built_in">help</span>=<span class="string">&#x27;Report timing, only works on macOS&#x27;</span></span>),</span></span><br><span class="line"><span class="params">    <span class="comment"># fmt: on</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        timestamp = datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d_%H%M%S&quot;</span>)</span><br><span class="line">        output = Path(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> race:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[yellow]Running with the race detector\n[/yellow]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[yellow] Verbosity level set to <span class="subst">&#123;verbose&#125;</span>[/yellow]&quot;</span>)</span><br><span class="line">        os.environ[<span class="string">&#x27;VERBOSE&#x27;</span>] = <span class="built_in">str</span>(verbose)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        total = iterations * <span class="built_in">len</span>(tests)</span><br><span class="line">        completed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        results = &#123;test: defaultdict(StatsMeter) <span class="keyword">for</span> test <span class="keyword">in</span> tests&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sequential:</span><br><span class="line">            test_instances = itertools.chain.from_iterable(itertools.repeat(test, iterations) <span class="keyword">for</span> test <span class="keyword">in</span> tests)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            test_instances = itertools.chain.from_iterable(itertools.repeat(tests, iterations))</span><br><span class="line">        test_instances = <span class="built_in">iter</span>(test_instances)</span><br><span class="line"></span><br><span class="line">        total_progress = Progress(</span><br><span class="line">            <span class="string">&quot;[progress.description]&#123;task.description&#125;&quot;</span>,</span><br><span class="line">            BarColumn(),</span><br><span class="line">            TimeRemainingColumn(),</span><br><span class="line">            <span class="string">&quot;[progress.percentage]&#123;task.percentage:&gt;3.0f&#125;%&quot;</span>,</span><br><span class="line">            TimeElapsedColumn(),</span><br><span class="line">        )</span><br><span class="line">        total_task = total_progress.add_task(<span class="string">&quot;[yellow]Tests[/yellow]&quot;</span>, total=total)</span><br><span class="line"></span><br><span class="line">        task_progress = Progress(</span><br><span class="line">            <span class="string">&quot;[progress.description]&#123;task.description&#125;&quot;</span>,</span><br><span class="line">            SpinnerColumn(),</span><br><span class="line">            BarColumn(),</span><br><span class="line">            <span class="string">&quot;&#123;task.completed&#125;/&#123;task.total&#125;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        tasks = &#123;test: task_progress.add_task(test, total=iterations) <span class="keyword">for</span> test <span class="keyword">in</span> tests&#125;</span><br><span class="line"></span><br><span class="line">        progress_table = Table.grid()</span><br><span class="line">        progress_table.add_row(total_progress)</span><br><span class="line">        progress_table.add_row(Panel.fit(task_progress))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> Live(progress_table, transient=<span class="literal">True</span>) <span class="keyword">as</span> live:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">_, frame</span>):</span><br><span class="line">                live.stop()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                print_results(results)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            signal.signal(signal.SIGINT, handler)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> ThreadPoolExecutor(max_workers=workers) <span class="keyword">as</span> executor:</span><br><span class="line"></span><br><span class="line">                futures = []</span><br><span class="line">                <span class="keyword">while</span> completed &lt; total:</span><br><span class="line">                    n = <span class="built_in">len</span>(futures)</span><br><span class="line">                    <span class="keyword">if</span> n &lt; workers:</span><br><span class="line">                        <span class="keyword">for</span> test <span class="keyword">in</span> itertools.islice(test_instances, workers-n):</span><br><span class="line">                            futures.append(executor.submit(run_test, test, race, timing))</span><br><span class="line"></span><br><span class="line">                    done, not_done = wait(futures, return_when=FIRST_COMPLETED)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> future <span class="keyword">in</span> done:</span><br><span class="line">                        test, path, rc, runtime = future.result()</span><br><span class="line"></span><br><span class="line">                        results[test][<span class="string">&#x27;completed&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line">                        results[test][<span class="string">&#x27;time&#x27;</span>].add(runtime)</span><br><span class="line">                        task_progress.update(tasks[test], advance=<span class="number">1</span>)</span><br><span class="line">                        dest = (output / <span class="string">f&quot;<span class="subst">&#123;test&#125;</span>_<span class="subst">&#123;completed&#125;</span>.log&quot;</span>).as_posix()</span><br><span class="line">                        <span class="keyword">if</span> rc != <span class="number">0</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;Failed test <span class="subst">&#123;test&#125;</span> - <span class="subst">&#123;dest&#125;</span>&quot;</span>)</span><br><span class="line">                            task_progress.update(tasks[test], description=<span class="string">f&quot;[red]<span class="subst">&#123;test&#125;</span>[/red]&quot;</span>)</span><br><span class="line">                            results[test][<span class="string">&#x27;failed&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> results[test][<span class="string">&#x27;completed&#x27;</span>].n == iterations <span class="keyword">and</span> results[test][<span class="string">&#x27;failed&#x27;</span>].n == <span class="number">0</span>:</span><br><span class="line">                                task_progress.update(tasks[test], description=<span class="string">f&quot;[green]<span class="subst">&#123;test&#125;</span>[/green]&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> rc != <span class="number">0</span> <span class="keyword">or</span> archive:</span><br><span class="line">                            output.mkdir(exist_ok=<span class="literal">True</span>, parents=<span class="literal">True</span>)</span><br><span class="line">                            shutil.copy(path, dest)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> timing:</span><br><span class="line">                            line = last_line(path)</span><br><span class="line">                            real, _, user, _, system, _ = line.replace(<span class="string">&#x27; &#x27;</span>*<span class="number">8</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                            results[test][<span class="string">&#x27;real_time&#x27;</span>].add(<span class="built_in">float</span>(real))</span><br><span class="line">                            results[test][<span class="string">&#x27;user_time&#x27;</span>].add(<span class="built_in">float</span>(user))</span><br><span class="line">                            results[test][<span class="string">&#x27;system_time&#x27;</span>].add(<span class="built_in">float</span>(system))</span><br><span class="line"></span><br><span class="line">                        os.remove(path)</span><br><span class="line"></span><br><span class="line">                        completed += <span class="number">1</span></span><br><span class="line">                        total_progress.update(total_task, advance=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                        futures = <span class="built_in">list</span>(not_done)</span><br><span class="line"></span><br><span class="line">        print_results(results, timing)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> loop:</span><br><span class="line">            iterations *= growth</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[yellow]Increasing iterations to <span class="subst">&#123;iterations&#125;</span>[/yellow]&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    typer.run(run_tests)</span><br></pre></td></tr></table></figure><blockquote><p>运行示例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dtest --<span class="built_in">help</span> <span class="comment">#查看运行参数</span></span><br><span class="line"></span><br><span class="line">dtest -n 100(运行一百遍) -p 5(五个并发的运行测试加快运行速率) -s(顺序执行) </span><br><span class="line">-v(将Debug打印到<span class="built_in">log</span>) 2B(测试点名称)</span><br></pre></td></tr></table></figure><p><img src="https://blog.josejg.com/assets/images/debugging-raft/progress.png" alt=""></p><p><img src="https://blog.josejg.com/assets/images/debugging-raft/table.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> Debug </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6：操作系统接口</title>
      <link href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%201%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%201%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在操作系统的简介中，说到为了方便程序使用硬件资源操作系统会提供一些应用接口。</p><p>如Figure1.1所示，在xv6中采取一个<strong>内核(kernel)空间</strong>的设计：一个特殊的程序提供服务给运行的程序。每个运行的程序我们称作为进程(Process)拥有指令、数据、栈。<strong>用户空间(user space)：</strong> 抽象出的一个空间，用于用户运行应用程序，如shell(本质上是一个应用程序，功能就是读取命令并执行)、cat</p><ul><li>指令(instruction)：实现程序的计算</li><li>数据(data)：一些计算的变量</li><li>栈(stack)：组织的程序(C语言中的函数)的调用</li></ul><p>当进程调用内核服务时我们就需要进行(invoke)<strong>系统调用</strong>，系统调用会进入内核，然后内核执行服务并返回，于是这样的一个进程会选择在用户空间与内核空间执行。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230128013838.png" alt="image.png"></p><h1 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h1><h2 id="进程-Process-："><a href="#进程-Process-：" class="headerlink" title="进程(Process)："></a>进程(Process)：</h2><blockquote><p>进程的概念：进程简单来说就是正在运行的程序，例如我们以及启动的word办公软件、游戏应用等应用程序。</p></blockquote><p>我们为了实现一个系统能够同时运行多个程序，系统需要提供一种拥有多个CPU的假象，称作为<strong>虚拟化CPU</strong></p><p>那为了实现这种技术我们采用了一种叫做<strong>时分(time sharing)</strong> 的CPU技术：一个进程只会运行一个时间片，之后便切换到其他进程，从而提供多个CPU的假象。</p><p>进程之间的切换称作为上下文切换(context switch).</p><h2 id="进程系统调用：xv6"><a href="#进程系统调用：xv6" class="headerlink" title="进程系统调用：xv6"></a>进程系统调用：xv6</h2><p>进程API设计所需要包含的内容</p><ul><li>创建（create）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 </li><li>销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。</li><li>等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。 </li><li>其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。</li><li>状态（status）：通常也有一些接口可以获得有关进程的状态信息。</li></ul><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>exit(int status)</code></td><td>中止当前进程，将状态报告给wait(),没有返回</td></tr><tr><td>int <code>getpid()</code></td><td>返回当前进程的PID</td></tr><tr><td>int <code>fork()</code></td><td>创建进程，返回子进程的PID</td></tr><tr><td>int <code>wait(int *status)</code></td><td>父进程等待子进程退出(exit);退出状态是<code>*Status</code>，返回值为子进程的PID</td></tr><tr><td>int <code>sleep(int n)</code></td><td>暂停进程n个时钟ticks的时间</td></tr><tr><td>int exec<code>(char *file, char *argv[])</code></td><td>加载文件<code>(*file)</code>执行，以其参数<code>(*argv)</code>执行程序，错误后返回-1</td></tr><tr><td>int <code>kill(int pid)</code></td><td>中止进程号为PID的进程，成功返回0，错误返回-1</td></tr><tr><td>char <code>*sbrk(int n)</code></td><td>增加当前进程的内存空间，并返回新内存的开始位置</td></tr></tbody></table></div><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ol><li><p>创建<br>使用<code>fork()</code>系统调用，可以创建进程，新创建的进程(child)会复制当前进程(parent)的内存(数据与指令)。<code>fork()</code>创建进程成功后(不同的进程的PID不会相同)，子进程的返回值为0，父进程的返回值为子进程的PID</p></li><li><p>退出—-其他控制<br>使用<code>exit()</code>系统调用，会导致调用它的进程停止运行，并且释放诸如内存和打开文件在内的资源。</p></li><li><p>等待<br>使用<code>wait()</code>系统调用，会返回一个当前进程已退出的子进程，如果没有子进程退出，wait 会等候直到有一个子进程退出。如果调用该接口的进程没有子进程，会返回-1，当我们不在意子进程的状态时，我们可以传入0去等待。</p></li></ol><p>观看下述代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中的运行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent: child=32381</span><br><span class="line">child: exiting</span><br><span class="line">//这条语句是等待子进程退出后才会执行</span><br><span class="line">child 32381 is done</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> 虽然我们父子进程在初始化时会有相同的内存，但是在之后，他们会有单独的寄存器与内存，两个进程的变量彼此互不干扰。例如，对于变量PID，父进程中PID = 32381，而子进程的PID = 0</p></blockquote><ol><li>执行文件<br>使用exec系统调用 ，将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。</li></ol><p>示例：这段代码将调用程序替换为 /bin/echo 这个程序，这个程序的参数列表为echo hello。大部分的程序都忽略第一个参数，这个参数惯例上是程序的名字（此例是 echo）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>xv6：</strong> user/sh.c中我们会开启一个死循环进行读取用户的输入，我们会创建一个进程，将解析完成的参数，传递给runcmd()函数去调用exce执行程序(echo程序)，wait是主程序需要等待f子进程的退出。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">    <span class="comment">//+3(&quot;cd &quot;) meanning skip to the string for dir</span></span><br><span class="line">    <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(parsecmd(buf));</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xv6 通常隐式地分配用户的内存空间。fork 在子进程需要装入父进程的内存拷贝时分配空间，exec 在需要装入可执行文件时分配空间。一个进程在需要额外内存时可以通过调用 sbrk(n) 来增加 n 字节的数据内存。 sbrk 返回新的内存的地址。</p><h2 id="进程创建-细节"><a href="#进程创建-细节" class="headerlink" title="进程创建(细节)"></a>进程创建(细节)</h2><ol><li>将代码和静态数据(初始化变量)加载到内存，再加载到进程的地址空间。(操作系统读取硬盘程序字节，并将其读入到内存中)</li><li>为程序运行期栈(run-time stack)分配内存，在C语言中我们使用栈来存放局部变量、函数参数和返回地址。操作系统可以使用参数来初始化栈，例如在linux中我们将argc、argv参数填入main中</li><li>为程序的堆(heap)分配内存，如C语言中使用malloc与free，申请与释放的内存为堆内存。注：堆内存远大于栈内存，因此一些大型数据结构需要使用堆来申请内存。</li><li>执行一些初始化任务，如一些IO操作。在unix中，每个进程默认情况都会打开3个文件描述符(file descriptor，一个整数句柄)，用于标准输入输出和错误。</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230129133311.png" alt="OSTEP4.1"></p><h2 id="进程的数据结构-xv6"><a href="#进程的数据结构-xv6" class="headerlink" title="进程的数据结构(xv6)"></a>进程的数据结构(xv6)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="I-O-与-文件描述符"><a href="#I-O-与-文件描述符" class="headerlink" title="I/O 与 文件描述符"></a>I/O 与 文件描述符</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul><li><strong>I/O：</strong> 输入(input)与输出(output),C语言的头文件<code>&lt;stdio.h&gt;</code>,代表的就是标准输入与输出</li><li><strong>文件描述符：</strong> file descriptor，用一个整数来表示内核管理的对象，进程可以通过该描述符进行读或写，文件描述符接口将这些文件、管道、设备抽象为字节流</li></ul><blockquote><p><strong>获得文件描述符(fd)</strong>,可以通过打开文件、目录、或设备、创建一个管道(Pipe)、通过复制(duplicate)已经存在的文件描述符</p></blockquote><ul><li><strong>进程表：</strong> 在xv6中每个进程都会有一个进程表，而文件描述符就是作为其中的一个索引。因此每个进程的私有空间内的文件描述符都是以0开始。</li></ul><p>在xv6中，通常情况下，进程会默认定义了3个文件描述符。</p><ul><li>标准输入：0，将fd=0文件的内容进行读取，也就是读取命令行的内容，等同于C语言中的stdin</li><li>标准输出：1，将内容输出写入到fd=1的文件中，也就是输出内容到命令行，等同于stdout</li><li>错误信息：2，将错误信息输出到fd=2的文件中，等同于stderr</li></ul><blockquote><p>fd = 0,1,2，这三个描述符引用的都是同一个文件<strong>console</strong>，相当于复制(duplicate)的操作，将三个描述符用于不同的路径。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;<span class="comment">//我们会陆续获得到0，1，2三个描述，为3时破除循环</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O系统调用：xv6"><a href="#I-O系统调用：xv6" class="headerlink" title="I/O系统调用：xv6"></a>I/O系统调用：xv6</h2><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>open(char *file, int flags)</code></td><td>打开一个文件，指定读写的标识(flag),返回文件描述符</td></tr><tr><td>int <code>write(int fd, char *buf, int n)</code></td><td>将buf的内容写入fd引用的文件，返回值为n</td></tr><tr><td>int <code>read(int fd, char *buf, int n)</code></td><td>将fd的文件内容读取到buf中，返回读取的数量，如果为0这代表EOF</td></tr><tr><td>int <code>close(int fd)</code></td><td>释放打开的文件描述符，包括open、pipe、dup所产生的fd，释放后可以复用该fd</td></tr><tr><td>int <code>dup(int fd)</code></td><td>返回一个新的描述符并引用与fd相同的文件</td></tr><tr><td>int <code>pipe(int p[])</code></td><td>创建管道，将标准输入输出描述符放入<code>p[0]</code>、<code>p[1]</code>中</td></tr></tbody></table></div><blockquote><p>open()接口的第二个参数为标识符(打开文件的方式)：</p></blockquote><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_CREATE：指定的文件不存在，新建文件</li><li>O_TRUNC：截断，将文件内容清除</li></ul><h2 id="应用示例-1"><a href="#应用示例-1" class="headerlink" title="应用示例"></a>应用示例</h2><ul><li><p>cat应用：文件位置user/cat.c，我们将open、read、write三个系统接口接口聚合形成了cat这个打印文件内容的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *agrv[])</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(argv[i], <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cat: cannot open %s\n&quot;</span>, argv[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cat(fd);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><p>void cat(int fd){<br>  …<br>  while((n = read(fd, buf, sizeof(buf))) &gt; 0) {<br>    if (write(1, buf, n) != n) {<br>      fprintf(2, “cat: write error\n”);<br>      exit(1);<br>    }<br>  }<br>  …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如我们使用cat打印hello.txt，文件内容为hello world!</span><br><span class="line">```shell</span><br><span class="line">cat hello.txt</span><br></pre></td></tr></table></figure><ol><li>首先在main中使用open打开hello.txt，第二个参数0代表只读(kernel / fctrl.c)中定义了O_RDONLY为0x000</li><li>然后将文件描述符传递给cat函数，根据指定的文件描述符使用read接口读取hello.txt的内容</li><li>最后再通过write将缓冲区的内容，写入到标准输出中</li></ol><h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><blockquote><p><strong>I/O重定向：</strong> 通常情况我们都是将内容输出到屏幕也就是命令行，通过I/O重定向便可以将内容输出到指定文件内。<strong>I/O的重定向</strong> = 将标准输入、输出、错误信息打印，三个文件描述符替换，作为指定文件的描述符</p></blockquote><p>linux下的重定向符号使用</p><ul><li><code>命令 &gt; 文件</code>：将内容输出到指定文件</li><li><code>命令 2&gt; 文件</code>,可以将错误信息输出到指定文件</li><li><code>命令 &gt;&gt; 文件</code>：以追加的形式输出到指定文件</li><li><p><code>命令 &gt; 文件 2&gt;&amp;1</code>：将标准输出于错误消息输出到指定文件，在后续将会使用到该符号，等同于<code>命令 &amp;&gt; 文件</code>。个人理解:&amp;作为引用相当于duplicate，fd=2作为一个fd=1的副本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> a b &gt; tmp1 2&gt;&amp;1 <span class="comment">#b目录不存在,将2(标准错误打印)重定向1(标准输出)</span></span></span><br></pre></td></tr></table></figure></li><li><code>命令 &lt; 文件</code>：将文件内容输入到指定位置，将文件内容作为命令的标准输入</li><li><code>命令 &lt; 文件1 &gt; 文件2</code>：将文件1作为命令的标准输入，并将标准输出到文件2</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">----打印到屏幕上----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world!</span></span><br><span class="line">----写入hello.txt文件中----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world! &gt; hello.txt</span></span><br><span class="line">----使用重定向清空文件内容,原理是将空内容输出到指定文件内----</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">: &gt; hello.txt <span class="comment"># or true &gt; hello.txt</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/null &gt; hello.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> &gt; hello.txt</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>实现：</strong> <code>fork()</code> + 文件描述符</p></blockquote><p>在进程讲解中我们知道了，fork生成的子进程会拷贝父进程的内存，那么父进程的描述符同样会拷贝到子进程。<code>exec()</code>系统调用将会替代调用进程的内存(后续不再执行该进程)，但是会保留文件表。</p><blockquote><p><strong>扩展：</strong> 在命令行键入<code>cat</code>，不加上文件名。cat会采用标准输入(fd=0)作为输入流运行程序。键入<code>cat</code>后，cat程序会一直占用标准输入，我们输入一行命令，就会输出一行命令。</p></blockquote><p>由于所有进程默认打开了三个文件描述符0，1，2。因此使用open打开文件的返回值是3。要想单个cat命令能够获取文件内容，我们就需要使用IO重定向。那么我们通过使用fork+exec两个接口来实现重定向，以<code>cat &lt; input.txt</code>为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;fd = %d\n&quot;</span>,fd);</span><br><span class="line">        execvp( <span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前的标准输入(fd = 0)替换为需要读入的文件描述符，也就是关闭完标准输入(fd = 0)后，此时调用open，我们会发现这个文件的描述符为0。这时我们再使用单个<code>cat</code>命令，只会读取我们打开的文件的内容。</p><blockquote><p>为什么我们需要将exec与fork两个接口分开</p></blockquote><p>子进程进行IO重定向，不会影响到主进程的IO设置。根据cat重定向，根据上述程序，若我们只使用一个forkexec，没有更换标准文件描述符的机会，就不可能实现IO重定向的功能。</p><blockquote><p>硬件接口占用问题</p></blockquote><p>虽然父子进程拥有隔离的文件描述符表，但是父子进程共用相同的文件偏移量。也就是当父子进程都使用同一个文件描述符时，我们无法控制其运行的顺序。例如：父子进程同时使用了标准输出的描述符，若没有wait，会出现<code>world\n hello</code>的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中我们使用了wait(0)，让父进程去等待子进程退出，从而控制了执行顺序。</p><blockquote><p>dup接口使用</p></blockquote><p>上述程序使用了dup接口进行改写，复制的fd引用了标准输出(fd=1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><blockquote><p>xv6中的IO重定向(user/sh.c)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);<span class="comment">//使用exce</span></span><br></pre></td></tr></table></figure><h1 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h1><h2 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h2><p><strong>管道：</strong> 是一个小的内核缓冲区提供给进程，作为一对文件描述符。一个用于写，一个用于读。给两个程序中创建一个通讯的管道，能够进行数据交换。</p><p><strong>作用：</strong> 用于不同进程之间的通讯，省去了临时文件的创建于删除。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>该程序wc(wordcount),我们将标准输入连接到了管道的读取端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);<span class="comment">// 复制一个 p[0](管道读端)，此时文件描述符 0（标准输入）也</span></span><br><span class="line">            <span class="comment">//引用管道读端，故改变了标准输入。</span></span><br><span class="line">    close(p[<span class="number">0</span>]);<span class="comment">//关闭了标准输入，同时p[0]管道端也失效</span></span><br><span class="line">    close(p[<span class="number">1</span>]);<span class="comment">//防止子进程自己阻塞自己</span></span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);<span class="comment">// wc 从标准输入读取数据(同cat)，并写入到</span></span><br><span class="line">                        <span class="comment">// 参数中的每一个文件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该程序中我们调用了pipe()系统调用，我们创建了新的管道，在p中记录下了文件的读写描述符。父子进程都标准IO引用同一管道</p><ul><li>子进程中我们close了标准输入(fd=0)的描述符，使用dup复制了管道输入描述符，从而引用了管道的读取(输入)端。简单来说就是<strong>将标准输入替换成了管道输入</strong>也就是重定向。</li><li>父进程中我们关闭了标准读取(输入)管道，将文件内容写入标准写入(输出)管道，从而将内容写入pipe缓冲区</li></ul><p>管道数据流向图</p><p><img src="../img/pipe.png" alt="pipe"></p><blockquote><p>父进程比子进程慢一点执行的话，缓冲区没有数据，会不会导致子进程读取失败？</p></blockquote><p>缓冲区没有数据，会有以下三种情况：</p><ul><li><p>等待写入(输出)端写入数据，输入端再进行读取(<strong>阻塞</strong>)</p></li><li><p>等待引用写入(输出)端的管道描述符被关闭</p></li></ul><p>在执行exec程序前，执行<code>close(p[1])</code>，若注释该语句，我们将不会有输出。<br>wc 的一个fd仍然引用了管道的写端，那么 wc 将永远看不到文件的关闭（被自己阻塞）。</p><ul><li>读取为0，就像读取到EOF一样</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在xv6中shell实现了管道，如<code>grep fork sh.c | wc -l</code>。创建两个子进程分别执行，将左端grep输出的内容，发送给了右端wc作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">   pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">     panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">1</span>);</span><br><span class="line">     dup(p[<span class="number">1</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">0</span>);</span><br><span class="line">     dup(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230201232207.png" alt="xv6-pipe"></p><p>如图：</p><ol><li>创建两个子进程(c1、c2)，创建管道连接左端(写入端)和右端(读取端)</li><li><strong>左端写入端：</strong> 子进程1中，运行runcmd，命令如grep fork sh.c，将内容写入buffer</li><li><strong>读取端：</strong> 子进程2中，运行runcmd，如wc -l，读取buffer的数据</li><li>互相等待其完成，简单来说一写一读</li></ol><p>右端可以包含一个或多个命令，如<code>a|b|c</code>，其中a为写入端，b、c都是读取端，b、c都是两个子进程</p><blockquote><p>Pipe的实际作用</p></blockquote><p>下述示例中管道除了没有临时文件产生没有什么用途了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pipe</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world | <span class="built_in">wc</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">common:without pipe</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; <span class="built_in">wc</span> &lt;/tmp/xyz</span></span><br></pre></td></tr></table></figure><p>但是管道与临时文件相比也有以下<strong>优势</strong></p><ol><li>管道会自动清理自己；如果是文件重定向，shell 在完成后必须小心翼翼地删除/tmp/xyz。</li><li>第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。</li><li>管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。</li><li>如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</li></ol><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><blockquote><p><strong>文件系统</strong> </p></blockquote><p>操作系统中用于管理磁盘的软件，可以高效的将用户创建的文件通过I/O设备存储到系统的磁盘中，从而实现持久化地存储数据。</p><blockquote><p><strong>文件类型</strong></p></blockquote><ul><li>目录：保存了数据文件与其他目录的名称引用，目录本质上也是文件</li><li>数据文件：连续的字节数组</li><li>设备文件：所有硬件都有对应的文件，文件系统通过文件去访问特定的设备。<a href="https://www.zhihu.com/question/61665350/answer/1700474752">什么是设备文件？ - 知乎</a></li></ul><blockquote><p><strong>文件存储路径</strong></p></blockquote><p>目录和文件将会形成一个树状结构(tree)。</p><p><code>/</code> 称为根(root)目录是所有文件的开始目录，以<code>/</code> 开始表示的路径称为<strong>绝对路径</strong> ，如/a/b/c，代表访问到了c这个文件或者是目录。反之不是以<code>/</code>开始的路径称为的<strong>相对路径</strong>。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230203190038.png" alt="file_tree"></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（index node）</strong> 和<strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><blockquote><p><strong>索引节点(inode)</strong></p></blockquote><p>文件系统会给硬盘内的每个文件分配一个底层数据结构inode，每一个inode的编号对应一个文件，用于保存文件<strong>元信息</strong>。在linux下我们可以使用stat命令查看inode消息，inode数据结构存在于磁盘中。</p><p>inode中的<strong>元信息(metadata)</strong> 如</p><ul><li>索引节点ID：对应文件本身</li><li>文件的字节数</li><li>文件类型:数据文件、目录、设备文件</li><li>链接数，即有多少文件名指向这个inode</li></ul><ul><li>文件内容在磁盘的位置</li></ul><blockquote><p><strong>目录项(directory entry)</strong> = dentry</p></blockquote><p>用来记录文件的<strong>名字</strong>、inode指针以及与其他dentry的层级关联关系。多个dentry关联起来，就会形成目录结构，但它与inode不同的是，目录项是由<strong>内核维护</strong>的一个数据结构，<strong>不存放于磁盘</strong>，而是缓存在内存。</p><p>由于inode唯一标识一个文件，而dentry记录着文件的名称，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个名称。</p><blockquote><p>硬盘存储数据</p></blockquote><p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p><p>所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p><p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230203180037.png" alt="inode and entry"></p><blockquote><p>inode是存储在硬盘上的数据，那么为了加速文件的访问，通常会把inode加载到内存中</p></blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/183238194">小林coding</a></p><h2 id="文件系统调用：xv6"><a href="#文件系统调用：xv6" class="headerlink" title="文件系统调用：xv6"></a>文件系统调用：xv6</h2><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>int <code>chdir(char *dir)</code></td><td>Change the current directory.</td></tr><tr><td>int <code>mkdir(char *dir)</code></td><td>Create a new directory.</td></tr><tr><td>int <code>mknod(char *file, int, int)</code></td><td>Create a device file.</td></tr><tr><td>int <code>fstat(int fd, struct stat *st)</code></td><td>Place info about an open file into <code>*st</code>.</td></tr><tr><td>int <code>stat(char *file, struct stat *st)</code></td><td>Place info about a named file into <code>*st.</code></td></tr><tr><td>int <code>link(char *file1, char *file2)</code></td><td>Create another name (file2) for the file file1.</td></tr><tr><td>int <code>unlink(char *file)</code></td><td>Remove a file.</td></tr></tbody></table></div><ul><li><p>cddir: 切换当前文件目录，同cd命令</p></li><li><p>mkdir: 创建目录，同linux下的mkdir命令</p></li><li><p>mknod: 创建一个特殊的文件，对设备文件进行引用，与设备文件相关的是主要和次要设备编号（mknod的两个参数），它们唯一地标识内核设备。</p></li><li><p>link:创建一个文件名，对相同的inode进行引用作为一个存在的文件</p><h2 id="应用示例-2"><a href="#应用示例-2" class="headerlink" title="应用示例"></a>应用示例</h2></li><li><p>chdir与open</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---使用chdir改变当前目录，以相对路径创建文件---*/</span></span><br><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="comment">/*---以绝对路径创建文件---*/</span></span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure></li><li><p>mkdir与mknod</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在根目录下创建dir文件夹，并以只写的方式创建file文件*/</span></span><br><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="comment">/*创建console设备文件*/</span></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>创建设备文件后，内核回将读写的系统调用转移到内核设备，而不是传递给文件系统</p></blockquote></li><li><p>link与unlink</p><blockquote><p><strong>链接(link)：</strong> 每个链接由目录中的条目也就是(dentry)组成，dentry内容包含文件名与引用的inode</p></blockquote></li></ul><p>如下，创建b的文件进行读写和对a进行读写的效果相同，对a、b文件使用stat命令进行观察，可以观测到a、b有相同的inode号与一样的链接数(nlink) =2。当使用unlink后，我们再观测b文件会返现nlink=0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个文件a，创建b文件对a进行链接*/</span></span><br><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">/*取消a文件的链接*/</span></span><br><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="数据结构-xv6"><a href="#数据结构-xv6" class="headerlink" title="数据结构(xv6)"></a>数据结构(xv6)</h2><ul><li><p>fstat系统调用检索inode的文件描述符信息，并将其填入stat结构体中如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br></pre></td></tr></table></figure></li></ul><p>struct stat {<br>  int dev;     // File system’s disk device<br>  uint ino;    // Inode number<br>  short type;  // Type of file<br>  short nlink; // Number of links to file<br>  uint64 size; // Size of file in bytes<br>};</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- cd命令改变shell当前的工作目录，如果cd作为普通命令执行，那么我们将会fork一个子进程，而子进程只会改变当前目录，不会该改变父进程目录。以此不需要fork一个进程去修改目录。</span><br><span class="line">```c</span><br><span class="line">  // Read and run input commands.</span><br><span class="line">  while(getcmd(buf, sizeof(buf)) &gt;= 0)&#123;</span><br><span class="line">    if(buf[0] == &#x27;c&#x27; &amp;&amp; buf[1] == &#x27;d&#x27; &amp;&amp; buf[2] == &#x27; &#x27;)&#123;</span><br><span class="line">      // Chdir must be called by the parent, not the child.</span><br><span class="line">      buf[strlen(buf)-1] = 0;  // chop \n</span><br><span class="line">      //buf+3(&quot;cd &quot;) &#x27;+3&#x27;meanning skip to the string for dir</span><br><span class="line">      if(chdir(buf+3) &lt; 0)</span><br><span class="line">        fprintf(2, &quot;cannot cd %s\n&quot;, buf+3);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(fork1() == 0)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章主要是讲解了系统调用的一些接口，并且简单的介绍了一些linux的常识。本节课也有对应的实验，可以让你去实现一些常用linux的工具<a href="https://pdos.csail.mit.edu/6.828/2022/labs/util.html">lab1</a>(其中十分有趣的实验用pipe去实现流水线)。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6：操作系统组成</title>
      <link href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%202%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90/"/>
      <url>/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%202%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>O/S提供CPU等硬件资源分配以及安全的功能</p></blockquote><ul><li>时分(time-share)的机制：让CPU资源能够被合理的调度。<a href="">进程调度</a></li><li>隔离性(isolation)：进程的资源(如内存)与故障都不会相互干扰</li><li>复用(multiplexing)：c语言的库文件</li><li>交互(interaction)：进程之间的通讯，如管道pipe</li></ul><blockquote><p>xv6运行在多核RISC-V微处理器上，RISC-V是一个64位CPU.</p></blockquote><p>xv6是一个用”LP64“C编写的内核(L-long，P-pointer)，在c语言中long类型与pointer类型都是64位，int类型位32位。</p><p>qemu是一个c语言编写的模拟硬件的程序，但是我们在编写xv6时，应该qemu看作一块RISC-V主板，内含CPU、ROM、RAM、磁盘等等硬件，xv6就是运行在该主板上的操作系统。</p><h1 id="抽象物理资源"><a href="#抽象物理资源" class="headerlink" title="抽象物理资源"></a>抽象物理资源</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><blockquote><p>为什么要使用操作系统？</p></blockquote><p>应用通过图1.2的系统调用接口(库)可以直接与<strong>硬件资源交互</strong>，方便程序设计者去编写程序</p><blockquote><p>库方法的缺陷</p></blockquote><p>有多个应用同时运行，应用必须保持良好的特性(不能有bug)。例如应用需要周期性的放弃CPU，让其他应用使用。这便是时分的调度资源的方法。</p><p><strong>协助时分方案</strong>(cooperative time share scheme)：提供了共享CPU的方法，但是如果有bug的软件运行，那么会导致整个系统奔溃。因此我们需要系统提供隔离性。</p><blockquote><p>将物理资源抽象为 <strong>服务(文件服务)或是系统调用</strong> 提供那些便利？</p></blockquote><ol><li><strong>强隔离性</strong>：禁止应用直接访问硬件资源，而是提供便捷的方式去访问物理资源。</li></ol><ul><li><p>提供文件服务(文件名)方便对硬盘资源进行交互操作，使用read、write、open接口使用硬盘资源</p></li><li><p>通过进程访问cpu的资源，同时应用也不需要考虑时间共享问题，系统中有调度程序去控制进程的切换。</p></li></ul><ol><li><strong>编程便捷性</strong>：对于程序员来说，我们不需要记住这些硬件的(二进制)指令来进行编程，而是通过简单易懂的接口直接使用物理资源进行程序编写。</li></ol><h1 id="模式与系统调用"><a href="#模式与系统调用" class="headerlink" title="模式与系统调用"></a>模式与系统调用</h1><h2 id="强隔离性："><a href="#强隔离性：" class="headerlink" title="强隔离性："></a>强隔离性：</h2><ul><li><strong>应用与硬件隔离</strong>：禁止应用直接<strong>访问</strong>敏感的<strong>硬件资源</strong>，将资源抽象为服务。例如使用文件系统调用接口去访问磁盘。</li><li><strong>进程隔离</strong>：一个进程不能够访问(操作)另一个进程的资源，例如：不能篡改另一个进程的内存资源</li><li><strong>硬边界(安全性)</strong>：用户空间与内核空间的实现。当应用出错时，O/S进程不会被这一个应用影响，相反O/S会将这个错误应用清除并运行另一个应用</li></ul><blockquote><p>O/S实现强隔离性</p></blockquote><ol><li>应用禁止修改O/S的数据结构和指令</li><li>应用不能访问其他进程资源</li></ol><blockquote><p>CPU提供隔离性</p></blockquote><p>在RISC-V这样中三种特权模式：</p><ol><li>机器模式(machine mode)：CPU初始时以该模式启动，并且指令最高特权级运行，该模式主要用于配置计算机。</li><li>管理者模式(supervisor mode)：允许CPU执行特权指令，如禁用中断，读写页表地址寄存器等。用户执行这些指令会导致程序终止。运行在内核空间的<strong>软件</strong>称为内核，其可以执行特权指令</li><li>用户模式(user mode)：应用只能执行用户指令，运行在用户空间。</li></ol><h2 id="特权模式转换"><a href="#特权模式转换" class="headerlink" title="特权模式转换"></a>特权模式转换</h2><p>应用想要调用内核函数(系统调用)必须要转到内核，但是应用不能直接调用内核函数，</p><p>CPU提供了特别指令：从用户模式到管理者模式然后进入内核指定的入口点(entry point)。在RISC-V中使用ecall可以达到目的</p><p>当CPU转换到管理者模式，内核将验证系统调用的参数，决定是否要执行请求操作。</p><blockquote><p>特权级修改指令</p></blockquote><ul><li><strong>ecall</strong>：当进程使用系统调用将会执行ecall指令(RISC-V)，该指令将会<strong>提升硬件的特权级</strong>，改变程序计数器到内核定义的入口点(entry point)。这样就可以转到内核栈并执行内核指令。</li><li><strong>sret</strong>：当内核执行完系统调用返回用户空间时，使用sret指令将会降低硬件的特权级，并重新执行用户指令</li></ul><h1 id="内核组织"><a href="#内核组织" class="headerlink" title="内核组织"></a>内核组织</h1><blockquote><p>关键：O/S运行在管理者模式</p></blockquote><h2 id="单内核-monolithic-kernel"><a href="#单内核-monolithic-kernel" class="headerlink" title="单内核(monolithic kernel)"></a>单内核(monolithic kernel)</h2><blockquote><p>定义：整个操作系统都在内核空间中，所有系统调用都运行在管理者模式</p></blockquote><p>这种内核组织中整个O/S以完全的(full)硬件特权级运行，这样的方便之处在于</p><ul><li>OS的设计者不需要决定O/S的那一个部分需要完全硬件特权级</li><li>使O/S不同部分之间的协作更加简单，如文件系统与虚拟内存系统可以共享缓冲区缓存</li></ul><blockquote><p>缺点</p></blockquote><ul><li>O/S的不同部分的接口会更加复杂，容易让系统开发者犯错。同时在单内核中犯错是致命的</li><li>内核故障会导致整个计算机停止工作，同时应用也会故障，计算机必须重启才行。</li></ul><h2 id="微内核-microkernel"><a href="#微内核-microkernel" class="headerlink" title="微内核(microkernel)"></a>微内核(microkernel)</h2><blockquote><p>定义：减少大量运行在管理者模式的OS代码，并将大部分的OS在用户模式运行</p></blockquote><p>图2.1</p><p>图中阐明了，文件系统像一个用户程序一样运行，作为进程运行的OS服务称为<strong>服务器</strong>，为了允许应用与文件服务器交互，内核提供了了进程间的交流机制从一个用户进程发送消息(message)到另一个进程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，单内核与微内核都非常普遍。许多Unix的内核实现如单内核，而向Minix、L4、QNX这样的OS就是微内核，并且微内核经常适用于嵌入式设置开发。</p><p>xv6是一个单内核实现的(类unix系统)，因此xv6内核接口相对于OS接口，内核实现完全像是一个OS。</p><h2 id="代码：xv6组织"><a href="#代码：xv6组织" class="headerlink" title="代码：xv6组织"></a>代码：xv6组织</h2><p>xv6的内核资源圈在kernel/的子文件中，资源也是被分为文件，像是一个个模块一样。图2.2也列出了这些文件，模块间的接口定义在(kernel/defs.h)中。</p><h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><p>xv6中的<strong>隔离单元</strong>(unit of isolation)就是一个进程，进程抽象是为了预防进程破坏或是监听另一进程的资源(CPU、内存、文件描述符等)，同时也保证了进程不会破坏内核程序，更不可能破坏内核的隔离机制。</p><blockquote><p>进程抽象对隔离性的实施提供了帮助</p></blockquote><ul><li>程序像是运行在一个私有的机器上。这机器中有私有的内存系统和地址空间，其他进程禁止读写。同时进程运行在这个机器的CPU上，执行程序指令。</li></ul><p>但实际上这个机器上可以运行许多个程序，而进程都会共享机器的CPU、内存(虚拟内存)等资源。进程的抽象给进程造成了一种假象，那就是这个机器只有我这一个程序在运行。</p><blockquote><p>页表提供了内存的隔离性</p></blockquote><p>xv6中我们使用了页表(用硬件实现的)给每个进程一个私有空间，将内存的物理空间(物理地址，physical address，PA)划分一个<strong>固定大小的地址空间</strong>(图2.3)给进程作为私有的虚拟空间(虚拟地址，virtual address，VA)。</p><p>那么通过这样就可以实现内存上的隔离，简单来说就是将一块大蛋糕(物理内存)划分给每一个进程，给它们一种自己得到所有蛋糕的错觉，那么它们就不会打扰其他进程的运行了</p><p>RISC-V页表的作用，主要是将虚拟地址通过映射转换为一个物理地址，也就是<strong>map</strong>(VA-&gt;PA)</p><p>xv6中维持了给每一个页表维持了一个独立的页表，定义了进程的地址空间。进程的虚拟地址空间是从0开始的，如图2.3中的布局</p><ol><li>user text and data：保存了指令与全局变量</li><li>user stack：用户栈，保存了局部变量与函数调用地址</li><li>heap：堆，用户可以根据需求进行扩展(malloc)</li><li>trapframe：一个页(page)，映射保存/恢复用户进程的状态</li><li>trampoline：一个页(page)，包含进出内核的代码</li></ol><blockquote><p>进程地址空间有所限制，RISC-V是一个64位宽的指针，在页表硬件只用低39位查找虚拟地址空间，xv6只使用39位中的38位。最大的地址空间为$MAXVA=2^{38}-1$ = 0x3fffffffff。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Figure2.3.png" alt="Figure2.3.png"></p><h3 id="进程的虚拟内存分配-扩展"><a href="#进程的虚拟内存分配-扩展" class="headerlink" title="进程的虚拟内存分配(扩展)"></a>进程的虚拟内存分配(扩展)</h3><blockquote><p>《CSAPP》<strong>进程地址空间</strong>分配:：进程创建时会分配这些固定的内存，从上到下依次为</p></blockquote><ol><li>用户<strong>栈(Stack)</strong>(运行期创建)：函数调用与局部数据变量</li><li>内存<strong>映射</strong>区域：链接共享库</li><li>运行期<strong>堆(heap)</strong>：C语言以malloc分配，C++以new分配</li><li><strong>读写段</strong>(R/W Segment)：<ul><li>.data:已经初始的全局变量和静态变量(C语言的Static变量)。</li><li>.bss:未初始化(或是初始化为0)的全局变量和静态变量。<br>说明全局变量和静态变量(全局静态变量也是一样)的生命周期是编译期到程序结束，注意局部的变量是保存在用户栈中。</li></ul></li><li><strong>只读段</strong>(R/O Segment)：<ul><li>.init:定义了一个小函数，叫做_init，被程序初始化代码调用</li><li>.text:编译期生成的机器码</li><li>.rodata:只读数据，如printf语句中的格式化字符串，或是const声明的变量</li></ul></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230128020458.png" alt="Process space"></p><blockquote><p><strong>程序计数器:</strong> program counter 简称为PC</p></blockquote><p>PC是CPU中的<strong>寄存器</strong>，保存了当前正在执行的指令的地址（位置）。当每个指令被获取，PC的<strong>存储地址加一</strong>。在每个指令被获取之后，程序计数器指向顺序中的下一个指令。当计算机重启或复位时，程序计数器通常恢复到零。</p><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul><li>线程(thread)：进程最开始只有一个线程，运行进程的指令</li><li>内核栈：p-&gt;kstack，内核栈是一个独立存在，因此，进程的用户栈出现问题时，内核也可以运行。</li><li>用户栈：储存局部变量等数据</li><li>进程状态：p-&gt;state，xv6中进程状态：分配(allocated)、就绪(ready)、运行(running)、阻塞(blocked)</li><li>页表：p-&gt;pagetable，页表作为物理地址的记录分配后存储在内存中，在用户空间执行进程时，xv6使分页硬件使用p-&gt;pagetable。</li></ul><blockquote><p>栈的切换</p></blockquote><ol><li>进程运行用户指令只使用用户栈，而用户栈为空</li><li>进程进入内核，用户栈会保存数据，但不会使用这个栈</li><li>进程的线程将会选择用户栈与内核栈</li></ol><h3 id="进程状态-扩展-：OSTEP"><a href="#进程状态-扩展-：OSTEP" class="headerlink" title="进程状态(扩展)：OSTEP"></a>进程状态(扩展)：OSTEP</h3><ul><li>运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。</li><li>就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。</li><li>阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器。</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230130003713.png" alt="Process: State Transitions"></p><blockquote><p>进程：两个主要设计思想</p></blockquote><ol><li>地址空间(<strong>内存虚拟化</strong>)：给进程以为自己拥有整个内存的错觉</li><li>线程(<strong>CPU虚拟化</strong>)：给进程以为自己独占CPU的错觉</li></ol><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在xv6的内核维持了进程的许多状态，全都汇集到了struct proc数据结构中。我们通常使用p-&gt;xxx指向一个proc结构体中的元素。</p><blockquote><p>进程重要的状态</p></blockquote><ul><li>页表</li><li>内核栈(p-&gt;kstack)</li><li>运行状态(proc.h中procstate枚举类型)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br></pre></td></tr></table></figure><h3 id="CPU状态"><a href="#CPU状态" class="headerlink" title="CPU状态"></a>CPU状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="XV6启动"><a href="#XV6启动" class="headerlink" title="XV6启动"></a>XV6启动</h1><h2 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h2><blockquote><p>加载内核</p></blockquote><p>RISC-V主板电源启动-&gt;ROM中的主引导程序(Boot loader)将内核程序载入内存-&gt;进入机器模式</p><blockquote><p>加载机器模式(machine mode)</p></blockquote><p>CPU执行<code>_entry</code>程序，将分页(paging)硬件禁用(start.c:34)：虚拟内存直接映射到物理内存</p><blockquote><p>为什么XV6内核在内存中的初始化物理地址为0x80000000？</p></blockquote><p>0x00000000:0x80000000这一段地址保存的是I/O的设备</p><blockquote><p>生成内核栈</p></blockquote><p><code>_entry</code>中加载了栈指针寄存器<code>sp</code>其地址为stack0+4096,处于栈顶(栈在RISC-V中是向下增长的),生成内核栈。</p><blockquote><p>设置寄存器</p></blockquote><p>entry.S在之后调用了start.c文件，开始配置特权模式</p><p><code>mret</code>这个指令，可以让CPU进入管理者(surpervisor)模式，主要是用于让上一个调用中返回，从管理者模式返回到机器模式。</p><ol><li>mstatus：保存了上一个特权模式，调用mret指令就进入该特权模式</li><li><strong>mepc</strong>：设置mret的返回地址</li><li><strong>satp</strong>：页表寄存器，写入0就禁用了页表硬件</li></ol><blockquote><p>初始化时钟，设置时间片</p></blockquote><p>start函数最后调用mret指令，将程序计数器转到main，进入管理者模式转到main.c程序中</p><p>内核模式如何配置查看后续的代码分析中的main函数</p><h2 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="1-entry-S：生成内核栈"><a href="#1-entry-S：生成内核栈" class="headerlink" title="1.entry.S：生成内核栈"></a>1.entry.S：生成内核栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # 设置C语言的栈</span><br><span class="line">        # stack0在start.c中被声明</span><br><span class="line">        # with a 4096-byte stack per CPU. 每个CPU的栈只有4096字节</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure><h3 id="2-start-c"><a href="#2-start-c" class="headerlink" title="2.start.c"></a>2.start.c</h3><ul><li>在11行处声明了，stack0</li><li>在21行处<code>_entry</code>被调用入了C代码</li></ul><blockquote><p>start不会像一个调用一样返回(returning)，而是将这些事情设置的像有过调用一样，并且在机器模式下执行</p></blockquote><ol><li>通过在寄存器<code>mstatus</code>中，设置之前的特权模式为管理者模式(24-27行)</li><li>通过写入main地址到寄存器<code>mepc</code>，设置返回地址为main的地址(31行)</li><li>通过写入0到页表寄存器<code>satp</code>，在管理者模式中将<strong>虚拟地址禁用</strong>(34行)</li><li>将所有的异常与中断托付给<strong>管理者模式</strong>(37-39行)</li><li>管理者模式能够接触到所有物理内存(43-44行)</li></ol><p>简单来说通过设置mstatus的模式为管理者模式，通过调用mret就能进入管理者模式了。而我们将mret的返回地址设置为main，这样xv6就在管理者模式中进入内核程序的主函数中了</p><blockquote><p>时钟生成</p></blockquote><p>在进入管理者模式之前，<code>start</code>还要执行一个任务(47行)：对时间切片进行编程初始化<strong>时钟中断</strong>。</p><blockquote><p>进入管理者模式,转到内核主函数</p></blockquote><p>在54行处通过mret汇编代码转换为管理者模式(内核模式)，进入main函数,mret指令最多被用来从先前的管理者模式转到机器模式。之后程序的计数器转到main函数(main.c:11)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timerinit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S needs one stack per CPU.内核栈</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a scratch area per CPU for machine-mode timer interrupts.</span></span><br><span class="line">uint64 timer_scratch[NCPU][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">timervec</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="user-main-c"><a href="#user-main-c" class="headerlink" title="user/main.c"></a>user/main.c</h3><p>main程序初始化设备与子系统(文件系统)，它通过userinit(proc.c:233行)去创建第一个进程。第一个进程将会执行汇编写的程序user/initcode.S，进行第一个系统调用。</p><p>在initcode.S(3行)载入了exec系统调用的编号，SYS_EXEC(syscall.h:8行)到寄存器a7然后调用ecall返回到内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>内核在syscall(132行)中使用寄存器a7的编号，去调用想要的系统调用。系统调用表(syscall.c)持有SYS_EXEC到sys_exec的映射</p><p>当内核完成exec，将会/init进程<strong>返回到用户空间</strong>。init(user/init.c:15行)创建一个控制台的设备文件，然后在控制台中启动console，xv6启动了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p><a href="https://blog.csdn.net/u011675745/article/details/122656997#:~:text=Undefined%20item%3A%20%22riscv%3Arv64%22%20%E4%BD%BF%E7%94%A8%20gdb-multiarch%20%E6%97%B6%E4%BC%9A%E5%9C%A8%E5%BC%80%E5%A4%B4%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%20set%20architecture,riscv64%20%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%8C%E6%80%AA%E4%B8%8D%E5%BE%97%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E3%80%82%20%E5%9C%A8%20Stack%20Overflow%20%E4%B8%8A%E6%89%BE%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E8%AF%B4%E9%9C%80%E8%A6%81%E5%B0%86%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%88%B0%208.3%20%E4%BB%A5%E4%B8%8A%E6%89%8D%E5%8F%AF%E4%BB%A5%E3%80%82">参考链接</a></p><blockquote><p>我的实验环境为<strong>ubuntu20.04</strong>，只有gdb-multiarch这个gdb调试工具</p></blockquote><h2 id="连接GDB-Server"><a href="#连接GDB-Server" class="headerlink" title="连接GDB Server"></a>连接GDB Server</h2><ol><li><p>打开一个terminal，在xv6的文件夹中键入make qemu-gdb打开gdbserver。在课程演示中我们使用了CPUs=1这个选项以一个cpu运行xv6<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091040.png" alt="image.png"></p></li><li><p>再打开一terminal，同样在xv6文件夹中，键入gdb-multiarch这个命令就可以链接到gdb-server了，链接成功后如图所示<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/20230228091420.png" alt="image.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6：页表</title>
      <link href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%203%EF%BC%9A%E9%A1%B5%E8%A1%A8/"/>
      <url>/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%203%EF%BC%9A%E9%A1%B5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>页表</strong>：是一种最受欢迎的操作系统提供给进程私有空间地址和内存的机制。页表决定了内存地址的意义，以及可以访问的内存部分。</p><p>页表在xv6中的作用</p></blockquote><ol><li><strong>隔离</strong>不同进程的地址空间</li><li><strong>复用</strong>物理内存：共享库</li></ol><h1 id="内存与地址空间"><a href="#内存与地址空间" class="headerlink" title="内存与地址空间"></a>内存与地址空间</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存与CPU直接交互，由RAM组成，断电后数据就会丢失。在这里我们可以将内存看作一个<code>[0,max]</code>的<strong>字节</strong>数组(RISC-V加载与储存数据都是以字节为单位，取单字或双字)，地址则是<strong>索引</strong>，那么CPU对内存进行读写也就和C语言中读写数组元素相似。</p><p>在第一章中，简述了进程是如何从磁盘加载到内存中的。那么下图就是内存中程序进程，分别由cat、sh、kernel等进程，那么按照内存是一个数组的假设，这些进程就会占据一段连续的空间。</p><blockquote><p><strong>WARNNING</strong>:在这种布局下，会出现一些问题。最明显的就是没有隔离性，在cat中使用指令那么我们就会修改sh的内存映像，更加危险的是会导致内核映像被修改。</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/memory.png" alt="memory.png"></p><h2 id="虚拟-地址空间"><a href="#虚拟-地址空间" class="headerlink" title="(虚拟)地址空间"></a>(虚拟)地址空间</h2><p>于是我们提供了<strong>地址空间</strong>(address space)这个<strong>抽象</strong>，地址空间就是给每一个进程一个独立的地址空间(虚拟的空间，都是从0到n)，给进程一种只有自己拥有整块内存空间的错觉。</p><p>如下图，对于sh、cat、OS这三个进程分配为三个独立的进程空间，如果这是cat还想修改1000地址的值，它也只能修改自己的地址空间了，而不能修改到sh进程的空间了。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/address%20space.png" alt="address space.png"></p><p>在地址空间的抽象下，我们实现了地址空间的抽象。实现了隔离性，这样其他进程也就不能访问其他进程的空间，更谈不上修改了。</p><blockquote><p><strong>challege</strong>:通过什么<strong>硬件</strong>支持才能够满足这种地址空间的抽象。并且如何在一个物理内存中<strong>复用</strong>多个内存，同时能够保持内存的隔离性。</p></blockquote><h1 id="分页硬件-MMU-RISCV"><a href="#分页硬件-MMU-RISCV" class="headerlink" title="分页硬件:MMU(RISCV)"></a>分页硬件:MMU(RISCV)</h1><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。</p><blockquote><p><strong>MMU</strong>:是集成到CPU内的一个组件，主要是负责读取虚拟内存的映射表(<strong>查看页表</strong>)，并通过映射表将虚拟地址转换为物理地址。</p><p><strong>RISC-V</strong>指令可以操作虚拟地址(VA,virtual address)。</p></blockquote><ul><li><strong>物理地址 PA</strong>：机器的RAM或是物理内存的索引</li><li><strong>虚拟地址 VA</strong>：进程的内存空间索引</li></ul><p>RISC-V页表硬件通过<strong>映射</strong>(mapping)VA到PA，连接了两种地址。对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。包括我们在C语言程序打印的地址都是虚拟地址。</p><p>假设寄存器a0中是地址0x1000，那么这是一个<strong>虚拟内存地址</strong>。虚拟内存地址会被转到MMU。MMU会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。如下图所示</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/address%20map.png" alt="address map.png"></p><blockquote><p>从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。</p></blockquote><p>地址翻译：MMU中会从<strong>内存</strong>加载0x1000虚拟地址的映射表到MMU中，如图中所示，0x1000的VA对应0xFFF0的PA。</p><p><strong>satp</strong>(Supervisor Address Translation and Protection Registers)：存放映射表的物理内存地址。由于映射表保存在内存中，所以satp中保存的是<strong>物理地址</strong>可以让MMU找到内存中保存的映射表。例如在图例中VA = 0x1000，其中satp = 0x10的物理地址中保存的是这个VA的映射表。</p><p>每个程序都会有自己独立的映射表，并且这个映射表定义了应用的地址空间。当进程上下文切换时，同时也需要切换satp寄存器的内容，从而获得新的表单。这样的话就可以将相同的虚拟地址翻译为不同的物理地址了(读写satp寄存器是管理者模式的特权)。</p><p>那么这个映射表可以称为页表(page table)，在RISC-V中一个映射表可以有多大，对于每一个VA映射表中都会有一个条目，这样的话在64位寄存器中就会有$2^{64}$个地址。</p><p>那么在RISC-V中使用地址条目为<strong>粒度</strong>来管理，那么映射表也会十分巨大，内存会被这个映射表给耗尽。在实际情况下，不会是一个内存地址对应页表中的一个条目，接着会学习一下页表是如何在RISC-V中工作的。</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><blockquote><p><strong>页表粒度</strong></p></blockquote><p>为每个页(page)创建一个映射表条目，因此每次地址翻译都是针对一个页。RISC-V页表是以4096($2^{12}$，一个页是4KB)字节块为<strong>粒度</strong>(由1字节转为4096字节)进行内存对齐。</p><blockquote><p><strong>虚拟地址配置</strong></p></blockquote><p>XV6运行在Sv39 RISC-V上，也就是64位虚拟地址的低39位被使用，高25位未被使用,那么这样说虚拟地址的数量就有$2^{27}$大概就是512GB(未使用的25位在更新的CPU中也许会支持更大的空间)。</p><p>如下图所示：</p><ul><li><strong>虚拟地址，VA</strong> = 64位 = EXT(未使用，高25位) + index(中27位) + offset(低12位)</li><li><strong>物理地址，PA</strong> = 56位 =  PPN(中44位) + offset(低12位)</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3.1.png" alt="3.1.png"></p><blockquote><p><strong>地址翻译</strong></p></blockquote><ol><li><p><strong>页(page)</strong>：由于一个页是4096字节，那么将一个页看作4096字节的数组，那么offset = $2^{12} = 4096$那么12位的offset刚好能够作为一个页的<strong>索引</strong>。</p></li><li><p><strong>页表(page table)</strong>：在Sv39配置中，一个RISC-V<strong>页表</strong>是一个$2^{27}$(134,2127,728)页表条目(PTEs,page table entries)的数组。分页硬件通过使用VA中高39位中的27位作为页表的索引来查找PTE。</p></li><li><p><strong>PTE</strong>：每一个包含了44位的物理页编号(PPN，Physical page number)和10位的标志位。</p></li><li><p><strong>PA</strong>：56位的物理地址其中高44位是PTE中的PPN，低12位是复制虚拟地址中的偏移量。</p></li></ol><p>在RISC-V中，物理内存地址是56bit。所以<strong>物理内存可以大于单个虚拟内存地址空间</strong>，但是也最多到$2^{56}$。</p><p>物理地址不是64位主要是因为主板只需要56根线；还有一个原因是这剩余的8位作为一个<strong>字节(8位)</strong>，那么64位就可以组成内存为$2^{56}$长度的字节数组。但是一般情况下并没有这么大的内存，56位PA还是用不完的。</p><p><strong>地址翻译</strong>就是将VA中的27位index翻译位44位的page好，剩余的12位offset直接复制即可生成PA。</p><p>如下图，是通过页表找到相应页的过程</p><ol><li>MMU通过stap的<strong>物理地址</strong>，从内存中读取页表</li><li>用VA中的index找到对应的PTE</li><li>用PTE中的PPN与VA，翻译得到PA</li><li>PA中的PPN在内存中找到对应的页</li><li>PA中的offset找到页中的对应的字节</li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/read%20mem.png" alt="read mem.png"></p><h2 id="三级页表"><a href="#三级页表" class="headerlink" title="三级页表"></a>三级页表</h2><blockquote><p>单级页表<strong>缺陷</strong></p></blockquote><p>如果使用单级页表，那么每一个进程的页表目录占$2^{27}$大小的内存。在机器上运行多个进程的话内存很快就会被耗尽了,并且我们要查找一个字节也十分的慢(最差的情况在$2^{27}$次才能找到想要的字节)。</p><blockquote><p>多级页表<strong>组成</strong></p></blockquote><p>实际上，页表会是一个多级的页表(称为页目录，在risc-v中没有明显的区分page-table与page-directory)。在RISC-V中我们会将27位index分为3个9位的三级index（L2、L1、L0）,三级页表如下图所示。</p><p>每一个页目录大小也是一个页大小(内存以页为单位进行划分的)，那么一个页是4096字节，PTE是64位 = 8字节。那么一个页目录的$PTE=4096 / 8 = 512$，那么三级索引每一级index=9，那么$2^{9} = 512$也刚好能够作为一个页目录的索引。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3.2.png" alt="3.2.png"></p><blockquote><p>PTE结构(了解)</p></blockquote><ul><li>63 - 54位：预留位，主要是未来的扩展，比如新的RISCV处理器出现后页表也可能发生改变。</li><li>53 - 10位：PPN，物理页编号<br>低十位为标志位，5-10位并不重要。</li><li>4位：表示该页能否被用户空间进程访问</li><li>1-3位：分别表示是否可以对这个页读、写、执行命令。</li><li>0位：valid标志位，表示这个物理页是否存在，设置为1是存在的页。如果读取PTE该位设置为0则会触发缺页异常。</li></ul><blockquote><p>三级页表如何<strong>执行</strong></p></blockquote><ol><li>satp存储了根页表页L2(page-table page)的物理地址，将其加载入mmu。就可以获得下一级L1的PPN。</li><li>通过根目录的PPN找到中间级页目录，获得最后一级的PPN</li><li>在根据<strong>最后一级</strong>这个PPN+offset(VA中继承)就可以合成PA了。</li></ol><p>注意：如何获得下一级的页目录的地址的？并不是加上VA的offset而是，通过PPN + 12bit的0，这样就是获得了下一级的页目录的56位PA。因此也就要求页目录需要与物理页对齐(简单来说就是页目录的起始位置就是某个页的起始地址，也就不需要页索引)</p><p>由于三级页表是树这样的数据结构，那么我们可以统计一下每一级页表最多有多少页</p><ul><li>L2：1页：512PTE</li><li>L1：512页(上一级有512PTE) ： $512* 512PTE = 2^{18}PTE$。</li><li>L0：$2^{18}$页(上一级有$2^{18}$PTE) ：$2^{18} * 512 PTE =  2^{27}PTE$ </li></ul><p>三级页表相比于一级页表会多保存L2、L1页目录513页，内存看似是多了，但是实际上我们并不需要，让每一个页表页都存在。</p><blockquote><p>三级页表的<strong>优势</strong></p></blockquote><ol><li><strong>节省内存空间</strong>：如果进程中有大部分地址没有使用。那么在三级页表下需要多少个PTE来映射指定的一个页(只有这一个页)？</li></ol><p>根页目录下我们需要一个索引为0的PTE(1)，指向中间为页目录也需要一个索引为0的PTE(2)，最后指向最低的页目录(页表)。因此在这三步下我们只需要分配3个页($3*512$PTE)就可以了。如果是单级页表方案中，如果我们查找一个页表还是需要用$2^{27}$个PTE。所需要的空间页大大的减少了。</p><ol><li><p><strong>查找页的效率提高</strong>：在3级页表中查找到一个页最差的情况为$3*512$次，而在单级页表中查找一个页最差的情况则是$2^{27}$次。3级页表的方案查找效率也大大提升</p></li><li><p>能够提高内存的安全性，防止应用程序越界访问内存。</p><h2 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h2></li></ol><blockquote><p>TLB = Translation Lookaside Buffer</p></blockquote><p>在三级页表中，当从内存中加载或是存储数据时，基本上都是左三次内存查找。那么对于PA寻址，需要读取三次内存，代价也十分的高。但在实际中，每一个处理器都会对最近使用的VA<strong>翻译结果</strong>(PPN)都有<strong>缓存</strong>，这个缓存也被称作为TLB，通常保存PTE的缓存。</p><p>因此当CPU第一次翻译VA，通过三次查找页表可以获得最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。那么下一次访问同一个VA时，查看TLB就会直接通过映射得到PA。(应该保存的是<strong>VA的index</strong>与<strong>最终的PPN</strong>的映射)</p><h1 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h1><p>Xv6为每一个进程维护了一个页表，用于描述每个进程的用户地址空间，加上一个描述单独内核地址空间的页表。</p><p>如下图3.3，是xv6中内核地址空间的布局。<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3.3.png" alt="3.3.png"></p><blockquote><p>物理地址，图右</p></blockquote><p>RISC-V处理器中有4个核，每一个核都有自己的MMU和TLB。</p><ul><li><p>0 - 0x1000：保留的地址</p></li><li><p>0x1000：boot程序<strong>ROM</strong>(存在于BIOS中)起始的地址，当主板加电工作，boot程序中的代码就会跳转到0x800000000启动xv6。</p></li><li><p>0x02000000：CLINT（Core Local Interruptor）也是中断的一部分。</p></li><li><p>0x0C000000：PLIC中断控制器（Platform-Level Interrupt Controller）</p></li><li><p>0x10000000：UART0（Universal Asynchronous Receiver/Transmitter）负责与Console和显示器交互。</p></li><li><p>0x10001000：VIRTIO disk，与磁盘进行交互。</p></li><li><p>0x8000000 - $2^{56}-1$：是DRAM或内存的地址，0x80000000(KERNBASE)也就是内核进程的起始位置</p></li></ul><p>向IO地址执行读写指令，实际上是实现了IO设备的芯片执行读写，可以认作为直接于设备交互，而不是在读写物理内存。</p><blockquote><p>(内核)虚拟地址，图左</p></blockquote><p>Xv6中内核进程的VA与PA是直接映射的(大部分是相等的关系)，也就是VA=PA。</p><p>特别的，有两个类页<strong>不是直接映射</strong>的。</p><ul><li><p><strong>trampoline</strong>页：位于虚拟地址空间的顶部，内核与用户有相同的映射。这个物理页(包含进出内核的代码)映射了到内核虚拟地址空间两次，一次在虚拟地址空间的顶部，一次是直接映射。</p></li><li><p><strong>kernel stack</strong>页(pages)：每一个进程都有自己的<strong>内核栈</strong>，映射在虚拟地址的高地址中，其中有未映射的保护页(guard page)，这些保护页是无效页(PTE中User位清空)，如果内核栈页溢出，就会触发缺页异常(page fault)并且内核也会崩溃。如果没有保护页发生内核栈溢出将会重写内核内存，会导致错误的操作。</p></li></ul><p>保护页不会映射到物理内存，所以不会浪费物理内存，只是占据了虚拟地址空间的一段靠后的地址。</p><p>同时<strong>内核栈页</strong>被虚拟内存映射了两次，在靠后的地址映射了一次，在PHYSTOP下的data段映射了一次，实际上使用的是靠后的一部分，因为是有<strong>保护页的保护</strong>。</p><blockquote><p>页权限</p></blockquote><ol><li><p>Kernel text page标记位R-X，可以读取或在该地址执行指令，但是不能向该页写入数据。(该页用于存放代码，因此可以读与执行)</p></li><li><p>Kernel text page需要能够被写入，所以是<code>RW-</code>权限 。并且不能执行该地址段的指令，所以X标志位没有设置。(该页用于存储数据，能够读写)</p></li></ol><p>通过权限设置，我们可以就可以尽早的发现Bug，出现Page fault就可以处理这些错误了。</p><h1 id="代码：创建地址空间"><a href="#代码：创建地址空间" class="headerlink" title="代码：创建地址空间"></a>代码：创建地址空间</h1><h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><p>大部分操作地址空间和页表的xv6代码存在于vm.c中。重要的数据结构是指向RISC-V的顶层页表页的指针<code>pagetable_t</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure><blockquote><p>重要的函数</p></blockquote><ol><li><p><strong>walk</strong>，它可以找到虚拟地址指向的PTE。</p></li><li><p><strong>mappages</strong>，为新的的映射创建PTE ，参数分别为页表地址、虚拟地址、物理地址、标志位。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>copyout</strong>与<strong>copyin</strong>，由系统调用提供，复制数据到或从用(to and from)户虚拟地址空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span>;</span><br></pre></td></tr></table></figure><p>在更早的引导顺序中，main调用kvminit使用kvmmake创建内核页表。这个调用在xv6在RISC-V开启分页之前发生。根据内核需求，调用kvmmap去创建翻译。</p><p> proc_mapstack分配内核栈给每一个进程。在该函数中调用kvmmap通过KSTATK映射到虚拟地址生成，而且保存了无效页(保护页)。</p><blockquote><p><strong>walk</strong>函数</p></blockquote><p><strong>walk</strong>模拟了RISC-V分页硬件一样为虚拟地址查找PTE。wakl按照三级页表规则一级一级的去查找。如果PTE无效，也就是需要的页没有分配，如果<strong>alloc</strong>的参数设置了，那么walk分配一个新的页表并将该页表物理地址放入PTE。最后返回第三级页表PTE的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---vm.c</span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>main函数调用kvminithart创建内核页表。它将根页表页的地址写入satp寄存器，然后CPU使用内核页表翻译地址。</p><blockquote><p><strong>TLB</strong></p></blockquote><p>每个RISV-V CPU缓存PTE在TLB中，当xv6更换页表，TLB必须告诉CPU无效相应以缓存的TLB条目(如果不更换，在切换进程时，相同的VA就会篡改前一个进程的内存)。</p><p>RISC-V中有一个指令sfence.vma，它可以刷新当前CPU的TLB。xv6重载satp后在kvinithart中执行sfence.vam，并且在trampoline代码中<strong>返回到用户空间之前</strong>，切换到用户页表。</p><h1 id="物理内存分配"><a href="#物理内存分配" class="headerlink" title="物理内存分配"></a>物理内存分配</h1><p>内核必须在<strong>运行期</strong>(run-time)为页表、用户内存、内核栈、管道缓存，分配和释放物理内存。</p><p>Xv6在运行期能够分配的物理内存在内核结束和PHYSTOP之间。它分配和释放是以4096字节一页为单位。内核使用一个(数据域为空)链表freelist(kernel/kalloc.c)跟踪空闲物理内存，在syscall实验中我们也使用过这个链表统计空闲内存。</p><h1 id="用户地址空间"><a href="#用户地址空间" class="headerlink" title="用户地址空间"></a>用户地址空间</h1><p>每个进程都有自己<strong>单独的</strong>页表，当xv6切换进程，它将会<strong>切换页</strong>表。图3.4展示了比图2.3更加详细的用户进程空间分配。</p><ol><li><p>用户进程的地址空间都是从0增长到MAXVA，规则上一个进程能够达到256GB但是xv6的物理内存只有<strong>128MB</strong>，<code>#define PHYSTOP (KERNBASE + 128*1024*1024)</code>。</p></li><li><p>进程地址空间由页(pages)组成，包含了程序的文本段(text)、初始化数据段(data)、栈页(one page)、堆页(pages)。并且这些页的全是都是RWU。</p></li><li><p>栈是一个单独页，显示的是exec创建的初始内容。包含了命令行参数的字符串，由一个数组指针指向它们位于栈顶端，在他下面是允许程序在main启动的值。</p></li><li><p>为检查用户分配栈内存是否溢出，xv6放置一个保护页(PTE_U被清空)在栈页正下方。如果栈溢出进程会尝试使用栈下方的地址，那么硬件会生成缺页异常。</p></li><li><p>xv6使用kalloc分配物理页，然后添加PTE到进程页表，PTE指向新的物理页。Xv6设置PTE的flag标志位。大部分进程不会使用整个用户地址空间，xv6也会</p></li></ol><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3.4.png" alt="3.4.png"></p><blockquote><p>页表优点</p></blockquote><ol><li><p><strong>隔离性</strong>：不同的进程的页表翻译<strong>相同</strong>用户地址到不同的物理内存页，因此每个进程有自己<strong>私有的地址空间</strong></p></li><li><p><strong>进程地址连续性</strong>：每个进程看见自己的内存都是一段<strong>连续的</strong>从0开始的虚拟地址，但进程的物理内存并不一定是连续的。</p></li><li><p><strong>可复用</strong>：内核映射trampoline页的代码在用户地址空间的顶部(PTE_U = 0，用户不能对该页进行操作)，因此单一的页可以通过物理内存加载到所有进程的地址空间中。 </p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章主要是讲解了内存、地址之间的概念。</p><ul><li>虚拟地址翻译</li><li>页、页表、三级页表</li><li>TLB</li><li>内核、用户的地址空间</li></ul><p>需要掌握的也就是地址翻译以及三级页表的翻译方法。如果要完成实验的话也是需要熟悉内核地址空间的布局以及相应的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit6.S081:lab utilities</title>
      <link href="/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab1%EF%BC%9Autilities/"/>
      <url>/2023/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab/Lab1%EF%BC%9Autilities/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>如何退出xv6(qemu)</strong>：先一起按下ctrl+a,然后再点击一下x即可</p></blockquote><h1 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc ,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;sleep:lack of arguement should input 2 you;but argc = %d&quot;</span>,argc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = (<span class="type">int</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sleep(num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pingpong"><a href="#Pingpong" class="headerlink" title="Pingpong"></a>Pingpong</h1><p>总体上没用什么难点，特别的就是需要创建两个管道，用于两个进程读写，避免自我阻塞问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;pingpong: too many arg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(p1)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipe(p2)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        read(p1[<span class="number">0</span>],<span class="string">&quot;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        write(p2[<span class="number">1</span>],<span class="string">&quot;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        write(p1[<span class="number">1</span>],<span class="string">&quot;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        read(p2[<span class="number">0</span>],<span class="string">&quot;&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Primes：素数筛-sieve"><a href="#Primes：素数筛-sieve" class="headerlink" title="Primes：素数筛(sieve)"></a>Primes：素数筛(sieve)</h1><blockquote><p>使用pipe编写一个并发版本的素数过滤，可以参考<a href="https://swtch.com/~rsc/thread/">pipeline</a></p></blockquote><p>我们需要创建多个进程，分别过滤掉2、3、5、7、…的倍数。在本次实验中我们主要是采用pipe与fork两个系统调用来进行实现pipeline的效果。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br></pre></td></tr></table></figure><p>如下图所示，当pipe1接收到数据后进行除2，并将没有过滤掉的数据(3,5,7,9..)继续发往下一个进程，以此类推。<br><img src="https://swtch.com/~rsc/thread/sieve.gif" alt=""></p><p>如果你单纯的项通过测试，可以直接printf(bushi),作为一个有专研精神的程序员，当前是要继续挑战</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;prime: too many arg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> ; i &lt;= <span class="number">35</span> ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>;j &lt; i/<span class="number">2</span>+<span class="number">1</span> ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == i/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先需要考虑创建多少个筛子，也就是进程。<code>[2,35]</code>之间有多少个素数也就是我们要创建的进程数—(11个)。</p></li><li><p>创建管道数，做完pingpong程序后我们知道了，当两进程需要来回传递时我们要创建2个管道避免阻塞，为了使子进程能够和自己的子进程传递数据那么就需要一个新的管道。</p></li><li><p>特别的，没有过滤掉的第一个数肯定是素数，例如2倍数的筛子(将2的倍数筛掉)-&gt;3倍数的筛子(将3的倍数筛掉)，我们收到的第一个数就是三我们也就是可以直接打印。</p></li></ol><blockquote><p><strong>NOTE:</strong> 当发送端的写入管道关闭时，接收端read返回值为0。在管道篇讲解到当缓冲区没有数据时会读取管道会出现阻塞，因此当write将数字发送完后，接收方读取完buffer数据，发送端就会关闭输出管道，接收方read<strong>返回值就为0</strong>。</p></blockquote><ol><li>以<strong>递归的方式</strong>实现，当递归调用最后一个primes函数时，此时读取p管道发现其关闭则结束递归调用，调用exit(0);</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> *p)</span>&#123;<span class="comment">//for parent</span></span><br><span class="line"></span><br><span class="line">    close(p[<span class="number">1</span>]);<span class="comment">//关闭该进程的写</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prime,tmp;</span><br><span class="line">    <span class="keyword">if</span>(read(p[<span class="number">0</span>],&amp;prime,<span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">0</span>)&#123;<span class="comment">//当没有输入时</span></span><br><span class="line">                                        <span class="comment">//让最后一个进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];<span class="comment">//for next child process</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(p1)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;pipe: err&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span> )&#123;</span><br><span class="line">        primes(p1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//parent</span></span><br><span class="line">       close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(read(p[<span class="number">0</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>)&#123;<span class="comment">//read from parent</span></span><br><span class="line">            <span class="keyword">if</span>((tmp%prime) != <span class="number">0</span>)&#123;</span><br><span class="line">                write(p1[<span class="number">1</span>],&amp;tmp,<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//write to child</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>);<span class="comment">//发送端等待接收端退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;primes: too many args&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;pipe: err&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        primes(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//write value to 2 times process</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span> ; i &lt;= <span class="number">35</span> ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(write(p[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="keyword">sizeof</span>(<span class="type">int</span>))&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;primes:err write&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><blockquote><p>通过编写find.c文件实现在unix下的<strong>find命令</strong>实现</p><ol><li>find 目录 -&gt; 打印目录下的所有文件</li><li>find 文件 -&gt; 打印当前目录下的文件路径</li></ol></blockquote><ol><li><p>首先我们需要观看ls.c文件查看如何读入目录文件的内容；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_DIR:</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line"> p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line"> *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"> <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">   <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   memmove(p, de.name, DIRSIZ);</span><br><span class="line">   p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>, fmtname(buf), st.type, st.ino, st.size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当文件类型为T_DIR时，拷贝path字符串。通过dirent结构体进行读取当前目录下的内容(可能含有数据文件、设备、目录)，de.name就是文件名(含有当前文件路径<code>./</code>)。</p></li><li><p>通过fmtname()函数对文件的路径名进行格式化。如我们输入/a/b/c路径字符串，我们返回的字符串将为c。在后续的修改中需要将memset的初始化字符修改为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash.</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line"> ;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return blank-padded name.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line">memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ls中代码如下所示</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line"><span class="keyword">case</span> T_DEVICE:</span><br><span class="line"><span class="keyword">case</span> T_FILE:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);<span class="comment">//递归输入的参数是数据文件路径则终止递归</span></span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> T_DIR:</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);<span class="comment">//打印目录名，不需要fmt</span></span><br><span class="line">  p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    memmove(p, de.name, DIRSIZ);</span><br><span class="line">    p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* tmpname = fmtname(buf);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tmpname,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span>||</span><br><span class="line">      <span class="built_in">strcmp</span>(tmpname,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    find(buf);<span class="comment">//子目录或是数据文件都开启递归</span></span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> 字符串比较不能使用<code>==</code>比较符号，需要使用字符串函数stmcpy。而且需要修改ls.c中的fmtname函数，将<code>memset(buf+strlen(p), &#39; &#39;, DIRSIZ-strlen(p))</code>中的空格修改为<code>0</code>或<code>&#39;\0&#39;</code></p></blockquote><h1 id="xarg"><a href="#xarg" class="headerlink" title="xarg"></a>xarg</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span>** dsn,<span class="type">char</span>* src)</span>&#123;</span><br><span class="line">    *dsn = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*dsn,src);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;xargs:err&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span>* vcmd[MAXARG]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc&amp;&amp;i&lt;MAXARG;i++)</span><br><span class="line">        copy(&amp;vcmd[i<span class="number">-1</span>],argv[i]);</span><br><span class="line"></span><br><span class="line">    i--;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p = <span class="built_in">strchr</span>(buf,<span class="string">&#x27;\n&#x27;</span>)))</span><br><span class="line">            *(p--) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(buf)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        copy(&amp;vcmd[i],buf);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* execarg[<span class="number">3</span>];</span><br><span class="line">    copy(&amp;execarg[<span class="number">0</span>],vcmd[<span class="number">0</span>]);</span><br><span class="line">    copy(&amp;execarg[<span class="number">1</span>],vcmd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++)&#123;    </span><br><span class="line">        <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">            copy(&amp;execarg[<span class="number">2</span>],vcmd[j]);</span><br><span class="line">            <span class="comment">// printf(&quot;%s\n&quot;,execarg[2]);</span></span><br><span class="line">            exec(execarg[<span class="number">0</span>],execarg);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exec file wrong\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugin Plus</title>
      <link href="/2023/01/27/C++/Tag%20Plugins%20Plus/"/>
      <url>/2023/01/27/C++/Tag%20Plugins%20Plus/</url>
      
        <content type="html"><![CDATA[<h1 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h1><ol><li>安装插件,在博客根目录[Blogroot]下打开终端，运行以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure><p>考虑到hexo自带的markdown渲染插件hexo-renderer-marked与外挂标签语法的兼容性较差，建议您将其替换成hexo-renderer-kramed</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol><li>添加配置信息，以下为写法示例</li></ol><p>在站点配置文件_config.yml或者主题配置文件_config.butterfly.yml中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag-plugins-plus</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/615e2dec/</span></span><br><span class="line"><span class="attr">tag_plugins:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="literal">false</span> <span class="comment">#issues标签依赖注入开关</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">/img/link.png</span> <span class="comment">#link_card标签默认的图标图片</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line">    <span class="attr">anima:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css</span> <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">    <span class="attr">jquery:</span> <span class="string">https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">issues:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">iconfont:</span> <span class="string">//at.alicdn.com/t/font_2032782_8d5kxvn09md.js</span> <span class="comment">#参看https://akilar.top/posts/d2ebecef/</span></span><br><span class="line">    <span class="attr">carousel:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js</span></span><br><span class="line">    <span class="attr">tag_plugins_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css</span></span><br></pre></td></tr></table></figure><ol><li>参数释义</li></ol><div class="table-container"><table><thead><tr><th>参数</th><th>备选值/类型</th><th>释义</th></tr></thead><tbody><tr><td>enable</td><td>true/false</td><td>【必选】控制开关</td></tr><tr><td>priority</td><td>number</td><td>【可选】过滤器优先级，数值越小，执行越早，默认为10，选填</td></tr><tr><td>issues</td><td>true/false</td><td>【可选】issues标签控制开关，默认为false</td></tr><tr><td>link.placeholder</td><td>【必选】link卡片外挂标签的默认图标</td><td></td></tr><tr><td>CDN.anima    URL</td><td>URL</td><td>【可选】issues标签依赖</td></tr><tr><td>CDN.iconfont    URL</td><td>URL</td><td>【可选】iconfont标签symbol样式引入，如果不想引入，则设为false</td></tr><tr><td>CDN.carousel</td><td>URL</td><td>【可选】carousel旋转相册标签鼠标拖动依赖，如果不想引入则设为false</td></tr><tr><td>CDN.tag_plugins_css</td><td>URL</td><td>【可选】外挂标签样式的CSS依赖，为避免CDN缓存延迟，建议将@latest改为具体版本号</td></tr></tbody></table></div><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="分栏tab"><a href="#分栏tab" class="headerlink" title="分栏tab"></a>分栏tab</h2><div class="tabs" id="分栏tab"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#分栏tab-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏tab-2">配置参数</button></li><li class="tab active"><button type="button" data-href="#分栏tab-3">样例展示</button></li><li class="tab"><button type="button" data-href="#分栏tab-4">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="分栏tab-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏tab-2"><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子/页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="分栏tab-3"><blockquote><p>Demo 1 - 预设选择第一个【默认】</p></blockquote><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 2 - 预设选择tabs</p></blockquote><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 3 - 没有预设值</p></blockquote><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p></blockquote><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏tab-4"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="链接卡片link"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#链接卡片link-1">标签语法</button></li><li class="tab active"><button type="button" data-href="#链接卡片link-2">样式预览</button></li><li class="tab"><button type="button" data-href="#链接卡片link-3">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="链接卡片link-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="链接卡片link-2"><div class="tag link"><a class="link-card" title="TagPlugin教程" href="链接"><div class="left"><img src="/img/favicon.ico"/></div><div class="right"><p class="text">TagPlugin教程</p><p class="url">链接</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="链接卡片link-3"><div class="tag link"><a class="link-card" title="TagPlugin教程" href="链接"><div class="left"><img src="/img/favicon.ico"/></div><div class="right"><p class="text">TagPlugin教程</p><p class="url">链接</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="引用文献"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#引用文献-1">标签语法</button></li><li class="tab"><button type="button" data-href="#引用文献-2">参数配置</button></li><li class="tab active"><button type="button" data-href="#引用文献-3">样式预览</button></li><li class="tab"><button type="button" data-href="#引用文献-4">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="引用文献-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="引用文献-2"><p>referto 引用上标<br>id: 上标序号内容，需与referfrom标签的id对应才能实现跳转<br>literature: 引用的参考文献名称</p><p>referfrom 引用出处<br>id: 序号内容，需与referto标签的id对应才能实现跳转<br>literature: 引用的参考文献名称<br>url: 引用的参考文献链接，可省略</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="引用文献-3"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;，Butterfly主题<span class="hidden-anchor" id="referto_[3]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[7]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[8]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;<span class="hidden-anchor" id="referto_[9]">&lt;/span&gt;<sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span>&lt;/span&gt;&lt;/span&gt;</p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="引用文献-4"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 魔改日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> 魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可调用对象</title>
      <link href="/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/01/20/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="std-function-and-bind"><a href="#std-function-and-bind" class="headerlink" title="std::function and bind"></a>std::function and bind</h1><h2 id="可调用对象-Callable-Object"><a href="#可调用对象-Callable-Object" class="headerlink" title="可调用对象(Callable Object)"></a>可调用对象(Callable Object)</h2><ol><li><p>函数指针</p></li><li><p>具有operator()成员函数的类对象(仿函数)</p></li><li><p>可被转换为函数指针的类对象</p></li><li><p>类成员函数指针</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;函数指针&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;仿函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">fr_t</span> = <span class="built_in">void</span>(*)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;指向函数的类对象&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">fr_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;成员函数&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">void</span>) = func;</span><br><span class="line">    <span class="built_in">func_ptr</span>();</span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (A::*mem_func_ptr)(<span class="type">void</span>) = A::mem_func;</span><br><span class="line">    <span class="type">int</span> A::*mem_obj_ptr = &amp;A::a;</span><br><span class="line"></span><br><span class="line">    A aa;</span><br><span class="line"></span><br><span class="line">    (aa.*mem_func_ptr)();</span><br><span class="line"></span><br><span class="line">    aa.*mem_obj_ptr = <span class="number">123</span>;</span><br><span class="line">    std::cout&lt;&lt;aa.a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可调用对象的包装器-std-function"><a href="#可调用对象的包装器-std-function" class="headerlink" title="可调用对象的包装器-std::function"></a>可调用对象的包装器-std::function</h2><blockquote><p>简介</p></blockquote><p>它是一个类模板，可以容纳类成员(函数)指针(<strong>需要用bind该函数将实际对象绑定</strong>)之外的所有可调用对象。通过指定他的模板参数，它可以统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们</p><blockquote><p>弹性更强</p></blockquote><ul><li>对于函数对象的返回值可以进行适当隐式转换(short and float -&gt; int)(兼容性)</li><li>对于函数对象的参数可以被隐式转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> f_int = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">foo_func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;    </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">f_int</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo_func;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mem_func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f</span><span class="params">()</span></span>&#123;</span><br><span class="line">       std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr1 = func;</span><br><span class="line">    <span class="built_in">fr1</span>();</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr2 = Foo::foo_func;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr2</span>(<span class="number">2</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//隐式转换类型</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr3 = <span class="built_in">Foo</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr3</span>(<span class="number">3</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fr4 = <span class="built_in">Bar</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">fr4</span>(<span class="number">4</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind和function联合</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----bind and function---&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> bf1 = std::<span class="built_in">bind</span>(&amp;A::mem_func,&amp;a);<span class="comment">//第二个引用可有可无</span></span><br><span class="line">    <span class="keyword">auto</span> bp1 = std::<span class="built_in">bind</span>(&amp;A::a,a);<span class="comment">//第二个取引用只是指向该类的对象</span></span><br><span class="line">    <span class="built_in">bp1</span>() = <span class="number">123</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">bp1</span>()&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;a.a&lt;&lt;std::endl;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fr5 = bf1;</span><br><span class="line">    <span class="built_in">fr5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test_f</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">call_when_even</span>(i,output);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind用来将可调用对象与其参数一起进行绑定，绑定后的结构可以使用std::function进行保存，并延迟调用到任何我们需要的时候</p><blockquote><p>作用</p></blockquote><ol><li><p>将可调用对象与其参数一起帮定成一个仿函数</p></li><li><p>将多元参数可调用对象转成一元或者(n-1)元金额调用对象，及只绑定部分参数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FuncEntity</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">eFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FuncEntity e;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">bind</span>(&amp;FuncEntity::eFunc,e,std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">a</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//function入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_when_even</span><span class="params">(<span class="type">int</span> x,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add_2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;x+<span class="number">2</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fr = std::<span class="built_in">bind</span>(output_add_2,std::placeholders::_1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">call_when_even</span>(i,fr);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>        <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::bind</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();                           <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);      <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_1)(<span class="number">1</span>);      <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="comment">// error: 调用时没有第二个参数</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>);</span><br><span class="line">   std::<span class="built_in">bind</span>(output, <span class="number">2</span>, std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 输出: 2 2</span></span><br><span class="line">   <span class="comment">// 调用时的第一个参数被吞掉了</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_1,std::placeholders::_2)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 1 2</span></span><br><span class="line">   std::<span class="built_in">bind</span>(output, std::placeholders::_2,std::placeholders::_1)(<span class="number">1</span>, <span class="number">2</span>);                        <span class="comment">// 输出: 2 1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind简化和增强bind1st和bind2nd"><a href="#bind简化和增强bind1st和bind2nd" class="headerlink" title="bind简化和增强bind1st和bind2nd"></a>bind简化和增强bind1st和bind2nd</h3><p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道，bind1st和bind2nd的作用是将一个二元算子转换成一个一元算子，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><hr><p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，并且还要想想到底是用bind1st还是bind2nd，用起来十分不便。</p><p>现在我们有了bind，就可以以统一的方式去实现了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素值大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素的个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind1st</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 查找元素之小于</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">std::<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>这样就不用关心到底是用bind1st还是bind2nd，只需要使用bind即可。</p><p>2.使用组合bind函数</p><p>bind还有一个强大之处就是可以组合多个函数。假设要找出集合中大于5小于10的元素个数应该怎么做呢？</p><p>首先，需要一个用来判断是否大于5的功能闭包，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这里std：：bind返回的仿函数只有一个int参数。当输入了这个int参数后，输入的int值将直接和5进行大小比较，并在大于5时返回true。</p><p>然后，我们需要一个判断是否小于10的功能闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), std::placeholders::_1, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>有了这两个闭包之后，只需要用逻辑与把它们连起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>然后就可以复合多个函数（或者说闭包）的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// 查找集合中大于</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>小于</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的元素个数</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>),</span><br><span class="line">std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">10</span>));</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), f);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FaRM</title>
      <link href="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/FaRM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="FaRM高性能分布式事务"><a href="#FaRM高性能分布式事务" class="headerlink" title="FaRM高性能分布式事务"></a>FaRM高性能分布式事务</h1><blockquote><p><strong>Title:</strong> No compromises: distributed transactions with consistency, availability, and performance</p></blockquote><h2 id="FaRM-Overview"><a href="#FaRM-Overview" class="headerlink" title="FaRM Overview"></a>FaRM Overview</h2><blockquote><p><strong>FaRM</strong> = Fast + Remote + Memory</p></blockquote><h3 id="为何要学习FaRM"><a href="#为何要学习FaRM" class="headerlink" title="为何要学习FaRM"></a>为何要学习FaRM</h3><ul><li><p>另一种对transactions+replication+sharding的实现：这仍然在研究领域，没有投入实际生产。</p></li><li><p>乐观并发控制OOC(stric serializability)</p></li><li><p>利用了了RDAM NICs的巨大性能潜力。</p></li></ul><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><ul><li><p>FaRM全部通讯都在一个数据中心</p><ul><li>与Spanner不同的是，Spanner全球性的广域的设计</li></ul></li><li><p>configuration manager：使用ZooKeeper, 选择主从复制 primaries/backups</p></li><li><p>Shards采用主从复制(只有在恢复的时候会进行通信)<br>  P1 B1<br>  P2 B2<br>  …</p><ul><li>只要至少有一个shard的副本就能恢复</li><li>f+1的副本就容忍f次的故障</li></ul></li><li><p>事务代码充当两阶段提交的事务协调器(TC)</p></li></ul><h3 id="FaRM目标"><a href="#FaRM目标" class="headerlink" title="FaRM目标"></a>FaRM目标</h3><ul><li>每秒完成百万数量级的事务<ul><li>时间的预算是几十微妙</li></ul></li></ul><h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><h3 id="如何高性能"><a href="#如何高性能" class="headerlink" title="如何高性能"></a>如何高性能</h3><ul><li><p>在多个服务器上进行分片(在评估中是90个)</p></li><li><p>数据必须符合总RAM(因此没有磁盘读取)</p></li><li><p>降低CPU的利用率 </p><ul><li>非易失性RAM(因此没有磁盘写入)</li><li>one-sided RDMA(快速跨网络访问内存)</li></ul></li><li><p>快速用户级访问网卡</p></li><li><p>事务+复制协议，利用单边RDMA</p></li></ul><h3 id="NVRAM-non-volatile-RAM"><a href="#NVRAM-non-volatile-RAM" class="headerlink" title="NVRAM (non-volatile RAM)"></a>NVRAM (non-volatile RAM)</h3><p>FaRM 直接写入RAM不需要写入磁盘 — eliminates a huge bottleneck</p><ul><li>RAM write takes 200 ns, hard drive write takes 10 ms, SSD write 100 us<ul><li>ns = nanosecond, ms = millisecond, us = microsecond<br>但是当我们在电源故障后将会使RAM的内容丢失，RAM不能持久化。因此我们使用了UPS。</li></ul></li></ul><h4 id="UPS-distributed-uninterruptible-power-supply"><a href="#UPS-distributed-uninterruptible-power-supply" class="headerlink" title="UPS(distributed uninterruptible power supply)"></a>UPS(distributed uninterruptible power supply)</h4><p>装备电池在每个机架上，当服务器发生断电时，可以再让运行机器几分钟。具体执行过程如下</p><ul><li><p>电源硬件通知软件当主电源断电，软件停止所有事务，软件将FaRM的RAM的数据写入到SSD，可能几分钟后机器就会关机。</p></li><li><p>在重新启动时，FaRM从SSD读取保存的内存映像“非易失性RAM”</p></li></ul><h4 id="如果奔溃阻止了软件写入SSD"><a href="#如果奔溃阻止了软件写入SSD" class="headerlink" title="如果奔溃阻止了软件写入SSD?"></a>如果奔溃阻止了软件写入SSD?</h4><p>例如FaRM或内核中的bug或者cpu/内存/硬件错误，FaRM处理单机崩溃和复制崩溃(除了电源故障)必须是独立的!因此崩溃不会阻止FaRm写入将RAM的数据写入SSD</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>NVRAM消除了持久写入瓶颈，剩下的瓶颈是网络和CPU</p><h3 id="降低CPU使用率-Reduce-CPU-Utilization"><a href="#降低CPU使用率-Reduce-CPU-Utilization" class="headerlink" title="降低CPU使用率(Reduce CPU Utilization)"></a>降低CPU使用率(Reduce CPU Utilization)</h3><h4 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h4><p>为什么网络在通常情况下会是性能瓶颈？</p><ul><li>FaRM假设只有一个数据中心，因此具有较低的光速延迟</li><li>但网络数据处理的CPU成本往往很大</li></ul><p>网络交互：<br>从应用中将数据写入socket的缓存中通过TCP封装，传递给网卡的硬件驱动，通过网卡进行发送。如下述例子所述<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app                       app</span><br><span class="line">---                       ---</span><br><span class="line">socket buffers            buffers</span><br><span class="line">TCP                       TCP</span><br><span class="line">NIC driver                driver</span><br><span class="line">NIC  -------------------- NIC</span><br></pre></td></tr></table></figure><br>大量昂贵的CPU操作如系统调用、复制信息、中断、上下文转换。这些都会成为FaRM的性能瓶颈</p><h4 id="Kernel-bypass"><a href="#Kernel-bypass" class="headerlink" title="Kernel bypass"></a>Kernel bypass</h4><blockquote><p>NIC直接访问内存</p></blockquote><p>FaRM应用直接与网卡交互，<strong>没有系统调用与内核参与</strong> </p><ul><li><p>网卡使用DMA访问用户的RAM</p></li><li><p>FaRM轮询DMA(内存)区域检查收入的消息</p><ul><li>NIC会维持一个接收消息的队列 </li></ul></li><li><p>网卡轮询DMA(内存)区域检查发送的消息</p><ul><li>NIC会维持一个发送消息的队列</li></ul></li><li><p>轮询是一个线程，用于代替系统中断，直接访问消息队列</p></li></ul><h4 id="one-sided-RDMA"><a href="#one-sided-RDMA" class="headerlink" title="one-sided RDMA"></a>one-sided RDMA</h4><blockquote><p>remote NIC directly reads/writes memory：宏观来讲就是直接访问另一台机器的内存且接收方CPU不参与操作</p></blockquote><p><strong>RDMA</strong>：是一些现代网卡实现的特殊功能。网卡寻找通过网络到达的特殊命令包，并自行执行命令(<strong>而不将包交给CPU</strong>)。这些命令指定内存操作，例如将值写入地址或从地址读取并通过网络将值发回。</p><p>此外，RDMA网卡允许应用程序代码直接与NIC通信以发送特殊的RDMA命令包，并在“<strong>硬件ACK</strong>”包到达时收到通知，表明接收网卡已经执行了命令。</p><ul><li><p>“One-sided” “指的是一台计算机中的应用程序代码使用这些RDMA网卡直接读取或写入另一台计算机中的内存，而<strong>不涉及另一台计算机的CPU</strong>。</p></li><li><p>FaRM有时使用RDMA作为一种快速方法来实现类似rpc的方案，以便与接收计算机上运行的软件进行通信。</p></li><li><p>RDMA的好处是速度快。单向RDMA读写只需1/18微秒，而传统RPC可能需要10微秒。即使FaRM使用RDMA进行消息传递也比传统RPC快得多:接收器中的用户空间代码经常<strong>轮询传入的NIC队列</strong>，以便快速查看新消息，而不是涉及中断和用户/内核转换。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM4.PNG" alt=""><br>该图表示了FaRM应用通过Kernel bypass + RDMA降低了CPU的利用率。NIC是一个特殊的网卡同时支持kernel bypass与RDMA。</p><ul><li><p>通过Kernel bypass发送消息将直接发送包到NIC不需要CPU参与</p></li><li><p>通过one-sided RDMA，接收方的接收处理包也不需要CPU的参与</p></li><li><p><strong>RDMA Read：</strong> “Validate”阶段仅使用one-sided读取。</p><ul><li>将请求对象的包(头部设置为RDMA包)，加入NIC的发送队列，传送到目的主机的接收队列，进行定时轮询内存区域，FaRM应用将对象的数据再通过NIC回复给请求主机</li></ul></li><li><p><strong>RDMA Write：</strong> “Lock”阶段以这种方式使用RDMA。(不需要加入NIC队列)</p><ul><li>发送方使用RDMA将请求消息写入接收方FaRM软件轮询(定期检查)的内存区域，将请求消息放入消息队列进行处理、Record写入Log，接收方以同样的方式发送应答。 </li></ul></li></ul><h2 id="编程模型与架构"><a href="#编程模型与架构" class="headerlink" title="编程模型与架构"></a>编程模型与架构</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM5.PNG" alt=""></p><h4 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h4><ul><li><p><strong>Region：</strong> 可以看作一个2GB的字节数组，其中包含了多个Object。同时Region也对应着(Pi,Bi)的映射</p></li><li><p><strong>Object：</strong> 一个数据结构，用于存储数据。object有唯一的一个标识符为oid，oid对应了Region号与地址，并且object的头部包含了一个64为的整数，高1位表示的是否Lock，低63位标识版本号</p></li><li><p><strong>Zookeeper：</strong> 作为FaRM的服务协调，提供一个Coordinator Management</p></li><li><p><strong>SSD：</strong> 断电时存储RAM内的数据</p></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Txn BEGIN</span><br><span class="line"></span><br><span class="line">O &lt;------ Read(oid)</span><br><span class="line"></span><br><span class="line">O.f + 1 = 1</span><br><span class="line"></span><br><span class="line">write(oid,O)</span><br><span class="line"></span><br><span class="line">Txn COMMIT</span><br></pre></td></tr></table></figure><p>该例子中我们使用了两个API为read与write。我们通过调用read方法填入oid(object id)从而实现了获得数据对象O，在O的字段上+1并缓存到本地，之后再调用write方法将对象写入。(一个事务可能跨多个Region)</p><h2 id="分布式事务与复制"><a href="#分布式事务与复制" class="headerlink" title="分布式事务与复制"></a>分布式事务与复制</h2><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/FaRM1.png" alt=""></p><p>图中虚线为处理读取，实线是写入，点线是硬件回复。其中P1、P2是处理读写事务，P3是只读事务。C为Zookeeper中的Coordinator[[ZooKeeper 论文笔记]]、P为Primary、B为Backup。黑色的方块为对象(副本中只有一个Backup，因此该副本只有一个容错)</p><ul><li><p>Coordiantor获取LOCK消息最后一条Ack消息的点为序列化点</p></li><li><p>Coordiantor获取VALIDATE消息的最后一条ACK消息的点为Decision点，<strong>事务开始提交</strong></p></li><li><p>Coordiantor获取COMMIT-PRIMARY的第一条ACK消息为开始提交的报告给应用，<strong>事务提交结束</strong></p></li></ul><h3 id="执行阶段-Execute-phase"><a href="#执行阶段-Execute-phase" class="headerlink" title="执行阶段(Execute phase)"></a>执行阶段(Execute phase)</h3><p>Coordinator进行操作</p><ul><li><p>one-sided RDMA对Primary进行读取(OCC)</p></li><li><p>将修改对象的内容缓存到本地</p></li><li><p>记录这些primary的<strong>地址</strong>以及读取并记录到的数据的<strong>版本号</strong>。</p><ul><li>如果Primary与backup与coordinator位于同一台机器上就不会使用RDMA进行读，而是使用本地内存进行访问(读取操作)</li></ul></li></ul><p>在Figure4中该阶段读取了三个分片，为S1，S2，S3</p><h3 id="提交阶段-Commit-phase"><a href="#提交阶段-Commit-phase" class="headerlink" title="提交阶段(Commit phase)"></a>提交阶段(Commit phase)</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li><p>原子性的分布式提交：全部写入或都没写入</p></li><li><p>序列化：每个事务都有先后顺序</p></li></ul><h4 id="五个步骤"><a href="#五个步骤" class="headerlink" title="五个步骤"></a>五个步骤</h4><ol><li><strong>Lock(写入日志).</strong> Coordinator通过<strong>RDMA Write</strong>发送一条Lock消息给每台读取对象的primary的日志中</li></ol><ul><li><p>Lock记录包含了这包含了oid、版本号和写对象的新值</p></li><li><p>Lock消息既是预读日志条目(Read-ahead log)，也是对主服务器的RPC请求。</p></li><li><p>日志将被加入到NVRAM中防止断电或者电源故障</p></li></ul><p><strong>收到LOCK后primary会做什么</strong>?</p><ul><li><p>FaRM软件轮询内存中的日志, 发现写入的日志</p><ul><li>检查日志，如果对象已经加锁了或者写入的对象的版本号与读取的不相同<ul><li>发送一个no的回复给coordinator</li></ul></li></ul></li><li><p>反之，将对象的Lock flag设置为1，回复一个yes给coordinator</p><ul><li><strong>并不会修改对象</strong>，也不会修改对象的版本号</li></ul></li><li><p>lock检查-&gt;版本号检查-&gt;lock的设置是原子性</p><ol><li>使用原子性的compare-and-swap指令将对象锁定在指定版本</li><li>防止其他CPU也在处理LOCK，或者客户端正在用RDMA读取</li></ol></li></ul><ol><li><strong>Validate(检查读取对象).</strong> Coordinator使用one-sided RDMA发送Validate消息给读取对象的primary，该消息只包含了oid以及版本号，执行读取验证(read Validate)。</li></ol><p><strong>Priamry处理</strong></p><p>检查Validate的版本号与primary内存中的版本号以及对象是否上锁</p><ul><li><p>如果冲突，则验证失败，发送no给coordinator，事务将会终止。</p></li><li><p>如果相同，则验证相同，发送yes给coordinator。</p></li><li><p>Validate默认使用的是one-side RDMA。</p></li></ul><ol><li><p><strong>Commit backups.(副本写入日志)</strong> Coordiantor写入一个COMMIT-BACKUP的记录(与Lock内容相同)到Backups的不易失的日志中，并等待不会让CPU中断的NIC硬件返送ACK消息。</p></li><li><p><strong>Commit primaries(处理日志).</strong> coordinator在接受到所有COMMIT-BACKUP的ACK消息后，Coordinator发送COMMIT-PRIMARY消息给每一台Primary中。</p></li></ol><ul><li>coordinator会等待硬件的ACK应答<ul><li>不会等待Primary处理日志</li><li>硬件应答意味着Primary的NVRAM很安全</li></ul></li></ul><p><strong>Primary处理日志</strong></p><ul><li><p>将新值拷贝到对象的内存中</p></li><li><p><strong>增加对象的版本号</strong></p></li><li><p>清除对象的lock flag，设置为0</p></li></ul><hr><ol><li><strong>Truncate.</strong> Primary与Backup中的日志会一直保存直到被截断。Coordinator接收到所有Primary的ACK后，将会阶段Primay与Backup的日志</li></ol><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><p>Q：为什么发现锁已经被其他锁占用后是中止而不是等待解除阻塞</p><p>A：Figure4中是读写事务，发现锁被其他事务占用说明我们读操作读取的数据的就已经被修改了，因此会破坏Strict Serializability，产生错误。</p><p>Q：Primary与Backup是主从复制，那为什么他们不直接通讯？</p><p>A：应用的设计是这样的，他们的一致性是由CM来保证(Lock与commit Backup消息内容相同)。只有在崩溃恢复时Primary与Backup会进行沟通。</p><p>Q：下述案例中，T2在T1完成Lock与Validate后，在T1提交前提交，这样会有什么样的错误(T1的validate阶段读取了T2修改的版本号)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1: Wx0 Wy0 Rz0 .....   L V .... C</span><br><span class="line"></span><br><span class="line">T2:             Rz0 Wz1 ... C</span><br></pre></td></tr></table></figure><p>A：T1 &lt; T2 ，T2在T1之后开始，因此根据严格序列化规则：T2必须看见T1的写入，因此根据该规则，T2的读也需要在T1提交之后才能执行。意思也就是T2比T1提前提交这种情况也是不会出现的。</p><h4 id="Log-Record-type"><a href="#Log-Record-type" class="headerlink" title="Log Record type"></a>Log Record type</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Log record type</th><th style="text-align:center">Content</th></tr></thead><tbody><tr><td style="text-align:center">LOCK</td><td style="text-align:center">transaction ID, IDs of all regions with objects written by the transaction, and addresses, versions, and values of all objects written by the transaction that the destination is primary for</td></tr><tr><td style="text-align:center">COMMIT-BACKUP</td><td style="text-align:center">contents are the same as lock record</td></tr><tr><td style="text-align:center">COMMIT-PRIMARY</td><td style="text-align:center">transaction ID to commit</td></tr><tr><td style="text-align:center">ABORT</td><td style="text-align:center">transaction ID to abort</td></tr><tr><td style="text-align:center">TRUNCATE</td><td style="text-align:center">low bound transaction ID for non-truncated transactions and transaction IDs to truncate</td></tr><tr><td style="text-align:center">表中展示了每条日志信息的类型以及对应的内容</td></tr></tbody></table></div><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><h4 id="乐观并发控制-OCC"><a href="#乐观并发控制-OCC" class="headerlink" title="乐观并发控制(OCC)"></a>乐观并发控制(OCC)</h4><blockquote><p><strong>OCC</strong>  = Serializability  + Snapshot isolation(MVCC)</p></blockquote><p> 对于读写事务中对于<strong>读操作是不需要加锁的</strong>，而写操作仍是需要加锁。读操作是通过Strict Serializaiblility来实现一致性。</p><p><strong>严格的序列化：</strong> 序列化点总是在开始执行和向应用程序报告完成之间(Figure4)</p><p>对于读操作我们在提交阶段加上了冲突检测版本号</p><ul><li>版本号冲突(写对象有锁或是版本号改变)的话事务中止(abort)</li><li>版本号相同则进行提交(commit)</li></ul><p>FaRM使用OCC的原因：</p><ul><li>使用了one-sided RDMA读取</li><li>服务器(CPU)不需要主动参与读取</li></ul><h4 id="Validate的作用"><a href="#Validate的作用" class="headerlink" title="Validate的作用"></a>Validate的作用</h4><p>当我们处理两事务：假设开始时X=0，y=0</p><ul><li>T1：if x == 0 ，set y = 1</li><li>T2：if y == 0 ，set x = 1</li></ul><p>我们假设可能产生的结果:绝不可能并发执行时产生x=1，y=1</p><ul><li>T1产生：x = 0 ，y = 1</li><li>T2产生：x = 1 ，y = 0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   excution   commit</span><br><span class="line">T1 Rx0 Ry0  | Ly Vx            Cy</span><br><span class="line"></span><br><span class="line">T2 Rx0 Ry0  |       Lx Vy(fail)   Cx</span><br></pre></td></tr></table></figure><p>当我们并发执行T1与T2：T1的x与T2的y都可以上锁</p><ol><li>首先T1先开始提交，将y上锁(不会增加对象版本号)，验证x；</li><li>然后T2开始提交，将x上锁，验证y，但是由于y已经上锁(说明y可能已经别其他对象修改)，因此需要中止T2事务</li></ol><h4 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h4><p>一个纯只读的FaRM事务只使用使用one-sided RDMA read：不需要写入、不需要日志、不需要锁。速率十分的快。(个人觉得不需要validate阶段像spanner的只读事务一样)</p><h4 id="提交时机"><a href="#提交时机" class="headerlink" title="提交时机"></a>提交时机</h4><ul><li>在<strong>最后一次读取</strong>后提交只读事务</li></ul><ul><li><p>在获取写锁时提交读写事务是<strong>可序列化的</strong></p><ul><li>在可序列化的点上的对象的版本号与执行阶段的相同</li></ul></li><li><p>Locking确定对象被写入，Validate确定对象为只读</p><ul><li>如果没有失败，这就相当于在<strong>序列化点原子地</strong>执行和提交整个事务。 </li></ul></li></ul><h4 id="提交协议"><a href="#提交协议" class="headerlink" title="提交协议"></a>提交协议</h4><ul><li><p><strong>传统两段提交协议：</strong> Participant可以在处理prepare消息时预留资源以提交事务，或者在没有足够的资源时拒绝准备事务。</p></li><li><p><strong>FaRM的提交协议：</strong></p><ul><li>在提交过程中避免Backup的CPU参加，Coordinator必须为所有参与者保留日志空间，以保证进度。</li><li>Coordinator为所有提交协议记录预留空间，包括在开始提交协议之前截断主日志和备份日志中的记录。<ul><li>如果截断被附加在另一条消息上，截断记录保留也会被释放 </li></ul></li></ul></li></ul><h2 id="Spanner-与-FaRM"><a href="#Spanner-与-FaRM" class="headerlink" title="Spanner 与 FaRM"></a>Spanner 与 FaRM</h2><h3 id="共同之处"><a href="#共同之处" class="headerlink" title="共同之处"></a>共同之处</h3><p>都是关于分片、复制和使用了事务的二段提交(2PC)</p><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><h4 id="Spanner"><a href="#Spanner" class="headerlink" title="Spanner:"></a>Spanner:</h4><ul><li><p>重点讨论由于地理复制而引起的网络延迟</p></li><li><p>Paxos提供容错延迟</p></li><li><p>TrueTime 让客户端读取当地的副本</p></li><li><p>性能方面: 读写事务处理花费10到100 ms (Tables 3 and 6)</p></li></ul><h4 id="FaRM"><a href="#FaRM" class="headerlink" title="FaRM"></a>FaRM</h4><ul><li><p>重点讨论减少CPU的利用率</p></li><li><p>RDMA、直接NIC获取、NVRAM去避免磁盘写入</p></li><li><p>RDMA让FaRM可以使用OCC</p></li><li><p>性能方面: 58微秒的时间处理简单的事务 (6.3, Figure 7)</p><ul><li>i.e. 比Spanner快100倍</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>超快速度的分布式事务</p></li><li><p>硬件是还处于研究阶段(NVRAM和RDMA)，但可能很快就会普及</p></li><li><p>使用OCC提高速度并允许快速One-sided RDMA读取</p></li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><h4 id="Q-目前使用FaRM的系统有哪些"><a href="#Q-目前使用FaRM的系统有哪些" class="headerlink" title="Q: 目前使用FaRM的系统有哪些?"></a>Q: 目前使用FaRM的系统有哪些?</h4><p>A: FaRM似乎是一个研究系统，而不是用于生产。我怀疑它会影响未来的设计，也许它本身会发展成一个生产系统。</p><h4 id="Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密"><a href="#Q-为什么公司-微软，谷歌，Facebook，雅虎等-会公开他们的软件，而不是对他们的设计保密" class="headerlink" title="Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?"></a>Q: 为什么公司(微软，谷歌，Facebook，雅虎等)会公开他们的软件，而不是对他们的设计保密?</h4><p>A: 这些公司发表的论文只涉及他们所编写软件的一小部分。他们发表文章的原因之一是，这些系统部分是由具有学术背景的人(即拥有博士学位的人)开发的，这些人认为他们人生的一部分使命是帮助世界理解他们发明的新思想。他们为自己的工作感到自豪，希望人们能欣赏他们的工作。另一个原因是，这些论文可能有助于公司吸引顶尖人才，因为这些论文是如何在那里进行智力上有趣的工作的。</p><h4 id="Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗"><a href="#Q-FaRM真的标志着分布式系统在一致性-可用性方面的必要妥协的结束吗" class="headerlink" title="Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?"></a>Q: FaRM真的标志着分布式系统在一致性/可用性方面的必要妥协的结束吗?</h4><p>A: 论文的这一部分看起来更像是广告而不是科学。历史表明，没有哪个绩效水平高到没有人会想要更高的，而那些人很可能愿意在其他方面做出妥协，以获得他们所需的绩效。</p><h4 id="Q-FaRM的局限性是什么"><a href="#Q-FaRM的局限性是什么" class="headerlink" title="Q: FaRM的局限性是什么?"></a>Q: FaRM的局限性是什么?</h4><p>A: 数据必须符合RAM。如果事务冲突很多，OCC将产生大量中止。事务API(在他们的NSDI 2014论文中描述)看起来使用起来很尴尬，因为回复在回调中返回。应用程序代码必须紧密交织执行应用程序事务和轮询RDMA NIC队列和日志来自其他计算机的消息。应用程序代码在执行最终会中止的事务时可以看到不一致。应用程序可能不能为自己的目的免费使用线程，因为FaRM将线程固定到核心，并使用所有核心。FaRM需要特殊的网络硬件，但尚未广泛部署。只有当所有的计算机彼此靠近时，这种设计才有意义;它不是地理分布的秘方(因此容错能力有限)。当然，FaRM是一个旨在探索新想法的研究原型。它不是一般用途的成品。如果人们继续从事这项工作，我们最终可能会看到FaRM的后代没有那么多粗糙的地方。</p><h4 id="Q-为什么FaRM基于RDMA的RPC比传统RPC更快"><a href="#Q-为什么FaRM基于RDMA的RPC比传统RPC更快" class="headerlink" title="Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?"></a>Q: 为什么FaRM基于RDMA的RPC比传统RPC更快?</h4><p>A: 传统RPC要求应用程序对本地内核进行系统调用，内核要求本地NIC发送一个数据包。在接收计算机上，NIC将数据包写入内存中的队列，并中断接收计算机的内核。内核将数据包复制到用户空间，然后上下文切换到接收应用程序。接收应用程序反向发送应答(系统调用内核，内核与NIC通话，另一端的NIC中断内核，等等)。这一点是为每个RPC执行大量的代码，而且速度不是很快。</p><p>相反，FaRM安排应用程序代码可以直接读写内存以与NIC通信，并将CPU内核(本文称之为硬件线程)专门用于轮询传入消息。这消除了中断、系统调用、在用户和内核之间复制数据以及上下文切换的成本。</p><h4 id="Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献"><a href="#Q-FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献" class="headerlink" title="Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?"></a>Q: FaRM的大部分性能来自于硬件。软件设计在哪些方面对性能有贡献?</h4><p>A: FaRM速度快的一个原因是硬件速度快。但是硬件已经存在了很多年了，但是还没有人知道如何将所有的部件组合在一起，从而真正发挥硬件的潜力。FaRM做得这么好的一个原因是他们同时投入了大量的精力来优化网络、持久存储和CPU的使用;许多以前的系统只优化了一个，而不是全部。一个特定的设计点是FaRM对许多交互使用快速单边RDMA(而不是较慢的完整RPC)的方式。</p><h4 id="Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储"><a href="#Q-其他系统是否使用UPS-不间断电源，带电池-来实现快速而持久的存储" class="headerlink" title="Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?"></a>Q: 其他系统是否使用UPS(不间断电源，带电池)来实现快速而持久的存储?</h4><p>A: 这种想法是古老的;例如，Harp复制文件服务在20世纪90年代早期就使用了它。许多存储系统以相关的方式使用电池(例如在RAID控制器中)来持续写入而不等待磁盘。然而，FaRM使用的这种电池设置并不是特别常见，所以必须通用的软件不能依赖它。如果您将自己的硬件配置为有电池，那么修改Raft(或k/v服务器)以利用电池是有意义的。</p><h4 id="Q-如果没有电池支持的RAM-FaRM的设计还有意义吗"><a href="#Q-如果没有电池支持的RAM-FaRM的设计还有意义吗" class="headerlink" title="Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?"></a>Q:如果没有电池支持的RAM, FaRM的设计还有意义吗?</h4><p>A: 我不确定FaRM在没有非易失性RAM的情况下是否有意义，因为这样单方面的日志写入(例如图4中的COMMIT-BACKUP)就不会在电源故障时持续存在。您可以修改FaRM，以便在返回之前将所有日志更新写入SSD，但这样会大大降低性能。SSD写入大约需要100微秒，而FaRM的单边RDMA写入非易失性RAM只需要几微秒。</p><h4 id="Q-DRAM本身不是不稳定的吗"><a href="#Q-DRAM本身不是不稳定的吗" class="headerlink" title="Q: DRAM本身不是不稳定的吗?"></a>Q: DRAM本身不是不稳定的吗?</h4><p>A: 作者通过使用UPS使RAM“非易失性”，允许FaRM在电源故障时将RAM的内容写入SSD。但是，这确实不是完全非易失性的，因为如果计算机由于任何其他原因而崩溃，而不是电源故障，那么故障机器的内存内容就会丢失。这就是为什么他们在多台机器上复制每个区域，并具有快速恢复协议的原因。</p><h4 id="Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗"><a href="#Q-如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗" class="headerlink" title="Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?"></a>Q: 如果电源即将失效，FaRM服务器将RAM复制到SSD。他们能用机械硬盘驱动器代替ssd吗?</h4><p>A: 他们使用ssd是因为它们速度快。他们本可以在不改变设计的情况下使用硬盘驱动器。然而，在断电期间将数据写入磁盘将花费大约10倍的时间，在恢复供电后将数据读入磁盘将花费大约10倍的时间。这需要更大的电池和更大的耐心。</p><h4 id="Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色"><a href="#Q-FaRM中主、备份和配置管理器之间的区别是什么-为什么有三个角色" class="headerlink" title="Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?"></a>Q:FaRM中主、备份和配置管理器之间的区别是什么?为什么有三个角色?</h4><p>A: 数据在许多主/备份集之间进行分片。备份的目的是存储碎片数据和日志的副本，以防主服务器出现故障。主数据中心<strong>执行对分片中数据的所有读写操作</strong>，而备份数据中心<strong>只执行写操作</strong>(以保持它们的数据副本与主数据中心的副本相同)。只有一个配置管理器。它跟踪哪些主备份处于活动状态，并跟踪数据如何在它们之间进行分片。在较高的级别上，这种安排类似于GFS，后者也在许多主/备份集之间对数据进行分片，并且也有一个主系统来跟踪数据的存储位置。</p><h4 id="Q-FaRM在小范围内可行吗"><a href="#Q-FaRM在小范围内可行吗" class="headerlink" title="Q: FaRM在小范围内可行吗?"></a>Q: FaRM在小范围内可行吗?</h4><p>A: 我认为FaRM只有在需要每秒支持大量事务时才有意义。如果您只需要每秒处理几千个事务，您可以使用现成的成熟技术，如MySQL。您可以设置一个比作者的90台机器系统小得多的FaRM系统。但是FaRM没有意义，除非你是在分片和复制数据，这意味着你至少需要四个数据服务器(两个分片，每个分片两个服务器)和一些用于ZooKeeper的机器(尽管你可能可以在这四台机器上运行ZooKeeper)。然后，也许你有一个成本约为10,000美元的系统，每秒可以执行数百万个简单交易，这是非常好的。</p><h4 id="Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的"><a href="#Q-第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的" class="headerlink" title="Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!"></a>Q: 第3节似乎说单个事务的读取可能会看到不一致的数据。这看起来不像是可序列化的!</h4><p>A:Farm仅保证提交的事务的可序列化性。如果事务看到了第3节所讨论的那种不一致，FaRM将中止事务。应用程序必须处理不一致，因为它们不应该崩溃，这样它们就可以请求提交，这样FaRM就可以中止它们。</p><h4 id="Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么"><a href="#Q-FaRM如何确保事务的读取是一致的-如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么" class="headerlink" title="Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?"></a>Q: FaRM如何确保事务的读取是一致的?如果一个事务读取了一个正在被另一个事务修改的对象，会发生什么?</h4><p>A: 这里有两个危险。首先，对于一个大对象，读取器可能会在并发事务写入它之前读取对象的前半部分，而在并发事务写入它之后读取后半部分，这可能会导致读取程序崩溃。其次，如果读事务不能与并发写事务串行化，则不允许提交它。</p><p>根据我对作者之前的NSDI 2014论文的阅读，第一个问题的解决方案是每个对象的每个缓存行都有一个版本号，单缓存行RDMA读写是原子的。读取事务的FaRM库获取对象的所有缓存行，然后检查它们是否都具有相同的版本号。如果是，标准库将对象的副本提供给应用程序;如果没有，库将通过RDMA再次读取它。第二个问题是由FaRM在第4节中描述的验证方案解决的。在VALIDATE步骤中，如果自我们的事务启动以来，另一个事务写入了由我们的事务读取的对象，那么我们的事务将被中止。</p><h4 id="Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗"><a href="#Q-日志截断是如何工作的-什么时候可以删除日志条目-如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗" class="headerlink" title="Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?"></a>Q: 日志截断是如何工作的?什么时候可以删除日志条目?如果截断调用删除了一个条目，那么之前的所有条目也都被删除了吗?</h4><p>A: 在TC看到主服务器和备份服务器的日志中都有一个COMMIT-PRIMARY或COMMIT-BACKUP后，TC告诉主服务器和备份服务器删除事务的日志条目。为了使恢复知道尽管截断了事务，但事务还是完成了，第62页提到，即使在截断之后，primary也会记住已完成的事务id。截断意味着删除截断点之前的所有日志条目;这是因为每个主/备份在每个TC上都有一个单独的日志。</p><h4 id="Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障"><a href="#Q-是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障" class="headerlink" title="Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?"></a>Q:是否可能在COMMIT-BACKUP期间发生中止，可能是由于硬件故障?</h4><p>A: 我想是的。如果其中一个备份没有响应，并且TC崩溃，那么事务可能会在恢复期间中止。</p><h4 id="Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗"><a href="#Q-当许多事务需要修改同一个对象时，FaRM性能会受到影响吗" class="headerlink" title="Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?"></a>Q:当许多事务需要修改同一个对象时，FaRM性能会受到影响吗?</h4><p>A:当多个事务同时修改同一个对象时，其中一些事务将在图4的LOCK阶段看到锁已经被持有。在VALIDATE阶段，读者可能会看到更改的版本或锁定标志。每个这样的事务都将中止并从头开始重新启动。如果这种情况经常发生，业绩确实会受到影响。“乐观并发控制”中的“乐观”指的是希望这样的冲突将很少发生，并且执行无锁读取的能力将产生高性能。事实上，对于作者测量的应用程序，FaRM获得了出色的性能。一个很可能的原因是，它们的应用程序具有相对较少的冲突事务，因此没有太多中止。</p><h4 id="Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢"><a href="#Q-图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢" class="headerlink" title="Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?"></a>Q: 图7显示了当操作数量超过每微秒120次时延迟的显著增加。为什么呢?</h4><p>A: 我怀疑服务器的极限是总共每秒只能处理大约1.4亿次操作。如果客户端发送操作的速度比这快，其中一些将不得不等待;这种等待会增加延迟。</p><h4 id="Q-什么是vertical-Paxos"><a href="#Q-什么是vertical-Paxos" class="headerlink" title="Q:什么是vertical Paxos?"></a>Q:什么是vertical Paxos?</h4><p>A: 它是Paxos协议的一种风格，其中外部主服务器执行重新配置，而Paxos组在进行重新配置时可以继续执行操作 (see <a href="https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf">https://lamport.azurewebsites.net/pubs/vertical-paxos.pdf</a> for the details). 在FaRM论文中，作者使用术语“垂直Paxos”来松散地表示配置管理是由外部服务(Zookeeper和CM)完成的，事务的处理写是通过标准的主/备份协议完成的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-2015.pdf">FaRM论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/farm-faq.txt">FaRM FQA</a></li><li><a href="https://pdos.csail.mit.edu/6.824/notes/l-farm.txt">FaRM Lecture</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> FaRM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effect C++笔记</title>
      <link href="/2023/01/20/C++/Effective%20C++/"/>
      <url>/2023/01/20/C++/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><blockquote><p>Effective学习笔记</p></blockquote><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h2><p>C++高效编程时情况而变，取决于你使用C++的那一部分</p><hr><h2 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h2><p><code>Perfer consts enum and inlines to #define</code></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>✦For simple constants, prefer const objects or enums to #defines.</p><p>✦For function-like macros, prefer inline functions to #defines.</p><hr><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><p><code>Use const whenever possible</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><blockquote><p>优点</p></blockquote><ol><li><p>他们使class接口比较容易被理解，可以得知那个函数可以改动对象成员，那个不能</p></li><li><p>他们使用“操作const对象”成为可能。</p></li></ol><blockquote><p>constness</p></blockquote><p>当两个成员函数如果只是常量性不同，就可以用const来重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">                         <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// const objects</span></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[ ](std::<span class="type">size_t</span> position)  </span><br><span class="line">                        <span class="comment">// operator[ ] for&#123; return text[position]; &#125;</span></span><br><span class="line">                        <span class="comment">// non-const objects</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">//TextBlock’s operator[]s can be used like this:</span></span><br><span class="line">TextBlock <span class="built_in">tb</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];    <span class="comment">// calls non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">// calls const TextBlock::operator[]</span></span><br></pre></td></tr></table></figure><h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>✦Declaring something const helps compilers detect usage errors. constcan be applied to objects at any scope, to function parameters andreturn types, and to member functions as a whole.</p><p>✦Compilers enforce bitwise constness, but you should program usinglogical constness.</p><p>✦When const and non-const member functions have essentially identi-cal implementations, code duplication can be avoided by having thenon-const version call the const version.</p><hr><h2 id="条款04：确定对象被使用前已经先被初始化"><a href="#条款04：确定对象被使用前已经先被初始化" class="headerlink" title="条款04：确定对象被使用前已经先被初始化"></a>条款04：确定对象被使用前已经先被初始化</h2><p><code>Make sure that object are initialized before they&#39;re used</code></p><h3 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h3><blockquote><p>规则</p></blockquote><p>永远在使用对象之前将它初始化。对于内置内省必须要手工完成初始化</p><p>对于自定义类型来说，初始化职责放在构造函数上</p><blockquote><p>赋值与初始化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;<span class="comment">// ABEntry = “Address Book Entry”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">            <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;<span class="comment">// these are all assignments,</span></span><br><span class="line">    theAddress = address;<span class="comment">// not initializations</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化</p></blockquote><p>成员变量初始化动作发生在进入构造函数本体之前，相对于赋值来说发生时间更早。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">        <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones): </span><br><span class="line">        <span class="built_in">theName</span>(name),</span><br><span class="line">        <span class="built_in">theAddress</span>(address),<span class="comment">// these are now all initializations</span></span><br><span class="line">        <span class="built_in">thePhones</span>(phones),</span><br><span class="line">        <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;<span class="comment">// the ctor body is now empty</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化优点</p></blockquote><p>通常效率较高；</p><p><strong>赋值版本</strong>：先调用构造函数为成员变量赋予初值，然后立刻在对他们赋予新值（传入的实参）。因此会浪费一部分时间</p><p><strong>初始化版本</strong>：成员初始列中针对各个成员变量而设的实参，被拿去作为各成员之构造函数的实参。</p><blockquote><p>必须初始化的情况</p></blockquote><p>例如：成员变量为const或references，必须要进行成员初始列表</p><p><strong>综述：</strong> 一般情况总是使用成员初始列表，可以针对普遍的变量，而且比赋值更高效</p><h3 id="成员初始化次序"><a href="#成员初始化次序" class="headerlink" title="成员初始化次序"></a>成员初始化次序</h3><ul><li><p>base class -&gt; derived class </p></li><li><p><strong>成员变量以被声明的次序进行初始化</strong>因此对于示例ABEntry 中theName 最先被初始化，然后是theAddress，再是thePhone，最后是numTimesConsulted.</p></li></ul><h3 id="static对象"><a href="#static对象" class="headerlink" title="static对象"></a>static对象</h3><blockquote><p>生命周期</p></blockquote><p>从被构造出来直到程序结束，因此不是堆栈对象。</p><blockquote><p>定义</p></blockquote><p>一般这种对象被定义为global对象、定于于namspace作用域、classes、函数内、以及file作用内声明为static的对象</p><blockquote><p>local static与non-local static对象</p></blockquote><p><strong>long static对象</strong>：定义域函数内，因为它对于函数而言是local</p><p><strong>non-local static对象</strong>：其他剩余的static对象</p><h3 id="多源文件跨编译单元编译"><a href="#多源文件跨编译单元编译" class="headerlink" title="多源文件跨编译单元编译"></a>多源文件跨编译单元编译</h3><p>一般至少应该non-local static对象</p><blockquote><p>问题</p></blockquote><p>某编译单元内的某个non-local static对象初始化动作使用了另一个编译单元内的某个编译单元内的某个non-local static对象，它所用到的这个对象可能没有被初始化，因为c++对于 <strong>”定义在不同编译单元的non-local对象那个“初始化次序没有明确的规定</strong></p><h4 id="non-local-static-对象初始化次序问题"><a href="#non-local-static-对象初始化次序问题" class="headerlink" title="non-local static 对象初始化次序问题"></a>non-local static 对象初始化次序问题</h4><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;<span class="comment">// from your library’s header file</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// one of many member functions</span></span><br><span class="line">...</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">// declare object for clients to use// (“tfs” = “the file system” ); definition// is in some .cpp file in your library</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;<span class="comment">// created by library client</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Directory</span>( params );...&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>( );<span class="comment">// use the tfs object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：用户决定创建应该Directory对象，用来放置临时文件</p><p>Directory tempDir{params}；</p><blockquote><p>初始化次序的重要性</p></blockquote><p>除非tfs在tempDir先被初始化，否则tempDir会用到尚未初始化的tfs。（但是tfs和tempDir是被不同人在不同时间创建的），他们是不同编译单元的non-local对象</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>将每个non-local对象搬到总结专属的函数内（函数也要声明为static）、</p><p>这些函数返回应该reference指向它所含的对象。然后用户调用这些函数</p><blockquote><p> C++保证</p></blockquote><p>函数内的local static对象会在<u>”该函数调用期间“”首次遇到该对象的定义式”</u>时被初始化。</p><p>因此如果用”函数调用“(返回应该reference指向local static对象)替换”直接访问non-local static对象“，就获得了保证，保证你所获得reference将指向应该历经初始化的对象。</p><blockquote><p>优点</p></blockquote><p>从未调用non-local static对象的”仿真函数“，就绝不会引发构造和析构成本</p><blockquote><p>优化代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;; <span class="comment">// as before</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">( )</span><span class="comment">// this replaces the tfs object; it could be</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// static in the FileSystem class</span></span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">// define and initialize a local static object</span></span><br><span class="line">    <span class="keyword">return</span> fs;<span class="comment">// return a reference to it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;<span class="comment">// as before</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )<span class="comment">// as before, except references to tfs are </span></span><br><span class="line">&#123;<span class="comment">// now to tfs( )</span></span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>( );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">( )</span><span class="comment">// this replaces the tempDir object; it</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="comment">// could be static in the Directory class</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Directory <span class="title">td</span><span class="params">( params )</span></span>;<span class="comment">// define/initialize local static object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> td;<span class="comment">// return reference to it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>✦Manually initialize objects of built-in type, because C++ only some-times initializes them itself.</p><p>✦In  a  constructor,  prefer  use  of  the  member  initialization  list  to  assignment  inside  the  body  of  the  constructor.  List  data  members  in the initialization list in the same order they’re declared in the class.</p><p>✦Avoid  initialization  order  problems  across  translation  units  by  re-placing non-local static objects with local static objects.</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="条款05：了解C-默认编写和调用了哪些函数"><a href="#条款05：了解C-默认编写和调用了哪些函数" class="headerlink" title="条款05：了解C++默认编写和调用了哪些函数"></a>条款05：了解C++默认编写和调用了哪些函数</h2><p><code>Know what functions C++silently writes and calls.</code></p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>✦Compilers may implicitly generate a class’s default constructor, copyconstructor, copy assignment operator, and destructor</p><hr><h2 id="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝"></a>条款06：若不想使用编译器自动生成的函数，就因该明确的拒绝</h2><p><code>Explicitly disallow the use of compiler-generated functions you do not want.</code></p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>✦To disallow functionality automatically provided by compilers, declare the corresponding member functions private and give no imple-mentations. Using a base class like private is one way to do this.</p><hr><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D constrctor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D destrutor&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        D d;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//多态</span></span><br><span class="line">    &#123;</span><br><span class="line">        B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        B* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">D destrutor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">B destrutor</span><br><span class="line"></span><br><span class="line">B constrctor</span><br><span class="line">D constrctor</span><br><span class="line">B destrutor</span><br></pre></td></tr></table></figure><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>✦Polymorphic base classes should declare virtual destructors. If aclass has any virtual functions, it should have a virtual destructor.</p><p>✦Classes not designed to be base classes or not designed to be usedpolymorphically should not declare virtual destructors.</p><hr><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><code>prevent exception from leaving destruction</code></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>✦Destructors should never emit exceptions. If functions called in adestructor may throw, the destructor should catch any exceptions,then swallow them or terminate the program.</p><p>✦If class clients need to be able to re act to exceptions thrown duringan operation, the class should provide a regular (i.e., non-destruc-tor) function that performs the operation.</p><hr><h2 id="条款11：在operator-中“自我赋值”"><a href="#条款11：在operator-中“自我赋值”" class="headerlink" title="条款11：在operator=中“自我赋值”"></a>条款11：在operator=中“自我赋值”</h2><p><code>Handle assignment to self in operator=</code></p><p>以widget窗口类为示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    Bit* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w = w; 自我赋值 </span><br></pre></td></tr></table></figure><h3 id="方法一：证同测试"><a href="#方法一：证同测试" class="headerlink" title="方法一：证同测试"></a>方法一：证同测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)                <span class="comment">//证同测试</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb；</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);    <span class="comment">//防止浅拷贝问题</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>异常问题：</p></blockquote><p>new Bitmap出现异常（分配内存错误导致错误）this-&gt;pb会指向一块被删除的内存</p><h3 id="方法二：异常安全性"><a href="#方法二：异常安全性" class="headerlink" title="方法二：异常安全性"></a>方法二：异常安全性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;                 <span class="comment">//创建*this一个副本</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);           <span class="comment">//pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig                          <span class="comment">//删除副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>证同测试效率问题</p></blockquote><p>应用证同测试会导致代码效率变低，if分支导致执行速度下降</p><blockquote><p>副本：</p></blockquote><p>不是指向一个对象只是一个<strong>值容器</strong>，如函数传参</p><h3 id="方法三：copy-swap（异常安全性）—-条款29"><a href="#方法三：copy-swap（异常安全性）—-条款29" class="headerlink" title="方法三：copy-swap（异常安全性）—-条款29"></a>方法三：copy-swap（异常安全性）—-条款29</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">//一个副本修改它不会修改其本身</span></span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);       <span class="comment">//rhs数据副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A variation on this theme takes advantage of the facts that</p><p> (1) a class’scopy assignment operator may be declared to take its argument byvalue and</p><p> (2) passing something by value makes a copy of it (seeItem20)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=( Widget rhs)<span class="comment">//一个副本修改它不会修改其对象本身</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);            <span class="comment">//pass by value 将*this的属于和副本的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦Make sure operator= is well-behaved when an object is assigned to itself. Techniques include comparing addresses of source and target objects, careful statement ordering, and copy-and-swap.</p><p>✦Make sure that any function operating on more than one object be-haves correctly if two or more of the objects are the same.</p></blockquote><hr><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p><code>think carefully about copying behavior in resource-managing classes</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm)</span></span><br><span class="line"><span class="function">        &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;<span class="comment">// acquire resource</span></span><br><span class="line">    ~<span class="built_in">Lock</span>( )</span><br><span class="line">        &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;<span class="comment">// release resource</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Clients use Lock in the conventional RAII fashion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;<span class="comment">// define the mutex you need to use</span></span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// create block to define critical sectionLock </span></span><br><span class="line"><span class="built_in">ml</span>(&amp;m);    <span class="comment">// lock the mutex</span></span><br><span class="line">...    <span class="comment">// perform critical section operations</span></span><br><span class="line">&#125;    <span class="comment">// automatically unlock mutex at end</span></span><br><span class="line">    <span class="comment">// of block</span></span><br></pre></td></tr></table></figure><h3 id="RAII对象copied的选择"><a href="#RAII对象copied的选择" class="headerlink" title="RAII对象copied的选择"></a>RAII对象copied的选择</h3><ul><li><p>禁止复制（prohibit copying）</p></li><li><p>对底层资源使用“引用计数法”</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>✦ 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为</p><p>✦普遍而常见的RAII classes copying 行为时：一直copying、实行引用计数法。</p><h2 id="条款15：在资源类中提供对原始资源的访问"><a href="#条款15：在资源类中提供对原始资源的访问" class="headerlink" title="条款15：在资源类中提供对原始资源的访问"></a>条款15：在资源类中提供对原始资源的访问</h2><p><code>provide access to raw resources in resource-managing classes</code></p><p><strong>原因：</strong> 编译器无法将RAII类(shared_ptr)作为指针,会将其作为一个对象，无法发生隐式转换而报错</p><blockquote><p><strong>示例</strong> ：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daysHeld</span><span class="params">(<span class="type">const</span> Investment *pi)</span></span>;<span class="comment">// return number of days</span></span><br><span class="line">                                    <span class="comment">// investment has been held</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);<span class="comment">// error!</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>解决方案：</strong> </p></blockquote><p><code>convert an object of the RAII class (in this case,tr1::shared_ptr) into the raw resource</code></p><p>(1)<strong>explicit conversion:</strong></p><p>smart_ptr offer a get number function to perform explicit conversion to return a raw pointer inside this smart_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>( ));<span class="comment">// fine, passes the raw pointer</span></span><br><span class="line">                                <span class="comment">// in pInv to daysHeld</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string* str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//explicit</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">test_string</span>(ptr);<span class="comment">//error can`t convert RAII to string</span></span><br><span class="line">    <span class="built_in">test_string</span>(ptr.<span class="built_in">get</span>());<span class="comment">//offer raw resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)<strong>implicit conversion:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Str</span><span class="params">(<span class="type">const</span> string&amp; str)</span>:m_str(str)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_str;&#125;<span class="comment">//implicit convertion</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_str;&#125;</span><br><span class="line">    ~<span class="built_in">Str</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_implicit_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">a</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">test_string</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>✦APIs often require access to raw resources, so each RAII classshould offer a way to get at the resource it manages.</p><p>✦Access may be via explicit conversion or implicit conversion. In gen-eral, explicit conversion is safer, but implicit conversion is more con-venient for clients.</p><hr><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款20：宁以pass-by-reference-to-const-替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string&amp; a):<span class="built_in">p_name</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;P&quot;</span>&lt;&lt;st::endl;<span class="keyword">return</span> p_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string p_name;</span><br><span class="line">    string p_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; a):<span class="built_in">s_name</span>(a)&#123;std::cout&lt;&lt;<span class="string">&quot;S construct\n&quot;</span>;&#125;</span><br><span class="line">    <span class="comment">//Student(const Student&amp; other)&#123;std::cout&lt;&lt;&quot;S copy construct\n&quot;;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">printN</span><span class="params">()</span><span class="type">const</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;std::endl;<span class="keyword">return</span> s_name;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Student</span>()&#123;std::cout &lt;&lt; <span class="string">&quot;S destruct\n&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s_name;</span><br><span class="line">    string s_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;p.<span class="built_in">printN</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用pass-by-reference-to-const的好处"><a href="#用pass-by-reference-to-const的好处" class="headerlink" title="用pass-by-reference-to-const的好处"></a>用pass-by-reference-to-const的好处</h3><ol><li><p><strong>高效</strong>，不会创建临时对象，因此不会再次调用construt和deconstruct。</p></li><li><p><strong>准确且正确的多态</strong>，pass-by-value无法识别准确的object，如test1中，real object 都是person无法调用student的多态，pass-by-reference-to-const是可以准确调用student对象</p></li></ol><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>✦Prefer pass-by-reference-to-const over pass-by-value. It’s typicallymore efficient and it avoids the slicing problem.</p><p>✦The rule doesn’t apply to built-in types and STL iterator and func-tion object types. For them, pass-by-value is usually appropriat</p><hr><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p><code>Don&#39;t try return a reference when you must return an object</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span> ()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">double</span> x, <span class="type">double</span> y):<span class="built_in">x_</span>(x),<span class="built_in">y_</span>(y)</span><br><span class="line">    &#123;cout&lt;&lt;<span class="string">&quot;construt&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该段代码描述有理数的相乘的类的设计</p><h3 id="当以reference作为返回值时的几大误区"><a href="#当以reference作为返回值时的几大误区" class="headerlink" title="当以reference作为返回值时的几大误区"></a>当以reference作为返回值时的几大误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">==================on the stack===================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational <span class="built_in">result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================on the heap======================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational *result =  <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line">=================<span class="type">static</span> local====================</span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result</span><br><span class="line">    result = <span class="built_in">Result</span>(lhs.x_*lhs.y_,rhs.x_*rhs.y_);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>on the stack</strong> :reference作为返回值时，result对象是一个stack值，当其返回时离开了作用域，result对象会被销毁，reference返回时会导致其指向了一个被销毁的值</p></li><li><p><strong>on the heap</strong> :heap分配的内存，new出来的对象，无法得知合适对该对象进行delete，因此会导致内存泄漏</p></li><li><p><strong>static local</strong> :会引起多线程问题，例如数据共享问题</p></li></ol><h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs,</span><br><span class="line">                    <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.x_*lhs.y_,rhs.x_*rhs.y_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：虽然会付出一点点的成本代价（construct和deconstruct），但从长远的角度和综合对比可知，此方法是最合适的做法</p><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>✦Never return a pointer or reference to a local stack object, a refer-ence to a heap-allocated object, or a pointer or reference to a localstatic object if there is a chance that more than one such object willbe needed. (Item4 provides an example of a design where returninga reference to a local static is reasonable, at least in single-threadedenvironments.)</p><hr><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p><code>Declare data member private</code></p><h3 id="private（提供封装）和其他（提供封装）"><a href="#private（提供封装）和其他（提供封装）" class="headerlink" title="private（提供封装）和其他（提供封装）"></a>private（提供封装）和其他（提供封装）</h3><p>对于protect声明的成员变量，当其出现问题后或是被取消后，将会影响整个派生类</p><h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><p>✦Declare data members private. It gives clients syntactically uniformaccess to data, affords fine-grained access control, allows invariantsto be enforced, and offers class authors implementation flexibility.</p><p>✦protected is no more encapsulated than public（protect 与 public 差不多）</p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p><code>Perfer non-member、non-friend to member function</code> </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>示例 :</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrower</span></span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">==================member================</span><br><span class="line"><span class="keyword">class</span> WebBrower&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">clearEverything</span>();<span class="comment">//调用clearCache、clearHistory、</span></span><br><span class="line">                           <span class="comment">//removeCookies</span></span><br><span class="line">&#125;</span><br><span class="line">=================non-member============</span><br><span class="line"><span class="type">void</span> <span class="built_in">clearBrowser</span>(WebBrowser&amp; wb)</span><br><span class="line">&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>我们更愿意使用non-member代替member函数</code></p><blockquote><p>原因</p></blockquote><p>1.non-member的封装性比member函数的更强</p><p>2.non-member对类的相关机能有较大的包裹弹性</p><blockquote><p><strong>封装</strong>：它使我们能够改变事物而只影响有限客户</p></blockquote><p>愈多东西被封装，愈少人能看见它，因此能够有愈大的弹性去改变它</p><p>愈多函数可以访问封装的函数，数据的封装性越低</p><p><strong>条款22</strong>：成员变量应该是private，以为如果他们不是，就有无数的函数可以去访问他们，没有封装可言</p><blockquote><p>访问限制</p></blockquote><p>能够访问private成员变量的函数只有class和member函数与friend函数可以访问</p><h3 id="程序设计问题"><a href="#程序设计问题" class="headerlink" title="程序设计问题"></a>程序设计问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设计特点</p></blockquote><ul><li><p>namespace 与classes不同，<strong>namespace可以支持跨多个源码文件</strong>而class不能</p></li><li><p>non-member、non-friend函数为用户提供较好的程序机能以及封装性</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowsers。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">   <span class="comment">//核心机能，提供所有的non-member函数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowserbookmarks。</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">//声明与书签相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//webbrowsercookies</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowerStuff</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//声明与cookies相关的non-member、non-friend便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例运用了namespace的跨越多个源码文件的特点</p><blockquote><p>标准库组织方式</p></blockquote><p>在STL头文件中std命名空间内的每一个东西，每个头文件声明std的某些机能</p><p>例如只想用vector，那就只用vector头文件，这允许客户支队他们所用的<strong>小部分系统形成编译依赖</strong>，但该方法不能适用于member函数，以为class必须整体定义，不可分割</p><p>将所有便利函数放在多个头文件内但隶属同一命名空间，意味用户可以轻松的扩展。需要只做到则是，在该命名空间<strong>添加non-member、non-friend函数</strong>。</p><h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Prefer non-member non-friend functions to member functions. Do-ing so increases encapsulation, packaging flexibility, and functionalextensibility.</p></blockquote><hr><h2 id="条款24：-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24：-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24： 若所有参数皆需类型转换,请为此采用non-member函数"></a>条款24： 若所有参数皆需类型转换,请为此采用non-member函数</h2><p><code>Declare non-member functions when type conversions should apply to all parameters</code></p><blockquote><p>示例：Rational</p></blockquote><p>运用条款3，20，21书写正确的operator*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">float</span> numerator = <span class="number">0</span>,<span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;<span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">    <span class="comment">// conversions</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// accessors for numerator and</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// denominator — see Item22private:</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Rational <span class="title">result</span><span class="params">((n*rhs.n),(d*rhs.d))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    <span class="type">float</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">r1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Rational r3 = r1 * r2;<span class="comment">//right</span></span><br><span class="line"></span><br><span class="line">    r3  = r1 * <span class="number">2</span>;<span class="comment">//right</span></span><br><span class="line">    r3  = <span class="number">2</span> * r1;<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;r3&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li><p>在隐式转换时，构造函数需要写出默认参数，不然不能进行隐式转换，因为Rational类构造函数有两个参数;</p></li><li><p>在构造函数加上explicit就可以防止隐式转换</p></li><li><p>2 *  r1 不能成功运行，是不是不满足交换律？</p></li></ul><blockquote><p>重写上述例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = r1.<span class="keyword">operator</span>*(<span class="number">2</span>);</span><br><span class="line">result = <span class="number">2.</span>opeator*(r1);<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">result = opeator*(<span class="number">2</span>,r1);</span><br></pre></td></tr></table></figure><p>因为r1内含一个operator<em>函数的class的对象，并且将2进行隐式转换r1.operator </em> (Rational(2))</p><p>对于2.operator(r1)显然时错误的,没有这个重载函数</p><h3 id="将operator写为non-member函数"><a href="#将operator写为non-member函数" class="headerlink" title="将operator写为non-member函数"></a>将operator写为non-member函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        rhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><ul><li><p>non-member函数如条款23所述封装性更强</p></li><li><p>支持所有参数的隐式类型转换</p></li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><blockquote><p>✦If you need type conversions on all parameters to a function (includ-ing the one that would otherwise be pointed to by the this pointer),the function must be a non-member.</p></blockquote><hr><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p><code>consider support a no-throwing swap</code></p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="无法交换值、无法交换指针"><a href="#无法交换值、无法交换指针" class="headerlink" title="无法交换值、无法交换指针"></a>无法交换值、无法交换指针</h4><p>普通swap函数实现细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br><span class="line">========================</span><br><span class="line">地址不变，值不变</span><br></pre></td></tr></table></figure><blockquote><p>陷阱</p></blockquote><p>对于c/c++的初学者来说，犯下一个很大的陷阱，那就是我们只传过去一个地址对于者个地址值只是一个<strong>副本信息</strong>，并不是原对象，导致无法交换地址值更无法交换指针值。我们只是通过传参过来的一个 <strong>(地址)值(副本)</strong>,这是我们只是对原对象的指针副本做了交换</p><h4 id="无法交换地址、可以交换指针"><a href="#无法交换地址、可以交换指针" class="headerlink" title="无法交换地址、可以交换指针"></a>无法交换地址、可以交换指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = *temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>解引用后，此时<em>a、</em>b是a、b地址对应内存的值，也就是原对象值，改操作进行的是<strong>对(原对象)内存的进行置换</strong>，但此时并不会改变地址值，地址值仍是一个副本</p><h4 id="可以交换值和地址"><a href="#可以交换值和地址" class="headerlink" title="可以交换值和地址"></a>可以交换值和地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>** a,<span class="type">int</span>** b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">swap</span>(p1,p2);</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>p1和p2是一个地址</p><p>我们用双层指针，写出一个swap的置换函数，我们传入地址进去，此时a、b的值是指向p1和p2的地址。对a、b进行解引用，则<strong>对应的<em>a 、</em>b是对应p1、p2的地址原对象</strong>。</p><p>进行置换则<strong>交换的是p1和p2的值</strong>，那么地址交换，相应改变的是p1和p2的对象名所对应的地址而已，而实际的内存并没有置换而已。</p><h4 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法既可以改值也可以改地址，因为引用的本身就是<strong>绑定一个原对象</strong>，并不是副本</p><h3 id="标准库swap"><a href="#标准库swap" class="headerlink" title="标准库swap"></a>标准库swap</h3><blockquote><p> std::swap</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// typical implementation of </span></span><br><span class="line">std::swap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b)</span><span class="comment">// swaps a’s and b’s values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换</p><h3 id="示例：swap"><a href="#示例：swap" class="headerlink" title="示例：swap"></a>示例：swap</h3><blockquote><p>实践Widget类</p></blockquote><ul><li>用pimpl手法将Widget的数据成员封装到WidgetImpl中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;<span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// details are unimportant...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// possibly lots of data —</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;<span class="comment">// expensive to copy!...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;<span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)<span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">    &#123;        <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">        ...<span class="comment">// details on implementing</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);<span class="comment">// operator= in general,</span></span><br><span class="line">        ...<span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;<span class="comment">// ptr to object with this </span></span><br><span class="line">&#125;;<span class="comment">// Widget’s data</span></span><br></pre></td></tr></table></figure><blockquote><p>设计问题</p></blockquote><ul><li><p>置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl)</p></li><li><p>可以直接交换指针的地址，改变指针指向的内存</p></li></ul><h4 id="置换其impl指针"><a href="#置换其impl指针" class="headerlink" title="置换其impl指针"></a>置换其impl指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)<span class="comment">//std::swap的全特化版本只能对</span></span><br><span class="line">           <span class="comment">//&lt;Widget&gt;表示这一特例化版本只是针对指针交换而设计</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl,b.pImpl);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下：</p><h4 id="声明public成员函数置换"><a href="#声明public成员函数置换" class="headerlink" title="声明public成员函数置换"></a>声明public成员函数置换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// addition of the swap mem func</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;<span class="comment">// the need for this declaration</span></span><br><span class="line">                    <span class="comment">// is explained later in this Item</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pImpl pointers</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// revised specialization of</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,<span class="comment">// std::swap</span></span><br><span class="line">                        Widget&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);<span class="comment">// to swap Widgets, call their</span></span><br><span class="line">&#125;<span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本</p><blockquote><p>缺点</p></blockquote><p>对于Widget class templates而非classes 将数据类型加以参数化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,<span class="comment">// error! illegal code!</span></span><br><span class="line">        Widget&lt;T&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">     a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>错误分析</p></blockquote><p>企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化，在function templates身上时不能偏特化的。因此无法编译。</p><h4 id="偏特化function-template"><a href="#偏特化function-template" class="headerlink" title="偏特化function template"></a>偏特化function template</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// an overloading of std::swap </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// (note the lack of “&lt;...&gt;” after</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Widget&lt;T&gt;&amp; b)</span><span class="comment">// “swap”), but see below for</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    a.<span class="built_in">swap</span>(b); </span><br><span class="line">&#125;<span class="comment">// why this isn’t valid code&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>重载function templates是没问题的，但std是一个特殊的命名空间：</p><ul><li><p>可以全特化std内的templates</p></li><li><p>不可以添加新的templates(class或function)到std里面</p></li></ul><h3 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h3><blockquote><p>高效正确的做法：non-member的swap、member的swap函数相结合</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...<span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// as before, including the swapclass </span></span><br><span class="line">Widget &#123; ... &#125;;<span class="comment">// member function</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// non-member swap function;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,<span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>swap实现效率不足的解决(class或template运用了pimpl手法)</p></blockquote><ol><li><p>提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常</p></li><li><p>在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数</p></li><li><p>如果编写一个<strong>class(而非class template)</strong>，为你的class特化一个std::swap，并令他调用你的swap的成员函数</p></li><li><p>必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符</p></li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>✦Provide a swap member function when std::swap would be inefficientfor your type. Make sure your swap doesn’t throw exceptions.</p><p>✦If you offer a member swap, also offer a non-member swap that callsthe member. For classes (not templates), specialize std::swap, too.</p><p>✦When calling swap, employ a using declaration for std::swap, then callswap without namespace qualification.</p><p>✦It’s fine to totally specialize std templates for user-defined types, butnever try to add something completely new to std.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="条款26：尽量将变量的声明置后"><a href="#条款26：尽量将变量的声明置后" class="headerlink" title="条款26：尽量将变量的声明置后"></a>条款26：尽量将变量的声明置后</h2><p><code>Postpone variable definitions as long as possible</code></p><h3 id="变量声明前置示例"><a href="#变量声明前置示例" class="headerlink" title="变量声明前置示例"></a>变量声明前置示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...            <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                   <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>使用：正常执行的时候需要用到encrypted</p><p>未使用：当异常抛出时，encrypted对象的构造成本已经造成，而析构要离开作用域后才会启用。</p><h3 id="变量置后"><a href="#变量置后" class="headerlink" title="变量置后"></a>变量置后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted’s definition until it’s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>( ) &lt; MinimumPasswordLength) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...          <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环中的变量声明"><a href="#循环中的变量声明" class="headerlink" title="循环中的变量声明"></a>循环中的变量声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    w = some value dependent on i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach B: define inside loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方法的成本对比</p></blockquote><p>■Approach A: 1 constructor + 1 destructor + n assignments.</p><p>■Approach B: n constructors + n destructors.</p><blockquote><p>效率分析</p></blockquote><p>■Approach A:可见性强，当n较大时效率更好</p><p>■Approach B:n小时效率高</p><p>(1) assignment相比constructor-destruction(对)更加便宜</p><p>(2) 如果您正在处理代码中对性能敏感的部分，则应默认使用方法B。</p><h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p>✦Postpone variable definitions as long as possible. It increases pro-gram clarity and improves program efficiency.</p><hr><h2 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款27：尽量少做转型操作</h2><p><code>Minimize casting</code></p><h3 id="C语言转型语法"><a href="#C语言转型语法" class="headerlink" title="C语言转型语法"></a>C语言转型语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C风格的转型</span></span><br><span class="line">(T) expression<span class="comment">// cast expression to be of type T</span></span><br><span class="line"><span class="comment">//函数风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression)<span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure><h3 id="C-新式转型-new-style"><a href="#C-新式转型-new-style" class="headerlink" title="C++新式转型(new-style)"></a>C++新式转型(new-style)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><p>const_cast通常被用来将对象的常量性去除</p></li><li><p>dynamic_cast 主要用来执行“向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，不可以移植。例如将pointer to int 转型为一个int。</p></li><li><p>static_cast用来强制隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derivered。但它无法将cosnt转为non-const——这个只有const_cast才能办到。</p></li></ul><h3 id="新式转换的优点"><a href="#新式转换的优点" class="headerlink" title="新式转换的优点"></a>新式转换的优点</h3><ul><li><p>在代码中容易被识别出来(grep工具和人工识别)，找出类型系统在那个地点被破坏</p></li><li><p>各转型动作的目标越窄化，编译器越可能诊断错误地点，例如将constness去除，除非使用新式转型中的const_cast否之无法通过编译</p></li></ul><h3 id="旧式类型转换的使用场景："><a href="#旧式类型转换的使用场景：" class="headerlink" title="旧式类型转换的使用场景："></a>旧式类型转换的使用场景：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                        <span class="comment">// with function-style </span></span><br><span class="line"><span class="built_in">castdoSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">// create Widget from int</span></span><br><span class="line">                                        <span class="comment">// with C++-style cast</span></span><br></pre></td></tr></table></figure><p>在function-style看起来更像类型转换。可进行显式构造函数中类型转换。</p><h3 id="RTII-Run-Time-Type-Identification"><a href="#RTII-Run-Time-Type-Identification" class="headerlink" title="RTII(Run Time Type Identification)"></a>RTII(Run Time Type Identification)</h3><blockquote><p>含义</p></blockquote><p>令编译器编译出运行期间执行的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)/y;</span><br></pre></td></tr></table></figure><p>将int 转型为double会产生一些代码，因为int与double的底层描述不相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drive</span>:<span class="keyword">public</span> Base&#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;<span class="comment">// implicitly convert Derived*⇒  Base*</span></span><br></pre></td></tr></table></figure><p>上述两个指针的值并不相同(&amp;d,pb)，这个时候会又一个偏移量运行期施加在Derived*指针上取得正确的指针值。</p><h3 id="转型容易写出似是而非的代码"><a href="#转型容易写出似是而非的代码" class="headerlink" title="转型容易写出似是而非的代码"></a>转型容易写出似是而非的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;<span class="comment">// base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;<span class="comment">// base onResize impl</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// derived onResize impl;</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">// cast *this to Window,</span></span><br><span class="line">                                         <span class="comment">// then call its onResize;</span></span><br><span class="line">                                        <span class="comment">// this doesn’t work!</span></span><br><span class="line">    ...<span class="comment">// do SpecialWindow-</span></span><br><span class="line">    &#125;<span class="comment">// specific stuff</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题所在</p></blockquote><p>static_cast(<em>this).onResize()，调用的onResize并不是当前对象上的函数，而是稍早转型动作所建立的一个 “</em>this对象的base class成分” 的<strong>暂时副本</strong>身上的onResize。</p><p>(函数就是函数，它只是一个成员仅此一份，关键在于成员函数都含有个隐藏的this指针，因此会影响成员操作数据)</p><p><strong>换句话来说就是会丢失在当前对象base-class中对数据的操作</strong></p><p><code>it does not invoke that function on the current object! Instead, the cast creates a new, temporary copy of the base class part of *this, then invokes onResize on the copy!</code> </p><blockquote><p>实际示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>():<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ++size; </span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>():<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;A&gt;(*<span class="keyword">this</span>).<span class="built_in">get_size</span>();  <span class="comment">//error</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如上述例子，我们的操作仅仅只是在*this指针强转得到一个副本上调用了函数，因此在当前对象上并没有调用base-class的成员函数，所有A::get_size中的size++不会在当前对象上作用，所以得到的结果为1.</p><blockquote><p>解决办法：去除类型转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>( );<span class="comment">// call Window::onResize</span></span><br><span class="line">    ...<span class="comment">// on *this</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic__cast"></a>dynamic__cast</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有指向base-class的一个pointer或reference时，想要去操作认定为derived-class对象身上执行derived-class操作函数，依靠该dynamic__cast转型方法实现</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>dynamic_cast的执行速度<strong>相当的慢</strong>，而且<strong>向下转型</strong>本就是一个<strong>不安全的行为</strong>，因此有两个办法用来取代dynamic__cast</p><h4 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h4><p>使用容器并在请汇总存储直接指向derived-class对象的指针(通常为只能指针)，消除了”通过base-class接口处理对象函数“的需要。</p><blockquote><p>示例</p></blockquote><p>假设先前的window/specialwindow继承体系只有specialwindows才支持闪烁效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span><span class="comment">// see Item13 for info</span></span><br><span class="line">std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;  </span><br><span class="line"><span class="comment">// on tr1::shared_ptr</span></span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// undesirable code:</span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// uses dynamic_cast++iter) </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;</span><br><span class="line">                                (iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();<span class="comment">// better code: uses </span></span><br><span class="line">        iter != winPtrs.<span class="built_in">end</span>();<span class="comment">// no dynamic_cast++iter)</span></span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure><p>缺陷在于无法在同一容器内存储指向window的任何派生类。处理多窗口需要多个容器，他们都具备类型安全性</p><h4 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h4><p>通过base-class接口处理所有window的所有派生类，就是在base-class内提供virtual函数做任何想多window派生类做的时</p><blockquote><p>示例</p></blockquote><p>虽然specialwindow可以闪烁，但或许将闪烁函数声明在base-class中并提供一份空的默认函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">// default impl is no-op;</span></span><br><span class="line">    ...                    <span class="comment">// see Item34 for why</span></span><br><span class="line">&#125;;<span class="comment">// a default impl may be</span></span><br><span class="line"><span class="comment">// a bad idea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;<span class="comment">// in this class, blink</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// does something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;<span class="comment">// container holds// (ptrs to) all possible</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Window types</span></span><br><span class="line"><span class="keyword">for</span> ( VPW::iterator iter = winPtrs.<span class="built_in">begin</span>( );iter != winPtrs.<span class="built_in">end</span>( );</span><br><span class="line">                ++iter)<span class="comment">// note lack of </span></span><br><span class="line">        (*iter)-&gt;<span class="built_in">blink</span>( );<span class="comment">// dynamic_cast</span></span><br></pre></td></tr></table></figure><p>无论是那种做法——”类安全容器“还是”virtual函数往继承体系上方移动“，都只是一个可行方案，需要靠自己判断</p><h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><p>✦Avoid casts whenever practical, especially dynamic_casts in perfor-mance-sensitive code. If a design requires casting, try to develop acast-free alternative. </p><p>✦When casting is necessary, try to hide it inside a function. Clientscan then call the function instead of putting casts in their own code.</p><p>✦Prefer C++-style casts to old-style casts. They are easier to see, andthey are more specific about what they do.</p><hr><h2 id="条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分"><a href="#条款28：避免返回handles-reference-pointer-iterators-指向对象内部成分" class="headerlink" title="条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分"></a>条款28：避免返回handles(reference,pointer,iterators)指向对象内部成分</h2><p><code>Avoid returning “handles” to object internals</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设您正在处理一个涉及矩形的应用程序，每个矩形可以由其左上角和右下角表示。要使矩形对象保持较小，可以决定定义其范围的点不应存储在矩形本身中，而应存储在矩形指向的辅助结构中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;<span class="comment">// Point data for a Rectangl</span></span><br><span class="line">    ePoint ulhc;<span class="comment">// ulhc = “ upper left-hand corner”</span></span><br><span class="line">    Point lrhc;<span class="comment">// lrhc = “ lower right-hand corner”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;RectData&gt; pData;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>对于Rectangle类我们添加两个const-reference member function，为何使用const-reference在<code>条款20</code>中有说明。但因此会导致以下问题。</p><h3 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;<span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                    <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);<span class="comment">// now rec goes from</span></span><br><span class="line">                        <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure><p>由上述代码可以得知，我们不仅仅能对矩形的点进行读，并且能够进行修改，那么我们<strong>定义的数据成员与public就没有什么两样</strong>。(虽然我们在upperLeft()函数添加了const定义，但我们只是不能对指向Rectdata的智能指针进行修改，可以对该对象内部的值进行修改)</p><blockquote><p>修改</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">( )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过将返回值加上const我们可以让const成员限定符不在是个fake，我们只能对数据进行读写。</p><p>但是这种方式仍然会引起下述问题</p><h3 id="dangling-handles-所指对象不存在"><a href="#dangling-handles-所指对象不存在" class="headerlink" title="dangling handles 所指对象不存在"></a>dangling handles 所指对象不存在</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rectangle                <span class="comment">// returns a rectangle by</span></span><br><span class="line"><span class="built_in">boundingBox</span>(<span class="type">const</span> GUIObject&amp; obj);<span class="comment">// value; see Item3 for why</span></span><br><span class="line">                                <span class="comment">//  return type is const</span></span><br><span class="line">=====================================================</span><br><span class="line"><span class="comment">//Now consider how a client might use this function:</span></span><br><span class="line">GUIObject *pgo;<span class="comment">// make pgo point to</span></span><br><span class="line">...            <span class="comment">// some GUIObject</span></span><br><span class="line"><span class="type">const</span> Point *pUpperLeft =            <span class="comment">// get a ptr to the upper </span></span><br><span class="line">    &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>( ));<span class="comment">// left point of its</span></span><br><span class="line">                                       <span class="comment">// bounding box</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析</p></blockquote><p>上述问题中会调用boundingBox(*pgo)函数对象，它所返回的值是一个临时的Rectangle副本(temp)，当我们用upperLeft去作用与temp身上，返回一个reference指向temp的一个内部成分</p><blockquote><p>错误</p></blockquote><p>当我们结束这段语句是会产生一个问题，就是我们的boundBox的返回值(temp)，将会被析构，也就是这个temp对象的内部成员都不复存在，那么我们的pUpperLeft就指向了一个<strong>不复存在的值</strong>。</p><h3 id="例外：operator"><a href="#例外：operator" class="headerlink" title="例外：operator[]"></a>例外：operator[]</h3><p>在vector和string容器中有个成员函数operator[]可以选择个别的元素，这个函数就是返回reference指向“容器内的数据”，但那些数据会随着容器的销毁而销毁。这仅仅只是有个例外。</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>✦Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helpsconst member functions act const, and minimizes the creation of dangling handles.</p><hr><h2 id="条款29：为”异常安全“而努力是值得的"><a href="#条款29：为”异常安全“而努力是值得的" class="headerlink" title="条款29：为”异常安全“而努力是值得的"></a>条款29：为”异常安全“而努力是值得的</h2><p><code>Strive for exception-safe code</code></p><blockquote><p>异常问题</p></blockquote><p>以class用来表现夹带背景图案的GUI菜单，运用于多线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;</span><br><span class="line">    ...  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image* bgImage;</span><br><span class="line">    <span class="type">int</span> imagechages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changebackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++ imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="”异常安全“的条件"><a href="#”异常安全“的条件" class="headerlink" title="”异常安全“的条件"></a>”异常安全“的条件</h3></blockquote><ol><li><p><strong>不泄漏任何资源</strong>：new Image(imgSrc)导致异常，对unlock的调用就绝不会执行。</p></li><li><p><strong>不允许数据败坏</strong>：new Iamge(imgSrc)抛出异常，bgImage就是指向一个被删除的对象，imageChanges以及被累加，而其实并没有新的图像被成功安装起来</p></li></ol><blockquote><p>RAII解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prettMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChages++;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>不在需要调用unlock</code></p><blockquote><h3 id="”异常安全函数“保证"><a href="#”异常安全函数“保证" class="headerlink" title="”异常安全函数“保证"></a>”异常安全函数“保证</h3></blockquote><ul><li><p><strong>基本承诺</strong>：异常抛出时，不会使对象或数据结构会因此而破坏，就数据保持异常抛出钱的状态</p></li><li><p><strong>强烈保证</strong>：异常抛出使，程序状态不会改变。(函数失败恢复到”调用函数之前“的状态)</p></li><li><p><strong>不抛掷保证</strong>：它们总能完成总能的原先承诺的功能</p></li></ul><h3 id="异常安全函数解决问题"><a href="#异常安全函数解决问题" class="headerlink" title="异常安全函数解决问题"></a>异常安全函数解决问题</h3><blockquote><h4 id="智能指针解决问题："><a href="#智能指针解决问题：" class="headerlink" title="智能指针解决问题："></a>智能指针解决问题：</h4></blockquote><p>1.引用智能指针类管理内存</p><p>2.将计数器的次序交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));<span class="comment">//以”new Image“;</span></span><br><span class="line">                                    <span class="comment">//设定bgImage内部指针</span></span><br><span class="line">    ++imageChagnes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><p>不需手动delete旧图像，而且删除操作是在对象被成功创建的之后，因此new成功后才会成功调用reset函数，Image（imgSrc）的临时对象也会在reset中释放掉（delete）</p><p><strong>问题</strong>：</p><p>Image构造函数会抛出异常（输出流的读取记号已经被移走）</p><h3 id="Copy-and-Swap"><a href="#Copy-and-Swap" class="headerlink" title="Copy and Swap"></a>Copy and Swap</h3><blockquote><p><strong>原则介绍</strong>：</p></blockquote><p>为你打造修改的对象（原件）做出一个副本，然后再那副本身上做一切的修改。若修改发生错误，源对象仍能保存原始状态。修改成功，则原件和副本做置换操作。</p><p>修改对象数据副本，一个<strong>不会抛出异常的函数</strong>（swap）中将修改后的数据和原件置换</p><blockquote><p>”隶属对象数据“ <strong>pimpi idiom</strong></p></blockquote><p>从原对象放进一个另一个对象内，然后赋予原对象一个指针，指向那个实现对象（副本）、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>&#123;<span class="comment">//pImpl是一个private成员具有封装性</span></span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettMenu</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettMenu::changeBackground</span><span class="params">(std::istream pImpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">//设计copy副本（值对象），保存原始数据</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;PMImpl&gt; <span class="title">ptemp</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    <span class="comment">//修改副本</span></span><br><span class="line">    ptemp-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line"></span><br><span class="line">    ptemp-&gt;imageChanges++;</span><br><span class="line">    <span class="comment">//原始对象与副本交换</span></span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);<span class="comment">//置换数据，释放mutex·</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>✦Exception-safe functions leak no resources and allow no data struc-tures to become corrupted, even when exceptions are thrown. Suchfunctions offer the basic, strong, or nothrow guarantees.</p><p>✦The strong guarantee can often be implemented via copy-and-swap,but the strong guarantee is not practical for all functions.</p><p>✦A function can usually offer a guarantee no stronger than the weak-est guarantee of the functions it calls. </p></blockquote><hr><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><code>Understand the ins and outs of inlining</code></p><h3 id="inline的细节"><a href="#inline的细节" class="headerlink" title="inline的细节"></a>inline的细节</h3><ol><li>inline函数代码量不易过大会导致程序体积过大，导致代码膨胀以至于额外的换页行为</li><li>inline只是对编译器的申请并不是强制命令，class内的函数被隐喻的称为inline</li><li>inline通常被置于头文件，在编译过程中进行inlining，而为将一个“函数调用”替换为“被调用函数的本体”</li></ol><h3 id="inline的声明"><a href="#inline的声明" class="headerlink" title="inline的声明"></a>inline的声明</h3><blockquote><p>隐式声明为inline的函数</p></blockquote><ul><li>member函数</li><li>friend函数</li></ul><blockquote><p>不应被声明为inline的函数</p></blockquote><ul><li>构造以及析构函数</li></ul><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>✦Limit most inlining to small, frequently called functions. This facili-tates debugging and binary upgradability, minimizes potential codebloat, and maximizes the chances of greater program speed.</p><p>✦Don’t declare function templates inline just because they appear inheader files.</p><hr><h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p><code>Minimize compilation dependdencies between files</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>( <span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr);</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string theName;<span class="comment">// implementation detail</span></span><br><span class="line">Date theBirthDate;<span class="comment">// implementation detail</span></span><br><span class="line">Address theAddress;<span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要想让Person class编译需要加入以下头文件的类或函数声明式</p><h1 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="include &lt; string &gt;"></a>include &lt; string &gt;</h1><h1 id="include-“date-h”"><a href="#include-“date-h”" class="headerlink" title="include “date.h”"></a>include “date.h”</h1><h1 id="include-“address-h”"><a href="#include-“address-h”" class="headerlink" title="include “address.h”"></a>include “address.h”</h1><p>但这样会导致这些文件中形成一种编译的<strong>依存关系</strong>，所依赖的头文件发生改变都会让Person class的头文件进行重新文件</p><blockquote><p>将class的实现细目至于class的定义式中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">string</span>;<span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// one — see below)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><ol><li><p>string前置声明错误，正确的也复杂</p></li><li><p>前置声明每一个东西困难的是，编译器必须知道对象的大小</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(params)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器清楚的知道int需要多大，而Person需要询问class的定义式。</p><p>针对于Person类可以用以下方法：将Person分割为两个classes，一个只<strong>提供接口</strong>，一个只负责<strong>实现该接口</strong>。将负责实现的Implementation class取名为PersonImpl，Person将定义如下</p><h3 id="pimpl-idiom-pointer-to-implementation"><a href="#pimpl-idiom-pointer-to-implementation" class="headerlink" title="pimpl idiom(pointer to implementation)"></a>pimpl idiom(pointer to implementation)</h3><p><em>pimpl 惯例</em>是一种新式 C++ 技术，用于<strong>隐藏实现、最小化耦合和分离接口</strong>。 Pimpl 对于”指向实现的指针”是短的。你可能已熟悉概念，但通过其他名称（如 Che一 cat 或编译器防火墙惯例）了解它。</p><p>下面是 pimpl 惯例如何改进软件开发生命周期：</p><ul><li><p>最大程度地减少编译依赖项。</p></li><li><p>接口和实现分离。</p></li><li><p>可移植性。</p></li></ul><blockquote><p>优点</p></blockquote><p>有较好的封装性以及减少客户端的文件依赖性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pimpl</span></span><br><span class="line"><span class="comment">// 在头文件person.hpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Person类的实现细节放置在该前向声明的实现类中。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  <span class="comment">// 指向实现类Impl的私有指针</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源文件person.cpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;basic_info.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>::Impl &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string id;</span><br><span class="line">  BasicInfo basic_info;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>() : <span class="built_in">pimpl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>1.减少了需要包含的头文件；2.当内部实现发生变化时，客户端的代码不需要重新编译。例如：客户端在gcc编译中只需要连接上其动态连接库或者静态库文件，这时候服务端已经将所需的文件的编译完了，可以减少客户端编译的时间</p><p>由此修改以上Person代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="comment">// standard library components</span></span></span><br><span class="line"><span class="comment">// shouldn’t be forward-declared</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for tr1::shared_ptr; see belowclass PersonImpl;</span></span></span><br><span class="line"><span class="comment">// forward decl of Person impl. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// forward decls of classes used in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                    <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// ptr to implementation;</span></span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;<span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;<span class="comment">// std::tr1::shared_ptr</span></span><br></pre></td></tr></table></figure><p>上述代码main class中内涵一个</p><p>这样的设计下，Person的客户就完全与Dataes，Address以及Persons的实现的细目分离。因此哪些classes的任何实现修改都不需要Person客户断重新编译。“接口与实现分离”</p><blockquote><p>关键</p></blockquote><p>这个分离在于以“声明的依存性”替换为“定义的依存性”，编译最小化的本质：现实中让头文件尽可能的自我满足，万一做不到，则让他与其他文件内的声明式(并非定义式)相依</p><h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>■Avoid using objects when object references and pointers will do</p><p>■Depend on class declarations instead of class definitions whenever you can.</p><p>声明函数而它用到某个class式，你并不需要改class的定义：纵使函数以by value方式传递改类型的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// class declaration</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// fine — no definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;<span class="comment">// of Date is needed</span></span><br></pre></td></tr></table></figure><p>声明这两个函数的无需Date的定义式，但是当有人调用哪些函数式，调用之前需要让Date的定义式曝光</p><p>如果将”提供class定义式“（通过#include完成）的义务冲”<strong>函数声明所在</strong>“之头文件转移到”<strong>内涵函数调用</strong>“之客户文件，便可将”<strong>并非真正必要的类型定义</strong>“与客户端之间的<strong>编译依存</strong>去除掉</p><p>■Provide separate header files for declarations and definitions</p><p>需要两个头文件，一个用于声明式，一个用于定义式。文件必须保持一致性，如果声明式被改变，两个文件都需要改变。<strong>#include一个声明文件</strong>而非前置声明若干函数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span><span class="comment">// header file declaring (but not</span></span></span><br><span class="line">                    <span class="comment">// defining) </span></span><br><span class="line"><span class="function"><span class="keyword">class</span> DateDate <span class="title">today</span><span class="params">( )</span></span>;<span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>C++中提供关键字export，允许将template声明式和template定义式分割与不同的文件内，但式这个关键字在有些编译器里不支持</p><h3 id="Handle-classses"><a href="#Handle-classses" class="headerlink" title="Handle classses"></a>Handle classses</h3><p>像Person这样使用pimpl idiom的classes，被称为Handle classes。</p><blockquote><p>方法一</p></blockquote><p>将他们的所有函数转交给一个相应的实验类并由后者完成实际工作。例如卖弄Person的两个成员函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span><span class="comment">// we must also #include PersonImpl’s class</span></span></span><br><span class="line"><span class="comment">// definition, otherwise we couldn’t call </span></span><br><span class="line"><span class="comment">// its member functions; note that </span></span><br><span class="line"><span class="comment">// PersonImpl has exactly the same public</span></span><br><span class="line"><span class="comment">// member functions as Person — their</span></span><br><span class="line"><span class="comment">// interfaces are identical</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">            <span class="type">const</span> Address&amp; addr): </span><br><span class="line">                        <span class="built_in">pImpl</span>(<span class="keyword">new</span> </span><br><span class="line">                            <span class="built_in">PersonImpl</span>(name, birthday, addr))&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">( )</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调PersonImpl::name，让Person百年城一个Handle class但不会改变他做的事，只会改变它做事的方法</p><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>令Person称为一个特殊的抽象基类，称为interface class。这汇总class的目的事猫叔derived的接口，因此他通常不带有成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtal函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>class的用户必须以Person的pointer和reference来写应用程序，因为他不可能针对”内含pure virtual函数“的person classes具体出实体。</p><p>interface class的客户必须有办法为这种class创建新的对象。</p><p>如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt;</span><br><span class="line">                    <span class="comment">// return a tr1::shared_ptr to a new</span></span><br><span class="line">    <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,<span class="comment">// Person initialized with the</span></span><br><span class="line">            <span class="type">const</span> Date&amp; birthday,<span class="comment">// given params; see Item18 for</span></span><br><span class="line">            <span class="type">const</span> Address&amp; addr);<span class="comment">// why a tr1::shared_ptr is returned</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户将会这样使用这些接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;Address address;</span><br><span class="line">...<span class="comment">// create an object supporting the Person interface</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 address))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>( )</span><br><span class="line">                            <span class="comment">// use the object via the</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot; was born on &quot;</span></span><br><span class="line">                            <span class="comment">// Person interface</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>( )</span><br><span class="line">    &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">    &lt;&lt; pp-&gt;<span class="built_in">address</span>( );</span><br><span class="line">    ...                    <span class="comment">// the object is automatically </span></span><br><span class="line">                            <span class="comment">// deleted when pp goes out of </span></span><br><span class="line">                            <span class="comment">// scope </span></span><br></pre></td></tr></table></figure><p>支持interface class接口的那个concrete class 必须被定义出来，而其真正的构造函数必须被调用。一切都在virtual构造函数实现所在的文件内放生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line"><span class="type">const</span> Address&amp; addr):   <span class="built_in">theName</span>(name), </span><br><span class="line"><span class="built_in">theBirthDate</span>(birthday), </span><br><span class="line"><span class="built_in">theAddress</span>(addr)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>( ) &#123; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// implementations of these </span></span><br><span class="line"><span class="function">std::string <span class="title">birthDate</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// functions are not shown, but </span></span><br><span class="line"><span class="function">std::string <span class="title">address</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// they are easy to imagineprivate:</span></span><br><span class="line">std::string theName;Date theBirthDate;Address theAddress;&#125;;</span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">//Given RealPerson, it is truly trivial to write Person::create:</span></span><br><span class="line">std::tr1::shared_ptr&lt;Person&gt; Person::</span><br><span class="line">                        <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">                                    <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                        <span class="type">const</span> Address&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> </span><br><span class="line">                        <span class="built_in">RealPerson</span>( name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更现实的Person::create实现代码会创建不同类型的derived class对象。取决于额外参数值、读自文件或数据库的数据、环境变量。</p><p>RealPerson示范实现了Interface class 的两个最常见的机制之一：从Interface class继承接口规格，然后实现出接口所覆盖的函数。第二点则是多重继承</p><h3 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h3><p>✦The general idea behind minimizing compilation dependencies is todepend on declarations instead of definitions. Two approachesbased on this idea are Handle classes and Interface classes.</p><p>✦Library header files should exist in full and declaration-only forms.This applies regardless of whether templates are involved.</p><hr><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑造出的is-a关系"><a href="#条款32：确定你的public继承塑造出的is-a关系" class="headerlink" title="条款32：确定你的public继承塑造出的is-a关系"></a>条款32：确定你的public继承塑造出的is-a关系</h2><p><code>Make sure public inheritance models &quot;is-a&quot;</code></p><p>通过public继承出的关系为“is-a”关系，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// fine, s is a Student,</span></span><br><span class="line">        <span class="comment">// and a Student is-a Person</span></span><br><span class="line"><span class="built_in">study</span>(s);<span class="comment">// fine</span></span><br><span class="line"><span class="built_in">study</span>(p);<span class="comment">// error! p isn’t a Student</span></span><br></pre></td></tr></table></figure><p>如上述关系可以表述出学生是人，但人这个抽象类却不一定是人</p><h3 id="is-a的误区"><a href="#is-a的误区" class="headerlink" title="is-a的误区"></a>is-a的误区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="comment">// birds can fly</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    <span class="comment">// penguins are birds</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>错误</p></blockquote><p>这个继承体系中说明企鹅是鸟的派生类，那么它应该含有鸟类的所有行为，但是企鹅却不会飞，这点显得不是特别的严谨。我们应该让is-a有较佳的真实性</p><h3 id="方法一-双class继承体系"><a href="#方法一-双class继承体系" class="headerlink" title="方法一:双class继承体系"></a>方法一:双class继承体系</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// no fly function is declared </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二：运行期错误"><a href="#方法二：运行期错误" class="headerlink" title="方法二：运行期错误"></a>方法二：运行期错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;<span class="comment">// defined elsewhere</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Attempt to make a penguin fly!&quot;</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处声明出企鹅是不会飞的，那么说企鹅会飞则是一种错误的认知，在运行期的时候会被检测出来</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结:"></a>总结:</h3><p>✦Public inheritance means “is-a.” Everything that applies to baseclasses must also apply to derived classes, because every derivedclass object is a base class object.</p><hr><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p><code>Avoid hiding inherited names</code></p><h3 id="命名查找规则-作用域"><a href="#命名查找规则-作用域" class="headerlink" title="命名查找规则(作用域)"></a>命名查找规则(作用域)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>&#123;<span class="built_in">mf2</span>();&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-30-29-image.png" alt=""></p><p>Base的作用域大于Derived的作用域，根据命名查找法，当我们在Derived类中查找mf2时，选择方向Derived-&gt;Base-&gt;global。小一级的作用域会将其覆盖。</p><h3 id="名称可视性-name-visibility"><a href="#名称可视性-name-visibility" class="headerlink" title="名称可视性(name visibility)"></a>名称可视性(name visibility)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-11-37-52-image.png" alt=""></p><p>Base内名为mf1和mf3的重载函数都被Derived内的mf1和mf3函数所遮掩。从名称查找观点来看Base::mf1和Base::mf3不在被Derived继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1d.mf1(x);</span></span><br><span class="line">        <span class="comment">// error! Derived::mf1 hides Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );<span class="comment">// fine, calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// error! Derived::mf3 hides Base::mf3</span></span><br></pre></td></tr></table></figure><p>更具以上代码可知，当我们在重载函数时，在子类中就只能对Derived作用域的函数名可见，但是对于重载函数是不可见的。不论是virtual还是non-virtual都是一样。</p><h3 id="解决继承来的名称的遮掩行为"><a href="#解决继承来的名称的遮掩行为" class="headerlink" title="解决继承来的名称的遮掩行为"></a>解决继承来的名称的遮掩行为</h3><blockquote><p>违反is-a关系</p></blockquote><p>当public继承而又不继承哪些重载函数就是违反base和deriver class之间的<strong>is-a关系</strong> </p><blockquote><p>using声明表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1;<span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line"><span class="keyword">using</span> Base::mf3;<span class="comment">// visible (and public) in Derived’s scope</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">( )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-03-12-47-00-image.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// still fine, still calls Derived::mf1d.mf1(x);</span></span><br><span class="line"><span class="comment">// now okay, calls Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>( );</span><br><span class="line"><span class="comment">// still fine, still calls Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>( );<span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// now okay, calls Base::mf3 (The int x is </span></span><br><span class="line">        <span class="comment">// implicitly converted to a double so that</span></span><br><span class="line">        <span class="comment">// the call to Base::mf3 is valid.</span></span><br></pre></td></tr></table></figure><p>用using声明，derived类继承了base并加上了重载函数，此时也可以重写一部分重载函数将base的函数给覆盖。</p><h3 id="forward-function转交函数"><a href="#forward-function转交函数" class="headerlink" title="forward function转交函数"></a>forward function转交函数</h3><blockquote><p>使用场景</p></blockquote><p>不想继承base的所有函数，在“is-a”中会违背其含义</p><blockquote><p>private继承</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">...<span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span>    <span class="comment">// forwarding function; implicitly</span></span></span><br><span class="line"><span class="function"></span>&#123; Base::<span class="built_in">mf1</span>( ); &#125;    <span class="comment">// inline — see Item30. (For info...</span></span><br><span class="line">                    <span class="comment">// on calling a pure virtual</span></span><br><span class="line"><span class="comment">//-------继承private----------</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="comment">//---------------------------</span></span></span><br><span class="line"><span class="function">&#125;</span>;<span class="comment">// function, see Item34.)</span></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>( );<span class="comment">// fine, calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">// error! Base::mf1( ) is hidden</span></span><br></pre></td></tr></table></figure><blockquote><p>inline转交函数的用途</p></blockquote><p>哪些不支持using声明式，将继承而得的名称汇入derived作用域</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>✦Names in derived classes hide names in base classes. Under publicinheritance, this is never desirable. </p><p>✦To make hidden names visible again, employ using declarations orforwarding functions.</p><hr><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p><code>Difference between inheritance of interface and inheritance of implementation</code></p><blockquote><p>public继承概念</p></blockquote><p><strong>函数接口继承</strong>和<strong>函数实现继承</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数的接口总是会被继承"><a href="#成员函数的接口总是会被继承" class="headerlink" title="成员函数的接口总是会被继承"></a>成员函数的接口总是会被继承</h3><p>public为is-a关系继承，所有对Base class为真的事件对于Derived class也为真。</p><blockquote><p>接口与实现</p></blockquote><ul><li>接口：是(对外或者对继承)可视的，定义一个的对象实体可以通过(对外可视的)接口去访问该对象</li><li>实现：是一个实体，可以看作是接口所要做到事，对外不一定可见，对内一定可见</li></ul><blockquote><p>pure virtual函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>pure virtual函数的特性：</p></blockquote><ul><li><p>必须被他们所继承的具象类所<strong>重新声明</strong></p></li><li><p>抽象类中通常没有对该函数的定义</p></li></ul><h3 id="pure-virtual函数-子类必须重写"><a href="#pure-virtual函数-子类必须重写" class="headerlink" title="pure virtual函数(子类必须重写)"></a>pure virtual函数(子类必须重写)</h3><blockquote><p><strong>让derived class只继承接口</strong></p></blockquote><p>shape class无法对shape::draw函数提供合理的默认实现，比较其模棱两可(椭圆和矩形的画法)，因此在具象derived class 中<strong>必须提供</strong>一个draw函数，并且不干涉如何实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape;<span class="comment">// error! Shape is abstract</span></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;<span class="comment">// fine 多态</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Rectangle::draw</span></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;<span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>( );<span class="comment">// calls Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls base class pure virtual函数也可以有实现</span></span><br><span class="line">Shape::drawps2-&gt;Shape::<span class="built_in">draw</span>();<span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure><h3 id="impure-virtual函数-可选是否重写"><a href="#impure-virtual函数-可选是否重写" class="headerlink" title="impure virtual函数(可选是否重写)"></a>impure virtual函数(可选是否重写)</h3><blockquote><p><strong>让derived class继承函数的接口和默认实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Shaped::error的声明式要求derived classes必须<strong>支持一个error函数</strong>，但如果不想自己写一个，那么就可以使用<strong>Shaped class提供的默认版本</strong></p><h3 id="non-virtual函数-不能重写"><a href="#non-virtual函数-不能重写" class="headerlink" title="non-virtual函数(不能重写)"></a>non-virtual函数(不能重写)</h3><blockquote><p><strong>让derived class继承函数的接口及一份强制性实现</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>non-virtual函数：并不打算在derived classes中有不同的行为。实际上non-virtual函数表现的不变性(invariant)大于其特异性(specialization)。</p><p>例如：Shape::objectID是有特定计算ID的一个函数，该方法是由其定义式决定的，任何derived class都<strong>不应该修改其行为</strong>，<strong>不应该在derived class中被重新定义</strong>。(<strong>破坏多态性</strong>)</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>✦Inheritance of interface is different from inheritance of implementa-tion.  Under  public  inheritance,  derived  classes  always  inherit  baseclass interfaces.</p><p>✦Pure virtual functions specify inheritance of interface only. </p><p>✦Simple  (impure)  virtual  functions  specify  inheritance  of  interfaceplus inheritance of a default implementation. </p><p>✦Non-virtual  functions  specify  inheritance  of  interface  plus  inherit-ance of a mandatory implementation.</p><h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><p><code>Consider alternatives to virtual function</code></p><p>设计一个计算人物生命值的函数healthValue()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// return character’s health rating;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// derived classes may redefine this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们一impure virtual函数去声明函数，那么当子类不提供函数重写那么人物将采用默认的声明值的计算方法</p><h3 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h3><p>Non-virtual interface实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span><span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// this — see Item36</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “before” stuff — see below</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>( );<span class="comment">// do the real work </span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// do “after” stuff — see below</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// default algorithm for calculating&#125;</span></span><br><span class="line">    <span class="comment">// character’s health</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本设计</p></blockquote><p>令客户通过public non-virtual成员函数去间接的调用private virtual函数，因此称为non-virtual(NVI)手法。</p><blockquote><p>优点</p></blockquote><p>NVI手法的优点在于“do ‘before’ stuff”和“do ‘after’ stuff”在上述的注释代码中，在Wrapper（healthValue）中设定好virtual函数的<strong>应用场景</strong></p><ul><li><p>“do ‘before’ stuff”：locking a mutex, making a log entry(日志记录项), verifying that class invariants and function preconditions aresatisfied, etc</p></li><li><p>“do ‘after’ stuff”：unlocking a mutex, veri-fying function postconditions, reverifying class invariants(再次验证class的约束条件), etc.</p></li></ul><blockquote><p>疑问</p></blockquote><p>NVI手法中涉及到derived class时base class private virtual 函数我们无法调用，但是我们需要redefining这些我们不会调用的private virtual 函数，看起来十分的矛盾。但时调用virtual函数表示它在”何时“被完成，但重定义virtual函数表示”如何“完成，这两者并不冲突。</p><p>NVI允许derived重新定义virtual函数，从而赋予了它如何具体实现的机能，但base class仍然保留函数合适被调用的权力</p><blockquote><p>特别的</p></blockquote><p>NVI手法中的virtual函数并不是非得是private。某些继承体要求在derived class中对应的实现必须调用器base class的对应兄弟，为了合法，那么就必须的设置为protect。</p><h3 id="Strategy-Pattern-via-Function-Pointers"><a href="#Strategy-Pattern-via-Function-Pointers" class="headerlink" title="Strategy Pattern via Function Pointers"></a>Strategy Pattern via Function Pointers</h3><blockquote><p>设计主张</p></blockquote><p>”人物的健康指数的计算与每个人物的类型无关“，这样的计算不需要人物这个成分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; </span><br><span class="line"><span class="comment">// forward declaration</span></span><br><span class="line"><span class="comment">// function for the default health calculation algorithm</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                    healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>优点</p></blockquote><p>相比virtual函数继承，这种设计模式提供了更好的弹性</p><blockquote><p>实例</p></blockquote><ul><li>在<strong>同一类型的不同的实体</strong>中应用不同的计算函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                        GameCharacter(hcf )</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculationint lose</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// funcs with different</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;<span class="comment">// same-type charac-</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;<span class="comment">// ters with different// health-related</span></span><br><span class="line">                                    <span class="comment">// behavior</span></span><br></pre></td></tr></table></figure><ul><li>已知人物的健康指数计算函数可在运行期变更。例如：base类可以提供一个成员函数setHealthCalculator，用来替换当前的健康计算函数</li></ul><h3 id="Strategy-Pattern-via-tr1-function"><a href="#Strategy-Pattern-via-tr1-function" class="headerlink" title="Strategy Pattern via tr1::function"></a>Strategy Pattern via tr1::function</h3><blockquote><p>函数指针的限制</p></blockquote><p>对template以及他们的的隐式接口的使用，基于函数的指针的做法就十分的死板。不够灵活，例如返回类型只能是int，函数对象不能是member function</p><blockquote><p>tr1::function</p></blockquote><p>改用tr1::function的对象替代函数指针，这样的对象可持有任何可调用物(callable entity 函数指针、函数对象、成员函数指针)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;<span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// HealthCalcFunc is any callable entity that can be called with</span></span><br><span class="line"><span class="comment">// anything compatible with a GameCharacter and that returns anything</span></span><br><span class="line"><span class="comment">// compatible with an int; see below for details</span></span><br><span class="line"><span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span>:</span></span><br><span class="line"><span class="function">                                             healthFunc(hcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个实例中我们用tr1::function instantiation来代替目标签名式。那个签名代表的函数时”接受一个reference 指向const GamCharacter“，并返回int。这个tr1::function类型产生的对象可持有任何与此签名式兼容的可调用物。例如可调用物的<strong>参数可以被隐式的转换为const GameCharacters&amp;</strong>，其<strong>返回类型可以被隐式转换为int</strong></p><p>tr1::function对象相当于指向函数的泛化指针。</p><blockquote><p>更具与弹性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// health calculation</span></span><br><span class="line"><span class="comment">// function; note </span></span><br><span class="line"><span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class for health</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span><span class="comment">// calculation function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;<span class="comment">// objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// health calculation</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mem function; note</span></span><br><span class="line">&#125;;<span class="comment">// non-int return type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">// another character</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// type; assume same</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constructor as // EvilBadGuy</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;<span class="comment">// character using a</span></span><br><span class="line">                <span class="comment">// health calculation// function</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator( ))</span></span>;<span class="comment">// character using a </span></span><br><span class="line">                <span class="comment">// health calculation// function object</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// see below for details);</span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>解析ebg2 -&gt; bind</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">( <span class="comment">// character using a</span></span></span></span><br><span class="line"><span class="params"><span class="function"> std::tr1::bind(&amp;GameLevel::health,<span class="comment">// health calculation</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            currentLevel,    <span class="comment">// member function;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      _1)</span></span></span><br></pre></td></tr></table></figure><p>GameLevel::health接受两个参数，一个是隐式参数currentLevel，也就是this指向的那个、另一个是reference指向GameCharactor。</p><p>GameCharacters的健康计算函数值接受单一参数：GameCharacters。</p><p>使用GameLevel::health作为ebg2的健康计算函数，我们需要以特殊方式转换，取出GameLevel其中的健康计算函数。</p><p>本例中用currentLevel作为ebg2的健康函数所需的GameLevel的对象。_1意味着用currenLevel作为GamLevel的对象</p><h3 id="the-“Classic”-Strategy-Pattern"><a href="#the-“Classic”-Strategy-Pattern" class="headerlink" title="the “Classic” Strategy Pattern"></a>the “Classic” Strategy Pattern</h3><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-06-21-21-05-image.png" alt=""></p><p>在该图中指示了GameCharacte是某个继承体系的根类，EviBadGuy与EyeCandyCharacter都是derived classes：HealthCalcFunc是另一个继承体系的根类。</p><blockquote><p>实现代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span>: </span></span><br><span class="line"><span class="function">                                                pHealthCalc(phcf )&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">( )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>✦Alternatives to virtual functions include the NVI idiom and variousforms of the Strategy design pattern. The NVI idiom is itself an ex-ample of the Template Method design pattern.</p><p>✦A disadvantage of moving functionality from a member function to afunction outside the class is that the non-member function lacks ac-cess to the class’s non-public members.</p><p>✦tr1::function objects act like generalized function pointers. Such ob-jects support all callable entities compatible with a given target sig-nature.</p><hr><h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p><code>Never redefine an inherited non-virtual function</code></p><blockquote><p>non-virtual性质</p></blockquote><p>在条款34中描述了non-virtual函数会给class建立一个<strong>不变性</strong>(invariant),凌驾其<strong>特异性</strong>(specialization)</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line">                <span class="comment">//Even without knowing anything about B, D, or mf, given an object x of</span></span><br><span class="line">                <span class="comment">//type D,</span></span><br><span class="line">D x;            <span class="comment">// x is an object of type D</span></span><br><span class="line">                <span class="comment">//you would probably be quite surprised if this,</span></span><br><span class="line">B *pB = &amp;x;      <span class="comment">// get pointer to xp</span></span><br><span class="line">B-&gt;<span class="built_in">mf</span>( );        <span class="comment">// call mf through pointerbehaved differently from this:</span></span><br><span class="line">D *pD = &amp;x;     <span class="comment">// get pointer to xp</span></span><br><span class="line">D-&gt;<span class="built_in">mf</span>( );      <span class="comment">// call mf through pointer</span></span><br></pre></td></tr></table></figure><p>上述示例中我们都会调用<strong>B::mf()</strong> 版函数，但是如果我们在D class中重写mf()那么我们会发现以下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">( )</span></span>;    <span class="comment">// hides B::mf; see Item33</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>( );        <span class="comment">// calls D::mf should call B::mf</span></span><br></pre></td></tr></table></figure><blockquote><p>non-virtual函数是一种<strong>静态绑定</strong>(statically bound)</p></blockquote><pre><code>    在子类中重写non-virutal函数，它会根据其**声明式** (也就是D* ,B*)来选取函数执行，但实际上pB与pD指向都是**同一对象**，按理来说应该调用同一对象的函数，因此重写non-virtual函数会**导致破坏多态性**。</code></pre><blockquote><p>public继承关系</p></blockquote><p>public继承关系”is-a”关系，那么non-vitual函数的作用(不变性凌驾于特异性):</p><ol><li><p>适用于B对象的每一件事，也适用与D对象</p></li><li><p>B的derived classes一定会继承mf的接口与实现，因为mf是B的一个non-virutal函数</p></li></ol><blockquote><p>多态性的虚构问题</p></blockquote><p>   条款7： virtual析构函数，对于B<em> pd = new D();由于声明的是non-virtual的析构函数，那么执行的时候会根据<em>*声明式来定义</em></em> 静态绑定调用函数，因此在多态中只会使用B的析构函数，对于D的析构则不会调用，这时候有些D类的成员不能被析构，会导致内存泄漏问题</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited non-virtual function.</p><hr><h2 id="条款37：绝不重新定义继承而来的默认参数值"><a href="#条款37：绝不重新定义继承而来的默认参数值" class="headerlink" title="条款37：绝不重新定义继承而来的默认参数值"></a>条款37：绝不重新定义继承而来的默认参数值</h2><p><code>Never redefine a function&#39;s inherited default parameter value</code></p><p><strong>virtual函数系动态绑定，然而默认的却是静态绑定</strong></p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><blockquote><p>静态绑定义</p></blockquote><pre><code>    在程序中被**声明时**所采用的类型,静态绑定容易造成的问题如：继承类重写non-virtual函数</code></pre><p>简单来说就是调用对象是采用声明对象的一部分行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// a class for geometric shapes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="comment">// all shapes must offer a function to draw themselves</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Shape::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// notice the different default parameter value — bad!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Rectangle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Circle::darw &quot;</span>&lt;&lt;color&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shape *ps;                    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pc = <span class="keyword">new</span> <span class="built_in">Circle</span>();    <span class="comment">// static type = Shape*</span></span><br><span class="line">    Shape *pr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();<span class="comment">// static type = Shape*</span></span><br><span class="line">    ps = pc;</span><br><span class="line">    ps = pr;</span><br><span class="line">   <span class="comment">// ps-&gt;draw();</span></span><br><span class="line">    pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">draw</span>();<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承关系</p></blockquote><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-07-20-28-31-image.png" alt=""></p><blockquote><p>指针(静态类型)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;    <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;<span class="comment">// static type = Shape*</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><blockquote><p>动态绑定定义</p></blockquote><pre><code>   普遍的来说是多态性，由一个**静态类型**的对象指针(引用)指向一个子类对象，在运行其就会将行为于其指向的对象进行绑定，调用子类对象的行为。    简单来说就是调用指向对象的行为</code></pre><blockquote><p>动态类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc;<span class="comment">// ps’s dynamic type is// now Circle*</span></span><br><span class="line">ps = pr;<span class="comment">// ps’s dynamic type is// now Rectangle*</span></span><br></pre></td></tr></table></figure><blockquote><p>调用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red);<span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">====================</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Circle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br><span class="line">Rectangle::darw <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>问题分析:动态绑定与静态绑定冲突</p></blockquote><pre><code>    在pr-&gt;draw();中出现了问题，pr的动态类型为Rectangle调用为virtual函数，但Rectangle::draw默认参数为应该时GREEN，但由于pr的静态类型为Shape*，所以此一调用的默认阐述时来自于Shape class，而不是来之于Rectangle class。这个函数时两个类共同完成的</code></pre><h3 id="NVI解决方案"><a href="#NVI解决方案" class="headerlink" title="NVI解决方案"></a>NVI解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span><span class="comment">// now non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);<span class="comment">// calls a virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">                                    <span class="comment">// the actual work is</span></span><br><span class="line">&#125;;<span class="comment">// done in this func</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;<span class="comment">// note lack of a</span></span><br><span class="line">    ...<span class="comment">// default param val.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>    non-virtual 函数一个不会被derived classes重写(条款36)，所以这个设计很清楚地使用了color的默认值为Red，相当于强制性不让动态绑定选择静态绑定的参数，NVI手法将动态绑定和静态绑定通过**private在继承中可见性**，进行了巧妙的结合</code></pre><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>✦Never redefine an inherited default parameter value, because defaultparameter values are statically bound, while virtual functions — theonly functions you should be redefining — are dynamically bound.</p><hr><h2 id="条款38：通过复合塑造出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑造出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑造出has-a或“根据某物实现出”"></a>条款38：通过复合塑造出has-a或“根据某物实现出”</h2><p><code>Model &quot;has-a&quot;or&quot;is-implement-in-terms-of&quot; throught composition</code></p><blockquote><p>复合类型</p></blockquote><p>在一个类中的数据成员是一个或者多个自定义数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; </span><br><span class="line">... </span><br><span class="line">&#125;;<span class="comment">// where someone lives</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name;<span class="comment">// composed object</span></span><br><span class="line">Address address;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber voiceNumber;<span class="comment">// ditto</span></span><br><span class="line">PhoneNumber faxNumber;<span class="comment">// ditto</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>has-a与is-a</p></blockquote><p>在上述Person中定义了name、address、voiceNumber、faxNumber，我们都很容易说，这个人有一个名字、地址、号码，但我们不能说这个人是一个名字，另外is-a是一种继承关系</p><h3 id="复合类型中的has-a和“根据某物实现出”区分"><a href="#复合类型中的has-a和“根据某物实现出”区分" class="headerlink" title="复合类型中的has-a和“根据某物实现出”区分"></a>复合类型中的has-a和“根据某物实现出”区分</h3><ul><li><p>has-a是应用域</p></li><li><p>is-implement-in-terms-of是实现域</p></li></ul><p>用Set&lt; T &gt;继承list&lt; T &gt;声明如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//将list应用于Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:<span class="keyword">public</span> std::list&lt;T&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>根据上述继承关系很容易区分出错误，list可以插入相同元素，Set不能含有相同元素，因此在逻辑上，Set不适用于list的逻辑，因此也不是is-a关系，所以对于这两种关系不能用public来实现.</p><blockquote><p>正确做法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">// the right way to use list for Set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;<span class="comment">// representation for Set data </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过复合类型可以很明显的看出关系，Set只是依赖list来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="type">const</span> T&amp; item) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item) != rep.<span class="built_in">end</span>( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; item)&#123; </span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::iterator it =<span class="comment">// see Item42 for info on</span></span><br><span class="line">    std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>( ), rep.<span class="built_in">end</span>( ), item);<span class="comment">// “typename” here</span></span><br><span class="line">                <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>( )) rep.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>✦Composition has meanings completely different from that of publicinheritance. </p><p>✦In the application domain, composition means has-a. In the imple-mentation domain, it means is-implemented-in-terms-of.</p><hr><h2 id="条款39：谨慎的使用“private”继承"><a href="#条款39：谨慎的使用“private”继承" class="headerlink" title="条款39：谨慎的使用“private”继承"></a>条款39：谨慎的使用“private”继承</h2><p><code>use private inheritance judiciously</code></p><h3 id="Private-继承"><a href="#Private-继承" class="headerlink" title="Private 继承"></a>Private 继承</h3><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;; <span class="comment">// inheritance is now private</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;<span class="comment">// anyone can eat</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;<span class="comment">// only students study</span></span><br><span class="line">Person p;<span class="comment">// p is a PersonStudent s;// s is a Student</span></span><br><span class="line"><span class="built_in">eat</span>(p);<span class="comment">// fine, p is a Person</span></span><br><span class="line"><span class="built_in">eat</span>(s);<span class="comment">// error! a Student isn’t a Person</span></span><br></pre></td></tr></table></figure><blockquote><p>private继承</p></blockquote><p>根据以上代码的展示，我们会发现private继承与public继承不是同一个含义，同样的public继承会产生一些逻辑上的错误，例如学生不是人</p><ul><li>private继承不会有隐式转换，同样<strong>不能多态</strong></li><li>private的语义为根据某物实现( is-implemented-in-terms-of),不会对外呈现父类的接口</li><li>private继承中base的成员都会变为private无论是protected还是public</li></ul><p>因此，private只在软件的实现中会有意义，在软件的设计中毫无意义</p><h3 id="复合与private继承的抉择"><a href="#复合与private继承的抉择" class="headerlink" title="复合与private继承的抉择"></a>复合与private继承的抉择</h3><p>private继承与复合都有根据某物实现( is-implemented-in-terms-of)的概念。</p><blockquote><p>取舍</p></blockquote><p>尽可能的选择复合，必要时才会使用private(当protected成员或virtual函数被牵扯进来)</p><h3 id="使用Private继承"><a href="#使用Private继承" class="headerlink" title="使用Private继承"></a>使用Private继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// automatically called for each tick</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// look at Widget usage data, etc</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于virtual函数，我们需要用private继承</p><p>上述代码当我们需要对一个Widget类进行计时，在运行期中周期性的检查Widget类。对于Timer这一个计时器，Widget中可以重新定义Timer内的virtual函数，但用public检查就说明Widget是一个Timer那肯定是不符合实际的。对于private继承确实是完美的选择：</p><ul><li>Widget会拥有Timer的一些实现,因此也是根据某物实现。</li><li>用户也不会造成接口的滥用，该此Timer实现也是对Widget对象内可见的。</li></ul><h3 id="复合实现"><a href="#复合实现" class="headerlink" title="复合实现"></a>复合实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;; </span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用复合类的方法实现private继承同样也是可以的，但是略显复杂</p><p><img src="C:\Users\黎咏杰\AppData\Roaming\marktext\images\2022-05-10-10-05-01-image.png" alt=""></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>✦Private  inheritance  means  is-implemented-in-terms  of.  It’s  usually inferior  to  composition,  but  it  makes  sense  when  a  derived  classneeds access to protected base class members or needs to redefineinherited virtual functions.</p><p>✦Unlike composition, private inheritance can enable the empty baseoptimization. This can be important for library developers who strive to minimize object sizes</p><hr><h2 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款40：明智而谨慎地使用多重继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;<span class="comment">// something a library lets you borrow</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;<span class="comment">// check the item out from the library</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// perform self-test, return whether</span></span><br><span class="line">    ...<span class="comment">// test succeeds</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>:<span class="comment">// note MI here</span></span><br><span class="line">        <span class="keyword">public</span> BorrowableItem,<span class="comment">// (some libraries loan MP3 players)</span></span><br><span class="line">        <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123; ... &#125;;                    <span class="comment">// class definition is unimportant</span></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>();<span class="comment">// ambiguous! which checkOut?</span></span><br></pre></td></tr></table></figure><blockquote><p>解决方案</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure><p>因为在MP3player中又两个相同的接口，因此在调用是会无法识别到底调用那个，因此只能指定数据成员</p><p>但是会得到一个尝试调用private成员的错误</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220511205507673.png" alt="image-20220511205507673"></p><p>以上的继承路线有两个条那么，假设File有一个filename数据成员分别继承到InputFile和OutputFile，当IOFile进行多重继承，那么我们会得到两份filename(InputFile::filename,Output::filename)。</p><p>得到的IOFile中如果要操作filename这<strong>数据成员要指定来自于那个父类</strong>同上。但再逻辑上这是不符合逻辑，一个文件不可能拥有两个名字。这时候就需要<strong>虚拟继承</strong>。</p><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><blockquote><p>含义</p><p>解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员。</p></blockquote><p>防止二义性问题，共享Top-Base类数据。</p><blockquote><p>虚拟继承与普通继承的区别</p></blockquote><p><strong>时间</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。(虚拟就是运行期进行选择)</p><p><strong>空间</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之 多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证 这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。</p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutputFile&#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>这样的做法就会使得再最终的outputFile中仅有一个一份filename，且不会产生二义性</p><h4 id="虚拟继承的成本"><a href="#虚拟继承的成本" class="headerlink" title="虚拟继承的成本"></a>虚拟继承的成本</h4><blockquote><p>空间</p></blockquote><p>virtual继承的class产生的non-virtual的继承体积大</p><blockquote><p>时间</p></blockquote><p>访问virtual继承的成员变量时，比访问non-virtual base classe的速度慢</p><h4 id="虚拟继承的初始化规则更复杂"><a href="#虚拟继承的初始化规则更复杂" class="headerlink" title="虚拟继承的初始化规则更复杂"></a>虚拟继承的初始化规则更复杂</h4><blockquote><p>初始化职责有继承中的最底层承担</p></blockquote><ol><li>classes若派生自virtual bases而需要初始化，必须要知道其virtual bases</li><li>当一个新的derived class加入继承体系中，它必须承当其virtual bases的初始化职责</li></ol><h4 id="虚拟继承的抉择"><a href="#虚拟继承的抉择" class="headerlink" title="虚拟继承的抉择"></a>虚拟继承的抉择</h4><ol><li>非必要不用虚拟继承，就用non-virtual 继承</li><li>必须使用virtual base classes，尽可能避免再其中放置数据</li></ol><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>✦Multiple inheritance is more complex than single inheritance. It canlead to new ambiguity issues and to the need for virtual inheritance. </p><p>✦Virtual  inheritance  imposes  costs  in  size,  speed,  and  complexity  ofinitialization and assignment. It’s most practical when virtual baseclasses have no data.</p><p>✦Multiple  inheritance  does  have  legitimate  uses.  One  scenario  in-volves  combining  public  inheritance  from  an  Interface  class  withprivate inheritance from a class that helps with implementation.CPersonIPersonPersonInfo{private}</p><hr><h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p><code>Understand implicit interfaces and compile-time polymorphism</code></p><h3 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h3><ul><li>提供显示接口</li><li>运行期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;<span class="comment">// see Item25</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//and this (equally meaningless) function,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">( Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ul><li>显示接口：在本例中我们在<code>doProcessing</code>中调用w的接口，我们可以在源文件中找到这些接口(.h文件)，必须知道接口的实现。</li><li>运行期多态：在条款37中有动态类型绑定，widget中virtual函数表现出来的为运行期多态</li></ul><h3 id="Template以及泛型编程-generic-programming"><a href="#Template以及泛型编程-generic-programming" class="headerlink" title="Template以及泛型编程( generic programming )"></a>Template以及泛型编程( generic programming )</h3><blockquote><p>面对对象的规则依然存在但是被弱化了</p></blockquote><ul><li>隐式接口</li><li>编译期多态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>( );</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>w所支持的接口，是由template中的w身上的操作来决定，w需要提供一系列的隐式接口</li><li>w的任何函数的调用，入operator&gt; and operator!=,有可能造成template的据具现化(instantiated),这些函数的调用都是具现化在编译期。通俗来讲就是，通过模板类型T去判断T中是否有以下行为(接口)，如果没有则会编译失败，如果存在则进行选择</li></ul><h3 id="运行期多态与编译期多态"><a href="#运行期多态与编译期多态" class="headerlink" title="运行期多态与编译期多态"></a>运行期多态与编译期多态</h3><blockquote><p>区别</p></blockquote><ul><li>运行期多态：那个virtual函数被选择</li><li>编译期多态：那个重载函数被调用</li></ul><h3 id="隐式接口与显式接口"><a href="#隐式接口与显式接口" class="headerlink" title="隐式接口与显式接口"></a>隐式接口与显式接口</h3><blockquote><p>显式接口</p></blockquote><p>通常是由函数的签名式(函数名称、参数类型、返回类型)构成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>( );</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上public接口有一个构造函数、析构函数、各个成员函数及其参数类型、返回类型、常量性构成。</p><blockquote><p>隐式接口</p></blockquote><p>它不基于函数签名式，是由有效表达式(valid expression)组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>( ) &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上：</p><p>T的隐式接口有一系列的约束</p><ul><li>必须提供size函数</li><li>必须提供operator !=的类型比较函数(假设<code>someNastyWidget</code>的类型为T)</li></ul><p><strong>隐式接口同样需要支持T类型</strong></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>✦Both classes and templates support interfaces and polymorphism.</p><p> ✦For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions. </p><p>✦For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution.</p><hr><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p><code>Understand the two meaning of typename</code></p><h3 id="class-and-typename-声明"><a href="#class-and-typename-声明" class="headerlink" title="class and typename 声明"></a>class and typename 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br></pre></td></tr></table></figure><p>class 与 typename没有任何不同。当声明template类型参数，class和typename的意义完全相同</p><h3 id="typename的另一重意义"><a href="#typename的另一重意义" class="headerlink" title="typename的另一重意义"></a>typename的另一重意义</h3><blockquote><p>声明“类型”</p></blockquote><p>当有static成员变量与T::~定义的类型命名冲突时会造成编译器的警告，因此需要typename的显式的声明这是命名为一个<strong>类型</strong>，而不是<strong>变量</strong></p><blockquote><p>示例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;<span class="comment">// typename allowed (as is “class”)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">const</span> C&amp; container,<span class="comment">// typename not allowed</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">typename</span> C::iterator iter)</span></span>;<span class="comment">// typename required</span></span><br></pre></td></tr></table></figure><p>上述的C不是嵌套从属类型名称，所以声明container时并不需要typename为签到，但C::iterator是个嵌套从属类型因此需要typename作为前置声明</p><blockquote><p>例外</p></blockquote><p>typename不能出现在base classes list内的嵌套从属类型名称之前，也不可以在member initalization list中作为base class修饰符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;<span class="comment">// base class list: typename not</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x)// base class identifier in mem.&#123;</span></span><br><span class="line">        <span class="comment">// init. list: typename not allowed</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;     <span class="comment">// use of nested dependent type</span></span><br><span class="line">        ...<span class="comment">// name not in a base class list or</span></span><br><span class="line">&#125;<span class="comment">// as a base class identifier in a </span></span><br><span class="line">...<span class="comment">// mem. init. list: typename required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>typename 与 typedef连用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>✦When declaring template parameters, class  and typename  are  inter-changeable.</p><p>✦Use typename  to  identify  nested  dependent  type  names,  except  inbase class lists or as a base class identifier in a member initializa-tion list</p><hr><h2 id="条款43-：学习处理模板化基类内的名称"><a href="#条款43-：学习处理模板化基类内的名称" class="headerlink" title="条款43 ：学习处理模板化基类内的名称"></a>条款43 ：学习处理模板化基类内的名称</h2><p><code>Know how to access names in templatized base classes</code></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>假设一个程序可以发送消息给不同公司，信息可以以密文或则明文的方式发送，用类模板这可以在编译期对公司进行选择</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...<span class="comment">// classes for other companies</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span> &#123; ... &#125;;<span class="comment">// class for holding information</span></span><br><span class="line"><span class="comment">// used to create a message</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        std::string msg;<span class="comment">//create msg from info;</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span><span class="comment">// similar to sendClear, except</span></span></span><br><span class="line"><span class="function">    </span>&#123; ... &#125;<span class="comment">// calls c.sendEncrypted</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>MsgSender类的调用不会用任何的问题</p><p>添加派生类LoggingMsgSender</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//write &quot;before sending&quot; info to the log;</span></span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// call base class function;</span></span><br><span class="line">                        <span class="comment">// this code will not compile!</span></span><br><span class="line">        <span class="comment">//write &quot;after sending&quot; info to the log;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:ice_cream: 这个派生类在新的一个non-virtual member函数中调用了父类的non-virtual member函数,这个函数解决了(条款33和条款36)non-virtual函数在派生类中出现的一系列问题，但是这个代码在不同的编译器是<strong>不能编译的</strong></p><p><img src="C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220518220901314.png" alt="image-20220518220901314"></p><blockquote><p>问题所在</p></blockquote><p>编译器遇到LoggingMsgSender的模板定义，不知道它是继承的那个类。</p><p>因为Company是一个模板参数，它是不确定的一个参数，只有当LoggingMsgSender被实例化后Company才会确定，因此在MsgSender&lt; Company &gt;的派生类中会出现无法确定继承的父类的问题。</p><p>更加明确的说是不知道Company中是否有sendClear这个函数</p><blockquote><p>模板全特化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123;<span class="comment">// this class offers no</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// sendCleartext function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">// a total specialization of </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;<span class="comment">// MsgSender; the same as the</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// general template, except </span></span><br><span class="line">    ...<span class="comment">// sendClear is omitted</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通用的MsgSender模板是不适用于CompanyZ的，因为模板提供的sendClear函数是对CompanyZ没有意义的。因此在仍然会出现上述问题，在Company中找不到sendClear的声明(因为CompanyZ的特例化没有定义sendClear函数)</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><blockquote><p>方案一:在base class函数调用动作之前加上this-&gt;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that// sendClear will be inherited</span></span><br><span class="line">        write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案二：使用using声明</p></blockquote><p>在条款33中找不到基类重载继承下来的隐藏的函数，是因为被派生类所隐藏</p><p>在本例中是编译器不搜索基类作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<span class="comment">// tell compilers to assume</span></span><br><span class="line">    ...<span class="comment">// that sendClear is in the// base class</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">            ...<span class="comment">// sendClear will be inherited</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>方案三：显式的指定你的函数位于base class中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);<span class="comment">// okay, assumes that</span></span><br><span class="line">        ...<span class="comment">// sendClear will be </span></span><br><span class="line">    &#125;<span class="comment">// inherited</span></span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这是一个不太好的方法，因为被调用的是virtual函数会导致virtual函数的绑定行为被关闭</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>✦In  derived  class  templates,  refer  to  names  in  base  class  templatesvia  a  “this-&gt;”  prefix,  via using  declarations,  or  via  an  explicit  base class qualification.</p><hr><h2 id="条款44：将于参数无关的代码抽离templates"><a href="#条款44：将于参数无关的代码抽离templates" class="headerlink" title="条款44：将于参数无关的代码抽离templates"></a>条款44：将于参数无关的代码抽离templates</h2><p>Factor parameter -independent code out of templates</p><blockquote><p>不恰当的使用template可能会导致代码膨胀(code bloat):其二进制带着重复的代码、数据</p></blockquote><p>解决方法：当两个函数实现的实质相同</p><p>抽离两个函数中共同的部分，将他放入第三个函数中，然后将他们调用这个新函数。class也是同样的道理，使用继承或则复合</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>用固定尺寸的方阵编写一个template。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="comment">// template for n x n matrices of</span></span><br><span class="line">            std::<span class="type">size_t</span> n&gt;<span class="comment">// objects of type T; see below for info</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;<span class="comment">// on the size_t parameter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span></span>;<span class="comment">// invert the matrix in place</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的类型为size_t的参数是一个非类型参数(non-type parameter)。</p><p>对上述代码进行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.<span class="built_in">invert</span>();<span class="comment">// call SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>上述代码中，将会具现化两份invert函数，但这两份函数是完全相同，因为其中一个操作的5<em>5矩阵而另一个是10 </em>10的矩阵，除了常量5和10其他部分完全相同，这将是一个典型的代码膨胀示例</p><blockquote><p>解决方案一</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// size-independent base class for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;<span class="comment">// square matrices</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;<span class="comment">// invert matrix of the given size</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;<span class="comment">// make base class version of invert</span></span><br><span class="line">                                    <span class="comment">// visible in this class; see Items 33</span></span><br><span class="line">                                    <span class="comment">// and 43</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">( )</span> </span>&#123;<span class="built_in">invert</span>(n); &#125;<span class="comment">// make inline call to base class</span></span><br><span class="line">&#125;;<span class="comment">// version of invert</span></span><br></pre></td></tr></table></figure><p>上述解决方案中</p><p>在所有方阵实体中只会共享一个父类的invert实现，这样就有效的防止的代码膨胀</p><ul><li>避免derived class代码重复：父类使用了protect代替了public。注<code>在调用时会如果时public(实体对象仍然可以调用该接口)的话也同样会产生不同版本的代码</code></li><li>调用其代码的成本为0，因为derived classes的inverts调用base clas的版本是inline调用</li><li>this-&gt;调用表示模板化基类反之函数名称被隐盖</li><li>使用private的继承关系表现的是一种is-a关系</li></ul><p><strong>问题</strong>：在该方案中没有解决父类与子类之间联系的问题，因为在子类中需要带入矩阵的相关数据，因此需要加入一个指针或者引用。但是反复的传参，这样也会影响效率</p><blockquote><p>解决方案二：父类中存储一个指针，指向所在的内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T *pMem)<span class="comment">// store matrix size and a</span></span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123; &#125;<span class="comment">// ptr to matrix values</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">( T *ptr)</span> </span>&#123; pData = ptr; &#125;<span class="comment">// reassign pData</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;<span class="comment">// size of matrix</span></span><br><span class="line">    T *pData;<span class="comment">// pointer to matrix values</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="built_in">SquareMatrix</span>( )<span class="comment">// send matrix size and </span></span><br><span class="line">        : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123; &#125;<span class="comment">// data ptr to base class</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法在子类中调用了父类的构造函数，用来初始父类中的数据成员</p><p>当数据成员特别大的时候可以使用<strong>动态内存分配</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>( )<span class="comment">// set base class data ptr to null,</span></span><br><span class="line">        :   <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),<span class="comment">// allocate memory for matrixpData(new T[n*n])</span></span><br><span class="line">                                        <span class="comment">// values, save a ptr to the</span></span><br><span class="line">    &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>( )); &#125;<span class="comment">// memory, and give a copy of it</span></span><br><span class="line">    ...<span class="comment">// to the base classprivate:boost::scoped_array&lt;T&gt; pData;</span></span><br><span class="line">        <span class="comment">// see Item13 for info on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>✦Templates generate multiple classes and multiple functions, so anytemplate code not dependent on a template parameter causes bloat.</p><p>✦Bloat due to non-type template parameters can often be eliminatedby replacing template parameters with function parameters or classdata members.</p><p>✦Bloat due to type parameters can be reduced by sharing implemen-tations for instantiation types with identical binary representations.</p><hr><h2 id="条款45：使用成员函数template接受所有可以兼容的类型"><a href="#条款45：使用成员函数template接受所有可以兼容的类型" class="headerlink" title="条款45：使用成员函数template接受所有可以兼容的类型"></a>条款45：使用成员函数template接受所有可以兼容的类型</h2><p><code>Use member function template to accept “all compatible type”</code></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>行为像指针的对象，并提供指针没有的技能。STL容器几乎都是用到智能指针，但是我们不会使用“++”的运算符将一个内置的指针从link list的节点移动到另一个节点，所以需要用到迭代器</p><h3 id="真实指针-raw-pointer"><a href="#真实指针-raw-pointer" class="headerlink" title="真实指针(raw pointer)"></a>真实指针(raw pointer)</h3><p>支持隐式转换。例如：Derived class 指针可以隐式的转换为base class指针(提供多态的选择)，“指向non-const对象”的指针可以转为”const对象”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top *pt1 = <span class="keyword">new</span> Middle;<span class="comment">// convert Middle*⇒  Top*</span></span><br><span class="line">Top *pt2 = <span class="keyword">new</span> Bottom;<span class="comment">// convert Bottom*⇒  Top*</span></span><br><span class="line"><span class="type">const</span> Top *pct2 = pt1;<span class="comment">// convert Top*⇒  const Top*</span></span><br></pre></td></tr></table></figure><h3 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// smart pointers are typically</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">( T *realPtr)</span></span>;<span class="comment">// initialized by built-in pointers </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =<span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =<span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></span><br><span class="line">            <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);<span class="comment">//     SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;<span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></span><br><span class="line">                            <span class="comment">//SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure><p>上述同一个template的不同具现体(instantiation)之间不存在继承关系，所以SmartPtr&lt; Top &gt;与SmartPtr&lt; Middle &gt;是完全不同的class</p><h3 id="Templates和泛型编程-Generic-Programming"><a href="#Templates和泛型编程-Generic-Programming" class="headerlink" title="Templates和泛型编程(Generic Programming)"></a>Templates和泛型编程(Generic Programming)</h3><blockquote><p>生产需求:自定义指针构造函数的编写</p></blockquote><p>当我们添加一个新继承关系的对象时，那没有添加转型的构造函数的情况下，就会反复的在SmartPtr中添加构造函数</p><p><code>class BelowBottom: public Bottom &#123; ... &#125;;</code></p><blockquote><p>member function tempaltes——泛化copy构造函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">// member template </span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);<span class="comment">// for a ”generalized</span></span><br><span class="line">    ...<span class="comment">// copy constructor”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中对于任意类型T与任意类型U，可以根据SmartPtr&lt; U &gt;生成一个SmartPtr&lt; T &gt;——因为SmartPtr&lt; T &gt;有个构造函数接受有个SmartPtr&lt; U &gt;参数。</p><p>泛化的copy构造函数并未被声明为explicit，因为原始指针之间(base class与derived class之间)的转换是隐式的转换，无需明白的写出转型动作(cast)</p><blockquote><p>提供原始资源的成员函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span><span class="comment">// initialize this held ptr: </span></span></span><br><span class="line"><span class="function">    <span class="title">heldPtr</span><span class="params">(other.get( ))</span> </span>&#123; ... &#125;<span class="comment">// with other’s held ptr</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// built-in pointer held</span></span><br><span class="line">    T*heldPtr;<span class="comment">// by the SmartPtr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用成员初始化列表来初始化SmartPtr&lt; T &gt;之内类型为T<em>的成员变量，并以类型为U</em>的指针作为初值。</p><p><code>member initialization templates</code>成员初始化列表的作用不限于构造函数，另一个作用是支持赋值操作</p><blockquote><p>摘录</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// construct from</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y * p)</span></span>;<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; <span class="comment">// built-in pointer,</span></span><br><span class="line">           <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// shared_ptr,</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// weak_ptr, or</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;<span class="comment">// auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp; r)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// assign from</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">// any compatible</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">// shared_ptr or</span></span><br><span class="line">        shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);<span class="comment">// auto_ptr...&#125;;</span></span><br></pre></td></tr></table></figure><p>上述所有构造函数都是explicit，唯有”泛化copy构造函数”除外，那么从<strong>某个shared_ptr类型隐式转为另一个shared_ptr</strong>是允许的，但是从某个内置指针或从其他智能指针进行隐式转换则是不允许的(显示的转换倒是可以)。</p><h3 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h3><p>✦Use member function templates to generate functions that accept allcompatible types.</p><p>✦If  you  declare  member  templates  for  generalized  copy  constructionor  generalized  assignment,  you’ll  still  need  to  declare  the  normalcopy constructor and copy assignment operator, too</p><hr><h2 id="条款46：需要类型转换是请为模板定义非成员函数"><a href="#条款46：需要类型转换是请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换是请为模板定义非成员函数"></a>条款46：需要类型转换是请为模板定义非成员函数</h2><p><code>Define non-member function inside templates when type conversion are desired</code></p><p>这个条款换个说法是：<strong>当我们需要进行模板函数参数类型需要隐式转换时，将模板函数定义为friend函数</strong></p><h3 id="示例：条款24的例子转为模板"><a href="#示例：条款24的例子转为模板" class="headerlink" title="示例：条款24的例子转为模板"></a>示例：条款24的例子转为模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// see Item28 for why returnconst </span></span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>;<span class="comment">// values are still passed by value,</span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>进行以下混合式(mixed-mode)运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">// this example is from Item24,</span></span><br><span class="line">                            <span class="comment">// except Rational is now a template</span></span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;<span class="comment">// error! won’t compile</span></span><br></pre></td></tr></table></figure><p>出现以下问题：</p><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\2022-06-03-17-34-47-image.png" alt=""></p><blockquote><p>分析</p></blockquote><p>以上问题是因为没有找对应的operator * 操作符对应的函数，也就是推导失败。</p><p>以上代码中operator*这个non-member函数的两个参数进行隐式类型推导时出现了问题:</p><ul><li>第一个实参是onehalf，所以T一定是int，能够顺利的推导出</li><li>第二个实参是2，编译器无法将其推导为Rational&lt; int &gt;</li></ul><p>经过以上考虑，因该是将隐式转换类型转换函数出现调用失败的问题,无法将non-member函数指定为operator*</p><h3 id="friend函数声明"><a href="#friend函数声明" class="headerlink" title="friend函数声明"></a>friend函数声明</h3><p>template class中friend声明式可以指定特定的函数，Rational&lt; T &gt;可以声明operator<em>是<em>*class的一个friend函数</em></em></p><p>class template并不依赖template的<strong>实参推导</strong>，所以能够在class Rational&lt; T &gt;具现化时得知T,<strong>换句话说就是T的类型被确定后，就已经指定调用operator*函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,<span class="comment">// see Item20 for why params</span></span><br><span class="line">             <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);<span class="comment">// are now passed by referenceconst </span></span><br><span class="line">    ...<span class="comment">// Item3 for why they’re const</span></span><br><span class="line">    <span class="keyword">friend</span><span class="comment">// declare operator*</span></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="comment">// function (see </span></span><br><span class="line">                             <span class="type">const</span> Rational&amp; rhs);<span class="comment">// below for details)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>此时混合式调用可以通过编译，当对象onehalf被声明为一个Rational&lt; int &gt;，class Rational&lt; int &gt;被具现化出来了。而作为过程的一部分，friend函数operator<em>(接受Rational&lt; int &gt; 参数)也就被<strong>自动声明出来</strong>。后者身为<em>*一个函而非函数模板</em></em>，因此编译器可以调用它时使用隐式转换函数。</p><p>上述friend函数同样可以声明为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><img src="C:\Users\lyj\Desktop\C and C++\学习笔记\C++11\img\image-20220603221112025.png" alt="image-20220603221112025"></p><p>虽然经过修改我们能过通过编译，但是在链接时会出现上述问题了，因为friend函数只有一个声明式存在，并没有被定义，因此会导致连接器无法找到对应的实现</p><h3 id="函数本体与声明式结合-简单版"><a href="#函数本体与声明式结合-简单版" class="headerlink" title="函数本体与声明式结合(简单版)"></a>函数本体与声明式结合(简单版)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="friend特殊意义"><a href="#friend特殊意义" class="headerlink" title="friend特殊意义"></a>friend特殊意义</h3><p> 在本条款中虽然使用了friend却和它的<strong>传统意义</strong>不同(访问non-public成分)，但是在此的意义却是让类型转换发生于所有实参身上，我们需要一个<strong>non-member函数</strong>(条款24)；为了使这个函数<strong>自动具现化</strong>(隐式转换构造函数的指定)，我们需要将它<strong>声明在class内部</strong>；而在class内部声明non-member函数的唯一方法就是将其声明为<strong>friend函数</strong></p><h3 id="non-member与friend-member合作"><a href="#non-member与friend-member合作" class="headerlink" title="non-member与friend member合作"></a>non-member与friend member合作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(T numerator = <span class="number">0</span>,</span><br><span class="line">    T denominator = <span class="number">1</span>):<span class="built_in">n</span>(numerator),<span class="built_in">d</span>(denominator)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">( )</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> d;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt; rhs.n/rhs.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs,rhs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n;</span><br><span class="line">    T d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>()*rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>()*rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>✦When  writing  a  class  template  that  offers  functions  related  to  thetemplate  that  support  implicit  type  conversions  on  all  parameters,define those functions as friends inside the class template.</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spanner</title>
      <link href="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Spanner%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spanner-全球化分布式数据库"><a href="#Spanner-全球化分布式数据库" class="headerlink" title="Spanner 全球化分布式数据库"></a>Spanner 全球化分布式数据库</h1><blockquote><p><strong>Title:</strong> Google’s Globally-Distributed Database,Spanner is Google’s scalable, multi-version, globallydistributed, and synchronously-replicated database</p></blockquote><p>论文中实现了广域的<strong>事务</strong>服务，也是在Google广泛使用的一种技术</p><ul><li><strong>R/W Transaction</strong>: 2PC + 2PL + Paxos Group</li><li><strong>R/O Transaction</strong>: Snapshot isolation + Synchronized Clocks</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Spanner部署"><a href="#Spanner部署" class="headerlink" title="Spanner部署"></a>Spanner部署</h3><p>Spanner的部署叫做<strong>universe</strong>，可以让Spanne全球性的管理数据，谷歌中使用了三套Spanner部署分别用于:测试、研发、上线</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/universe.png" alt=""></p><p>​    如上图Spanner server的结构图中，Spanner由多个<strong>Zone</strong>(管理部署的单元、物理隔离的单元)组成。一个数据中心中可以由一个或者多个Zone</p><p>​    上图中的一个Zone有一个<strong>zonemaster(分配数据给spanserver)</strong> 和100-1000个<strong>spanserver (服务与客户端)</strong>，用户使用<strong>localtion proxies</strong> 定位每个Zone中分配数据服务的<strong>spanservers</strong></p><ul><li><strong>universe master</strong>:主要是一个控制台，它显示了关于 zone 的各种状态信息，可以用于相互之间的调试</li><li><strong>Placement driver</strong>: 会周期性地与 spanserver 进行交互，来发现那些需要被转移的数据，或者是为了满足新的副本约束条件，或者是为了进行负载均衡<h3 id="Spanserver-SoftWare-Stack"><a href="#Spanserver-SoftWare-Stack" class="headerlink" title="Spanserver SoftWare Stack"></a>Spanserver SoftWare Stack</h3></li></ul><blockquote><p>每个Spanserver的副本部署以及软件栈</p></blockquote><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerSoftware.png" alt="SpannerSoftware"></p><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li><strong>Colossus</strong>:放置tablet的文件系统,GFS的升级版</li></ul><ul><li><strong>tablet</strong>:类似于bigtable中的tablet，实现如下映射<code>(key:string, timestamp:int64)-&gt;string</code> </li><li><strong>Paxos</strong>:共识算法于raft类似</li><li><strong>replica</strong>:Paxos的上层状态机</li><li><strong>locktable</strong>:实现并发控制,与分布式事务([[Distribute Transaction 笔记#两阶段锁（Two-Phase Locking）——悲观并发]])的二阶段锁相同</li><li><strong>Transaction manager</strong>：每个Paxos组中的支持分布式事务的软件<h4 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h4></li></ul><blockquote><p>universe的结构中展示了多个Zone中都含有100-1000个Spanserver，Zone可以理解为一个区域(地域)的数据中心。而每个SpanServer都是由一个Paxos状态机和Paxos协议组成(但是一个Paxos Group的Paxos副本不一定在一个Zone中),不同Zone之间的数据复制也是通过Paxos Group</p></blockquote><p>​    Spanner于bigtable不同之处在于，Spanner分配Timestamp给数据作为版本号，是其更像是一个多版本数据库，而不是键值对的存储，tablet的状态存储在B-tree类似的文件与WAL中</p><p>​    tablet的上层则是一个paxos的状态机方便复制(Paxos的一些细节我也没有研究过，复制过程可以参考[[Raft实验#Lab 2B : Log Replicated]])。每次写操作都需要写入两次：1.写入tablet的log中 2.写入Paxos的日志中。写操作必须在领导者上初始化 Paxos 协议，读操作可以直接从底层的任何副本的 tablet 中访问状态信息，只要这个副本足够新。副本的集合被称为一个 Paxos group。</p><p>​    对于每个是领导者的副本而言，每个 spanserver 会实现一个锁表来实现并发控制。对于那些需要同步的操作，比如事务型的读操作，需要获得锁表中的锁，而其他类型的操作则可以不理会锁表。</p><p>​    对于每个Paxos Group中都会有Leader会开启Transaction manager功能，每个拥有该功能的副本就称为一个<strong>Participant Leader</strong>，其余副本称为<strong>Participant slave</strong>。如果只有一个Paxos组如果一个事务只包含一个 Paxos 组(对于许多事务而言都是如此)，它就可以==绕过事务管理器==，因为锁表和 Paxos 二者一起可以保证事务性。如果一个事务包含了多 于一个 Paxos 组，那些组的领导者之间会彼此协调合作完成==两阶段提交==。其中一个参与者组，会被选为协调者，该组的 participant leader 被称为 <strong>coordinator leader</strong>，该组的 participant slaves 被称为 <strong>coordinator slaves</strong>。</p><h3 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/directory.png" alt="directory"></p><p>​    Spanner 对具有公共前缀的键做了一个抽象，称为 <strong>directory</strong>。目前一个 directory 是数据存放的基本单位。属于一个目录的所有数据，都具有相同的副本配置。 当数据在不同的 Paxos 组之间进行移动时，会一个目录一个目录地转移，如上图所示。Spanner 可能会移动一个目录从而减轻一个 Paxos 组的负担，也可能会把那些被频繁地一起访问的目录都放置到同一个组中，或者会把一个目录转移到距离访问者更近的地方。当客户端操作正在进行时，也可以进行目录的转移。我们可以预期在几秒内转移 50MB 的目录。</p><p>directory 是数据复制和placement配置的基本单位。spanner中负载均衡的最小单位也是 directory，同时提供方法 MoveDir 可以手动将一个 directory 移动到指定的zone</p><h3 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h3><p>​    spanner的行模型是 <code>(key:string, timestamp:int64) -&gt; row content</code>，可以看到跟big table的模型最大的不同是这里强化了row的概念，不再突出column；这样spanner的timestamp是赋给整行数据的，是有物理意义的，这使得spanner更像一个实现多版本并发的数据库，而在big table中，timestamp仅仅用于保存多个版本的key-value，跟并发完全无关；我觉得这也是为什么spanner称自己为semi-relational 数据库，而big table只称自己是semi-structure 数据库的原因。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/spannerDataModel.png" alt=""></p><p>​    Spanner 的数据模型不是纯粹关系型的，它的行必须有名称。更准确地说，每个表都需 要有包含一个或多个主键列的排序集合。这种需求，让 Spanner 看起来仍然有点像键值存储: 主键形成了一个行的名称，每个表都定义了从主键列到非主键列的映射。当一个行存在时，必须要求已经给行的一些键定义了一些值(即使是 NULL)。采用这种结构是很有用的，因为这可以让应用通过选择键来控制数据的局部性。</p><h3 id="High-level-Organization"><a href="#High-level-Organization" class="headerlink" title="High-level Organization"></a>High-level Organization</h3><p>​    考虑下图3个数据中心的A、B、C(存在于不同的地域中)，数据存储在分片中,包含了数据库的行和一些键值对，例如A的分片中有键A-M的。现将该分片复制到B、C数据中心中，即使整个数据中心出现故障也可以继续。</p><p>​    位于不同数据中心的spanserver形成了Paxos Group 如Figure3中所示，也就是一个Paxos Group中的副本可以存在于不同数据中心中。三个键A-M的shard是通过日志复制使状态机去更新键值对</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerShard.jpg" alt=""></p><h4 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h4><ul><li><p>多个分片是为了获得更好的并行性</p></li><li><p>每个分片有一个Paxos组用于复制，若a-c的距离远复制开销大，也只需要a、b之间获得majority即可</p></li><li><p>数据中心的容错，速率过慢</p></li><li><p>副本靠近客户端，客户可以获得高性能的只读事务,其原理[[KVRaft#Read-Only Query:]]</p></li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><h3 id="Read-of-local-Relipca-yield-latest-write"><a href="#Read-of-local-Relipca-yield-latest-write" class="headerlink" title="Read of local Relipca yield latest write"></a>Read of local Relipca yield latest write</h3><p>​    追求更强的一致性，在ZooKeeper中实现的fast-read是弱的线性一致性。本地副本需要读到最新的写，在本文中将会用到</p><h3 id="Trasaction-across-shard"><a href="#Trasaction-across-shard" class="headerlink" title="Trasaction across shard"></a>Trasaction across shard</h3><p>​    支持跨分片的事务，例如转账事务中一个分片是一个账户、另一个分片是目标账户，当我们要执行转账操作时可以像事务一样执行，并且具有ACID的语义</p><h3 id="Transaction-must-be-serializable"><a href="#Transaction-must-be-serializable" class="headerlink" title="Transaction must be serializable"></a>Transaction must be serializable</h3><p>​    读取多条记录的事务必须是可序列化的。但是本地碎片可能反映已提交事务的不同子集!</p><h2 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h2><div class="table-container"><table><thead><tr><th><strong>Method</strong></th><th><strong>return</strong></th></tr></thead><tbody><tr><td>TT.now()</td><td>TTinterval: [earliest, latest]</td></tr><tr><td>TT.after(t)</td><td>true if t has definitely passed</td></tr><tr><td>TT.before(t)</td><td>true if t has definitely not arrived</td></tr></tbody></table></div><p>TrueTime API 是一个非常有创意的东西，可以同步全球的时间。</p><ul><li><p>TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。</p></li><li><p>TT.after(t)和TT.before(t)是基于TT.now()实现的。</p></li></ul><p>​    那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。实际部署的时候。每个数据中心需要部署一些Master机器，其他机器上需要有一个slave进程来从Master同步。有的Master用GPS，有的Master用原子钟。</p><blockquote><p>Denote the absolute time of an event e by the function $t_{abs}$(e). </p><p>In more formal terms, TrueTime guarantees that for an invocation tt = TT.now(), tt.earliest ≤ $t<em>{abs}$($e</em>{now}$) ≤ tt.latest, where enow is the invocation event.</p></blockquote><h2 id="Concurrent-control"><a href="#Concurrent-control" class="headerlink" title="Concurrent control"></a>Concurrent control</h2><h3 id="Timestamp-Management"><a href="#Timestamp-Management" class="headerlink" title="Timestamp Management"></a>Timestamp Management</h3><p>Spanner使用TrueTime来控制并发，实现外部一致性。支持以下几种事务。</p><ul><li>读写事务：读写操作的集合</li><li>只读事务：只有读操作，并且提供的<strong>snapshot isolation</strong>的功能，保证强一致性</li><li>快照读,只读事务由客户端提供时间戳：可以读取stale data</li><li>快照读,客户端提供时间范围<br><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerTransaction.png" alt=""></li></ul><p>​    上表是Spanner现在支持的事务。单独的写操作都被实现为读写事务 ； 单独的非快照被实现为只读事务。事务总有失败的时候，如果失败，对于这两种操作会自己重试，无需应用自己实现重试循环。</p><p>​    时间戳的设计大大提高了只读事务的性能。事务开始的时候，要声明这个事务里没有写操作，只读事务可不是一个简单的没有写操作的读写事务。它会用一个系统时间戳去读，所以对于同时的其他的写操作是没有Block的(只读事务是lock free的)。而且只读事务可以在任意一台已经更新过的replica上面读。</p><p>​    对于快照读操作，可以读取以前的数据，需要客户端指定一个时间戳或者一个时间范围。Spanner会找到一个已经充分更新好的replica上读取。</p><p>​    还有一个<strong>有趣的特性</strong>的是，对于只读事务，如果执行到一半，该replica出现了错误。客户端没有必要在本地缓存刚刚读过的时间，因为是根据时间戳读取的。只要再用刚刚的时间戳读取，就可以获得一样的结果。</p><h2 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h2><h3 id="RW-Transaction-without-TS"><a href="#RW-Transaction-without-TS" class="headerlink" title="RW Transaction without TS"></a>RW Transaction without TS</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerRW.png" alt=""></p><p>​    A、B是两个不同的数据中心，客户端最开始的请求的读操作并不是事务操作，目的是为了找到Paxos Group的leader，并且Leader在锁表中分配该数据的锁，当client获得返回值时进行提交(commit)，该实现与Lab3中的读操作服务本质相同。后续执行二段提交部分，提交完成后并释放锁。</p><p>​    这种实现与Distribute Transaction中实现的2PC+2PL的实现方法相同，只不过加入了Paxos的容错设计</p><h3 id="Assigning-Timestamp-to-RW-Transaction"><a href="#Assigning-Timestamp-to-RW-Transaction" class="headerlink" title="Assigning Timestamp to RW Transaction"></a>Assigning Timestamp to RW Transaction</h3><p>​    事务的读写将会用到二段锁，当所有的锁都已经获得以后，在任何锁被释放之前(也就是持有所有锁期间)，就可以给事务分配时间戳。对于一个给定的事务，Spanner 会为事务分配时间戳，这个时间戳是 Paxos 分配给 Paxos 写操作的，它代表了<strong>事务提交的时间</strong>。</p><p>​    Spanner 依赖下面这些单调性:在每个 Paxos 组内，Spanner 会以单调增加的顺序给每个 Paxos 写操作分配时间戳，即使在跨越多个领导者时也是如此。一个单个的领导者副本，可以很容易地以单调增加的方式分配时间戳。在多个领导者之间就会强制实现彼此隔离的不连 贯:一个领导者必须只能分配属于它自己租约时间区间内的时间戳。要注意到，一旦一个时间戳 S 被分配，$S_{max}$就会被增加到 s，从而保证彼此隔离性(不连贯性)。</p><ul><li>$S<em>i$：一个读写事务的时间戳，当$S_i$被分配，$S</em>{max}$就会增长到S</li><li>$T_i$：表示一个事务</li><li>$e_i$：代表一个事务的一些事件如开始或结束</li><li>$e_i^{server}$ ：表示写事务$T_i$的Commit请求到达Coordinator的时间</li><li>$t_{abs}$：一个时间的绝对时间</li></ul><p><strong>External consistency</strong> -&gt; 不变性(invariant)：如果事务T2开始发生在T1提交事务之前，T2的时间戳就必须大于T1的提交事务的时间戳：由tabs($e_1^{commit}$) &lt; tabs($e_2^{start}$) 可得  $S_1$ &lt; $S_2$</p><p><strong>Start</strong>：为一个事务 $T_i$担任协调者的领导者分配一个提交时间戳 $s_i$，不会小于 TT.now().latest 的值，TT.now().latest的值是在$e_i^{server}$事件之后计算得到的。要注意，担任参与者的领导者， 在这里不起作用。第 4.2.1 节描述了这些担任参与者的领导者是如何参与下一条规则的实现的。</p><p><strong>Commit Wait</strong>：担任协调者的领导者，必须确保客户端不能看到任何被$T_i$提交的数据，直到 TT.after( $s_i$)为真。提交等待，就是要确保 $s_i$ 会比$T_i$的绝对提交时间小。Commit Wait 的证明如下图所示(只针对于R/W 事物)</p><ul><li>commit wait：T1的时间戳小于其commit提交开始的绝对时间</li><li>assumption：T2的开始时间大于T1 commit的事件的事件</li><li>causality： T2开始的时间小于或等于其commit消息到coordinator的时间</li><li>start：commit消息到达coordinator的时间小于等于T2的时间戳则事物开始</li><li>transitivity：可以得到s1发生在s2之前</li></ul><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SpannerProof.png" alt=""></p><h4 id="detail-论文内容—-了解"><a href="#detail-论文内容—-了解" class="headerlink" title="detail(论文内容—-了解)"></a>detail(论文内容—-了解)</h4><p>​    Spanner在2PC开始之前读操作将会发生在transaction中被Client缓存，这样的话读操作就不会看见同一事务中写入的影响了</p><p><strong>读写操作的实现细节</strong><br>    读操作在读写事务中使用wound-wait方法去避免死锁。Client发起读操作到合适Paxos Group的leader副本，获取读锁并且读取最近的数据，在客户端事务存活的时候会不断的向leader发心跳，防止超时。当客户端完成了所有的读操作，并且缓存了所有的写操作，就开始了两阶段提交。客户端选择一个coordinator group，并给每一个leader发送coordinator的id和缓存的写数据。(由客户端驱动二段提交避免两次广域的链接)</p><p><strong>写操作开始</strong><br>    non-coordinator-leader首先会获取一个写锁，选择一个prepare时间戳大于之前事务已经分配时间戳的，通过Paxos记录prepare日志。每一个Participant的都要给coordinator发送他自己prepare的那个时间戳。</p><p>​    coordinator leader首先获得写锁但是需要<strong>跳过Prepare阶段</strong>，在收到(hearing,应该是类似与心跳的机制)所有Participant的Prepare消息后，它需要准备一个时间戳给整个事务，并且commit timestamp S必须大于或等于所有的prepare的时间戳(满足4.1.3中的限制)，大于TT.now().lastest，同一时间coordinator收到commit消息(Participant回复Prepare消息是commit/abort形式)并且大于leader分配给之前事务的时间戳</p><p>​    在coordinator的副本apply commit的日志记录之前，为了遵循commit-wait规则coordinator leader需要等待TT.after(S)。因为coordinator leader需拿着S基于TT.now().lastest,并且。在commit-wait之后coordinator leader会commit的时间戳发送给client和所有Participant leader</p><h2 id="只读事务-高性能读"><a href="#只读事务-高性能读" class="headerlink" title="只读事务:高性能读"></a>只读事务:高性能读</h2><ul><li>快速的读从本地的(邻近的)分片中</li><li>不需要<strong>二段锁</strong></li><li>不需要<strong>二段提交</strong></li></ul><h3 id="Corretness"><a href="#Corretness" class="headerlink" title="Corretness"></a>Corretness</h3><p><strong>Serializeble:</strong> ${R/W}_1$（T1）  R/O  ${R/W}_2$ （T2） R/W</p><blockquote><p>External consistency(外部一致性)：Serializable+Real time</p></blockquote><p>与线性一致性相似只不过Extenal consisitency是==事务级别的属性==</p><p><strong>示例</strong>：下一个事务必须看见上一个事务的写入</p><ol><li>如果事务T1再另一个事务T2开始之前提交, 则T1提交的时间戳会小于T2提交的时间戳</li><li>如果T1&lt; T2  ，则T2 必须看见T1的写入</li></ol><h3 id="Bad-Plan-只读操作读取最新提交的值"><a href="#Bad-Plan-只读操作读取最新提交的值" class="headerlink" title="Bad Plan 只读操作读取最新提交的值"></a>Bad Plan 只读操作读取最新提交的值</h3><p>由于R/O操作是不加锁的，T3在只读操作时Ry会读取到T2提交的值，因此违背了事务的隔离性也不是串行化。</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Bad_Read.png" alt=""></p><h3 id="R-O-with-Snapshot-isolation-只读事务快照隔离"><a href="#R-O-with-Snapshot-isolation-只读事务快照隔离" class="headerlink" title="R/O with Snapshot isolation(只读事务快照隔离)"></a>R/O with Snapshot isolation(只读事务快照隔离)</h3><ol><li>分配时间戳给事务:<ul><li><strong>R/W:</strong> commit 提交开始(coordinator leader分配)</li><li><strong>R/O:</strong> Start 事务开始(paxos leader分配)</li></ul></li><li>执行事务按照时间戳的顺序</li><li>每个副本的数据存储都需要有时间戳作为版本号(MVCC,multiple version concurrent control)</li></ol><blockquote><p>In both Bigtable and Spanner, we designed for long-lived transactions (for example, for report generation, which might take on the order of minutes), which perform poorly under optimistic concurrency control in the presence of conflicts</p></blockquote><p>​    论文中所讲到Spanner在事务(<strong>实际上是只读事务，读写事务还是需要加锁</strong>)上使用了乐观并发控制，对于只读事务我们是不加锁的，因此对于只读事务我们使用乐观并发控制。</p><p>PS: 在FaRM论文中实现了对与读写事务的OCC，对于读操作是不加锁的</p><p>DDIA中说到：<strong>Serilaizability</strong> + <strong>Snapshot isolation</strong> = ==Optimistic concurrent control==</p><p>​    如下图：T1提交的时间戳为@10，T2提交的时间戳为@20，T3只读事务开始的时间戳为@15，读取y值，会按照时间戳的顺序，因此读取y值会现读@15以前的数据，满足了快照隔离性与可串行性</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Snapshot_isolation.png" alt=""></p><h3 id="R-O-from-Local-Replica-non-Leader-of-Paxos"><a href="#R-O-from-Local-Replica-non-Leader-of-Paxos" class="headerlink" title="R/O from Local Replica(non-Leader of Paxos)"></a>R/O from Local Replica(non-Leader of Paxos)</h3><p><strong>问题</strong>：从当地副本进行只读事务，有可能只读事务之前写入还没有同步复制到该副本。例如：副本中没有W@10的操作</p><blockquote><p>解决方案</p></blockquote><ul><li><strong>Saft Time</strong> ：所有副本中会跟踪这个$t<em>{safe}$值是所有副本中最大的时间戳，以此来保证副本是最新的。若读操作时间戳为@t,一个副本需要满足t&lt;=$t</em>{safe}$ ,才能进行读写。</li><li>Paxos按照时间戳的顺序发送写操作给副本</li><li>在Rx@15执行前，需要等待大于@15的时间戳写入(与no-op操作道理是一样的)</li><li>等待prepared但是未commit的事务执行</li></ul><h3 id="Clock-must-be-perfect"><a href="#Clock-must-be-perfect" class="headerlink" title="Clock must be perfect"></a>Clock must be perfect</h3><ul><li><p>对只读事务很重要</p></li><li><p>只读事务的时间戳过大 =&gt; 等待时间过长</p></li><li><p>只读事务的时间戳过小 =&gt; 分配给T3更小的时间戳例如为5</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example of problem if r/o xaction&#x27;s TS is too small:</span><br><span class="line">  r/w T1 @  0: Wx1 C</span><br><span class="line">  r/w T2 @ 10:         Wx2 C</span><br><span class="line">  r/o T3 @  5:                   Rx?</span><br><span class="line">(C for commit)</span><br></pre></td></tr></table></figure><p>根据上述情形我们只会看见T1@0写入的x=1的值，但是实际上T3开始在T2提交过后，根据<strong>external consistency</strong>：T3必须看见T2的写入(x=2)。该问题就是不正确时钟导致的分配时间戳错误的问题,</p><p>下述方案中将会解决不正确时钟导致时间戳过小的问题</p><h3 id="Timestamp-are-interval"><a href="#Timestamp-are-interval" class="headerlink" title="Timestamp are interval"></a>Timestamp are interval</h3><blockquote><p>如何保证R/O Txn不会的时间戳不会太小导致读写错误?</p></blockquote><p>4.12节两个规则:</p><ul><li><strong>Start rule</strong>:<br>  事务的时间戳==TS = TT.now().latest==<br>  对于只读事务来说时间戳TS就是开始时间<br>  对于读写事务来说时间戳TS就是事务提交开始(commit begin)的时间，也就是prepared完成时间。</li><li><strong>Commit wait</strong>, for r/w xaction:<br> 在完成提交前, 延迟直到TS &lt; TS.now().earliest，保证该时间戳已经过去，因此只读操作永远不会选择在commit事务开始之前的时间戳。</li></ul><h3 id="update-example-with-interval"><a href="#update-example-with-interval" class="headerlink" title="update example with interval"></a>update example with interval</h3><p>该方案是T1提交然后T2开始，T2必须看见T1的写入，需要TS1 &lt; TS2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  r/w T0 @  1: Wx1 C</span><br><span class="line">                   |1-----------10| |11--------------20|</span><br><span class="line">  r/w T1 @ 10:         Wx2 P          C</span><br><span class="line">                                 |10--------12|</span><br><span class="line">  r/o T2 @ 12:                           Rx?</span><br><span class="line">(P for T1&#x27;s Prepare, C for T1 finishing Commit)</span><br></pre></td></tr></table></figure><p>在P中T2选择了TS2 = TT.now().lastest = 10，Commit-Wait确保C发生在TS2之后(@10过去)，C开始读取时钟获得间隔为11-20 (CommitWait TS.now().earliest =11 &gt;10)。</p><p>T3开始在C之后通过Commit-wait规则我们已经直到@10这个真实时间已经过去(assumption条件)，因此T3在@10之后，T2选择TS3=TT.now().latest=12,这个值是在当前时间之后所以是在@10之后,我们将会读到T2写入的值。</p><blockquote><p>为什么当T2在提交时，T3并发执行能够获得会得到T2的值? 因为根据lab3中只有committed的log才会应用(applied)到状态机，从而修改数据库的值。如果在处理只读事务T3时，并状态机没有应用T2@10写入的数据，会导致T3读取不到T2的值。</p></blockquote><p>我的猜想是<strong>saft time</strong>的机制解决该问题，等待大于@12的值写入数据库之后才能处理只读。因为我们已经分配了为@12的时间戳给了只读事务T3，执行顺序也不会出错，现在就是保证replica中一定由@10的写入。</p><blockquote><p>Commit-Wait的规则是保证序列化与时间戳的正确性。</p></blockquote><p>该例子只是解释了commit-wait+True Time的机制可以防止时钟的错误导致违背外部一致性，因此是否能够读写的T2的写入我想是必然的(因为读取不到T1的写入也违背外部一致性)，但是如何解决T2事务commit与T3并发处理的机制，还是取决于设计者。</p><p>最后可得${TS}_3$&gt;${TS}_2$,因此T3的可以读到T2写入的X的值</p><blockquote><p>Why this provides external consistency for r/o transactions:<br>  Given that T1 finishes before T2 starts.Commit wait means TS1 is <strong>guaranteed to be in the past.</strong> TS2 = TT.now().latest is guaranteed to be &gt;= correct time thus &gt;= TS of any previous committed transaction (due to its commit wait)</p></blockquote><h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><p>分配时间戳需要参与到读事务的Paxos groups的协商，这样的话，Spanner需要一个Scope的表示每一个只读操作，可以描述整个读事务的键(PS：应该不需要coordinator的参加)</p><p><strong>single Paxos</strong>：scop的值只被一个Paxos Group提供，client提交只读事务到leader。leader分配一个$S<em>{read}$的时间戳并执行读操作。LastTS()是Paxos Group最后一次comitted的读操作，如果没有任何的已经准备的事务，$S</em>{read}$=LastTS()满足了external-consistency:事务将会看见最后一次写入的结果，因此只读事务将会安排到之后一次提交写事务完成之后</p><p><strong>multiple Paxos</strong>：拥有多个的选项，最复杂的选项是所有groups的leader协商完基于LastTS()的$S<em>{read}$，一个更简单的选着是clent避免协商的回合，当满足$S</em>{read}$ = TT.now().lastest。所有的读操作将会发送到up-to-date的副本</p><h3 id="discussion"><a href="#discussion" class="headerlink" title="discussion"></a>discussion</h3><ul><li>R/W Txn =&gt; 2PC + 2PL</li><li>R/O Txn =&gt; Snapshot isolation + serializablity</li><li>extenal consistency  =&gt; timestamp order + time interval</li></ul><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt">https://pdos.csail.mit.edu/6.824/papers/spanner-faq.txt</a></p><h4 id="Q-原子时钟是什么"><a href="#Q-原子时钟是什么" class="headerlink" title="Q: 原子时钟是什么?"></a>Q: 原子时钟是什么?</h4><p>A: 一个非常稳定的振荡器。有两种主要的技术被称为“原子钟”:铷钟和铯钟。两者都利用了外层电子状态的变化，这涉及到特定的能量量子和波长。人们可以通过观察电子的兴奋程度来精确地将信号发生器调节到那个波长。原子钟只是时钟的振荡器部分:它产生一个频率，使时钟以正确的频率滴答作响，但它自己不知道它是什么时间。为了提供时间，原子钟最初必须与时间同步，通常是通过GPS(它本身是由一堆原子钟提供时间的)。</p><h4 id="Q-Spanner使用什么种类的原子时钟"><a href="#Q-Spanner使用什么种类的原子时钟" class="headerlink" title="Q: Spanner使用什么种类的原子时钟?"></a>Q: Spanner使用什么种类的原子时钟?</h4><p>A: 遗憾的是，论文没有说明。铷时钟通常是几千美元(e.g. <a href="https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP">https://thinksrs.com/products/fs725.html)。铷时钟可能每周漂移几微秒，所以每隔一段时间就需要重新同步到UTC(通常是通过GPS)。铯钟的价格大概是5万美元;HP</a> 5071A就是一个很好的例子。铯钟不会漂移。当然，任何一个时钟都可能发生故障或电源故障，所以即使有完美的铯时钟，你仍然需要多个铯时钟，并能够同步到UTC。我猜，基于价格，Spanner使用的是与GPS接收器同步的铷时钟。</p><h4 id="Q-TrueTime如何以一种保证包含正确时间的方式选择间隔"><a href="#Q-TrueTime如何以一种保证包含正确时间的方式选择间隔" class="headerlink" title="Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?"></a>Q: TrueTime如何以一种保证包含正确时间的方式选择间隔?</h4><p>A: 这里有一个简单的例子来说明它所使用的推理方法。</p><p>假设主时间服务器S1拥有正确的时间(来自GPS或原子钟)。S2向S1发送请求，询问时间，并得到响应。响应显示“10:00:00 AM”，它在S2发送请求后两秒到达(可以合理地假设S2可以计算事情所花费的时间，即使它不知道绝对时间)。由于整个请求/响应花费了两秒，S2可以推断网络可能将请求延迟了两秒;或者将响应延迟两秒;但仅此而已。因此S2可以得出结论，在它接收到响应的那一刻，正确的时间必须在09:59:58和10:00:02之间。</p><h4 id="Q-外部一致性与线性一致性和序列化有什么关系"><a href="#Q-外部一致性与线性一致性和序列化有什么关系" class="headerlink" title="Q: 外部一致性与线性一致性和序列化有什么关系?"></a>Q: 外部一致性与线性一致性和序列化有什么关系?</h4><p>A: 外部一致性似乎等同于线性化，但应用于整个事务，而不是单个的读写。外部一致性似乎也等同于严格的串行性，这是添加了等效串行顺序必须服从实时顺序的约束的串行性。关键属性是，如果事务T1完成，然后(随后实时)事务T2开始，T2必须看到T1的写入。</p><h4 id="Q-为什么外部一致性是可取的"><a href="#Q-为什么外部一致性是可取的" class="headerlink" title="Q: 为什么外部一致性是可取的?"></a>Q: 为什么外部一致性是可取的?</h4><p>A: 假设哈特谢普苏特通过圣何塞数据中心的网络服务器修改了她的工作组共享的一个帐户的密码。她低声说把新密码隔着隔间告诉了她的同事卡桑德拉。卡桑德拉通过位于圣马特奥的另一个数据中心的网络服务器登录了这个账户。外部一致性保证Cassandra将观察到密码的更改，而不是，例如，看到一个陈旧的副本。</p><h4 id="Q-云Spanner使用Raft而不是Paxos"><a href="#Q-云Spanner使用Raft而不是Paxos" class="headerlink" title="Q: 云Spanner使用Raft而不是Paxos?"></a>Q: 云Spanner使用Raft而不是Paxos?</h4><p>A: 是的。在这篇论文的层面上没有区别。在Spanner构建的时候，Raft还不存在，谷歌已经有了一个调优的可靠的Paxos实现。看看Chandra等人的论文Paxos Made Live。</p><h4 id="Q-Spanner的Commit-Wait有什么目的"><a href="#Q-Spanner的Commit-Wait有什么目的" class="headerlink" title="Q: Spanner的Commit Wait有什么目的?"></a>Q: Spanner的Commit Wait有什么目的?</h4><p>A: 提交等待确保读/写事务在其时间戳中保证已经过时才完成。这意味着在读/写事务完成后启动的只读事务保证具有更高的时间戳，从而可以看到读/写事务的写操作。这有助于实现外部一致性的保证:如果T1在T2开始之前完成，T2将以相同的串行顺序在T1之后完成(即T2将看到T1的写入)。</p><h4 id="Q-什么地方使用Spanner"><a href="#Q-什么地方使用Spanner" class="headerlink" title="Q: 什么地方使用Spanner?"></a>Q: 什么地方使用Spanner?</h4><p>A: 据说有数百个谷歌服务依赖于Spanner。本文介绍了谷歌广告系统对其的使用。谷歌的Zanzibar授权系统使用Spanner。它以云Spanner的形式提供给谷歌的云客户。CockroachDB开源数据库是基于Spanner设计的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://int64.me/2017/Spanner%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.html">Spanner 论文笔记 | Life is magic. Coding is art.</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">spanner论文</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">MIT6.824 Spanner讲义</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Spanner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab2:Raft</title>
      <link href="/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Raft%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Raft%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-Raft-—-实验过程记录"><a href="#Lab-2-Raft-—-实验过程记录" class="headerlink" title="Lab 2: Raft — 实验过程记录"></a>Lab 2: Raft — 实验过程记录</h1><div class="tip warning faa-parent animated-hover"><p><p class="faa-horizontal">这篇文章写的有点烂，我会在后续进行修改</p></div>  <div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div> <blockquote><p><strong>写在前面</strong>：Raft是基于共识算法而实现的一个对 fault-tolerant test-and-set service，在MapReduce 、GFS、Fault-Tolerate VM 中都存在一个主要的管理机器(Cooridator 、master、primary) ，集中的去管理、分配任务、复制、同步信息。</p></blockquote><p>参考材料：</p><ol><li><a href="https://raft.github.io/#implementations">Raft Consensus Algorithm</a>，这时raft的官网，其中有一个有趣的是raft visualization部分，在网页可以可视化的观察的raft执行过程。</li><li><a href="https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A :: Jon Gjengset (thesquareplanet.com)</a>，MIT6.824关于raft的问答</li><li><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft论文</a>，raft算法作者的研究生论文。</li></ol><h1 id="Lab-2A-Leader-Election"><a href="#Lab-2A-Leader-Election" class="headerlink" title="Lab 2A : Leader Election"></a>Lab 2A : Leader Election</h1><h2 id="Leader-Election-共识算法"><a href="#Leader-Election-共识算法" class="headerlink" title="Leader Election(共识算法)"></a>Leader Election(共识算法)</h2><h2 id="实现implement"><a href="#实现implement" class="headerlink" title="实现implement"></a>实现implement</h2><h3 id="1-Figure2"><a href="#1-Figure2" class="headerlink" title="1.Figure2"></a>1.Figure2</h3><p> 按照raft figure 2 的操作将其Raft结构体完善，添加相应的RPC结构体、将State转换封装为rf的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToFollower() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Follower</span><br><span class="line">    rf.votedFor = <span class="number">-1</span></span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToCandidate() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Candidate</span><br><span class="line">    rf.votedFor = rf.me</span><br><span class="line">    rf.currentTerm++</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ConvertToLeader() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.State = Leader</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ticker-中实现Leader-Election-demo"><a href="#2-ticker-中实现Leader-Election-demo" class="headerlink" title="2.ticker()中实现Leader Election(demo)"></a>2.ticker()中实现Leader Election(demo)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration((rand.Intn(<span class="number">100</span>))+electionInterval) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isReceive &amp;&amp; rf.State != Leader &#123;</span><br><span class="line">        <span class="keyword">go</span> rf.StartElection()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> State == Follower &#123;</span><br><span class="line">        <span class="comment">//reset timer </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选举-startElection"><a href="#3-选举-startElection" class="headerlink" title="3.选举(startElection)"></a>3.选举(startElection)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartElection() &#123;</span><br><span class="line">    rf.ConvertToCandidate()</span><br><span class="line">    VoteCounter := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="comment">//go routine 向其他server发送RequestVote RPC</span></span><br><span class="line">        <span class="keyword">if</span> VoteCounter 超过一半&#123;</span><br><span class="line">            rf.ConverToLeade()</span><br><span class="line">            <span class="comment">//发送heartbeat</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-完善RPC处理函数-接收方"><a href="#4-完善RPC处理函数-接收方" class="headerlink" title="4.完善RPC处理函数(接收方)"></a>4.完善RPC处理函数(接收方)</h3><p>S1：sendRPC -&gt; S2</p><p>S2:  RPChandler 处理sendRPC的请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">true</span></span><br><span class="line">    State := rf.State</span><br><span class="line">    Term := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt;= Term &#123;</span><br><span class="line">        <span class="keyword">if</span> State != Follower &#123;</span><br><span class="line">            rf.ConvertToFollower()</span><br><span class="line">        &#125;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.Term = Term</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">true</span></span><br><span class="line">    Term := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; Term &#123;</span><br><span class="line">        reply.Term = Term</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Term &gt; Term &#123;</span><br><span class="line">        rf.ConvertToFollower()</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">        rf.votedFor = args.CandidateId</span><br><span class="line">        reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>在条件判断(if)中去读取变量会导致读取速度慢或是死锁问题，因此应该将共享变量在判断前用临时变量保存</p><p>例：将ticker修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration((rand.Intn(<span class="number">100</span>))+electionInterval) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    State := rf.State<span class="comment">//将共享变量枷锁读取用临时变量保存防止race</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isReceive &amp;&amp; State != Leader &#123;</span><br><span class="line">        rf.StartElection()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> State == Follower &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.votedFor = <span class="number">-1</span></span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>测试-race flag</p><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Lab%202%20-race.png" alt="Lab 2 -race"></p><h1 id="Lab-2B-Log-Replicated"><a href="#Lab-2B-Log-Replicated" class="headerlink" title="Lab 2B : Log Replicated"></a>Lab 2B : Log Replicated</h1><blockquote><p>根据Raft论文的figure 2完成AE与Start部分的代码</p></blockquote><h3 id="1-AE-接收方Follower的处理log的方式"><a href="#1-AE-接收方Follower的处理log的方式" class="headerlink" title="1.AE(接收方Follower的处理log的方式)"></a>1.AE(接收方Follower的处理log的方式)</h3><ol><li>更新log</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//condition args.Term = Term is to avoid appearing two leader with same term</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.State != Follower &#123; <span class="comment">//discover a Leader conver To Follower</span></span><br><span class="line">            rf.ConvertToFollower(args.Term)</span><br><span class="line">            Debug(dClient, <span class="string">&quot;S%d ConvertTo Follower T:%d(AE)&quot;</span>, rf.me, rf.currentTerm)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.isReceive = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123; <span class="comment">//In new Term Empty votedFor</span></span><br><span class="line">            rf.currentTerm, rf.votedFor = args.Term, <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//change Leader Term</span></span><br><span class="line">        reply.Term, reply.Success, rf.isReceive = rf.currentTerm, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update commitIndex</span></span><br><span class="line">    LastlogEntry := rf.GetLastLogEntry()</span><br><span class="line">    <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &amp;&amp; args.Term == LastlogEntry.Term &#123;</span><br><span class="line">        rf.commitIndex = min(args.LeaderCommit, LastlogEntry.Index)</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d update CI:%d&quot;</span>, rf.me, rf.commitIndex)</span><br><span class="line">        rf.applyCond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Entries == <span class="literal">nil</span> &#123; <span class="comment">//which RPC is heatbeat</span></span><br><span class="line">        Debug(dTimer, <span class="string">&quot;S%d receive heartbeat from S%d T:%d&quot;</span>, rf.me, args.LeadId, args.Term)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !rf.isMatchLog(args.PrevlogIndex, args.PrevlogTerm) &#123;</span><br><span class="line">        Debug(dLog2, <span class="string">&quot;S%d can&#x27;t match the PLI:%d&quot;</span>, rf.me, args.PrevlogIndex)</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    LastAppendEntry := args.Entries[<span class="built_in">len</span>(args.Entries)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> LastlogEntry.Term == args.Term &amp;&amp;</span><br><span class="line">        LastlogEntry.Index &gt;= LastAppendEntry.Index &#123;</span><br><span class="line">        <span class="comment">//Leader won&#x27;t delete current leader&#x27;s replicate Logs</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Debug(dLog2, &quot;S%d match prevLog from S%d&quot;, rf.me, args.LeadId)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//concurrent Start for network latency delete exist Log</span></span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Index</span><br><span class="line">    rf.logs = rf.logs[:args.PrevlogIndex-lastIncludedIndex+<span class="number">1</span>]</span><br><span class="line">    rf.logs = <span class="built_in">append</span>(rf.logs, args.Entries...)</span><br><span class="line"></span><br><span class="line">    LastlogEntry = rf.GetLastLogEntry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">        rf.commitIndex = min(args.LeaderCommit, LastlogEntry.Index)</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d update CI:%d&quot;</span>, rf.me, rf.commitIndex)</span><br><span class="line">        rf.applyCond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">    Debug(dPersist, <span class="string">&quot;S%d save T:%d VF:%d LastLog:%v&quot;</span>, rf.me, rf.currentTerm,</span><br><span class="line">        rf.votedFor, args.Entries[<span class="built_in">len</span>(args.Entries)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> ：该下面条件是由于<strong>网络延迟</strong>AE包的到达乱序导致follower的log 被误删(相同prevIndex但是Entries更多的比Entries更少的先到)，由于在同一周期的Leader的已经添加的Log不能被删除以及，不同周期内leader不能被删除commit Log，因此有以下判断条件可以将LastlogEntry.Term更换为rf.currentTerm。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> LastlogEntry.Term == args.Term &amp;&amp;</span><br><span class="line">    LastlogEntry.Index &gt;= LastAppendEntry.Index &#123;</span><br><span class="line">    <span class="comment">//Leader won&#x27;t delete current leader&#x27;s replicate Logs</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>updatecommit</strong></li></ol><p>更新follower的commitIndex以heartbeat与AppendEntry中携带的信息进行更新即可</p><h3 id="2-Start-（发送方-Leader）"><a href="#2-Start-（发送方-Leader）" class="headerlink" title="2.Start （发送方 Leader）"></a>2.Start （发送方 Leader）</h3><blockquote><p>必要的函数处理</p></blockquote><p>1.log commit后发送ApplyMsg到applyCh</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendApply(index <span class="type">int</span>, command <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    applyMsg := ApplyMsg&#123;&#125;</span><br><span class="line">    applyMsg.Command = command</span><br><span class="line">    applyMsg.CommandIndex = index</span><br><span class="line">    applyMsg.CommandValid = <span class="literal">true</span></span><br><span class="line">    rf.ApplySend &lt;- applyMsg</span><br><span class="line">    <span class="comment">//Debug(dLog2, &quot;S%d saved log.Command %v, Index:%d&quot;, rf.me, applyMsg.Command, applyMsg.CommandIndex)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取N也就是更具matchIndex来判断更新commitIndex的索引</p><p>这里先将代码排序后取中位数的方法就可以获取最大的已提交的Index</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMid</span><span class="params">(matchIndex []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    tMatchArr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(matchIndex))</span><br><span class="line">    <span class="built_in">copy</span>(tMatchArr, matchIndex)</span><br><span class="line">    sort.Sort(sort.Reverse(sort.IntSlice(tMatchArr)))</span><br><span class="line"></span><br><span class="line">    N := tMatchArr[<span class="built_in">len</span>(tMatchArr)/<span class="number">2</span>]</span><br><span class="line">    Debug(dCommit, <span class="string">&quot;N :%d,tmatchArr:%v&quot;</span>, N, tMatchArr)</span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.大跨步原则快速更新NextIndex</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> OptimizeReduce(server <span class="type">int</span>, Args *AppendEntriesArgs) &#123;</span><br><span class="line">    PrevIndex := Args.PrevlogIndex</span><br><span class="line">    <span class="keyword">for</span> PrevIndex &gt; <span class="number">0</span> &amp;&amp; rf.log[PrevIndex].Term == Args.PrevlogTerm &#123;</span><br><span class="line">        PrevIndex--</span><br><span class="line">    &#125;</span><br><span class="line">    rf.nextIndex[server] = PrevIndex + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.获取最后一个log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetLastLogEntry() LogEntry &#123;</span><br><span class="line">    LastIndex := <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">    logEntry := rf.log[LastIndex]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>replicate log</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> rf.nextIndex[server] &lt; <span class="number">1</span> &#123;</span><br><span class="line">    rf.nextIndex[server] = <span class="number">1</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="keyword">if</span> LastlogEntry.Index &gt;= rf.nextIndex[server] &#123;</span><br><span class="line">    Success, ok := rf.CallAE(server, Args)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.OptimizeReduce(server, Args)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handReply...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong> :发送RPC的过程不能加锁</p><p>在发送callAE时不能进行加锁操作，因为当follower失联后会导致server收到回复十分的缓慢，这样的话锁资源不能及时释放会导致sendheartbeat等需要锁资源的活动停止行动</p><blockquote><p>更新commitIndex以及应用apply</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">//原理同AE中网络包返回的时序问题</span></span><br><span class="line"><span class="keyword">if</span> Args.PrevlogIndex+<span class="built_in">len</span>(Args.Entries) &gt; rf.matchIndex[server] &#123;</span><br><span class="line">    rf.matchIndex[server] = Args.PrevlogIndex + <span class="built_in">len</span>(Args.Entries)</span><br><span class="line">    rf.nextIndex[server] = rf.atchIndex[server] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">N := GetMid(rf.matchIndex)</span><br><span class="line">cond.Broadcast()</span><br><span class="line"><span class="keyword">if</span> rf.log[N].Term == rf.currentTerm &amp;&amp; N &gt; rf.commitIndex &#123;</span><br><span class="line">    rf.commitIndex = N</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.peers[rf.me] == p &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">        rf.lastApplied++</span><br><span class="line">        rf.SendApply(rf.lastApplied, rf.log[rf.lastApplied].Command)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure><h3 id="3-实现Election-striction（-5-41）"><a href="#3-实现Election-striction（-5-41）" class="headerlink" title="3.实现Election striction（#5.41）"></a>3.实现Election striction（#5.41）</h3><blockquote><p>RV</p></blockquote><p>follower只会给比自己日志更新(up-to-date)的candidate授予票</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.LastlogTerm != LogEntry.Term &#123;</span><br><span class="line">    reply.VoteGranted = args.LastlogTerm &gt; LogEntry.Term</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reply.VoteGranted = args.LastlogIndex &gt;= LogEntry.Index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">    rf.votedFor = args.CandidateId</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Debug(dVote, <span class="string">&quot;S%d Log is more new than S%d reject vote&quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的在startElection处RPC参数中添加上LastlogTerm参数即可</p><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2Bpass.png" alt="2Bpass.png"></p><h1 id="Lab-2C：Persistent-State"><a href="#Lab-2C：Persistent-State" class="headerlink" title="Lab 2C：Persistent State"></a>Lab 2C：Persistent State</h1><h3 id="1-Persist-函数完善"><a href="#1-Persist-函数完善" class="headerlink" title="1.Persist 函数完善"></a>1.Persist 函数完善</h3><p>persist():将Persist state写入磁盘，根据figure2 中所述将currentTerm、votedFor、log状态写入磁盘(本次实验实际上是序列化与反序列化)，此函数需要在Persist State修改后插入此函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(rf.currentTerm)</span><br><span class="line">    e.Encode(rf.votedFor)</span><br><span class="line">    e.Encode(rf.log)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    rf.persister.SaveRaftState(data)<span class="comment">//Persist.go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readpersist():在Server Crash后重启调用Make(…)，将Crash前保存的状态进行读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> Log []LogEntry</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;currentTerm) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;Log) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.currentTerm = currentTerm</span><br><span class="line">        rf.votedFor = votedFor</span><br><span class="line">        rf.log = <span class="literal">nil</span></span><br><span class="line">        rf.log = <span class="built_in">append</span>(rf.log, Log...)</span><br><span class="line">        Debug(dPersist, <span class="string">&quot;S%d Read State T:%d VF:%d Log:%v&quot;</span>, rf.me,</span><br><span class="line">            rf.currentTerm, rf.votedFor, rf.log)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-RPC：失败重传"><a href="#2-RPC：失败重传" class="headerlink" title="2.RPC：失败重传"></a>2.RPC：失败重传</h3><p>任何RPC都要保证传送成功，只有当前节点状态发生改变或是传送成功时才停止</p><blockquote><p>RV</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ok &#123; <span class="comment">//follower crash re-send RV</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.State != Candidate &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    VoteGranted, ok = rf.CallRV(server, Args)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AE</p></blockquote><p>1.replicate log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Success, ok := rf.CallAE(server, Args)</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">    Debug(dDrop, <span class="string">&quot;S%d -&gt; S%d can&#x27;t replicated log&quot;</span>, rf.me, server)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Update CommitIndex</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !ok &#123; <span class="comment">// re-send if follower crash</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    _, ok = rf.CallAE(server, Args)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-终止僵尸进程-heartbeat-（使用rf-killed-）"><a href="#3-终止僵尸进程-heartbeat-（使用rf-killed-）" class="headerlink" title="3.终止僵尸进程(heartbeat)（使用rf.killed()）"></a>3.终止僵尸进程(heartbeat)（使用rf.killed()）</h3><p>Debug：在发送heartbeat时leader crash后重启，该heartbeat进程尚未终止，因此当heartbeat全部都发送失败时则将状态转变为follower</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> LeaderWork() &#123;</span><br><span class="line">    heartbeatInterval := <span class="number">35</span> <span class="comment">// dont set too low to pass Count2B</span></span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//reinitialized volatile  state on leader</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sendheatbeat</span></span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        _, ok = rf.GetState()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            rf.Sendheartbeat(args)</span><br><span class="line">            time.Sleep(time.Duration(heartbeatInterval) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Unreliable：网络中的复杂通信问题"><a href="#4-Unreliable：网络中的复杂通信问题" class="headerlink" title="4.Unreliable：网络中的复杂通信问题"></a>4.Unreliable：网络中的复杂通信问题</h3><blockquote><p>Figure8Unreliable2C的测试点中的fail to reachment</p></blockquote><p>该测试点就是模拟了网络中的复杂的情况，它将包的传输顺序打乱然后随机的增加网络的传输延迟</p><blockquote><p>问题分析</p></blockquote><p>在log中的显示实际上是，在最后的cfg.one(..)中要求在一定时间内将所有的log commitIndex更新到一致</p><p>在处理包的实际中存在延迟问题，需要加以优化</p><p>Students’ Guide to Raft:<strong>不要随意重置election</strong></p><blockquote><p>Make sure you reset your election timer <em>exactly</em> when Figure 2 says you should. Specifically, you should <em>only</em> restart your election timer if a) you get an <code>AppendEntries</code> RPC from the <em>current</em> leader (i.e., if the term in the <code>AppendEntries</code> arguments is outdated, you should <em>not</em> reset your timer); b) you are starting an election; or c) you <em>grant</em> a vote to another peer</p></blockquote><p>a) 过期的RPC包不重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; args.Term&#123;</span><br><span class="line">    reply.Term = Term <span class="comment">//change Leader Term</span></span><br><span class="line">    reply.Success = <span class="literal">false</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.isReceive = <span class="literal">false</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 开始election可以重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span>StartElection()&#123;</span><br><span class="line">    ...</span><br><span class="line">    rf.isReceive = <span class="literal">true</span> <span class="comment">//在选举结束前都不会开启下一次选举</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c) RV:给另一个peer投票后才重置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">    rf.votedFor = args.CandidateId</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Debug(dVote, <span class="string">&quot;S%d Log is more new than S%d reject vote&quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-实验结果："><a href="#5-实验结果：" class="headerlink" title="5.实验结果："></a>5.实验结果：</h3><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\Persist.png" alt="Persist.png"></p><h2 id="性能优化ReplicateLog"><a href="#性能优化ReplicateLog" class="headerlink" title="性能优化ReplicateLog"></a>性能优化ReplicateLog</h2><h3 id="Batch-and-PipelineTikv"><a href="#Batch-and-PipelineTikv" class="headerlink" title="Batch and PipelineTikv"></a>Batch and Pipeline<a href="https://pingcap.com/zh/blog/optimizing-raft-in-tikv">Tikv</a></h3><p>对于服务请求会多次的调用Start()去添加log，但是若每次添加Log都去触发ReplicateLog的话，那么会导致性能上的浪费。</p><ul><li><strong>Batch:</strong> 我们可以等待Start()添加log到达一定数量时去唤醒Relicate协程，将一批次的Log进行ReplicateLog</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BatchMaxSize = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BatchInterval = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> BatchMutex sync.Mutex</span><br><span class="line"><span class="keyword">var</span> batchNum <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateInBatch() &#123;</span><br><span class="line">    BatchMutex.Lock()</span><br><span class="line">    batchNum++</span><br><span class="line">    <span class="keyword">if</span> batchNum &gt;= BatchMaxSize &#123; <span class="comment">//achive batchsize,in fact the BatchMaxSize should be Set larger</span></span><br><span class="line">        batchNum = <span class="number">0</span> <span class="comment">//so is BatchInterval</span></span><br><span class="line">        BatchMutex.Unlock()</span><br><span class="line">        rf.replicateTopeers()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BatchMutex.Unlock()</span><br><span class="line">        time.Sleep(time.Duration(BatchInterval) * time.Millisecond)</span><br><span class="line">        batchNum = <span class="number">0</span></span><br><span class="line">        rf.replicateTopeers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Pipeline:</strong> 如果只是用 batch，Leader 还是需要等待 Follower 返回才能继续后面的流程，我们这里还可以使用 Pipeline 来进行加速。Leader 会维护一个 NextIndex 的变量来表示下一个给 Follower 发送的 log 位置，只负责多发，保证速率，包的顺序由接收方Follower去控制，不用在意Follower的返回。(接收方能够确保包的序列，保存或者丢弃无用的包，例如TCP中的pipeline)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicateTopeers() &#123; <span class="comment">//pipeline</span></span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.peers[rf.me] == p &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> rf.replicate(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicate(server <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastlogIndex := rf.GetLastLogEntry().Index</span><br><span class="line">        <span class="keyword">if</span> lastlogIndex &gt;= rf.nextIndex[server] &#123;</span><br><span class="line">            args := rf.GetAppendArgs(server)</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            Success, ok := rf.CallAE(server, args)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">                time.Sleep(time.Duration((rand.Intn(<span class="number">30</span>))+electionInterval) * time.Millisecond)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">                rf.mu.Lock()</span><br><span class="line">                lastIncludedIndex = rf.GetFirstLogEntry().Index</span><br><span class="line">                <span class="comment">//Pervlog(=firstIndex) can&#x27;t match the follower log that means follower is lag</span></span><br><span class="line">                <span class="keyword">if</span> args.PrevlogIndex &lt;= lastIncludedIndex &#123;</span><br><span class="line">                    rf.mu.Unlock()</span><br><span class="line">                    rf.Install(server, lastIncludedIndex)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                rf.OptimizeReduce(server, args)</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            rf.handleAEReply(server, args)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Asynchronous-Apply"><a href="#Asynchronous-Apply" class="headerlink" title="Asynchronous Apply"></a>Asynchronous Apply</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rf.applyCond = sync.NewCond(&amp;rf.mu)<span class="keyword">go</span> rf.applier()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> rf.applier()</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="comment">//asynchronous apply the command</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &#123;</span><br><span class="line">            rf.applyCond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        commitIndex := rf.commitIndex</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">var</span> Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">            rf.lastApplied++</span><br><span class="line">            Command = rf.log[rf.lastApplied-rf.LastIncludedIndex].Command</span><br><span class="line">            rf.SendApply(rf.lastApplied, Command)</span><br><span class="line">        &#125;</span><br><span class="line">        Debug(dCommit, <span class="string">&quot;S%d LAI:%d LCI:%d&quot;</span>, rf.me, rf.lastApplied, rf.commitIndex)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/Tikv.jpg" alt="Tikv.jpg"></p><h3 id="SofaRaft"><a href="#SofaRaft" class="headerlink" title="SofaRaft"></a><a href="(https://mp.weixin.qq.com/s/jzqhLptmgcNix6xYWYL01Q">SofaRaft</a></h3><ul><li>开启Replicator协程：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">    rf.matchIndex[i], rf.nextIndex[i] = <span class="number">0</span>, rf.GetLastLogEntry().Index+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.replicateCond[i] = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">        <span class="comment">//replicate log entries in batch</span></span><br><span class="line">        <span class="keyword">go</span> rf.replicator(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Replicator</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicator(server <span class="type">int</span>) &#123;</span><br><span class="line">    rf.replicateCond[server].L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.replicateCond[server].L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> rf.nextIndex[server] &gt; rf.GetLastLogEntry().Index &#123;</span><br><span class="line">            rf.replicateCond[server].Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pipeline</span></span><br><span class="line">        rf.replicate(server)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知协程</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastToReplicate() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> rf.me == i &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// just Broadcast To signal go routine</span></span><br><span class="line">        rf.replicateCond[i].Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Replicate向follower发送AE</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> replicate(server <span class="type">int</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.GetFirstLogEntry().Index &gt; rf.nextIndex[server] &#123;</span><br><span class="line">        Args := &amp;InstallSnapshotArgs&#123;&#125;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        rf.CallISS(server, Args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        args := rf.GetAppendArgs(server)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        Success, ok := rf.CallAE(server, args)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123; <span class="comment">//sendAE false</span></span><br><span class="line">            <span class="comment">//Debug(dDrop, &quot;S%d -&gt; S%d can&#x27;t replicated log&quot;, rf.me, server)</span></span><br><span class="line">            rf.replicateCond[server].Signal()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">            rf.OptimizeReduce(server, args)</span><br><span class="line">            rf.replicateCond[server].Signal()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rf.handleAEReply(server, args)</span><br><span class="line">        rf.replicateCond[server].Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/SofaRaft.jpg" alt="SofaRaft.jpg"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>Tikv</li></ul><p>batch的使用会导致测试时间加长，因为在实验中并没有大量的数据用以测试，而且在有时会用one()来要求所有peer的数据强制统一，这强制共识会花费一定的时间，并且设置了一个<strong>batchInterval</strong>的时间间隔，只有batchtime超时后才进行replicate，导致时间加长。而且对于2B的最后一个测试点，batch操作也会导致发送过多的heartbeat导致无法通过。</p><ul><li>SofaRaft</li></ul><p>时间延迟等问题还未太过研究</p><h1 id="Lab-2D-Compaction-Log"><a href="#Lab-2D-Compaction-Log" class="headerlink" title="Lab 2D: Compaction Log"></a>Lab 2D: Compaction Log</h1><blockquote><p>在实验二中并不会去实现快照只是实现日志压缩，快照的相关实现会在Lab3中实现</p></blockquote><h2 id="Snapshot的作用："><a href="#Snapshot的作用：" class="headerlink" title="Snapshot的作用："></a>Snapshot的作用：</h2><ol><li><p><strong>raft层裁剪日志</strong>：该服务属于服务层的应用接口(在VM ware 中就有该功能)，当客户端或者服务层发现log的size到达一定数量时会导致<strong>磁盘空间膨胀</strong>，因此，我们将使用snapshot对于一定的log进行<strong>裁剪删除</strong>。</p></li><li><p><strong>服务层保存状态机状态</strong>：对于服务层来说，日志到达指定大小后服务端调用Snapshot()会将<strong>applied</strong>的日志的状态机的<strong>状态(数据库…)</strong> 进行快照拍摄,并将改状态之前的日志压缩也即是丢弃，当服务端crash后可以读取改快照时的状态到达快速恢复的作用</p></li></ol><h2 id="Snapshot的接口："><a href="#Snapshot的接口：" class="headerlink" title="Snapshot的接口："></a>Snapshot的接口：</h2><ul><li>service接口</li></ul><p><strong>snapshot():</strong> log到达一定数量后进行裁剪和压缩</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Inde</span><br><span class="line">    <span class="keyword">if</span> index &lt;= lastIncludedIndex &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.CompactLog(index, snapshot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CompactLog(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    lastIncludedIndex := rf.GetFirstLogEntry().Index</span><br><span class="line">    <span class="comment">//将log裁剪到lastIncludedindex,不包括该点,用以替代之前的空log[0],</span></span><br><span class="line">    <span class="comment">//更容易去进行匹配与snapshot的安装</span></span><br><span class="line">    rf.logs = rf.logs[index-lastIncludedIndex:]</span><br><span class="line">    rf.logs[<span class="number">0</span>].Command = <span class="literal">nil</span></span><br><span class="line">    rf.snapshotpersist(snapshot)</span><br><span class="line">    <span class="keyword">go</span> rf.SendApplySnapshot(index, rf.logs[<span class="number">0</span>].Term, snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>condInstallsnapshot():</strong> 服务层进行协调log与snapshot,主动调用该函数判断是否需要安装快照，服务层发现Applych发送过来的snapshot消息来判断是否还是需要重新调用snapshot()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="comment">// outdated snapshot,can&#x27;t compact uncommitted log</span></span><br><span class="line">    <span class="keyword">if</span> lastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行日志压缩</span></span><br><span class="line">    <span class="keyword">if</span> lastIncludedIndex &gt; rf.GetLastLogEntry().Index &#123;</span><br><span class="line">        rf.logs = <span class="literal">nil</span></span><br><span class="line">        rf.logs = <span class="built_in">make</span>([]LogEntry, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> rf.SendApplySnapshot(lastIncludedIndex, lastIncludedTerm, snapshot)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.CompactLog(lastIncludedIndex, snapshot)</span><br><span class="line">    &#125;</span><br><span class="line">    rf.logs[<span class="number">0</span>].Term, rf.logs[<span class="number">0</span>].Index = lastIncludedTerm, lastIncludedIndex</span><br><span class="line">    rf.lastApplied, rf.commitIndex = lastIncludedIndex, lastIncludedIndex</span><br><span class="line"></span><br><span class="line">    rf.snapshotpersist(snapshot)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>raft接口</li></ul><p><strong>saveStateAndSnapshot()</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> snapshotpersist(snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(rf.currentTerm)</span><br><span class="line">    e.Encode(rf.votedFor)</span><br><span class="line">    e.Encode(rf.logs)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    rf.persister.SaveStateAndSnapshot(data, snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReadSnapshot()</strong>：服务层恢复后读取snapshot进行恢复</p><h2 id="InstallSnapshot-RPC"><a href="#InstallSnapshot-RPC" class="headerlink" title="InstallSnapshot RPC"></a>InstallSnapshot RPC</h2><ol><li><p>Leader对滞后的follower进行发送snapshot RPC，follower在处理InstallSnapshot时，让follower直接更新到Leader的SM_state，并将其log全部删除(因为leader最小的日志索引都大于了follower)，</p></li><li><p>将其SM_state传输到服务层进行同步，因为follower时滞后的状态通过传送applyCh给服务层进行判断并存储即可</p></li></ol><blockquote><p>发送时机:</p></blockquote><ul><li>当nextIndex[server] &lt;= firstIndex(LastIncluded)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.nextIndex[server] &lt;= lastIncludedIndex &#123;</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            rf.Install(server, lastIncludedIndex)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>当发送此次RPC时最开始的index(lastIncludedIndex)都与follower匹配不上</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !Success &#123; <span class="comment">//log inconsistence</span></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    lastIncludedIndex = rf.GetFirstLogEntry().Index</span><br><span class="line">    <span class="comment">//Pervlog(=firstIndex) can&#x27;t match the follower log that means follower is lag</span></span><br><span class="line">    <span class="keyword">if</span> args.PrevlogIndex &lt;= lastIncludedIndex &#123;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    rf.Install(server, lastIncludedIndex)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.OptimizeReduce(server, args)</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送InstallRPC：SnapshotRPC中的offset与done的参数也不需要完成</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Install(server <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    Debug(dSnap, <span class="string">&quot;S%d -&gt; S%d Send ISS&quot;</span>, rf.me, server)</span><br><span class="line">    lastIncludedTerm := rf.GetFirstLogEntry().Term</span><br><span class="line">    snapshot := rf.persister.ReadSnapshot()</span><br><span class="line">    args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">        Term:              rf.currentTerm,</span><br><span class="line">        LeaderId:          rf.me,</span><br><span class="line">        LastIncludedIndex: lastIncludedIndex,</span><br><span class="line">        LastIncludedTerm:  lastIncludedTerm,</span><br><span class="line">        Data:              snapshot,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rf.CallISS(server, args) &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.nextIndex[server] = rf.GetLastLogEntry().Index</span><br><span class="line">        Debug(dTrace, <span class="string">&quot;S%d -&gt; S%d (ISS)update nextIndex:%d&quot;</span>, rf.me, server, rf.nextIndex[server])</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RPC处理</p></blockquote><p>​    若传送过来的LastIncludeIndex &lt;= rf.commitIndex则可以说明follower已经同步snapshot中的状态，不需要用此条消息中的snapshot去更新上层状态机，因此不需要处理这条消息。</p><p>​    既然follower的log已经滞后，那么将其长度进行判断后删除log和旧的snapshot，然后args中的data[]作为snapshot持久化后再通过channel上传到service层。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapShot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//handle Term as same as RequestVote</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.LastIncludedIndex &lt;= rf.commitIndex &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Debug(dSnap, <span class="string">&quot;S%d &lt;- S%d InstallSnap LII:%d&quot;</span>, rf.me, args.LeaderId, args.LastIncludedIndex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> rf.SendApplySnapshot(args.LastIncludedIndex, args.LastIncludedTerm, args.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/2D.png" alt="2D.png"></p><h2 id="Lab2测试结果"><a href="#Lab2测试结果" class="headerlink" title="Lab2测试结果"></a>Lab2测试结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu% </span><span class="language-bash">go <span class="built_in">test</span> -run 2</span></span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">  ... Passed --   3.0  3  152   37666    0</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">  ... Passed --   5.6  3  363   72800    0</span><br><span class="line">Test (2A): multiple elections ...</span><br><span class="line">  ... Passed --   5.5  7 1322  276420    0</span><br><span class="line">Test (2B): basic agreement ...</span><br><span class="line">  ... Passed --   0.4  3   23    5697    3</span><br><span class="line">Test (2B): RPC byte count ...</span><br><span class="line">  ... Passed --   0.6  3   75  119217   11</span><br><span class="line">Test (2B): agreement after follower reconnects ...</span><br><span class="line">  ... Passed --   5.1  3  290   69423    8</span><br><span class="line">Test (2B): no agreement if too many followers disconnect ...</span><br><span class="line">  ... Passed --   3.5  5  415   87611    3</span><br><span class="line">Test (2B): concurrent Start()s ...</span><br><span class="line">  ... Passed --   0.5  3   21    5239    6</span><br><span class="line">Test (2B): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   6.1  3  493  107841    4</span><br><span class="line">Test (2B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --   9.2  5 3107 1524763  102</span><br><span class="line">Test (2B): RPC counts aren&#x27;t too high ...</span><br><span class="line">  ... Passed --   2.0  3  126   31740   12</span><br><span class="line">Test (2C): basic persistence ...</span><br><span class="line">  ... Passed --   8.3  3  453  110028    6</span><br><span class="line">Test (2C): more persistence ...</span><br><span class="line">  ... Passed --  14.3  5 2031  421054   16</span><br><span class="line">Test (2C): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   1.3  3   59   14177    4</span><br><span class="line">Test (2C): Figure 8 ...</span><br><span class="line">  ... Passed --  32.8  5 1919  414186   49</span><br><span class="line">Test (2C): unreliable agreement ...</span><br><span class="line">  ... Passed --   1.6  5 1547  462287  246</span><br><span class="line">Test (2C): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  41.1  5 15167 15643471  441</span><br><span class="line">Test (2C): churn ...</span><br><span class="line">  ... Passed --  16.2  5 21731 148707193 2309</span><br><span class="line">Test (2C): unreliable churn ...</span><br><span class="line">  ... Passed --  16.1  5 6125 5732595  603</span><br><span class="line">Test (2D): snapshots basic ...</span><br><span class="line">  ... Passed --   1.8  3  651  177508  206</span><br><span class="line">Test (2D): install snapshots (disconnect) ...</span><br><span class="line">  ... Passed --  47.6  3 3687 1268045  303</span><br><span class="line">Test (2D): install snapshots (disconnect+unreliable) ...</span><br><span class="line">  ... Passed --  74.8  3 5734 2004161  359</span><br><span class="line">Test (2D): install snapshots (crash) ...</span><br><span class="line">  ... Passed --  37.7  3 2951 1224282  365</span><br><span class="line">Test (2D): install snapshots (unreliable+crash) ...</span><br><span class="line">  ... Passed --  66.3  3 4643 1664199  355</span><br><span class="line">Test (2D): crash and restart all servers ...</span><br><span class="line">  ... Passed --   3.5  3  386   98139   57</span><br><span class="line">PASS</span><br><span class="line">ok      6.824/raft    404.893s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab:KVRaft</title>
      <link href="/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/KVRaft/"/>
      <url>/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/KVRaft/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab3-KVRaft"><a href="#Lab3-KVRaft" class="headerlink" title="Lab3:KVRaft"></a>Lab3:KVRaft</h1><blockquote><p><strong>写在前面</strong>：lab3 的内容是要在 lab2 的基础上实现一个高可用的 KV 存储服务，算是要将 raft 真正的用起来。相关协调服务可以参考OngaroPhD的作者的博士论文或者是ZooKeeper 论文笔记的协调服务,另外Chain Replicate 论文笔记的设计中同样满足了高性能读的服务</p></blockquote><h1 id="PartA-Key-value-service-without-snapshots"><a href="#PartA-Key-value-service-without-snapshots" class="headerlink" title="PartA:Key/value service without snapshots"></a>PartA:Key/value service without snapshots</h1><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="Client创建"><a href="#Client创建" class="headerlink" title="Client创建"></a>Client创建</h3><p>创建client自动生成ID号(使用nrand()函数生成)用于Session来记录lastRequest的回复,用LeaderID快速连接server，减少重试leader时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">    ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">    ck.servers = servers</span><br><span class="line">    <span class="comment">// You&#x27;ll have to add code here.</span></span><br><span class="line">    ck.LeaderId = <span class="number">0</span></span><br><span class="line">    ck.ClientId = nrand()</span><br><span class="line">    ck.CommandId = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetryToLeader()</strong> ：重连leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> RetryToLeader() &#123;</span><br><span class="line">  oneRound := <span class="number">0</span></span><br><span class="line">  args := &amp;GetArgs&#123;Key: <span class="string">&quot;&quot;</span>, ClientId: ck.ClientId, CommandId: ck.CommandId&#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">      oneRound++</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      reply.Err = <span class="string">&quot;&quot;</span></span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line"><span class="comment">//在分区后client可能无法连接到该失联分区的server，发送失败则更换server进行连接</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line"></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          <span class="keyword">if</span> oneRound == <span class="built_in">len</span>(ck.servers) &#123;</span><br><span class="line">              oneRound = <span class="number">0</span></span><br><span class="line">              time.Sleep(<span class="number">700</span> * time.Millisecond)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client发送读写"><a href="#Client发送读写" class="headerlink" title="Client发送读写"></a>Client发送读写</h3><h4 id="读操作-Get"><a href="#读操作-Get" class="headerlink" title="读操作:Get()"></a>读操作:Get()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  ck.CommandId++</span><br><span class="line">  args := &amp;GetArgs&#123;</span><br><span class="line">      Key:       key,</span><br><span class="line">      CommandId: ck.CommandId,</span><br><span class="line">      ClientId:  ck.ClientId,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You will have to modify this function.</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      reply := &amp;GetReply&#123;&#125;</span><br><span class="line">      ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> !ok &#123;</span><br><span class="line">          <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">          ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">          ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">          ck.RetryToLeader()</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == ErrNoKey &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">          <span class="keyword">return</span> reply.Value</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写操作-PutAppend"><a href="#写操作-PutAppend" class="headerlink" title="写操作:PutAppend()"></a>写操作:PutAppend()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line">    ck.CommandId++</span><br><span class="line">    args := &amp;PutAppendArgs&#123;</span><br><span class="line">        Key:       key,</span><br><span class="line">        Value:     value,</span><br><span class="line">        Op:        op,</span><br><span class="line">        CommandId: ck.CommandId,</span><br><span class="line">        ClientId:  ck.ClientId,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">for</span> !ok &#123;</span><br><span class="line">            <span class="comment">//this serverID is disconnect and change ServerID</span></span><br><span class="line">            ck.LeaderId = (ck.LeaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">            ok = ck.servers[ck.LeaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reply.Err == ErrWrongLeader || reply.Err == ErrTimeout &#123;</span><br><span class="line">            ck.RetryToLeader()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Err == OK &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><h3 id="创建服务器-StartKVServer"><a href="#创建服务器-StartKVServer" class="headerlink" title="创建服务器:StartKVServer():"></a>创建服务器:StartKVServer():</h3><ul><li><strong>服务器数据结构</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    rf      *raft.Raft</span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    servers     <span class="type">int</span></span><br><span class="line">    lastapplied <span class="type">int</span></span><br><span class="line">    Term        <span class="type">int</span></span><br><span class="line">    sm          KVStateMachine</span><br><span class="line">    Session     <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond       <span class="comment">// （clientId, lastRespond）record last command&#x27;s id ,respond</span></span><br><span class="line">    NotifyChans <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond <span class="comment">// (client , Chan Respond) ansynchoron to notif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read only check whether all log are applied</span></span><br><span class="line">    isRecovery <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建kv-server 与 下层raft进行交互,到达共识提高容错</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">    labgob.Register(Op&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    kv := <span class="built_in">new</span>(KVServer)</span><br><span class="line">    kv.me = me</span><br><span class="line">    kv.maxraftstate = maxraftstate</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">    <span class="comment">//creat raft layer</span></span><br><span class="line">    kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You may need initialization code here.</span></span><br><span class="line">    kv.lastapplied = kv.rf.GetFirstLogEntry().Index</span><br><span class="line">    kv.Term = <span class="number">0</span></span><br><span class="line">    kv.sm.mkv = NewMemoryKV()</span><br><span class="line">    kv.Session = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]LastRespond)</span><br><span class="line">    kv.NotifyChans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> CommandRespond)</span><br><span class="line">    kv.servers = <span class="built_in">len</span>(servers)</span><br><span class="line">    <span class="comment">//handle with recovery</span></span><br><span class="line">    kv.isRecovery = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    kv.recovery()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> kv.applier()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateMachine的内存模型："><a href="#StateMachine的内存模型：" class="headerlink" title="StateMachine的内存模型："></a>StateMachine的内存模型：</h3><blockquote><p>主要是创建一个kv-table，以一种内存模型的方式进行记录client端发来的修改信息,后续用于生成快照</p></blockquote><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">    mkv *MemoryKV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemoryKV <span class="keyword">struct</span> &#123;<span class="comment">//键值表的定义</span></span><br><span class="line">    KV <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemoryKV</span><span class="params">()</span></span> *MemoryKV &#123;<span class="comment">//申请堆内存</span></span><br><span class="line">    <span class="keyword">return</span> &amp;MemoryKV&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kv-table的内存模型的接口："><a href="#kv-table的内存模型的接口：" class="headerlink" title="kv-table的内存模型的接口："></a>kv-table的内存模型的接口：</h4><ul><li><strong>Append()  Put() Get()</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Get(key <span class="type">string</span>) (<span class="type">string</span>, Err) &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mkv.KV[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, OK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Put(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    mkv.KV[key] = value</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mkv *MemoryKV)</span></span> KV_Append(key, value <span class="type">string</span>) Err &#123;</span><br><span class="line">    <span class="keyword">if</span> mkv.KV[key] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        mkv.KV[key] = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkv.KV[key] += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用日志操作到状态机"><a href="#应用日志操作到状态机" class="headerlink" title="应用日志操作到状态机"></a>应用日志操作到状态机</h4><p> 处理request信息并记录其respond:将ApplyCh中的op msg应用至kvserver状态机中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *KVStateMachine)</span></span> ApplyToStateMachine(op Op) CommandRespond &#123;</span><br><span class="line">    <span class="keyword">var</span> cr CommandRespond</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> op.Opt &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Get&quot;</span>:</span><br><span class="line">        cr.Value, cr.Err = sm.mkv.KV_Get(op.Key)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Append&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Append(op.Key, op.Value)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Put&quot;</span>:</span><br><span class="line">        cr.Err = sm.mkv.KV_Put(op.Key, op.Value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><ol><li><p>使用<strong>NotifyChans</strong>去通知处理request的接口，raft的op以及apply，以channel的方式进行异步的处理</p></li><li><p>用<strong>Session</strong>记录(clientID,LastRespond)，将每个client的request的响应消息进行记录，用于防止client retry多次将命令应用于state machine，以及快速响应</p></li></ol><p><strong>applier()</strong>:异步的接收raft层apply channel所传递上来的消息</p><ol><li><p><strong>防止日志回滚</strong> msg.CommandIndex &lt;= kv.lastapplied</p></li><li><p><strong>处理duplicate消息</strong> </p></li><li><p><strong>Apply</strong> 将apply的消息应用到状态机中</p></li><li><p><strong>回复客户端</strong> leader需要通过<strong>NotifyChan</strong>将状态机<strong>应用命令后回复的消息</strong>传递给该消息所调用的Put/Get,从而回复给Client,leader只能通知当前周期的命令,非当前周期的命令没有接收者从而导致阻塞</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">//avoid log rollback</span></span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> msg.CommandIndex &lt;= kv.lastapplied &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d discard outdate msg&quot;</span>, kv.me)</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            kv.lastapplied = msg.CommandIndex</span><br><span class="line">            <span class="keyword">var</span> respond CommandRespond</span><br><span class="line">            op := msg.Command.(Op)</span><br><span class="line">            <span class="comment">//apply msg -&gt; kv machine</span></span><br><span class="line">            <span class="keyword">if</span> kv.isRedundantRequest(op.ClientId, op.CommandId) &#123;</span><br><span class="line">                respond = kv.Session[op.ClientId].Respond</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                respond = kv.sm.ApplyToStateMachine(op)</span><br><span class="line">                _, isLeader := kv.rf.GetState()</span><br><span class="line">                <span class="keyword">if</span> isLeader &amp;&amp; op.opt != <span class="string">&quot;Get&quot;</span> &#123;</span><br><span class="line">                    kv.Session[op.ClientId] = LastRespond&#123;op.CommandId, respond&#125;</span><br><span class="line">                    DPrintf(<span class="string">&quot;S%d -&gt; C%d LastRequest type:%v K:%v V:%v CmdId:%d CMI:%d T:%d&quot;</span>,</span><br><span class="line">                        kv.me, op.ClientId%<span class="number">50</span>, op.Opt, op.Key, op.Value,</span><br><span class="line">                            op.CommandId, msg.CommandIndex, op.CommandTerm)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentTerm, isLeader := kv.rf.GetState(); isLeader &amp;&amp;</span><br><span class="line">                currentTerm == op.CommandTerm &#123;</span><br><span class="line">                DPrintf(<span class="string">&quot;S%d Notify%v to C%d index %d&quot;</span>, kv.me, respond,</span><br><span class="line">                    op.ClientId%<span class="number">50</span>, msg.CommandIndex)</span><br><span class="line">                ch := kv.GetNotifyChan(msg.CommandIndex)</span><br><span class="line">                ch &lt;- respond</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作:"></a>读写操作:</h3><blockquote><p>读写操作需要满足线性一致性:[[ZooKeeper 论文笔记#线性一致性：Linearizability]]</p></blockquote><ul><li><strong>PutAppend()</strong>:处理client的修改请求</li></ul><ol><li><p>Client请求该方法</p></li><li><p>冗余检测</p></li><li><p>调用Start将Command传递到下层达到共识</p></li><li><p>创建Notifychan等待applier将response消息push</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        reply.Err = err</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d PutAppend request is redundant(PA)&quot;</span>, args.ClientId%<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       args.Op,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        Value:     args.Value,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d PutAppendRequest CmdId %d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err = cr.Err</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeOut</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Get()</strong>:将read操作记录至log，主要是防止分区时向minority partition的leader请求返回stale data导致线性不一致，<strong>缺陷</strong>：将read操作同步会导致浪费磁盘空间以及同步写入read log的时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line">    _, is_leader := kv.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="comment">//DPrintf(&quot;S%d is not KVLeader cmdID%d&quot;, kv.me, args.CommandId)</span></span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> kv.isRedundantRequest(args.ClientId, args.CommandId) &#123;</span><br><span class="line">        err := kv.Session[args.ClientId].respond.Err</span><br><span class="line">        value := kv.Session[args.ClientId].respond.Value</span><br><span class="line">        reply.Err, reply.Value = err, value</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        DPrintf(<span class="string">&quot;C%d Get request is redundant(Get) cmdId %d&quot;</span>, args.ClientId%<span class="number">5</span>, args.CommandId)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Opt:       <span class="string">&quot;Get&quot;</span>,</span><br><span class="line">        Key:       args.Key,</span><br><span class="line">        ClientId:  args.ClientId,</span><br><span class="line">        CommandId: args.CommandId,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(<span class="string">&quot;S%d &lt;- C%d GetRequest LI:%d CmdId:%d&quot;</span>, kv.me, args.ClientId%<span class="number">50</span>, index, args.CommandId)</span><br><span class="line"></span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> cr := &lt;-ch:</span><br><span class="line">        reply.Err, reply.Value = cr.Err, cr.Value</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        reply.Err = ErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Read-Only-Query"><a href="#Read-Only-Query" class="headerlink" title="Read-Only Query:"></a>Read-Only Query:</h2><blockquote><p>Read-only Query不讲读日志写入磁盘，因为read本就是幂等操作(idempotent),不会影响状态机的状态，因此可以不用写入磁盘同步</p></blockquote><h3 id="challenge-共识"><a href="#challenge-共识" class="headerlink" title="challenge:共识"></a>challenge:共识</h3><ul><li><p><strong>分区容错性(Partition-torlerance)</strong>：由于不写入只读日志到raft层，无法使server到达<strong>共识</strong>(强一致性)，因此当前leader无法知道是否处于<strong>大多数分区中</strong>,可能会导致分区时少部分区域的leader回复给client旧的数据。</p><p><strong>解决方案:</strong> 因此在回复client时需要<strong>确认自己的leader状态</strong>,发送heartbeat能否获得大多数的server响应</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-------------raft.<span class="keyword">go</span>----------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> KV_Sendheartbeat() <span class="type">bool</span> &#123;</span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">        Term:         rf.currentTerm,</span><br><span class="line">        LeadId:       rf.me,</span><br><span class="line">        LeaderCommit: rf.commitIndex,</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> p == rf.peers[rf.me] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            _, ok := rf.CallAE(server, args)</span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                wg.Done()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">            num++</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">//majority of peers can rececive</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMajority = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------kvraft.<span class="keyword">go</span>-----------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ConfirmLeadership() <span class="type">bool</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> isMajority <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> _, isLeader := kv.rf.GetState(); isLeader &#123;</span><br><span class="line">        isMajority = kv.rf.KV_Sendheartbeat()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMajority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Leader日志applied到最新(Leader completeness guarantee)</strong> :出现分区等问题时新的Leader没有收到当前任期的Log因此之前的任期的log也不会提交并应用，导致当leader进行在处理只读操作时leader并没有同步所有日志，例如：Leader的currentTerm = 5，自己含有term=3或4的log没有applied，导致此时leader会返回旧数据。</p><p><strong>解决方案</strong>:当任期<strong>更改</strong>时<strong>添加no-op</strong>,添加一个空的log使peers达到共识，并使leader的日志同步到达最新</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  &#123;</span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, kv.Term)</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Keep Log Completeness:Send no-op log let leader applied all log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> getCompleteness(CommandId <span class="type">int64</span>, term <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        CommandId:   CommandId,</span><br><span class="line">        CommandTerm: term,</span><br><span class="line">        Opt:         <span class="string">&quot;no-op&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    index, _, is_leader := kv.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !is_leader &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch := kv.GetNotifyChan(index)</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d send no-op index %d &quot;</span>, kv.me, index)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">        DPrintf(<span class="string">&quot;no-op Channel is timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> kv.RecycleOutdateChan(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>recovery的时候进行Read-only操作(Recovery Reading)</strong>：因为read-only操作不写入log(正在recovery的leader也可以返回只读操作)，所以不会等待其applied后进行返回，会导致recovery的leader将正在replay的数据返回给client。</p><p><strong>解决方案</strong>：加入一个<strong>isRecovery</strong>变量，当service重启时赋值，只读操作需要让正在恢复的leader应用到所有的log,才能执行只读操作，因此当检测到本次只读操作时leader正在recovery就需要发送no-op让leader强制同步</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement Read-Only in raft , read operation is idempotent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get_RO(args *GetArgs, reply *GetReply) &#123; <span class="comment">//read-only</span></span><br><span class="line">    .......</span><br><span class="line">    kv.mu.Lock()</span><br><span class="line">    <span class="comment">//Completeness guarantee:send no-op make leader applied all log</span></span><br><span class="line">    <span class="keyword">if</span> term &gt; kv.Term  || kv.isRecovery&#123;</span><br><span class="line"></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        isLeader := kv.getCompleteness(args.CommandId, term)</span><br><span class="line">        kv.mu.Lock()</span><br><span class="line">        <span class="comment">//将isRecovery、term放置在getCompletness</span></span><br><span class="line">        <span class="comment">//防止并发客户端的只读请求跳过no-op操作</span></span><br><span class="line">        <span class="comment">//例如：讲Term与Recovery放置在</span></span><br><span class="line">        kv.Term = term</span><br><span class="line">        kv.isRecovery = <span class="literal">false</span></span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">            reply.Err = ErrWrongLeader</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Read-Only-Query-More-efficiency："><a href="#Read-Only-Query-More-efficiency：" class="headerlink" title="Read-Only Query More efficiency："></a>Read-Only Query More efficiency：</h2><p><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a></p><p>实现线性一致读最常规的办法是走 Raft 协议，将读请求同样按照 Log 处理，通过 Log 复制和状态机执行来获取读结果，然后再把读取的结果返回给 Client。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。                                                                                                                                                                                                                                                         </p><p>因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的 系统中是无法被接受的，通常都不会使用。                            </p><p>在 Raft 里面，节点有三个状态：Leader，Candidate 和 Follower，任何 Raft 的写入操作都必须经过 Leader，只有 Leader 将对应的 Raft Log 复制到 Majority 的节点上面认为此次写入是成功的。所以如果当前 Leader 能确定一定是 Leader，那么能够直接在此 Leader 上面读取数据，因为对于 Leader 来说，如果确认一个 Log 已经提交到大多数节点，在 t1 的时候 apply 写入到状态机，那么在 t1 后的 Read 就一定能读取到这个新写入的数据。</p><p>那么如何确认 Leader 在处理这次 Read 的时候一定是 Leader 呢？在 Raft 论文里面，提到两种方法：</p><ul><li>ReadIndex Read</li><li>Lease Read</li></ul><h3 id="ReadIndex-Read"><a href="#ReadIndex-Read" class="headerlink" title="ReadIndex Read"></a>ReadIndex Read</h3><p>第一种是 ReadIndex Read，当 Leader 需要处理 Read 请求时，Leader 与过半机器交换心跳信息确定自己仍然是 Leader 后可提供线性一致读：</p><ol><li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li><li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li><li>Leader 执行 Read 请求，将结果返回给 Client。</li></ol><p>使用 ReadIndex Read 提供 Follower Read 的功能，很容易在 Followers 节点上面提供线性一致读，Follower 收到 Read 请求之后：</p><ol><li>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li><li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li><li>Follower 执行 Read 请求，将结果返回给 Client。</li></ol><p>不同于通过 Raft Log 的 Read，ReadIndex Read 使用 Heartbeat 方式来让 Leader 确认自己是 Leader，省去 Raft Log 流程。相比较于走 Raft Log 方式，ReadIndex Read 省去磁盘的开销，能够大幅度提升吞吐量。虽然仍然会有网络开销，但是 Heartbeat 本来就很小，所以性能还是非常好的。</p><h3 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h3><p>虽然 ReadIndex Read 比原来的 Raft Log Read 快很多，但毕竟还是存在 Heartbeat 网络开销，所以考虑做更进一步的优化。Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start+Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start+Election Timeout/Clock Drift Bound 时间点。Lease Read 与 ReadIndex 类似但更进一步优化，不仅节省 Log，而且省掉网络交互，大幅提升读的吞吐量并且能够显著降低延时。</p><p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p><p>Lease Read 实现方式包括：</p><ol><li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li><li>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤(2)；</li><li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read。</li></ol><h1 id="PartB-Key-value-service-with-snapshots"><a href="#PartB-Key-value-service-with-snapshots" class="headerlink" title="PartB: Key/value service with snapshots"></a>PartB: Key/value service with snapshots</h1><h2 id="服务层使用快照-Snapshot-："><a href="#服务层使用快照-Snapshot-：" class="headerlink" title="服务层使用快照(Snapshot)："></a>服务层使用快照(Snapshot)：</h2><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p><strong>SnapShot正常执行</strong></p><ol><li><strong>调用Snapshot()</strong> :KV-Server在applier中应用日志时要判断,raft_State是否超过规定值,超过maxraftstate使用<strong>snapshot(sm_state)</strong> 拍摄状态机的状态快照,也就是将服务器的数据库、Session最后一次响应进行快照拍摄</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> needSnapshot() <span class="type">bool</span> &#123;</span><br><span class="line">    size := kv.rf.Persister.RaftStateSize()</span><br><span class="line">    <span class="keyword">if</span> kv.maxraftstate == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kv.maxraftstate &lt;= size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> takeSnapshot(CommandIndex <span class="type">int</span>) &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;S%d Taking Snapshot CommandIndex %d&quot;</span>, kv.me, CommandIndex)</span><br><span class="line">    w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    e := labgob.NewEncoder(w)</span><br><span class="line">    e.Encode(kv.sm.mkv)</span><br><span class="line">    e.Encode(kv.Session)</span><br><span class="line">    data := w.Bytes()</span><br><span class="line">    kv.rf.Snapshot(CommandIndex, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Think about when a kvserver should snapshot its state and what should be included in the snapshot.</p><p>Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots.</p></blockquote><p><strong>snapshot包含的信息</strong>:数据库+Session</p><ul><li><p>数据库:键值表</p></li><li><p>Session:客户端与服务端会话的最后一次request的响应</p></li></ul><ol><li><strong>压缩日志持久化snapshot:</strong> snapshot中会对当前commitIndex进行压缩日志,将raft_state(压缩后的日志)</li></ol><p><strong>Crash后恢复</strong></p><ol><li>当所有Server重启后，服务端需要读取snapshot，调用ReadSnapshot(),快速恢复状态机</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> recovery() &#123;</span><br><span class="line">    data := kv.rf.Persister.ReadSnapshot()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> mkv *MemoryKV</span><br><span class="line">    <span class="keyword">var</span> session <span class="keyword">map</span>[<span class="type">int64</span>]LastRespond</span><br><span class="line">    r := bytes.NewBuffer(data)</span><br><span class="line">    d := labgob.NewDecoder(r)</span><br><span class="line">    <span class="keyword">if</span> d.Decode(&amp;mkv) != <span class="literal">nil</span> ||</span><br><span class="line">        d.Decode(&amp;session) != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;read error&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kv.sm.mkv = mkv</span><br><span class="line">        kv.Session = session</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理滞后Follower</strong></p><ol><li><p><strong>raft层:</strong> Leader调用InstallSnapshot()发送snapshot给滞后的follower，follower处理此条消息用将<strong>snapshot消息</strong> push到channel中</p></li><li><p><strong>服务层:</strong> 检测本条channel的snap消息，使用CondInstallSnapshot() 对raft的日志进行调整,返回正确后，读取snapshot,将已有的SM_State覆盖</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line">    <span class="comment">//for !kv.killed() &#123;</span></span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            ...apply log to SM_State</span><br><span class="line">            kv.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> kv.needSnapshot() &#123;</span><br><span class="line">                kv.takeSnapshot(msg.CommandIndex)</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="keyword">if</span> kv.rf.CondInstallSnapshot(msg.SnapshotTerm, msg.SnapshotIndex, msg.Snapshot) &#123;</span><br><span class="line">                kv.lastapplied = msg.SnapshotIndex</span><br><span class="line">                <span class="comment">//updata snapshot to Sm_machine</span></span><br><span class="line">                kv.recovery()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ember-img.oss-cn-chengdu.aliyuncs.com/3B.png" alt=""></p><h3 id="调试中的bug"><a href="#调试中的bug" class="headerlink" title="调试中的bug"></a>调试中的bug</h3><p><strong>问题描述</strong></p><p>服务层与raft层ch通讯延时导致服务层applied信息过慢(可能是锁的原因)，而raft_State的logs已经增长的过多。</p><p>导致服务层对于raft 通过channel传递上来的消息都要调用一次Snapshot(),但是此时的索引却又很小,一次压缩可能就是压缩一个长度的log,因此下一条命令处理后raft_State仍是很大,又是重复此流程，程序的运行的则会报出<code>logs were not trimmed 日志未裁剪的错误,改报错是超过了指定的测试指定的大小</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验完成了KVRaft的所有测试点，对于Raft的博士论文中的讲解对于只读操作进行了实现，但是对于只读操作的调试过程是相对于比较困难的，还好最后完成了只读操作的实现，对于follower读取(Read-Only Query More effieciency)并没有打算进行实现(主要是只读操作花费太多精力了)，如果你想要对该操作进行实现可以参考<a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">SOFAJRaft 线性一致读实现剖析 | SOFAJRaft 实现原理 · SOFAStack</a>.</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Raft </tag>
            
            <tag> 线性一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab1:MapReduce</title>
      <link href="/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/MapReduce%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/01/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/MapReduce%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1：MAPREDUCE"><a href="#Lab1：MAPREDUCE" class="headerlink" title="Lab1：MAPREDUCE"></a>Lab1：MAPREDUCE</h1><h2 id="一、基础框架"><a href="#一、基础框架" class="headerlink" title="一、基础框架"></a>一、基础框架</h2><blockquote><p>paper中的mapreduce概念模型</p></blockquote><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\image-20220521154605632.png" alt="image-20220521154605632"></p><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\image-20220521154644882.png" alt="image-20220521154644882"></p><h3 id="程序调用"><a href="#程序调用" class="headerlink" title="程序调用"></a>程序调用</h3><blockquote><p>coordinator(master)及worker的调用框架</p></blockquote><p>lab1中的主要是把单进程的map-reduce分开执行并且使用coordinator作为master进行调用</p><p>1.工具链(静态库)</p><p>将map与reduce的方法放置于wc.go中，然后生成工具链</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -race -buildmode=plugin ../mrapps/wc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>2.挂起coordinator例程</p><p>coordinator运行时挂起，打开监听socket，等待worker的请求，并作出响应(返回文件名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run -race mrcoordinator.<span class="keyword">go</span> pg-*.txt</span><br></pre></td></tr></table></figure><p>第二个参数为pg-*.txt，为输入文件</p><p>mrcoordinator中调用mr/coordinator.go中的Makecoordinator并传入<strong>input文件名与reduce的任务数量</strong></p><p>3.打开worker例程(可以打开多个)</p><p>mrworker调用mr/worker.go ，mrworker中获取工具链中的mapf-reducef传入worker.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run -race mrworker.<span class="keyword">go</span> wc.so</span><br></pre></td></tr></table></figure><p>worker.go中需要向coordinator发出请求</p><p>worker.go 调用map程序输出intermediate文件</p><p>将intermediate文件传递给reduce完成工作</p><h2 id="二、实验分析"><a href="#二、实验分析" class="headerlink" title="二、实验分析"></a>二、实验分析</h2><p><img src="C:\Users\lyj\Desktop\C%20and%20C++\学习笔记\分布式系统\img\1653357858623.jpeg" alt=""></p><p>上述为一部分网络上的mapduce的流程</p><blockquote><p>实验心得</p></blockquote><p>刚开始做本次实验，由于没有go语言基础以及做项目的基础，导致做本次实验十分的吃力，一共完成了三版</p><ol><li>通过上述思路图的实验第一版较为粗糙以及复杂(结构体套结构体的版本，传递一些无效参数)，但是没有处理并发问题，导致很多测试点过不了(踩了Struct成员需要首字母大写的坑)</li><li>实验第二版，实验简化了很多无效使调用关系以及无效参数，调用关系更加明确，但是没有处理<strong>并行问题</strong>导致出现了任务量达超标的问题。但是莫名其妙的过了Crash测试</li><li>实验第三版，参考了一点别人的代码，修改了请求任务阶段(<strong>使用了Channel</strong>)，并行问题导致了超标的任务量</li></ol><h3 id="并行问题-实验第二版"><a href="#并行问题-实验第二版" class="headerlink" title="并行问题(实验第二版)"></a>并行问题(实验第二版)</h3><blockquote><p>并发实现</p></blockquote><p>在Coordianor中将每个Worker申请的服务例程放入goroutine中，多个Worker就是多线程</p><p><code>go http.Serve(l, nil)</code></p><blockquote><p>在分配Map以及Reduce任务时Coordinate的并行调度问题</p></blockquote><p>用GetMapTask进行示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> c.Mt &#123;</span><br><span class="line">        <span class="keyword">if</span> !m.State &#123;</span><br><span class="line">            c.MapMu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> c.MapMu.Unlock()</span><br><span class="line">            reply.Inputfile = m.Inputfile</span><br><span class="line">            reply.ID = m.ID</span><br><span class="line"></span><br><span class="line">            reply.Nreduce = c.Nreduce</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始想法</p></blockquote><p>遍历MapTask结构体的数组，去判断哪些任务还未被分配，然后将输入文件和文件ID传给Worker</p><p>这个方法偶尔会通过Crash测试，分析应该是任务未完成，State是未被置为true导致，因为Coordinator不断去遍历MapTask数组，就能够发现哪些任务未被完成</p><blockquote><p>Jobcount测试</p></blockquote><p>在该测试中，发现了原本为只需要8个Worker去完成的工作，居然出现了16个！通过查看测试脚本发现了，Jobcount中开启了两个Worker,那么回想并行的状态，一定是两个Worker去读了MapTask数组，又同时去更新了任务，导致了出现了两倍的任务量。</p><blockquote><p>解决并行问题</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reply.ID = &lt;-c.MapID:</span><br><span class="line">        reply.Inputfile = c.Mt[reply.ID].Inputfile</span><br><span class="line">        reply.Nreduce = c.Nreduce</span><br><span class="line">            <span class="comment">/*go func(ID int) &#123;//Crash测试</span></span><br><span class="line"><span class="comment">                time.Sleep(10 * time.Second)</span></span><br><span class="line"><span class="comment">                c.MapMu.Lock()</span></span><br><span class="line"><span class="comment">                defer c.MapMu.Unlock()</span></span><br><span class="line"><span class="comment">                if !c.Mt[reply.ID].State &#123;</span></span><br><span class="line"><span class="comment">                    c.MapID &lt;- ID</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;(reply.ID)*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        reply.ID = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程初始化Coordinator</span></span><br><span class="line">c.MapID = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, c.Mapnum)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.Mt &#123;</span><br><span class="line">    c.Mt[i].Inputfile = files[i]</span><br><span class="line">    c.Mt[i].State = <span class="literal">false</span></span><br><span class="line">    c.MapID &lt;- i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p><p>在实验的第二版中出现了并行问题在于同时这个点，解决方案就是在于同步的问题，当一个线程读取了数据后，另一个线程不能访问，或是及时将另一个线程阻塞或是告知它读取下个任务</p></blockquote><p>使用了Go语言中的Channel的语法，主例程发送一个ID，就会导致阻塞，然后当有Worker调用GetMapTasK将ID读入，才会又下一个ID发送。<strong>读写会相互阻塞</strong>，这导致在多个Worker中不会去<strong>同时读入一个ID</strong>，解决了并发问题</p><h3 id="Worker与Coordinator之间的关系"><a href="#Worker与Coordinator之间的关系" class="headerlink" title="Worker与Coordinator之间的关系"></a>Worker与Coordinator之间的关系</h3><blockquote><p> Coordinator(RPC的Server机)</p></blockquote><ol><li>在Coordinator中需要完成的是<strong>定义RPC的方法</strong>来完成Worker的请求</li><li>Coordinator结构体中是与<strong>Worker通信</strong>中需要传递的参数，以及<strong>分配任务的一些判断依据</strong>，以及多线程中的保护<strong>共享数据需的互斥锁(Mutex)</strong></li><li>由于是多线程并行问题，Coordiantor需要合适去调度任务</li></ol><blockquote><p>Worker(RPC的客户机)</p></blockquote><ol><li>在实验中我们可以用一个或则多个(<strong>并行</strong>)的去向Coordinator申请任务(在多个终端中开启Worker)</li></ol><p><code>go run -race mrworker.go wc.so</code></p><ol><li>Worker需要去完成Map与Reduce两种任务，Map与Reduce的工具在mrapps中有所定义，所以我们只需定义一些请求任务所需的参数(需要在rpc.go中定义)，将这许传回的参数进行相应的任务</li><li>一个Worker是<strong>双线程</strong>去完成相应的任务，Worker需要判断任务是否完成，执行怎样的任务，<strong>不断的</strong>向Coordinator申请任务</li><li>多个Worker是多线线程<strong>并行的</strong>去完成相应的任务(<strong>任务量</strong>测试点)</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>结构体成员需要以<strong>大写字母</strong>开始，否则会出现定义为private对象，无法初始化字</p><h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><blockquote><p>rpc中的参数以及回复</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求Map</span></span><br><span class="line"><span class="keyword">type</span> MapArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MapReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    Inputfile <span class="type">string</span></span><br><span class="line">    Nreduce   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求reduce</span></span><br><span class="line"><span class="keyword">type</span> ReduceArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReduceReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span></span><br><span class="line">    Mapnum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查map任务的是否全部完成</span></span><br><span class="line"><span class="keyword">type</span> MapfinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MapfinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Finished <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check state of map task</span></span><br><span class="line"><span class="keyword">type</span> FinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> FinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Finished <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>coordinator对象</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nreduce    <span class="type">int</span></span><br><span class="line">    MapID      <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    Mt         []MapTask</span><br><span class="line">    Mapnum     <span class="type">int</span> <span class="comment">//the number of map task</span></span><br><span class="line">    ReduceID   <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    Rt         []ReduceTask</span><br><span class="line">    Finished   <span class="type">bool</span></span><br><span class="line">    MapMu      sync.Mutex <span class="comment">//map task mutex</span></span><br><span class="line">    ReduceMu   sync.Mutex <span class="comment">//reduce task mutex</span></span><br><span class="line">    FinishedMu sync.Mutex <span class="comment">//Done Mutex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    Inputfile <span class="type">string</span> <span class="comment">//bind file and ID</span></span><br><span class="line">    State     <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    State <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><blockquote><p>主要框架</p></blockquote><ol><li>一个for死循环，不断的去向主例程申请任务</li><li>先判断所有任务是否完成也就是判断(向Coordinator询问Reduce任务是否全部完成)，完成的话则执行break结束Worker例程，</li><li>否则进入Map或者Reduce任务，(向Coordinator询问所有Map任务是否完成)，Map所有任务完成的话就执行Reduce任务，否则执行Map剩余的Map任务</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">    reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//finished?</span></span><br><span class="line">        <span class="keyword">if</span> !AllFinished() &#123;</span><br><span class="line">            <span class="keyword">if</span> !Mapfinished() &#123; <span class="comment">//tasktype</span></span><br><span class="line">                <span class="comment">//do map</span></span><br><span class="line">                <span class="comment">//update worker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do reduce    </span></span><br><span class="line">                <span class="comment">//update task</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>定义Worker例程的调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> UpdateMapTask(args *MapArgs, reply *MapReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> MapTaskFinished(args *FinishArgs, reply *FinishReply) <span class="type">error</span></span><br><span class="line"><span class="comment">//RedueceTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> GetReduceTask(args *ReduceArgs, reply *ReduceReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> UpdateReduceTask(args *ReduceArgs, reply *ReduceReply) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> ReduceTaskFinished(args *FinishArgs, reply *FinishReply) <span class="type">error</span></span><br><span class="line"><span class="comment">//Init Coordinator Object </span></span><br></pre></td></tr></table></figure><p>Crash开启判断例程(GetMapTask)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reply.ID = &lt;-c.MapID:</span><br><span class="line">        reply.Inputfile = c.Mt[reply.ID].Inputfile</span><br><span class="line">        reply.Nreduce = c.Nreduce</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">            c.MapMu.Lock()</span><br><span class="line">            <span class="keyword">defer</span> c.MapMu.Unlock()</span><br><span class="line">            <span class="keyword">if</span> !c.Mt[reply.ID].State &#123;</span><br><span class="line">                c.MapID &lt;- ID<span class="comment">//未完成重复读入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(reply.ID)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        reply.Inputfile = <span class="string">&quot;&quot;</span></span><br><span class="line">        reply.Nreduce = <span class="number">0</span></span><br><span class="line">        reply.ID = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>首先知道Worker是一个并行的线程，而这个GetMapTask可以作为Worker线程的一部分，于是Channel可以当作通信的一部分。</p><p>设置一个协程，当一个任务Crash掉后，我们要知道是那个任务失败，还要设置一个判断时间，当这个时间过去后判断该状态还未完成，就重新将ID发送，让GetTask能够再次读入并重新执行</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MapRedcue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
